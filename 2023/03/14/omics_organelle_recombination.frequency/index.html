<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="线粒体的重复介导重组的鉴定和计算重组频率。">
<meta property="og:type" content="article">
<meta property="og:title" content="线粒体的重复介导重组的鉴定和计算重组频率">
<meta property="og:url" content="http://example.com/2023/03/14/omics_organelle_recombination.frequency/index.html">
<meta property="og:site_name" content="生信技工">
<meta property="og:description" content="线粒体的重复介导重组的鉴定和计算重组频率。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true">
<meta property="article:published_time" content="2023-03-13T16:00:00.000Z">
<meta property="article:modified_time" content="2023-11-27T08:29:22.863Z">
<meta property="article:author" content="南方枝叶">
<meta property="article:tag" content="mitogenome">
<meta property="article:tag" content="repeat">
<meta property="article:tag" content="recombination">
<meta property="article:tag" content="rearrangement">
<meta property="article:tag" content="insert size">
<meta property="article:tag" content="recombination frequency">
<meta property="article:tag" content="ROUSFinder">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true">

<link rel="canonical" href="http://example.com/2023/03/14/omics_organelle_recombination.frequency/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>线粒体的重复介导重组的鉴定和计算重组频率 | 生信技工</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?a7db9ab8b9b3ef3b239a82e4a58e43dc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="生信技工" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">生信技工</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-resume">

    <a href="/resume/index.html" rel="section"><i class="fa fa-file fa-fw"></i>resume</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/14/omics_organelle_recombination.frequency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="南方枝叶">
      <meta itemprop="description" content="学习生物信息学的笔记本">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="生信技工">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          线粒体的重复介导重组的鉴定和计算重组频率
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-14 00:00:00" itemprop="dateCreated datePublished" datetime="2023-03-14T00:00:00+08:00">2023-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-27 16:29:22" itemprop="dateModified" datetime="2023-11-27T16:29:22+08:00">2023-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/omics/" itemprop="url" rel="index"><span itemprop="name">omics</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/omics/organelle/" itemprop="url" rel="index"><span itemprop="name">organelle</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/omics/organelle/recombination/" itemprop="url" rel="index"><span itemprop="name">recombination</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus: </span>
    
    <a title="disqus" href="/2023/03/14/omics_organelle_recombination.frequency/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2023/03/14/omics_organelle_recombination.frequency/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>53k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>48 mins.</span>
            </span>
            <div class="post-description">线粒体的重复介导重组的鉴定和计算重组频率。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=105213&auto=1&height=32"></iframe></div>

<h1 id="1-线粒体的重复介导重组（repeat-mediated-recombination）"><a href="#1-线粒体的重复介导重组（repeat-mediated-recombination）" class="headerlink" title="1. 线粒体的重复介导重组（repeat-mediated recombination）"></a>1. 线粒体的重复介导重组（repeat-mediated recombination）</h1><ol>
<li>线粒体的重复序列</li>
</ol>
<ul>
<li>通常在植物线粒体上存在重复序列（这里的重复序列不是核基因组的TE等转座元件的概念，就是一段序列在另一个位置同时存在完全一致的序列），则有可能介导重组，从而生成线粒体的多种构象。重复序列常常成对存在（也有一些超过两个），被称作重复对（repeat pairs）。</li>
</ul>
<ol start="2">
<li>鉴定的背景</li>
</ol>
<ul>
<li>Illumina PE测序是双端测序，测序获得的reads常见的长度是150bp。一对reads的联合体的长度被称为插入尺寸（insert size）。插入尺寸（insert size）常在350bp左右，但具体的每对测序reads都不一样，要通过把reads进行mapping到参考序列上，才能测量insert size。</li>
<li>如果是repeat pairs的长度小于测序reads的insert size长度，可以构建两种构象（参考构象和重组构象），把reads mapping到两种构象来判断repeat pairs是否介导重组（如果两种构象都有mapped reads则是repeat pair介导重组的证据），并且通过mapped reads的计数来计算重组频率（recombination frequency）。</li>
</ul>
<h1 id="2-鉴定重复"><a href="#2-鉴定重复" class="headerlink" title="2. 鉴定重复"></a>2. 鉴定重复</h1><h2 id="2-1-鉴定重复的脚本"><a href="#2-1-鉴定重复的脚本" class="headerlink" title="2.1. 鉴定重复的脚本"></a>2.1. 鉴定重复的脚本</h2><p>这篇文章Repeats of Unusual Size in Plant Mitochondrial Genomes: Identification, Incidence and Evolution： <a target="_blank" rel="noopener" href="https://academic.oup.com/g3journal/article/9/2/549/6026745">https://academic.oup.com/g3journal/article/9/2/549/6026745</a> 总结了植物线粒体基因组的重复序列的特征。研究表明，植物线粒体基因组比动物的要大，包含大量的非编码DNA，突变率低，重排率高。</p>
<ul>
<li>文章提供了python脚本ROUSFinder.py，用在鉴定线粒体的重复序列上。</li>
<li>脚本是python2写的，依赖主要有blastn。</li>
<li>有以下三个版本。</li>
</ul>
<ol>
<li>ROUSFinder.py</li>
</ol>
<ul>
<li>调用blastn进行一条序列与自身的成对比对。</li>
<li>默认参数是最小重复50bp，E value 10,000， match的赏分是+1，mismatch的罚分是-20。</li>
<li>脚本贴在下面：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> sys, math, os, argparse, csv  </span><br><span class="line">csv.field_size_limit(sys.maxsize)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># January 16, 2018 version 1.1  </span></span><br><span class="line"><span class="comment"># Find dispersed repeated sequences in genomes.   </span></span><br><span class="line"><span class="comment"># Designed for plant mitochondrial genomes of up to a few Mbp.  </span></span><br><span class="line"><span class="comment"># May be very slow with larger genomes.   </span></span><br><span class="line"><span class="comment"># Blast can also sometimes give odd results with large or highly repetetive genomes.  </span></span><br><span class="line"><span class="comment"># Gaps, or runs of &#x27;N&#x27;s in the sequence will definitely give weird results.   </span></span><br><span class="line"><span class="comment"># The program assumes there aren&#x27;t any, and that the longest repeat will be the full sequence to itself.  </span></span><br><span class="line"><span class="comment"># If there are long repeats in the output that are listed as being only at one location, this is probably what happened.  </span></span><br><span class="line"><span class="comment"># If there are a lot of repeats within repeats the results can also be odd.  </span></span><br><span class="line"><span class="comment"># Copyright Alan C. Christensen, University of Nebraska, 2018  </span></span><br><span class="line"><span class="comment"># No guarantees, warranties, support, or anything else is implicit or explicit.  </span></span><br><span class="line"><span class="comment"># Input is a fasta format file of a sequence. Genbank format works but generates lots of error messages in stdout.  </span></span><br><span class="line"><span class="comment"># Output is a list of unique, ungapped repeated sequences, fasta formatted.  </span></span><br><span class="line"><span class="comment"># The names are in the format &#x27;&gt;Repeat/ROUS_name_start_end_length&#x27;.  </span></span><br><span class="line"><span class="comment"># Percent identity is limited to &gt;=99%, to allow for sequencing errors of &lt;1%.  </span></span><br><span class="line"><span class="comment"># A table of repeats with the coordinates of each one is generated.  </span></span><br><span class="line"><span class="comment"># A list of repeat name, length and copy number is generated.  </span></span><br><span class="line"><span class="comment"># A binned table of the total number of repeats in size ranges is generated.  </span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># PARAMETERS  </span></span><br><span class="line"><span class="comment">#   REQUIRED:  </span></span><br><span class="line"><span class="comment">#      input file in fasta format  </span></span><br><span class="line"><span class="comment">#   Optional  </span></span><br><span class="line"><span class="comment">#      -o output file name  </span></span><br><span class="line"><span class="comment">#      -m minimum length of exact matches to keep  </span></span><br><span class="line"><span class="comment">#      -b path to blastn (default is /usr/bin/)  </span></span><br><span class="line"><span class="comment">#      -k keep temp files  </span></span><br><span class="line"><span class="comment">#      -gb to write the repeats to a genbank format file  </span></span><br><span class="line">  </span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;Find repeats in a fasta sequence file&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;infile&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Input .fasta file&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-o&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;outfile&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Output file name seed, default is input_repeats&#x27;</span>, default=<span class="string">&#x27;default&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-m&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;minlen&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Minimum length of matches to keep, default=24&#x27;</span>, default=<span class="string">&#x27;24&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-b&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;blast_path&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Path to blastn program, default is /usr/bin/&#x27;</span>, default=<span class="string">&#x27;/usr/bin/&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-k&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, dest=<span class="string">&#x27;keep&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;True to keep temp files&#x27;</span>, default=<span class="literal">False</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-gb&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, dest=<span class="string">&#x27;genbank&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;True to write GenBank format file&#x27;</span>, default=<span class="literal">False</span>)  </span><br><span class="line">results = parser.parse_args()  </span><br><span class="line">infile = results.infile  </span><br><span class="line">outfile = results.outfile  </span><br><span class="line">minlen = <span class="built_in">int</span>(results.minlen)  </span><br><span class="line">blast_path = results.blast_path  </span><br><span class="line">keep = results.keep  </span><br><span class="line">genbank = results.genbank  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># It might be useful to define the wordsize as something less than minlen, so both variables are used.  </span></span><br><span class="line"><span class="comment"># Wordsize smaller than minlen would give smaller core identical sequences in the middle of repeats.  </span></span><br><span class="line"><span class="comment"># An example might be to change this to wordsize = str(int(minlen/2)).  </span></span><br><span class="line">wordsize = <span class="built_in">str</span>(minlen)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># If no output file seed is specified, make one by stripping leading directory information  </span></span><br><span class="line"><span class="comment"># and stripping trailing .fa or .fasta from the input file name and using that.  </span></span><br><span class="line"><span class="keyword">if</span> outfile == <span class="string">&#x27;default&#x27;</span>:  </span><br><span class="line">    outfile = infile  </span><br><span class="line">    <span class="keyword">if</span> outfile.count(<span class="string">&#x27;/&#x27;</span>) &gt; <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(outfile.count(<span class="string">&#x27;/&#x27;</span>)):  </span><br><span class="line">            index = outfile.index(<span class="string">&#x27;/&#x27;</span>)  </span><br><span class="line">            outfile = outfile[index+<span class="number">1</span>:]  </span><br><span class="line">    <span class="keyword">if</span> outfile.endswith(<span class="string">&#x27;.fa&#x27;</span>) <span class="keyword">or</span> outfile.endswith(<span class="string">&#x27;.fasta&#x27;</span>):  </span><br><span class="line">        outfile = outfile.rstrip(<span class="string">&#x27;fasta&#x27;</span>)  </span><br><span class="line">    outfile = outfile.rstrip(<span class="string">&#x27;.&#x27;</span>)  </span><br><span class="line">outfa = outfile+<span class="string">&#x27;_rep.fasta&#x27;</span>  </span><br><span class="line">outtab = outfile+<span class="string">&#x27;_rep_table.txt&#x27;</span>  </span><br><span class="line">outbin = outfile+<span class="string">&#x27;_binned.txt&#x27;</span>  </span><br><span class="line">outcount = outfile+<span class="string">&#x27;_rep_counts.txt&#x27;</span>  </span><br><span class="line">outgb = outfile+<span class="string">&#x27;_repeats.gb.txt&#x27;</span>  </span><br><span class="line">tempblast = outfile+<span class="string">&#x27;_tempblast.txt&#x27;</span>  </span><br><span class="line">temprepeats = outfile+<span class="string">&#x27;_temprepeats.txt&#x27;</span>  </span><br><span class="line">tempparse = outfile+<span class="string">&#x27;_sequence_parsing.txt&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Get sequence name and length from fasta file.  </span></span><br><span class="line">seq = <span class="built_in">open</span>(infile, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">seqname = seq.readline()  </span><br><span class="line">seqname = seqname.lstrip(<span class="string">&#x27;&gt; &#x27;</span>)  </span><br><span class="line">seqname = seqname.rstrip()  </span><br><span class="line">seqlen = <span class="number">0</span>   </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> seq:  </span><br><span class="line">    <span class="keyword">if</span>(line[<span class="number">0</span>] == <span class="string">&quot;&gt;&quot;</span>):  </span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line">    seqlen += <span class="built_in">len</span>(line.strip())  </span><br><span class="line">seq.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># run blastn with query file plus strand (removing first line which is full length sequence), minus strand, and concatenate  </span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Performing self-blastn comparison with &#x27;</span>+seqname  </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+infile+<span class="string">&#x27; -strand plus -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward 1 -penalty -20 -ungapped -dust no -soft_masking false -evalue 1000 -outfmt &quot;10 qstart qend length sstart send mismatch sstrand qseq&quot; | tail -n+2 &gt; tempblast1.txt&#x27;</span>)  </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+infile+<span class="string">&#x27; -strand minus -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward 1 -penalty -20 -ungapped -dust no -soft_masking false -evalue 1000 -outfmt &quot;10 qstart qend length sstart send mismatch sstrand qseq&quot; &gt; tempblast2.txt&#x27;</span>)  </span><br><span class="line">os.system(<span class="string">&#x27;cat tempblast1.txt tempblast2.txt &gt; &#x27;</span>+tempblast)  </span><br><span class="line">os.system(<span class="string">&#x27;rm tempblast1.txt tempblast2.txt&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># open tempblast.txt, convert to list of lists, and sort by length and position descending  </span></span><br><span class="line"><span class="comment"># This is necessary because blastn does not output every possible pair of hits when there are more than 2 copies of a repeat  </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Sorting alignments...&#x27;</span>  </span><br><span class="line">f = <span class="built_in">open</span>(tempblast, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">reader = csv.reader(f)  </span><br><span class="line">alignments = <span class="built_in">list</span>(reader)  </span><br><span class="line">f.close()  </span><br><span class="line">alignments = <span class="built_in">sorted</span>(alignments, key=<span class="keyword">lambda</span> x: (-<span class="number">1</span>*<span class="built_in">int</span>(x[<span class="number">2</span>]), -<span class="number">1</span>*<span class="built_in">int</span>(x[<span class="number">0</span>])))  </span><br><span class="line">alignments.append([<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;X&#x27;</span>])  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># New list of uniques  </span></span><br><span class="line"><span class="comment"># Text file &#x27;_sequence_parsing.txt&#x27; includes the information on how duplicates were found.  </span></span><br><span class="line"><span class="comment"># Start at row 0. Compare to subsequent rows.   </span></span><br><span class="line"><span class="comment"># If repeat length is different from the next row, it has passed all the tests, write it to the file.  </span></span><br><span class="line"><span class="comment"># If query or subject coordinates are the same as the query or subject or reversed coordinates  </span></span><br><span class="line"><span class="comment"># of a subsequent row, it is not unique, so go to the next row and do the comparisons again.  </span></span><br><span class="line"><span class="comment"># Thanks to Alex Kozik for repeatedly testing and finding bugs in the algorithm.  </span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Finding unique repeats...&#x27;</span>  </span><br><span class="line">uniques = []  </span><br><span class="line">sp = <span class="built_in">open</span>(tempparse, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alignments)):  </span><br><span class="line">    sp.write(<span class="string">&#x27;row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(alignments[row][<span class="number">2</span>]) &lt; minlen:  </span><br><span class="line">        <span class="comment"># This won&#x27;t happen unless the word_size is defined as something other than minlen.  </span></span><br><span class="line">        <span class="comment"># That could be useful under some circumstances.  </span></span><br><span class="line">        sp.write(<span class="string">&#x27;row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is less than minlength&#x27;</span>)  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> compare <span class="keyword">in</span> <span class="built_in">range</span>(row+<span class="number">1</span>,<span class="built_in">len</span>(alignments)):  </span><br><span class="line">            <span class="keyword">if</span> alignments[row][<span class="number">2</span>] != alignments[compare][<span class="number">2</span>]:   </span><br><span class="line">                uniques.append(alignments[row])  </span><br><span class="line">                sp.write(<span class="string">&#x27;\tadding row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; to unique list\n&#x27;</span>)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                sp.write(<span class="string">&#x27;\tcomparing to &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">                <span class="keyword">if</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">0</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">1</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; and &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27; are the same\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">1</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">0</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qend and qstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">3</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">4</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as sstart and send of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">4</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">3</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as send and sstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">0</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">1</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qstart and qend of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">1</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">0</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qend and qstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">3</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">4</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as sstart and send of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">4</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">3</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as send and sstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">else</span>:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is different\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">sp.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Write uniques into output file  </span></span><br><span class="line"><span class="comment"># Start list for copy number table  </span></span><br><span class="line">rous_count = <span class="number">0</span>  </span><br><span class="line">g = <span class="built_in">open</span>(outfa, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">repcopies = []  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(uniques)):  </span><br><span class="line">    qstart = uniques[i][<span class="number">0</span>]  </span><br><span class="line">    qend = uniques[i][<span class="number">1</span>]  </span><br><span class="line">    length = uniques[i][<span class="number">2</span>]  </span><br><span class="line">    seq = uniques[i][<span class="number">7</span>]  </span><br><span class="line">      </span><br><span class="line">    rous_count += <span class="number">1</span>  </span><br><span class="line">    g.write(<span class="string">&#x27;&gt;Repeat_&#x27;</span>+<span class="built_in">str</span>(rous_count)+<span class="string">&#x27;\n&#x27;</span>+seq+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">    repcopies.append([<span class="string">&#x27;Repeat_&#x27;</span>+<span class="built_in">str</span>(rous_count),length])  </span><br><span class="line">          </span><br><span class="line"><span class="keyword">if</span> rous_count == <span class="number">0</span>:  </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;\tRepeats of unusual size? I don&#x27;t think they exist&quot;</span>  </span><br><span class="line">g.close()  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Repeat fasta file is done, as you wish.&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Now find each copy of each repeat. Again, this is because the blastn output file does not have every possible alignment.  </span></span><br><span class="line"><span class="comment"># It is also because the information on locations and strand is not organized well in the blastn output.  </span></span><br><span class="line"><span class="comment"># In addition, this subroutine eliminates duplicates of nested repeats.  </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Finding all copies of repeats...&quot;</span>  </span><br><span class="line">g = <span class="built_in">open</span>(outfa, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+outfa+<span class="string">&#x27; -strand both -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward 1 -penalty -20 -ungapped -dust no -soft_masking false -evalue 1000 -outfmt &quot;10 qseqid length sstart send sstrand qcovhsp&quot; &gt; &#x27;</span>+temprepeats)  </span><br><span class="line">g.close()  </span><br><span class="line">  </span><br><span class="line">tempr = <span class="built_in">open</span>(temprepeats, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">reader = csv.reader(tempr)  </span><br><span class="line">replist = <span class="built_in">list</span>(reader)  </span><br><span class="line">tempr.close()  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Making a table of the repeats...&quot;</span>  </span><br><span class="line">sum_rep_len = <span class="number">0</span>  </span><br><span class="line">bin_dict = &#123;&#125;  </span><br><span class="line">binned = [seqname,seqlen,<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># defining the bins  </span></span><br><span class="line">i = <span class="number">0</span>  </span><br><span class="line">j = <span class="number">50</span>  </span><br><span class="line"><span class="keyword">while</span> j &lt; <span class="number">1000</span>:  </span><br><span class="line">    bin_dict[i] = j  </span><br><span class="line">    binned.append(<span class="number">0</span>)  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    j += <span class="number">50</span>  </span><br><span class="line"><span class="keyword">while</span> j &lt;= <span class="number">10000</span>:  </span><br><span class="line">    bin_dict[i] = j  </span><br><span class="line">    binned.append(<span class="number">0</span>)  </span><br><span class="line">    i +=<span class="number">1</span>  </span><br><span class="line">    j += <span class="number">250</span>  </span><br><span class="line">      </span><br><span class="line"><span class="comment"># make list for entire sequence, set each position as 0  </span></span><br><span class="line">posit = []  </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(seqlen):  </span><br><span class="line">    posit.append(<span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Thanks to Emily Wynn for suggesting qcovhsp for this loop.  </span></span><br><span class="line"><span class="comment"># if qcovhsp is &gt;98%, write to the file  </span></span><br><span class="line"><span class="comment"># write tab separated values of repeat name, length, start, end, strand to outtab  </span></span><br><span class="line"><span class="comment"># make list for genbank file  </span></span><br><span class="line"><span class="comment"># Keep stats on lengths  </span></span><br><span class="line">rt = <span class="built_in">open</span>(outtab, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">rt.write(seqname+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(seqlen)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">templist = []  </span><br><span class="line">gblist =[]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># look at each repeat in turn  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(replist)):  </span><br><span class="line">    <span class="comment"># if repeat is good (&gt;98% identical to another one), write it to the file, and put the name in a list  </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(replist[i][<span class="number">5</span>])&gt;<span class="number">98</span>:  </span><br><span class="line">        rt.write(<span class="built_in">str</span>(replist[i][<span class="number">0</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">1</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">2</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">3</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">4</span>])+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">        <span class="keyword">if</span> replist[i][<span class="number">4</span>] == <span class="string">&#x27;minus&#x27;</span>:  </span><br><span class="line">            location = <span class="string">&#x27;complement(&#x27;</span>+replist[i][<span class="number">3</span>]+<span class="string">&#x27;..&#x27;</span>+replist[i][<span class="number">2</span>]+<span class="string">&#x27;)&#x27;</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            location = replist[i][<span class="number">2</span>]+<span class="string">&#x27;..&#x27;</span>+replist[i][<span class="number">3</span>]  </span><br><span class="line">        gblist.append(<span class="string">&#x27;     repeat_region   &#x27;</span>+location+<span class="string">&#x27;\n                     /rpt_type=dispersed\n                     /label=&#x27;</span>+replist[i][<span class="number">0</span>]+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">        templist.append(replist[i][<span class="number">0</span>])  </span><br><span class="line">        <span class="comment"># then write 1&#x27;s at every position in the sequence covered by that repeat  </span></span><br><span class="line">        <span class="comment"># these can then be summed to get total bases of repeats  </span></span><br><span class="line">        <span class="comment"># bases in overlapping repeats are only counted once  </span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(replist[i][<span class="number">2</span>]), <span class="built_in">int</span>(replist[i][<span class="number">3</span>])):  </span><br><span class="line">            posit[n] = <span class="number">1</span>  </span><br><span class="line">        <span class="comment"># then scan through bin sizes and if a repeat is greater than the  </span></span><br><span class="line">        <span class="comment"># bin_dict size cutoff, add one to the bin  </span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binned)-<span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>):  </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(replist[i][<span class="number">1</span>]) &gt;= bin_dict[j]:  </span><br><span class="line">                binned[j+<span class="number">3</span>] +=<span class="number">1</span>  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">sum_rep_len = posit.count(<span class="number">1</span>)  </span><br><span class="line">binned[<span class="number">2</span>] = sum_rep_len  </span><br><span class="line">rt.close()  </span><br><span class="line"><span class="keyword">if</span> genbank == <span class="literal">True</span>:  </span><br><span class="line">    gb = <span class="built_in">open</span>(outgb, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gblist)):  </span><br><span class="line">        gb.write(gblist[i])  </span><br><span class="line">    gb.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># write tab separated values of repeat name, length, copy number to outcount  </span></span><br><span class="line"><span class="comment"># first two lines are also a table of stats on repeats  </span></span><br><span class="line">rc = <span class="built_in">open</span>(outcount,<span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">rc.write(<span class="string">&#x27;Sequence\tGenome_size\tNumRepeats\tAvgSize\tAvgCopyNum\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">numrous = <span class="number">0</span>  </span><br><span class="line">sizerous = <span class="number">0</span>  </span><br><span class="line">copyrous = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(repcopies)):  </span><br><span class="line">    repname = repcopies[i][<span class="number">0</span>]  </span><br><span class="line">    replen = <span class="built_in">float</span>(repcopies[i][<span class="number">1</span>])  </span><br><span class="line">    repcop = <span class="built_in">float</span>(templist.count(repname))  </span><br><span class="line">  </span><br><span class="line">    numrous += <span class="number">1</span>  </span><br><span class="line">    sizerous += replen  </span><br><span class="line">    copyrous += repcop  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> numrous == <span class="number">0</span>:  </span><br><span class="line">    avsizerous = <span class="string">&#x27;NA&#x27;</span>  </span><br><span class="line">    avcopyrous = <span class="string">&#x27;NA&#x27;</span>  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    avsizerous = sizerous/numrous  </span><br><span class="line">    avcopyrous = copyrous/numrous  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">rc.write(seqname+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(seqlen)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(numrous)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(avsizerous)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(avcopyrous)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(repcopies)):  </span><br><span class="line">    rc.write(repcopies[i][<span class="number">0</span>]+<span class="string">&#x27;\t&#x27;</span>+repcopies[i][<span class="number">1</span>]+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(templist.count(repcopies[i][<span class="number">0</span>]))+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">rc.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Write binned table headers, then stats for this sequence.  </span></span><br><span class="line">binfile = <span class="built_in">open</span>(outbin, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;Sequence\tSeq_len\tRep_len\t&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bin_dict)):  </span><br><span class="line">    binfile.write(<span class="built_in">str</span>(bin_dict[i])+<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binned)):  </span><br><span class="line">    binfile.write(<span class="built_in">str</span>(binned[i])+<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">binfile.close()  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Repeat tables are done, as you wish.&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Removing temp files if necessary  </span></span><br><span class="line"><span class="keyword">if</span> keep == <span class="literal">False</span>:  </span><br><span class="line">    os.system(<span class="string">&#x27;rm &#x27;</span>+tempblast+<span class="string">&#x27; &#x27;</span>+temprepeats+<span class="string">&#x27; &#x27;</span>+tempparse)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Rachael Schulte, William Goldman and Rob Reiner inspired this section of code  </span></span><br><span class="line">quote_dict = &#123;<span class="number">0</span>:<span class="string">&quot;48656c6c6f2e204d79206e616d6520697320496e69676f204d6f6e746f79612e20596f75206b696c6c6564206d79206661746865722e205072657061726520746f206469652e&quot;</span>, <span class="number">1</span>:<span class="string">&quot;5768656e20492077617320796f7572206167652c2074656c65766973696f6e207761732063616c6c656420626f6f6b732e&quot;</span>, <span class="number">2</span>:<span class="string">&quot;486176652066756e2073746f726d696e2720646120636173746c6521&quot;</span>, <span class="number">3</span>:<span class="string">&quot;4d79207761792773206e6f7420766572792073706f7274736d616e6c696b652e&quot;</span>, <span class="number">4</span>:<span class="string">&quot;596f75206b656570207573696e67207468617420776f72642e204920646f206e6f74207468696e6b206974206d65616e73207768617420796f75207468696e6b206974206d65616e732e&quot;</span>, <span class="number">5</span>:<span class="string">&quot;4d75726465726564206279207069726174657320697320676f6f642e&quot;</span>,<span class="number">6</span>:<span class="string">&quot;496e636f6e6365697661626c6521&quot;</span>, <span class="number">7</span>:<span class="string">&quot;5468657265277320612062696720646966666572656e6365206265747765656e206d6f73746c79206465616420616e6420616c6c20646561642e&quot;</span>, <span class="number">8</span>:<span class="string">&quot;596f7520727573682061206d697261636c65206d616e2c20796f752067657420726f7474656e206d697261636c65732e&quot;</span>, <span class="number">9</span>:<span class="string">&quot;476f6f64206e696768742c20576573746c65792e20476f6f6420776f726b2e20536c6565702077656c6c2e2049276c6c206d6f7374206c696b656c79206b696c6c20796f7520696e20746865206d6f726e696e672e&quot;</span>,<span class="number">10</span>:<span class="string">&quot;4e6f206d6f7265207268796d65732c2049206d65616e2069742120416e79626f64792077616e742061207065616e75743f&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">import</span> random, binascii  </span><br><span class="line">z = random.randint(<span class="number">0</span>,<span class="number">10</span>)  </span><br><span class="line"><span class="built_in">print</span> binascii.unhexlify(quote_dict[z])+<span class="string">&#x27;\n&#x27;</span>  </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>MultipleRepeats.py</li>
</ol>
<ul>
<li>MultipleRepeats.py批量运行一个文件夹下的每个序列文件。</li>
<li>脚本贴在下面：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> sys, math, os, argparse  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Usage: -din directory of files to find repeats in  </span></span><br><span class="line"><span class="comment">#        -word word_size  </span></span><br><span class="line">  </span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;Find repeats in a directory of fasta sequence files&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-din&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;din&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Input .fasta directory&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-word&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;word&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Word size for blast&#x27;</span>)  </span><br><span class="line">results = parser.parse_args()  </span><br><span class="line">din = results.din  </span><br><span class="line">word = results.word  </span><br><span class="line">  </span><br><span class="line">li = os.listdir(din)  </span><br><span class="line">inputs = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: <span class="string">&#x27;.fasta&#x27;</span> <span class="keyword">in</span> x, li)  </span><br><span class="line">inputs.sort()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inputs)):  </span><br><span class="line">    infile = <span class="built_in">str</span>(inputs[i])  </span><br><span class="line">    os.system(<span class="string">&quot;/home/alan/applications/ROUSFinder.py -m &quot;</span>+word+<span class="string">&quot; &quot;</span>+din+infile) </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ROUSFinder2.py</li>
</ol>
<ul>
<li>ROUSFinder2.py可以在命令行设置match赏分和mismatch罚分。</li>
<li>脚本贴在下面：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> sys, math, os, argparse, csv  </span><br><span class="line">csv.field_size_limit(sys.maxsize)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Version 2.0, November 21, 2018  </span></span><br><span class="line"><span class="comment"># Changes: uses variable parameters  </span></span><br><span class="line"><span class="comment"># Find dispersed repeated sequences in genomes.   </span></span><br><span class="line"><span class="comment"># Designed for plant mitochondrial genomes of up to a few Mbp.  </span></span><br><span class="line"><span class="comment"># May be very slow with larger genomes.   </span></span><br><span class="line"><span class="comment"># Blast can also sometimes give odd results with large or highly repetetive genomes.  </span></span><br><span class="line"><span class="comment"># Gaps, or runs of &#x27;N&#x27;s in the sequence will definitely give weird results.   </span></span><br><span class="line"><span class="comment"># The program assumes there aren&#x27;t any, and that the longest repeat will be the full sequence to itself.  </span></span><br><span class="line"><span class="comment"># If there are long repeats in the output that are listed as being only at one location, this is probably what happened.  </span></span><br><span class="line"><span class="comment"># If there are a lot of repeats within repeats the results can also be odd.  </span></span><br><span class="line"><span class="comment"># Copyright Alan C. Christensen, University of Nebraska, 2018  </span></span><br><span class="line"><span class="comment"># No guarantees, warranties, support, or anything else is implicit or explicit.  </span></span><br><span class="line"><span class="comment"># Input is a fasta format file of a sequence. Genbank format works but generates lots of error messages in stdout.  </span></span><br><span class="line"><span class="comment"># Output is a list of unique, ungapped repeated sequences, fasta formatted.  </span></span><br><span class="line"><span class="comment"># The names are in the format &#x27;&gt;Repeat/ROUS_name_start_end_length&#x27;.  </span></span><br><span class="line"><span class="comment"># A table of repeats with the coordinates of each one is generated.  </span></span><br><span class="line"><span class="comment"># A list of repeat name, length and copy number is generated.  </span></span><br><span class="line"><span class="comment"># A binned table of the total number of repeats in size ranges is generated.  </span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># PARAMETERS  </span></span><br><span class="line"><span class="comment">#   REQUIRED:  </span></span><br><span class="line"><span class="comment">#      input file in fasta format  </span></span><br><span class="line"><span class="comment">#   Optional  </span></span><br><span class="line"><span class="comment">#      -o output file name  </span></span><br><span class="line"><span class="comment">#      -m minimum length of exact matches to keep  </span></span><br><span class="line"><span class="comment">#      -b path to blastn (default is /usr/bin/)  </span></span><br><span class="line"><span class="comment">#      -k keep temp files  </span></span><br><span class="line"><span class="comment">#      -gb to write the repeats to a genbank format file  </span></span><br><span class="line"><span class="comment">#      -rew reward for match (default is 1)  </span></span><br><span class="line"><span class="comment">#      -pen penalty for mismatch (default is 20)  </span></span><br><span class="line">  </span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;Find repeats in a fasta sequence file&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;infile&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Input .fasta file&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-o&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;outfile&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Output file name seed, default is input_repeats&#x27;</span>, default=<span class="string">&#x27;default&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-m&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;minlen&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Minimum length of matches to keep, default=50&#x27;</span>, default=<span class="string">&#x27;50&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-b&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;blast_path&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Path to blastn program, default is /usr/bin/&#x27;</span>, default=<span class="string">&#x27;/usr/bin/&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-k&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, dest=<span class="string">&#x27;keep&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;True to keep temp files&#x27;</span>, default=<span class="literal">False</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-gb&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, dest=<span class="string">&#x27;genbank&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;True to write GenBank format file&#x27;</span>, default=<span class="literal">False</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-rew&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;reward&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Reward for match&#x27;</span>, default=<span class="string">&#x27;1&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-pen&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;penalty&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Penalty for mismatch&#x27;</span>, default=<span class="string">&#x27;20&#x27;</span>)  </span><br><span class="line">results = parser.parse_args()  </span><br><span class="line">infile = results.infile  </span><br><span class="line">outfile = results.outfile  </span><br><span class="line">minlen = <span class="built_in">int</span>(results.minlen)  </span><br><span class="line">blast_path = results.blast_path  </span><br><span class="line">keep = results.keep  </span><br><span class="line">genbank = results.genbank  </span><br><span class="line">reward = results.reward  </span><br><span class="line">penalty = results.penalty  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># It might be useful to define the wordsize as something less than minlen, so both variables are used.  </span></span><br><span class="line"><span class="comment"># Wordsize smaller than minlen would give smaller core identical sequences in the middle of repeats.  </span></span><br><span class="line"><span class="comment"># An example might be to change this to wordsize = str(int(minlen/2)).  </span></span><br><span class="line">wordsize = <span class="built_in">str</span>(minlen)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># If no output file seed is specified, make one by stripping leading directory information  </span></span><br><span class="line"><span class="comment"># and stripping trailing .fa or .fasta from the input file name and using that.  </span></span><br><span class="line"><span class="keyword">if</span> outfile == <span class="string">&#x27;default&#x27;</span>:  </span><br><span class="line">    outfile = infile  </span><br><span class="line">    <span class="keyword">if</span> outfile.count(<span class="string">&#x27;/&#x27;</span>) &gt; <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(outfile.count(<span class="string">&#x27;/&#x27;</span>)):  </span><br><span class="line">            index = outfile.index(<span class="string">&#x27;/&#x27;</span>)  </span><br><span class="line">            outfile = outfile[index+<span class="number">1</span>:]  </span><br><span class="line">    <span class="keyword">if</span> outfile.endswith(<span class="string">&#x27;.fa&#x27;</span>) <span class="keyword">or</span> outfile.endswith(<span class="string">&#x27;.fasta&#x27;</span>):  </span><br><span class="line">        outfile = outfile.rstrip(<span class="string">&#x27;fasta&#x27;</span>)  </span><br><span class="line">    outfile = outfile.rstrip(<span class="string">&#x27;.&#x27;</span>)  </span><br><span class="line">outfa = outfile+<span class="string">&#x27;_rep.fasta&#x27;</span>  </span><br><span class="line">outtab = outfile+<span class="string">&#x27;_rep_table.txt&#x27;</span>  </span><br><span class="line">outbin = outfile+<span class="string">&#x27;_binned.txt&#x27;</span>  </span><br><span class="line">outcount = outfile+<span class="string">&#x27;_rep_counts.txt&#x27;</span>  </span><br><span class="line">outgb = outfile+<span class="string">&#x27;_repeats.gb.txt&#x27;</span>  </span><br><span class="line">tempblast = outfile+<span class="string">&#x27;_tempblast.txt&#x27;</span>  </span><br><span class="line">temprepeats = outfile+<span class="string">&#x27;_temprepeats.txt&#x27;</span>  </span><br><span class="line">tempparse = outfile+<span class="string">&#x27;_sequence_parsing.txt&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Get sequence name and length from fasta file.  </span></span><br><span class="line">seq = <span class="built_in">open</span>(infile, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">seqname = seq.readline()  </span><br><span class="line">seqname = seqname.lstrip(<span class="string">&#x27;&gt; &#x27;</span>)  </span><br><span class="line">seqname = seqname.rstrip()  </span><br><span class="line">seqlen = <span class="number">0</span>   </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> seq:  </span><br><span class="line">    <span class="keyword">if</span>(line[<span class="number">0</span>] == <span class="string">&quot;&gt;&quot;</span>):  </span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line">    seqlen += <span class="built_in">len</span>(line.strip())  </span><br><span class="line">seq.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># run blastn with query file plus strand (removing first line which is full length sequence), minus strand, and concatenate  </span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Performing self-blastn comparison with &#x27;</span>+seqname      </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+infile+<span class="string">&#x27; -strand plus -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward &#x27;</span>+reward+<span class="string">&#x27; -penalty -&#x27;</span>+penalty+<span class="string">&#x27; -ungapped -dust no -soft_masking false -evalue 10  -outfmt &quot;10 qstart qend length sstart send mismatch sstrand qseq&quot; | tail -n+2 &gt; tempblast1.txt&#x27;</span>)  </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+infile+<span class="string">&#x27; -strand minus -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward &#x27;</span>+reward+<span class="string">&#x27; -penalty -&#x27;</span>+penalty+<span class="string">&#x27; -ungapped -dust no -soft_masking false -evalue 10 -outfmt &quot;10 qstart qend length sstart send mismatch sstrand qseq&quot; &gt; tempblast2.txt&#x27;</span>)  </span><br><span class="line">os.system(<span class="string">&#x27;cat tempblast1.txt tempblast2.txt &gt; &#x27;</span>+tempblast)  </span><br><span class="line">os.system(<span class="string">&#x27;rm tempblast1.txt tempblast2.txt&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># open tempblast.txt, convert to list of lists, and sort by length and position descending  </span></span><br><span class="line"><span class="comment"># This is necessary because blastn does not output every possible pair of hits when there are more than 2 copies of a repeat  </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Sorting alignments...&#x27;</span>  </span><br><span class="line">f = <span class="built_in">open</span>(tempblast, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">reader = csv.reader(f)  </span><br><span class="line">alignments = <span class="built_in">list</span>(reader)  </span><br><span class="line">f.close()  </span><br><span class="line">alignments = <span class="built_in">sorted</span>(alignments, key=<span class="keyword">lambda</span> x: (-<span class="number">1</span>*<span class="built_in">int</span>(x[<span class="number">2</span>]), -<span class="number">1</span>*<span class="built_in">int</span>(x[<span class="number">0</span>])))  </span><br><span class="line">alignments.append([<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;X&#x27;</span>])  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># New list of uniques  </span></span><br><span class="line"><span class="comment"># Text file &#x27;_sequence_parsing.txt&#x27; includes the information on how duplicates were found.  </span></span><br><span class="line"><span class="comment"># Start at row 0. Compare to subsequent rows.   </span></span><br><span class="line"><span class="comment"># If repeat length is different from the next row, it has passed all the tests, write it to the file.  </span></span><br><span class="line"><span class="comment"># If query or subject coordinates are the same as the query or subject or reversed coordinates  </span></span><br><span class="line"><span class="comment"># of a subsequent row, it is not unique, so go to the next row and do the comparisons again.  </span></span><br><span class="line"><span class="comment"># Thanks to Alex Kozik for repeatedly testing and finding bugs in the algorithm.  </span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Finding unique repeats...&#x27;</span>  </span><br><span class="line">uniques = []  </span><br><span class="line">sp = <span class="built_in">open</span>(tempparse, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alignments)):  </span><br><span class="line">    sp.write(<span class="string">&#x27;row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(alignments[row][<span class="number">2</span>]) &lt; minlen:  </span><br><span class="line">        <span class="comment"># This won&#x27;t happen unless the word_size is defined as something other than minlen.  </span></span><br><span class="line">        <span class="comment"># That could be useful under some circumstances.  </span></span><br><span class="line">        sp.write(<span class="string">&#x27;row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is less than minlength&#x27;</span>)  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> compare <span class="keyword">in</span> <span class="built_in">range</span>(row+<span class="number">1</span>,<span class="built_in">len</span>(alignments)):  </span><br><span class="line">            <span class="keyword">if</span> alignments[row][<span class="number">2</span>] != alignments[compare][<span class="number">2</span>]:   </span><br><span class="line">                uniques.append(alignments[row])  </span><br><span class="line">                sp.write(<span class="string">&#x27;\tadding row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; to unique list\n&#x27;</span>)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                sp.write(<span class="string">&#x27;\tcomparing to &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">                <span class="keyword">if</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">0</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">1</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; and &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27; are the same\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">1</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">0</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qend and qstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">3</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">4</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as sstart and send of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">4</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">3</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as send and sstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">0</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">1</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qstart and qend of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">1</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">0</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qend and qstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">3</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">4</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as sstart and send of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">4</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">3</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as send and sstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">else</span>:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is different\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">sp.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Write uniques into output file  </span></span><br><span class="line"><span class="comment"># Start list for copy number table  </span></span><br><span class="line">rous_count = <span class="number">0</span>  </span><br><span class="line">g = <span class="built_in">open</span>(outfa, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">repcopies = []  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(uniques)):  </span><br><span class="line">    qstart = uniques[i][<span class="number">0</span>]  </span><br><span class="line">    qend = uniques[i][<span class="number">1</span>]  </span><br><span class="line">    length = uniques[i][<span class="number">2</span>]  </span><br><span class="line">    seq = uniques[i][<span class="number">7</span>]  </span><br><span class="line">      </span><br><span class="line">    rous_count += <span class="number">1</span>  </span><br><span class="line">    g.write(<span class="string">&#x27;&gt;Repeat_&#x27;</span>+<span class="built_in">str</span>(rous_count)+<span class="string">&#x27;\n&#x27;</span>+seq+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">    repcopies.append([<span class="string">&#x27;Repeat_&#x27;</span>+<span class="built_in">str</span>(rous_count),length])  </span><br><span class="line">          </span><br><span class="line"><span class="keyword">if</span> rous_count == <span class="number">0</span>:  </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;\tRepeats of unusual size? I don&#x27;t think they exist&quot;</span>  </span><br><span class="line">g.close()  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Repeat fasta file is done, as you wish.&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Now find each copy of each repeat. Again, this is because the blastn output file does not have every possible alignment.  </span></span><br><span class="line"><span class="comment"># It is also because the information on locations and strand is not organized well in the blastn output.  </span></span><br><span class="line"><span class="comment"># In addition, this subroutine eliminates duplicates of nested repeats.  </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Finding all copies of repeats...&quot;</span>  </span><br><span class="line">g = <span class="built_in">open</span>(outfa, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+outfa+<span class="string">&#x27; -strand both -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward 1 -penalty -20 -ungapped -dust no -soft_masking false -evalue 1000 -outfmt &quot;10 qseqid length sstart send sstrand qcovhsp&quot; &gt; &#x27;</span>+temprepeats)  </span><br><span class="line">g.close()  </span><br><span class="line">  </span><br><span class="line">tempr = <span class="built_in">open</span>(temprepeats, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">reader = csv.reader(tempr)  </span><br><span class="line">replist = <span class="built_in">list</span>(reader)  </span><br><span class="line">tempr.close()  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Making a table of the repeats...&quot;</span>  </span><br><span class="line">sum_rep_len = <span class="number">0</span>  </span><br><span class="line">bin_dict = &#123;&#125;  </span><br><span class="line">binned = [seqname,seqlen,<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># defining the bins  </span></span><br><span class="line">i = <span class="number">0</span>  </span><br><span class="line">j = <span class="number">50</span>  </span><br><span class="line"><span class="keyword">while</span> j &lt; <span class="number">1000</span>:  </span><br><span class="line">    bin_dict[i] = j  </span><br><span class="line">    binned.append(<span class="number">0</span>)  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    j += <span class="number">50</span>  </span><br><span class="line"><span class="keyword">while</span> j &lt;= <span class="number">10000</span>:  </span><br><span class="line">    bin_dict[i] = j  </span><br><span class="line">    binned.append(<span class="number">0</span>)  </span><br><span class="line">    i +=<span class="number">1</span>  </span><br><span class="line">    j += <span class="number">250</span>  </span><br><span class="line">      </span><br><span class="line"><span class="comment"># make list for entire sequence, set each position as 0  </span></span><br><span class="line">posit = []  </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(seqlen):  </span><br><span class="line">    posit.append(<span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Thanks to Emily Wynn for suggesting qcovhsp for this loop.  </span></span><br><span class="line"><span class="comment"># if qcovhsp is &gt;98%, write to the file  </span></span><br><span class="line"><span class="comment"># write tab separated values of repeat name, length, start, end, strand to outtab  </span></span><br><span class="line"><span class="comment"># make list for genbank file  </span></span><br><span class="line"><span class="comment"># Keep stats on lengths  </span></span><br><span class="line">rt = <span class="built_in">open</span>(outtab, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">rt.write(seqname+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(seqlen)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">templist = []  </span><br><span class="line">gblist =[]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># look at each repeat in turn  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(replist)):  </span><br><span class="line">    <span class="comment"># if repeat is good (&gt;98% identical to another one), write it to the file, and put the name in a list  </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(replist[i][<span class="number">5</span>])&gt;<span class="number">98</span>:  </span><br><span class="line">        rt.write(<span class="built_in">str</span>(replist[i][<span class="number">0</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">1</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">2</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">3</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">4</span>])+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">        <span class="keyword">if</span> replist[i][<span class="number">4</span>] == <span class="string">&#x27;minus&#x27;</span>:  </span><br><span class="line">            location = <span class="string">&#x27;complement(&#x27;</span>+replist[i][<span class="number">3</span>]+<span class="string">&#x27;..&#x27;</span>+replist[i][<span class="number">2</span>]+<span class="string">&#x27;)&#x27;</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            location = replist[i][<span class="number">2</span>]+<span class="string">&#x27;..&#x27;</span>+replist[i][<span class="number">3</span>]  </span><br><span class="line">        gblist.append(<span class="string">&#x27;     repeat_region   &#x27;</span>+location+<span class="string">&#x27;\n                     /rpt_type=dispersed\n                     /label=&#x27;</span>+replist[i][<span class="number">0</span>]+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">        templist.append(replist[i][<span class="number">0</span>])  </span><br><span class="line">        <span class="comment"># then write 1&#x27;s at every position in the sequence covered by that repeat  </span></span><br><span class="line">        <span class="comment"># these can then be summed to get total bases of repeats  </span></span><br><span class="line">        <span class="comment"># bases in overlapping repeats are only counted once  </span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(replist[i][<span class="number">2</span>]), <span class="built_in">int</span>(replist[i][<span class="number">3</span>])):  </span><br><span class="line">            posit[n] = <span class="number">1</span>  </span><br><span class="line">        <span class="comment"># then scan through bin sizes and if a repeat is greater than the  </span></span><br><span class="line">        <span class="comment"># bin_dict size cutoff, add one to the bin  </span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binned)-<span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>):  </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(replist[i][<span class="number">1</span>]) &gt;= bin_dict[j]:  </span><br><span class="line">                binned[j+<span class="number">3</span>] +=<span class="number">1</span>  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">sum_rep_len = posit.count(<span class="number">1</span>)  </span><br><span class="line">binned[<span class="number">2</span>] = sum_rep_len  </span><br><span class="line">rt.close()  </span><br><span class="line"><span class="keyword">if</span> genbank == <span class="literal">True</span>:  </span><br><span class="line">    gb = <span class="built_in">open</span>(outgb, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gblist)):  </span><br><span class="line">        gb.write(gblist[i])  </span><br><span class="line">    gb.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># write tab separated values of repeat name, length, copy number to outcount  </span></span><br><span class="line"><span class="comment"># first two lines are also a table of stats on repeats  </span></span><br><span class="line">rc = <span class="built_in">open</span>(outcount,<span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">rc.write(<span class="string">&#x27;Sequence\tGenome_size\tNumROUS\tAvgSize\tAvgCopyNum\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">numrous = <span class="number">0</span>  </span><br><span class="line">sizerous = <span class="number">0</span>  </span><br><span class="line">copyrous = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(repcopies)):  </span><br><span class="line">    repname = repcopies[i][<span class="number">0</span>]  </span><br><span class="line">    replen = <span class="built_in">float</span>(repcopies[i][<span class="number">1</span>])  </span><br><span class="line">    repcop = <span class="built_in">float</span>(templist.count(repname))  </span><br><span class="line">  </span><br><span class="line">    numrous += <span class="number">1</span>  </span><br><span class="line">    sizerous += replen  </span><br><span class="line">    copyrous += repcop  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> numrous == <span class="number">0</span>:  </span><br><span class="line">    avsizerous = <span class="string">&#x27;NA&#x27;</span>  </span><br><span class="line">    avcopyrous = <span class="string">&#x27;NA&#x27;</span>  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    avsizerous = sizerous/numrous  </span><br><span class="line">    avcopyrous = copyrous/numrous  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">rc.write(seqname+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(seqlen)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(numrous)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(avsizerous)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(avcopyrous)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(repcopies)):  </span><br><span class="line">    rc.write(repcopies[i][<span class="number">0</span>]+<span class="string">&#x27;\t&#x27;</span>+repcopies[i][<span class="number">1</span>]+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(templist.count(repcopies[i][<span class="number">0</span>]))+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">rc.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Write binned table headers, then stats for this sequence.  </span></span><br><span class="line">binfile = <span class="built_in">open</span>(outbin, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;Sequence\tSeq_len\tRep_len\t&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bin_dict)):  </span><br><span class="line">    binfile.write(<span class="built_in">str</span>(bin_dict[i])+<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binned)):  </span><br><span class="line">    binfile.write(<span class="built_in">str</span>(binned[i])+<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">binfile.close()  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Repeat tables are done, as you wish.&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Removing temp files if necessary  </span></span><br><span class="line"><span class="keyword">if</span> keep == <span class="literal">False</span>:  </span><br><span class="line">    os.system(<span class="string">&#x27;rm &#x27;</span>+tempblast+<span class="string">&#x27; &#x27;</span>+temprepeats+<span class="string">&#x27; &#x27;</span>+tempparse)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Rachael Schulte, William Goldman and Rob Reiner inspired this section of code  </span></span><br><span class="line">quote_dict = &#123;<span class="number">0</span>:<span class="string">&quot;48656c6c6f2e204d79206e616d6520697320496e69676f204d6f6e746f79612e20596f75206b696c6c6564206d79206661746865722e205072657061726520746f206469652e&quot;</span>, <span class="number">1</span>:<span class="string">&quot;5768656e20492077617320796f7572206167652c2074656c65766973696f6e207761732063616c6c656420626f6f6b732e&quot;</span>, <span class="number">2</span>:<span class="string">&quot;486176652066756e2073746f726d696e2720646120636173746c6521&quot;</span>, <span class="number">3</span>:<span class="string">&quot;4d79207761792773206e6f7420766572792073706f7274736d616e6c696b652e&quot;</span>, <span class="number">4</span>:<span class="string">&quot;596f75206b656570207573696e67207468617420776f72642e204920646f206e6f74207468696e6b206974206d65616e73207768617420796f75207468696e6b206974206d65616e732e&quot;</span>, <span class="number">5</span>:<span class="string">&quot;4d75726465726564206279207069726174657320697320676f6f642e&quot;</span>,<span class="number">6</span>:<span class="string">&quot;496e636f6e6365697661626c6521&quot;</span>, <span class="number">7</span>:<span class="string">&quot;5468657265277320612062696720646966666572656e6365206265747765656e206d6f73746c79206465616420616e6420616c6c20646561642e&quot;</span>, <span class="number">8</span>:<span class="string">&quot;596f7520727573682061206d697261636c65206d616e2c20796f752067657420726f7474656e206d697261636c65732e&quot;</span>, <span class="number">9</span>:<span class="string">&quot;476f6f64206e696768742c20576573746c65792e20476f6f6420776f726b2e20536c6565702077656c6c2e2049276c6c206d6f7374206c696b656c79206b696c6c20796f7520696e20746865206d6f726e696e672e&quot;</span>,<span class="number">10</span>:<span class="string">&quot;4e6f206d6f7265207268796d65732c2049206d65616e2069742120416e79626f64792077616e742061207065616e75743f&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">import</span> random, binascii  </span><br><span class="line">z = random.randint(<span class="number">0</span>,<span class="number">10</span>)  </span><br><span class="line"><span class="built_in">print</span> binascii.unhexlify(quote_dict[z])+<span class="string">&#x27;\n&#x27;</span>  </span><br></pre></td></tr></table></figure>

<h2 id="2-2-运行脚本鉴定重复"><a href="#2-2-运行脚本鉴定重复" class="headerlink" title="2.2. 运行脚本鉴定重复"></a>2.2. 运行脚本鉴定重复</h2><p>选择ROUSFinder2.py脚本来鉴定线粒体的重复序列。</p>
<ol>
<li>脚本参数</li>
</ol>
<ul>
<li>必需参数：fasta格式的输入序列</li>
<li>-o out：输出文件名称</li>
<li>-m 50：鉴定的重复序列的最小长度，默认是50bp。</li>
<li>-b &#x2F;path&#x2F;to&#x2F;blastn&#x2F;：blastn命令的路径，默认是&#x2F;usr&#x2F;bin&#x2F;。</li>
<li>-k：保留临时文件，out_tempblast.txt和out_temprepeats.txt</li>
<li>-gb：生成重复序列的genbank格式文件，out_repeats.gb.txt</li>
<li>-rew 1：match赏分，默认是+1</li>
<li>-pen 20：mismatch罚分，默认是-20</li>
</ul>
<ol start="2">
<li>运行脚本</li>
</ol>
<ul>
<li><code>ROUSFinder2.py input.fa -m 30 -gb -o out</code></li>
</ul>
<h2 id="2-3-结果文件"><a href="#2-3-结果文件" class="headerlink" title="2.3. 结果文件"></a>2.3. 结果文件</h2><ol>
<li>out_rep_table.txt：包含每个repeat单元的名称，长度，起始位置和终止位置，正负链（plus或minus）。</li>
</ol>
<ul>
<li>第一行显示了第一个染色体的名称和长度。</li>
<li>后面的行有五列，分别是repeat名称，repeat长度，repeat在染色体序列上的起始位置和终止位置，repeat的正负链方向。</li>
<li>通常前面只有一行信息的重复单元（如Repeat_1和Repeat_2）需要手动去除，留下后面有2个或以上重复单元的信息（如Repeat_3和Repeat_4）作为重复序列鉴定的结果。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Chr01	147501</span><br><span class="line">Repeat_1	2702	1	2702	plus</span><br><span class="line">Repeat_2	2480	1	2480	plus</span><br><span class="line">Repeat_3	1171	1933	3103	plus</span><br><span class="line">Repeat_3	1171	2322	3492	plus</span><br><span class="line">Repeat_4	938	1696	2633	plus</span><br><span class="line">Repeat_4	938	2237	3174	plus</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>out_rep.fasta：包含fasta格式的repeat序列</li>
<li>out_rep_counts.txt：包含repeat的总数（NumROUS），平均长度（AvgSize），平均数量（AvgCopyNum），和每个repeat的长度和数量。</li>
<li>out_repeats.gb.txt：使用-gb参数则生成此文件，是genbank格式的repeat的注释文件。</li>
<li>out_binned.txt：包含&gt;50bp,100bp,150bp,…,1000bp,1250bp,1500bp,…,10000bp的repeat的数量</li>
<li>out_tempblast.txt：使用-k参数会保留两个临时temp文件</li>
<li>out_temprepeats.txt：使用-k参数会保留两个临时temp文件。</li>
</ol>
<ul>
<li>out_temprepeats.txt是用重复单元与输入序列做blastn的-outfmt 10的结果，包含qseqid length sstart send sstrand qcovhsp六列内容。</li>
<li>out_rep_table.txt结果文件是从这个out_temprepeats.txt临时文件中提取生成的。</li>
</ul>
<h2 id="2-4-修改鉴定重复的脚本，使其显示重复序列所在染色体位置"><a href="#2-4-修改鉴定重复的脚本，使其显示重复序列所在染色体位置" class="headerlink" title="2.4. 修改鉴定重复的脚本，使其显示重复序列所在染色体位置"></a>2.4. 修改鉴定重复的脚本，使其显示重复序列所在染色体位置</h2><p>ROUSFinder2.py脚本鉴定线粒体的重复序列是被设计的用于鉴定一条序列与自身的重复，所以结果文件中不包含重复所在染色体位置信息。好在脚本容易修改，就修改了脚本使其显示染色体位置，可用于多染色体线粒体基因组的重复序列鉴定。</p>
<p>使用修改后脚本的输出结果中两个文件（out_rep_table.txt和out_temprepeats.txt）有所不同，其他结果文件都与修改前的脚本的结果一致。</p>
<ol>
<li>修改后的脚本ROUSFinder2.0_adjusted.by.yz.py</li>
</ol>
<ul>
<li>ROUSFinder2.0_adjusted.by.yz.py可以在结果文件out_rep_table.txt中显示染色体位置信息。</li>
<li>修改后脚本保存在：<a target="_blank" rel="noopener" href="https://github.com/yanzhongsino/bioscripts/blob/main/modified_scripts/ROUSFinder2.0_adjusted.by.yz.py">https://github.com/yanzhongsino/bioscripts/blob/main/modified_scripts/ROUSFinder2.0_adjusted.by.yz.py</a></li>
<li>修改后脚本也贴在下面：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> sys, math, os, argparse, csv  </span><br><span class="line">csv.field_size_limit(sys.maxsize)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># minior adjustments by Yan Zhong, November 27, 2023  </span></span><br><span class="line"><span class="comment"># Version 2.0, November 21, 2018  </span></span><br><span class="line"><span class="comment"># Changes: uses variable parameters  </span></span><br><span class="line"><span class="comment"># Find dispersed repeated sequences in genomes.   </span></span><br><span class="line"><span class="comment"># Designed for plant mitochondrial genomes of up to a few Mbp.  </span></span><br><span class="line"><span class="comment"># May be very slow with larger genomes.   </span></span><br><span class="line"><span class="comment"># Blast can also sometimes give odd results with large or highly repetetive genomes.  </span></span><br><span class="line"><span class="comment"># Gaps, or runs of &#x27;N&#x27;s in the sequence will definitely give weird results.   </span></span><br><span class="line"><span class="comment"># The program assumes there aren&#x27;t any, and that the longest repeat will be the full sequence to itself.  </span></span><br><span class="line"><span class="comment"># If there are long repeats in the output that are listed as being only at one location, this is probably what happened.  </span></span><br><span class="line"><span class="comment"># If there are a lot of repeats within repeats the results can also be odd.  </span></span><br><span class="line"><span class="comment"># Copyright Alan C. Christensen, University of Nebraska, 2018  </span></span><br><span class="line"><span class="comment"># No guarantees, warranties, support, or anything else is implicit or explicit.  </span></span><br><span class="line"><span class="comment"># Input is a fasta format file of a sequence. Genbank format works but generates lots of error messages in stdout.  </span></span><br><span class="line"><span class="comment"># Output is a list of unique, ungapped repeated sequences, fasta formatted.  </span></span><br><span class="line"><span class="comment"># The names are in the format &#x27;&gt;Repeat/ROUS_name_start_end_length&#x27;.  </span></span><br><span class="line"><span class="comment"># A table of repeats with the coordinates of each one is generated.  </span></span><br><span class="line"><span class="comment"># A list of repeat name, length and copy number is generated.  </span></span><br><span class="line"><span class="comment"># A binned table of the total number of repeats in size ranges is generated.  </span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># PARAMETERS  </span></span><br><span class="line"><span class="comment">#   REQUIRED:  </span></span><br><span class="line"><span class="comment">#      input file in fasta format  </span></span><br><span class="line"><span class="comment">#   Optional  </span></span><br><span class="line"><span class="comment">#      -o output file name  </span></span><br><span class="line"><span class="comment">#      -m minimum length of exact matches to keep  </span></span><br><span class="line"><span class="comment">#      -b path to blastn (default is /usr/bin/)  </span></span><br><span class="line"><span class="comment">#      -k keep temp files  </span></span><br><span class="line"><span class="comment">#      -gb to write the repeats to a genbank format file  </span></span><br><span class="line"><span class="comment">#      -rew reward for match (default is 1)  </span></span><br><span class="line"><span class="comment">#      -pen penalty for mismatch (default is 20)  </span></span><br><span class="line">  </span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;Find repeats in a fasta sequence file&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;infile&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Input .fasta file&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-o&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;outfile&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Output file name seed, default is input_repeats&#x27;</span>, default=<span class="string">&#x27;default&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-m&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;minlen&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Minimum length of matches to keep, default=50&#x27;</span>, default=<span class="string">&#x27;50&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-b&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;blast_path&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Path to blastn program, default is /usr/bin/&#x27;</span>, default=<span class="string">&#x27;/usr/bin/&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-k&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, dest=<span class="string">&#x27;keep&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;True to keep temp files&#x27;</span>, default=<span class="literal">False</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-gb&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, dest=<span class="string">&#x27;genbank&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;True to write GenBank format file&#x27;</span>, default=<span class="literal">False</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-rew&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;reward&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Reward for match&#x27;</span>, default=<span class="string">&#x27;1&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-pen&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;penalty&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Penalty for mismatch&#x27;</span>, default=<span class="string">&#x27;20&#x27;</span>)  </span><br><span class="line">results = parser.parse_args()  </span><br><span class="line">infile = results.infile  </span><br><span class="line">outfile = results.outfile  </span><br><span class="line">minlen = <span class="built_in">int</span>(results.minlen)  </span><br><span class="line">blast_path = results.blast_path  </span><br><span class="line">keep = results.keep  </span><br><span class="line">genbank = results.genbank  </span><br><span class="line">reward = results.reward  </span><br><span class="line">penalty = results.penalty  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># It might be useful to define the wordsize as something less than minlen, so both variables are used.  </span></span><br><span class="line"><span class="comment"># Wordsize smaller than minlen would give smaller core identical sequences in the middle of repeats.  </span></span><br><span class="line"><span class="comment"># An example might be to change this to wordsize = str(int(minlen/2)).  </span></span><br><span class="line">wordsize = <span class="built_in">str</span>(minlen)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># If no output file seed is specified, make one by stripping leading directory information  </span></span><br><span class="line"><span class="comment"># and stripping trailing .fa or .fasta from the input file name and using that.  </span></span><br><span class="line"><span class="keyword">if</span> outfile == <span class="string">&#x27;default&#x27;</span>:  </span><br><span class="line">    outfile = infile  </span><br><span class="line">    <span class="keyword">if</span> outfile.count(<span class="string">&#x27;/&#x27;</span>) &gt; <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(outfile.count(<span class="string">&#x27;/&#x27;</span>)):  </span><br><span class="line">            index = outfile.index(<span class="string">&#x27;/&#x27;</span>)  </span><br><span class="line">            outfile = outfile[index+<span class="number">1</span>:]  </span><br><span class="line">    <span class="keyword">if</span> outfile.endswith(<span class="string">&#x27;.fa&#x27;</span>) <span class="keyword">or</span> outfile.endswith(<span class="string">&#x27;.fasta&#x27;</span>):  </span><br><span class="line">        outfile = outfile.rstrip(<span class="string">&#x27;fasta&#x27;</span>)  </span><br><span class="line">    outfile = outfile.rstrip(<span class="string">&#x27;.&#x27;</span>)  </span><br><span class="line">outfa = outfile+<span class="string">&#x27;_rep.fasta&#x27;</span>  </span><br><span class="line">outtab = outfile+<span class="string">&#x27;_rep_table.txt&#x27;</span>  </span><br><span class="line">outbin = outfile+<span class="string">&#x27;_binned.txt&#x27;</span>  </span><br><span class="line">outcount = outfile+<span class="string">&#x27;_rep_counts.txt&#x27;</span>  </span><br><span class="line">outgb = outfile+<span class="string">&#x27;_repeats.gb.txt&#x27;</span>  </span><br><span class="line">tempblast = outfile+<span class="string">&#x27;_tempblast.txt&#x27;</span>  </span><br><span class="line">temprepeats = outfile+<span class="string">&#x27;_temprepeats.txt&#x27;</span>  </span><br><span class="line">tempparse = outfile+<span class="string">&#x27;_sequence_parsing.txt&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Get sequence name and length from fasta file.  </span></span><br><span class="line">seq = <span class="built_in">open</span>(infile, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">seqname = seq.readline()  </span><br><span class="line">seqname = seqname.lstrip(<span class="string">&#x27;&gt; &#x27;</span>)  </span><br><span class="line">seqname = seqname.rstrip()  </span><br><span class="line">seqlen = <span class="number">0</span>   </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> seq:  </span><br><span class="line">    <span class="keyword">if</span>(line[<span class="number">0</span>] == <span class="string">&quot;&gt;&quot;</span>):  </span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line">    seqlen += <span class="built_in">len</span>(line.strip())  </span><br><span class="line">seq.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># run blastn with query file plus strand (removing first line which is full length sequence), minus strand, and concatenate  </span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Performing self-blastn comparison with &#x27;</span>+seqname      </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+infile+<span class="string">&#x27; -strand plus -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward &#x27;</span>+reward+<span class="string">&#x27; -penalty -&#x27;</span>+penalty+<span class="string">&#x27; -ungapped -dust no -soft_masking false -evalue 10  -outfmt &quot;10 qstart qend length sstart send mismatch sstrand qseq&quot; | tail -n+2 &gt; tempblast1.txt&#x27;</span>)  </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+infile+<span class="string">&#x27; -strand minus -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward &#x27;</span>+reward+<span class="string">&#x27; -penalty -&#x27;</span>+penalty+<span class="string">&#x27; -ungapped -dust no -soft_masking false -evalue 10 -outfmt &quot;10 qstart qend length sstart send mismatch sstrand qseq&quot; &gt; tempblast2.txt&#x27;</span>)  </span><br><span class="line">os.system(<span class="string">&#x27;cat tempblast1.txt tempblast2.txt &gt; &#x27;</span>+tempblast)  </span><br><span class="line">os.system(<span class="string">&#x27;rm tempblast1.txt tempblast2.txt&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># open tempblast.txt, convert to list of lists, and sort by length and position descending  </span></span><br><span class="line"><span class="comment"># This is necessary because blastn does not output every possible pair of hits when there are more than 2 copies of a repeat  </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Sorting alignments...&#x27;</span>  </span><br><span class="line">f = <span class="built_in">open</span>(tempblast, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">reader = csv.reader(f)  </span><br><span class="line">alignments = <span class="built_in">list</span>(reader)  </span><br><span class="line">f.close()  </span><br><span class="line">alignments = <span class="built_in">sorted</span>(alignments, key=<span class="keyword">lambda</span> x: (-<span class="number">1</span>*<span class="built_in">int</span>(x[<span class="number">2</span>]), -<span class="number">1</span>*<span class="built_in">int</span>(x[<span class="number">0</span>])))  </span><br><span class="line">alignments.append([<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;X&#x27;</span>])  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># New list of uniques  </span></span><br><span class="line"><span class="comment"># Text file &#x27;_sequence_parsing.txt&#x27; includes the information on how duplicates were found.  </span></span><br><span class="line"><span class="comment"># Start at row 0. Compare to subsequent rows.   </span></span><br><span class="line"><span class="comment"># If repeat length is different from the next row, it has passed all the tests, write it to the file.  </span></span><br><span class="line"><span class="comment"># If query or subject coordinates are the same as the query or subject or reversed coordinates  </span></span><br><span class="line"><span class="comment"># of a subsequent row, it is not unique, so go to the next row and do the comparisons again.  </span></span><br><span class="line"><span class="comment"># Thanks to Alex Kozik for repeatedly testing and finding bugs in the algorithm.  </span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Finding unique repeats...&#x27;</span>  </span><br><span class="line">uniques = []  </span><br><span class="line">sp = <span class="built_in">open</span>(tempparse, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alignments)):  </span><br><span class="line">    sp.write(<span class="string">&#x27;row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(alignments[row][<span class="number">2</span>]) &lt; minlen:  </span><br><span class="line">        <span class="comment"># This won&#x27;t happen unless the word_size is defined as something other than minlen.  </span></span><br><span class="line">        <span class="comment"># That could be useful under some circumstances.  </span></span><br><span class="line">        sp.write(<span class="string">&#x27;row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is less than minlength&#x27;</span>)  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> compare <span class="keyword">in</span> <span class="built_in">range</span>(row+<span class="number">1</span>,<span class="built_in">len</span>(alignments)):  </span><br><span class="line">            <span class="keyword">if</span> alignments[row][<span class="number">2</span>] != alignments[compare][<span class="number">2</span>]:   </span><br><span class="line">                uniques.append(alignments[row])  </span><br><span class="line">                sp.write(<span class="string">&#x27;\tadding row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; to unique list\n&#x27;</span>)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                sp.write(<span class="string">&#x27;\tcomparing to &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">                <span class="keyword">if</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">0</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">1</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; and &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27; are the same\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">1</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">0</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qend and qstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">3</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">4</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as sstart and send of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">4</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">3</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as send and sstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">0</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">1</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qstart and qend of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">1</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">0</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qend and qstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">3</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">4</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as sstart and send of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">4</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">3</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as send and sstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">else</span>:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is different\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">sp.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Write uniques into output file  </span></span><br><span class="line"><span class="comment"># Start list for copy number table  </span></span><br><span class="line">rous_count = <span class="number">0</span>  </span><br><span class="line">g = <span class="built_in">open</span>(outfa, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">repcopies = []  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(uniques)):  </span><br><span class="line">    qstart = uniques[i][<span class="number">0</span>]  </span><br><span class="line">    qend = uniques[i][<span class="number">1</span>]  </span><br><span class="line">    length = uniques[i][<span class="number">2</span>]  </span><br><span class="line">    seq = uniques[i][<span class="number">7</span>]  </span><br><span class="line">      </span><br><span class="line">    rous_count += <span class="number">1</span>  </span><br><span class="line">    g.write(<span class="string">&#x27;&gt;Repeat_&#x27;</span>+<span class="built_in">str</span>(rous_count)+<span class="string">&#x27;\n&#x27;</span>+seq+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">    repcopies.append([<span class="string">&#x27;Repeat_&#x27;</span>+<span class="built_in">str</span>(rous_count),length])  </span><br><span class="line">          </span><br><span class="line"><span class="keyword">if</span> rous_count == <span class="number">0</span>:  </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;\tRepeats of unusual size? I don&#x27;t think they exist&quot;</span>  </span><br><span class="line">g.close()  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Repeat fasta file is done, as you wish.&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Now find each copy of each repeat. Again, this is because the blastn output file does not have every possible alignment.  </span></span><br><span class="line"><span class="comment"># It is also because the information on locations and strand is not organized well in the blastn output.  </span></span><br><span class="line"><span class="comment"># In addition, this subroutine eliminates duplicates of nested repeats.  </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Finding all copies of repeats...&quot;</span>  </span><br><span class="line">g = <span class="built_in">open</span>(outfa, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+outfa+<span class="string">&#x27; -strand both -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward 1 -penalty -20 -ungapped -dust no -soft_masking false -evalue 1000 -outfmt &quot;10 qseqid length sstart send sstrand qcovhsp sseqid qstart qend&quot; &gt; &#x27;</span>+temprepeats)  <span class="comment"># adjusted by yz</span></span><br><span class="line">g.close()  </span><br><span class="line">  </span><br><span class="line">tempr = <span class="built_in">open</span>(temprepeats, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">reader = csv.reader(tempr)  </span><br><span class="line">replist = <span class="built_in">list</span>(reader)  </span><br><span class="line">tempr.close()  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Making a table of the repeats...&quot;</span>  </span><br><span class="line">sum_rep_len = <span class="number">0</span>  </span><br><span class="line">bin_dict = &#123;&#125;  </span><br><span class="line">binned = [seqname,seqlen,<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># defining the bins  </span></span><br><span class="line">i = <span class="number">0</span>  </span><br><span class="line">j = <span class="number">50</span>  </span><br><span class="line"><span class="keyword">while</span> j &lt; <span class="number">1000</span>:  </span><br><span class="line">    bin_dict[i] = j  </span><br><span class="line">    binned.append(<span class="number">0</span>)  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    j += <span class="number">50</span>  </span><br><span class="line"><span class="keyword">while</span> j &lt;= <span class="number">10000</span>:  </span><br><span class="line">    bin_dict[i] = j  </span><br><span class="line">    binned.append(<span class="number">0</span>)  </span><br><span class="line">    i +=<span class="number">1</span>  </span><br><span class="line">    j += <span class="number">250</span>  </span><br><span class="line">      </span><br><span class="line"><span class="comment"># make list for entire sequence, set each position as 0  </span></span><br><span class="line">posit = []  </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(seqlen):  </span><br><span class="line">    posit.append(<span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Thanks to Emily Wynn for suggesting qcovhsp for this loop.  </span></span><br><span class="line"><span class="comment"># if qcovhsp is &gt;98%, write to the file  </span></span><br><span class="line"><span class="comment"># write tab separated values of repeat name, length, start, end, strand to outtab  </span></span><br><span class="line"><span class="comment"># make list for genbank file  </span></span><br><span class="line"><span class="comment"># Keep stats on lengths  </span></span><br><span class="line">rt = <span class="built_in">open</span>(outtab, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line"><span class="comment"># rt.write(seqname+&#x27;\t&#x27;+str(seqlen)+&#x27;\n&#x27;) # adjusted by yz</span></span><br><span class="line">rt.write(<span class="string">&#x27;repeat.name&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;alignment.length&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;repeat.start&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;repeat.end&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;strand&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;qcovhsp&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;chr.name&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;chr.start&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;chr.end&#x27;</span>+<span class="string">&#x27;\n&#x27;</span>)  <span class="comment"># adjusted by yz</span></span><br><span class="line">templist = []  </span><br><span class="line">gblist =[]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># look at each repeat in turn  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(replist)):  </span><br><span class="line">    <span class="comment"># if repeat is good (&gt;98% identical to another one), write it to the file, and put the name in a list  </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(replist[i][<span class="number">5</span>])&gt;<span class="number">98</span>:  </span><br><span class="line">        rt.write(<span class="built_in">str</span>(replist[i][<span class="number">0</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">1</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">7</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">8</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">4</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">5</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">6</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">2</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">3</span>])+<span class="string">&#x27;\n&#x27;</span>)  <span class="comment"># adjusted by yz</span></span><br><span class="line">        <span class="keyword">if</span> replist[i][<span class="number">4</span>] == <span class="string">&#x27;minus&#x27;</span>:  </span><br><span class="line">            location = <span class="string">&#x27;complement(&#x27;</span>+replist[i][<span class="number">3</span>]+<span class="string">&#x27;..&#x27;</span>+replist[i][<span class="number">2</span>]+<span class="string">&#x27;)&#x27;</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            location = replist[i][<span class="number">2</span>]+<span class="string">&#x27;..&#x27;</span>+replist[i][<span class="number">3</span>]  </span><br><span class="line">        gblist.append(<span class="string">&#x27;     repeat_region   &#x27;</span>+location+<span class="string">&#x27;\n                     /rpt_type=dispersed\n                     /label=&#x27;</span>+replist[i][<span class="number">0</span>]+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">        templist.append(replist[i][<span class="number">0</span>])  </span><br><span class="line">        <span class="comment"># then write 1&#x27;s at every position in the sequence covered by that repeat  </span></span><br><span class="line">        <span class="comment"># these can then be summed to get total bases of repeats  </span></span><br><span class="line">        <span class="comment"># bases in overlapping repeats are only counted once  </span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(replist[i][<span class="number">2</span>]), <span class="built_in">int</span>(replist[i][<span class="number">3</span>])):  </span><br><span class="line">            posit[n] = <span class="number">1</span>  </span><br><span class="line">        <span class="comment"># then scan through bin sizes and if a repeat is greater than the  </span></span><br><span class="line">        <span class="comment"># bin_dict size cutoff, add one to the bin  </span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binned)-<span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>):  </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(replist[i][<span class="number">1</span>]) &gt;= bin_dict[j]:  </span><br><span class="line">                binned[j+<span class="number">3</span>] +=<span class="number">1</span>  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">sum_rep_len = posit.count(<span class="number">1</span>)  </span><br><span class="line">binned[<span class="number">2</span>] = sum_rep_len  </span><br><span class="line">rt.close()  </span><br><span class="line"><span class="keyword">if</span> genbank == <span class="literal">True</span>:  </span><br><span class="line">    gb = <span class="built_in">open</span>(outgb, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gblist)):  </span><br><span class="line">        gb.write(gblist[i])  </span><br><span class="line">    gb.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># write tab separated values of repeat name, length, copy number to outcount  </span></span><br><span class="line"><span class="comment"># first two lines are also a table of stats on repeats  </span></span><br><span class="line">rc = <span class="built_in">open</span>(outcount,<span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">rc.write(<span class="string">&#x27;Sequence\tGenome_size\tNumROUS\tAvgSize\tAvgCopyNum\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">numrous = <span class="number">0</span>  </span><br><span class="line">sizerous = <span class="number">0</span>  </span><br><span class="line">copyrous = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(repcopies)):  </span><br><span class="line">    repname = repcopies[i][<span class="number">0</span>]  </span><br><span class="line">    replen = <span class="built_in">float</span>(repcopies[i][<span class="number">1</span>])  </span><br><span class="line">    repcop = <span class="built_in">float</span>(templist.count(repname))  </span><br><span class="line">  </span><br><span class="line">    numrous += <span class="number">1</span>  </span><br><span class="line">    sizerous += replen  </span><br><span class="line">    copyrous += repcop  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> numrous == <span class="number">0</span>:  </span><br><span class="line">    avsizerous = <span class="string">&#x27;NA&#x27;</span>  </span><br><span class="line">    avcopyrous = <span class="string">&#x27;NA&#x27;</span>  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    avsizerous = sizerous/numrous  </span><br><span class="line">    avcopyrous = copyrous/numrous  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">rc.write(seqname+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(seqlen)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(numrous)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(avsizerous)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(avcopyrous)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(repcopies)):  </span><br><span class="line">    rc.write(repcopies[i][<span class="number">0</span>]+<span class="string">&#x27;\t&#x27;</span>+repcopies[i][<span class="number">1</span>]+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(templist.count(repcopies[i][<span class="number">0</span>]))+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">rc.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Write binned table headers, then stats for this sequence.  </span></span><br><span class="line">binfile = <span class="built_in">open</span>(outbin, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;Sequence\tSeq_len\tRep_len\t&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bin_dict)):  </span><br><span class="line">    binfile.write(<span class="built_in">str</span>(bin_dict[i])+<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binned)):  </span><br><span class="line">    binfile.write(<span class="built_in">str</span>(binned[i])+<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">binfile.close()  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Repeat tables are done, as you wish.&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Removing temp files if necessary  </span></span><br><span class="line"><span class="keyword">if</span> keep == <span class="literal">False</span>:  </span><br><span class="line">    os.system(<span class="string">&#x27;rm &#x27;</span>+tempblast+<span class="string">&#x27; &#x27;</span>+temprepeats+<span class="string">&#x27; &#x27;</span>+tempparse)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Rachael Schulte, William Goldman and Rob Reiner inspired this section of code  </span></span><br><span class="line">quote_dict = &#123;<span class="number">0</span>:<span class="string">&quot;48656c6c6f2e204d79206e616d6520697320496e69676f204d6f6e746f79612e20596f75206b696c6c6564206d79206661746865722e205072657061726520746f206469652e&quot;</span>, <span class="number">1</span>:<span class="string">&quot;5768656e20492077617320796f7572206167652c2074656c65766973696f6e207761732063616c6c656420626f6f6b732e&quot;</span>, <span class="number">2</span>:<span class="string">&quot;486176652066756e2073746f726d696e2720646120636173746c6521&quot;</span>, <span class="number">3</span>:<span class="string">&quot;4d79207761792773206e6f7420766572792073706f7274736d616e6c696b652e&quot;</span>, <span class="number">4</span>:<span class="string">&quot;596f75206b656570207573696e67207468617420776f72642e204920646f206e6f74207468696e6b206974206d65616e73207768617420796f75207468696e6b206974206d65616e732e&quot;</span>, <span class="number">5</span>:<span class="string">&quot;4d75726465726564206279207069726174657320697320676f6f642e&quot;</span>,<span class="number">6</span>:<span class="string">&quot;496e636f6e6365697661626c6521&quot;</span>, <span class="number">7</span>:<span class="string">&quot;5468657265277320612062696720646966666572656e6365206265747765656e206d6f73746c79206465616420616e6420616c6c20646561642e&quot;</span>, <span class="number">8</span>:<span class="string">&quot;596f7520727573682061206d697261636c65206d616e2c20796f752067657420726f7474656e206d697261636c65732e&quot;</span>, <span class="number">9</span>:<span class="string">&quot;476f6f64206e696768742c20576573746c65792e20476f6f6420776f726b2e20536c6565702077656c6c2e2049276c6c206d6f7374206c696b656c79206b696c6c20796f7520696e20746865206d6f726e696e672e&quot;</span>,<span class="number">10</span>:<span class="string">&quot;4e6f206d6f7265207268796d65732c2049206d65616e2069742120416e79626f64792077616e742061207065616e75743f&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">import</span> random, binascii  </span><br><span class="line">z = random.randint(<span class="number">0</span>,<span class="number">10</span>)  </span><br><span class="line"><span class="built_in">print</span> binascii.unhexlify(quote_dict[z])+<span class="string">&#x27;\n&#x27;</span>  </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改前脚本的结果文件out_rep_table.txt</li>
</ol>
<ul>
<li>第一行显示了第一个染色体的名称和长度。</li>
<li>后面的行有五列，分别是重复单元的名称(repeat.name)，重复单元的长度(alignment.length)，重复单元在输入的染色体序列上的起始位置和终止位置(chr.start和chr.end)，重复单元的正负链方向(strand)。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Chr01	147501</span><br><span class="line">Repeat_1	2702	1	2702	plus</span><br><span class="line">Repeat_2	2480	1	2480	plus</span><br><span class="line">Repeat_3	1171	1933	3103	plus</span><br><span class="line">Repeat_3	1171	2322	3492	plus</span><br><span class="line">Repeat_4	938	1696	2633	plus</span><br><span class="line">Repeat_4	938	2237	3174	plus</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改后脚本的结果文件out_rep_table.txt</li>
</ol>
<ul>
<li>添加了标题行。包含重复单元的名称(repeat.name)，重复单元的长度(alignment.length)，重复单元在重复序列上起始和终止位置(repeat.start和repeat.end)，重复单元的正负链方向(strand)，每个高度相似片段HSP中的重复单元的覆盖度(Query Coverage Per HSP, qcovhsp)，染色体序列名称(chr.name)，重复单元在输入的染色体序列上的起始位置和终止位置(chr.start和chr.end)。</li>
<li>添加了列的展示，主要是染色体序列名称(chr.name)，还包括repeat.start和repeat.end，qcovhsp。</li>
<li>调整了列的展示顺序。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repeat.name	alignment.length	repeat.start	repeat.end	strand	qcovhsp	chr.name	chr.start	chr.end</span><br><span class="line">Repeat_1	2702	1	2702	plus	100	Chr38	1	2702</span><br><span class="line">Repeat_2	2480	1	2480	plus	100	Chr39	1	2480</span><br><span class="line">Repeat_3	1171	1	1171	plus	100	Chr34	1933	3103</span><br><span class="line">Repeat_3	1171	1	1171	plus	100	Chr09	2322	3492</span><br><span class="line">Repeat_4	938	1	938	plus	100	Chr38	1696	2633</span><br><span class="line">Repeat_4	938	1	938	plus	100	Chr32	2237	3174</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>修改后脚本的结果文件out_temprepeats.txt</li>
</ol>
<ul>
<li>修改后脚本的结果文件out_temprepeats.txt比起修改前在后面多加了三列信息chr.name,repeat.start和repeat.end。</li>
</ul>
<ol start="5">
<li>notes（与脚本的修改无关）</li>
</ol>
<ul>
<li>从修改后脚本的结果文件out_rep_table.txt的示例文件可看出，qcovhsp列绝大部分情况下是100，因为这个值高于98才会被鉴定为重复单元。</li>
<li>repeat.start和repeat.end两列的值也一般是固定的，从1到重复单元的末位。这两列值是用重复序列与输入序列做blast，比对结果中比对到的重复序列的重复单元的位置，通常只有完全比对上（repeat.start和repeat.end两列值从1到重复单元的末位）的才被鉴定为重复单元。</li>
</ul>
<h2 id="2-5-重复的应用"><a href="#2-5-重复的应用" class="headerlink" title="2.5. 重复的应用"></a>2.5. 重复的应用</h2><ol>
<li>辅助线粒体组装</li>
</ol>
<ul>
<li>通过鉴定出来的重复，可以帮助线粒体组装得更完整。</li>
<li>调整线粒体的已有组装。比如通过计算重组率，把主导的优势构象作为最后的线粒体组装构象。</li>
</ul>
<ol start="2">
<li>鉴定重组</li>
</ol>
<ul>
<li>重复序列可能介导重组，所以鉴定重复是鉴定重组的基础。</li>
</ul>
<h1 id="3-鉴定重组和计算重组率"><a href="#3-鉴定重组和计算重组率" class="headerlink" title="3. 鉴定重组和计算重组率"></a>3. 鉴定重组和计算重组率</h1><p>鉴定出线粒体的重复序列后，还可以进一步鉴定这些重复序列是否介导了重组。</p>
<p>重组会导致构象的变化，构象变化的形式包括：</p>
<ol>
<li>位于不同染色体环上的一对重复序列可能介导重组，使得两个小环变成一个大环。</li>
<li>位于同一个染色体环上的同方向的一对重复序列可能介导重组，使得一个大环变成两个小环。</li>
<li>位于同一个染色体环上的反方向的一对重复序列，可能在其他重复对的重组变换下变成同方向或者两个小环的状态。</li>
</ol>
<h2 id="3-1-鉴定重组的步骤"><a href="#3-1-鉴定重组的步骤" class="headerlink" title="3.1. 鉴定重组的步骤"></a>3.1. 鉴定重组的步骤</h2><h3 id="3-1-1-构建参考构象和重组构象的序列"><a href="#3-1-1-构建参考构象和重组构象的序列" class="headerlink" title="3.1.1. 构建参考构象和重组构象的序列"></a>3.1.1. 构建参考构象和重组构象的序列</h3><ol>
<li>针对一对可能造成重组的重复序列，构建参考构象和重组构象</li>
<li>在参考构象和重组构象中，以重复序列加上两翼各300bp作为参考构象序列(ref_1和ref_2)和重组构象序列(rec_1和rec_2)</li>
<li>构建参考序列和mapping注意事项</li>
</ol>
<ul>
<li>可以把参考构象序列和重组构象序列（一共四条）一同作为参考序列（reference）用于mapping，避免同一条reads mapping到多个构象序列从而重复计数的情况。</li>
<li>如果担心叶绿体派生的reads影响重组率的计算，还可以加上叶绿体基因组作为参考序列（reference），这样叶绿体的reads会被mapping到叶绿体上，从而起到过滤的作用。</li>
<li>如果担心核基因派生的reads影响，可以用一个cutoff值(比如100bp)，小于100bp的mapping被筛除。</li>
</ul>
<h3 id="3-1-2-把reads往参考序列进行mapping"><a href="#3-1-2-把reads往参考序列进行mapping" class="headerlink" title="3.1.2. 把reads往参考序列进行mapping"></a>3.1.2. 把reads往参考序列进行mapping</h3><ol>
<li>把reads往参考序列进行mapping，之后再根据mapping的reads的位置进行筛选，筛选出横跨repeat区域的有效mapping。</li>
<li>比如repeat长度为220bp，两边各截取300bp，共820bp长度的参考序列。这里把跨越220bp的repeat，并且两边各至少映射上10bp的reads作为有效mapping。这意味着，mapping的起始位置需要小于290，终止位置需要大于530bp。</li>
<li>bwa进行mapping后得到的bam文件的第4列代表read比对到的参考序列最左侧的位置坐标（未必对上第4列为0）；第9列代表pair read完全匹配到同一条参考序列时，两个read之间的长度。可以理解为insert size。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 530 # 设置终止位置需要大于的值，这里是530bp</span><br><span class="line">bwa index reference.fa # 为参考序列建立索引</span><br><span class="line">bwa mem -t 4 reference.fa  sample_1.clean.fq sample_2.clean.fq | samtools sort -@ 4 -m 4G &gt; reference.bam # 映射reads到参考序列</span><br><span class="line">samtools view reference.bam |awk -F&quot;\t&quot; -v awka=&quot;$a&quot; &#x27;$4&lt;290 &amp;&amp; ($4+$9)&gt;awka &#123;print $0&#125;&#x27; &gt; reference.bam.filter # 筛选起始位置小于290，终止位置大于530bp的mapped reads。这里的`awk -F&quot;\t&quot;`参数设定列分隔符非常重要，已经坑过我两把了。</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-计算重组率-recombination-rate"><a href="#3-1-3-计算重组率-recombination-rate" class="headerlink" title="3.1.3. 计算重组率(recombination rate)"></a>3.1.3. 计算重组率(recombination rate)</h3><ol>
<li>把reads往参考序列进行mapping得到有效映射的比对文件reference.bam.filter后，计算不同参考序列的有效映射的reads数量（即数据行数）。</li>
<li>重组构象的两条序列(rec_1和rec_2)的比对reads数量之和作为分子，重组构象的两条序列(rec_1和rec_2)的比对reads数量与参考构象的两条序列(ref_1和ref_2)的比对reads数量之和作为分母，两者的比值可作为重组率。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n_ref_1 = $(cat reference.bam.filter | awk &#x27;$3 == &quot;ref_1&quot; &#123;print $0&#125;&#x27; |wc -l) # 统计参考构象序列ref_1上有效映射reads的数量</span><br><span class="line">n_ref_2 = $(cat reference.bam.filter | awk &#x27;$3 == &quot;ref_2&quot; &#123;print $0&#125;&#x27; |wc -l) # 统计参考构象序列ref_2上有效映射reads的数量</span><br><span class="line">n_rec_1 = $(cat reference.bam.filter | awk &#x27;$3 == &quot;rec_1&quot; &#123;print $0&#125;&#x27; |wc -l) # 统计参考构象序列rec_1上有效映射reads的数量</span><br><span class="line">n_rec_2 = $(cat reference.bam.filter | awk &#x27;$3 == &quot;rec_2&quot; &#123;print $0&#125;&#x27; |wc -l) # 统计参考构象序列rec_2上有效映射reads的数量</span><br><span class="line">mapping_rate = $(($n_rec_1+$n_rec_2)/($n_ref_1+$n_ref_2+$n_rec_1+$n_rec_2)) # 计算重组率</span><br></pre></td></tr></table></figure>

<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li>ROUSFinder.py脚本：<a target="_blank" rel="noopener" href="https://academic.oup.com/g3journal/article/9/2/549/6026745">https://academic.oup.com/g3journal/article/9/2/549/6026745</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=30% title="wechat_public_QRcode.png" align=center/>
    </div>

    
    
    
        <div class="reward-container">
  <div>真诚赞赏，手留余香</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="南方枝叶 WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="南方枝叶 Alipay">
        <p>Alipay</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/mitogenome/" rel="tag"># mitogenome</a>
              <a href="/tags/repeat/" rel="tag"># repeat</a>
              <a href="/tags/recombination/" rel="tag"># recombination</a>
              <a href="/tags/rearrangement/" rel="tag"># rearrangement</a>
              <a href="/tags/insert-size/" rel="tag"># insert size</a>
              <a href="/tags/recombination-frequency/" rel="tag"># recombination frequency</a>
              <a href="/tags/ROUSFinder/" rel="tag"># ROUSFinder</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/13/bioinfo_phylogeny_MDS/" rel="prev" title="树空间的多维缩放（multidimensional scaling，MDS）可视化物种树和基因树的RF距离">
      <i class="fa fa-chevron-left"></i> 树空间的多维缩放（multidimensional scaling，MDS）可视化物种树和基因树的RF距离
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/04/19/linux_operation.and.maintenance_RAID.Controller.Card/" rel="next" title="服务器的硬件和开机流程的简介，以及BIOS和磁盘阵列控制器的设置">
      服务器的硬件和开机流程的简介，以及BIOS和磁盘阵列控制器的设置 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E7%BA%BF%E7%B2%92%E4%BD%93%E7%9A%84%E9%87%8D%E5%A4%8D%E4%BB%8B%E5%AF%BC%E9%87%8D%E7%BB%84%EF%BC%88repeat-mediated-recombination%EF%BC%89"><span class="nav-text">1. 线粒体的重复介导重组（repeat-mediated recombination）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E9%89%B4%E5%AE%9A%E9%87%8D%E5%A4%8D"><span class="nav-text">2. 鉴定重复</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E9%89%B4%E5%AE%9A%E9%87%8D%E5%A4%8D%E7%9A%84%E8%84%9A%E6%9C%AC"><span class="nav-text">2.1. 鉴定重复的脚本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E9%89%B4%E5%AE%9A%E9%87%8D%E5%A4%8D"><span class="nav-text">2.2. 运行脚本鉴定重复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E7%BB%93%E6%9E%9C%E6%96%87%E4%BB%B6"><span class="nav-text">2.3. 结果文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E4%BF%AE%E6%94%B9%E9%89%B4%E5%AE%9A%E9%87%8D%E5%A4%8D%E7%9A%84%E8%84%9A%E6%9C%AC%EF%BC%8C%E4%BD%BF%E5%85%B6%E6%98%BE%E7%A4%BA%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97%E6%89%80%E5%9C%A8%E6%9F%93%E8%89%B2%E4%BD%93%E4%BD%8D%E7%BD%AE"><span class="nav-text">2.4. 修改鉴定重复的脚本，使其显示重复序列所在染色体位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">2.5. 重复的应用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E9%89%B4%E5%AE%9A%E9%87%8D%E7%BB%84%E5%92%8C%E8%AE%A1%E7%AE%97%E9%87%8D%E7%BB%84%E7%8E%87"><span class="nav-text">3. 鉴定重组和计算重组率</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E9%89%B4%E5%AE%9A%E9%87%8D%E7%BB%84%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-text">3.1. 鉴定重组的步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E6%9E%84%E5%BB%BA%E5%8F%82%E8%80%83%E6%9E%84%E8%B1%A1%E5%92%8C%E9%87%8D%E7%BB%84%E6%9E%84%E8%B1%A1%E7%9A%84%E5%BA%8F%E5%88%97"><span class="nav-text">3.1.1. 构建参考构象和重组构象的序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E6%8A%8Areads%E5%BE%80%E5%8F%82%E8%80%83%E5%BA%8F%E5%88%97%E8%BF%9B%E8%A1%8Cmapping"><span class="nav-text">3.1.2. 把reads往参考序列进行mapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-%E8%AE%A1%E7%AE%97%E9%87%8D%E7%BB%84%E7%8E%87-recombination-rate"><span class="nav-text">3.1.3. 计算重组率(recombination rate)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-references"><span class="nav-text">4. references</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">南方枝叶</p>
  <div class="site-description" itemprop="description">学习生物信息学的笔记本</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">112</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">62</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">384</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://github.com/yanzhongsino" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yanzhongsino" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yan.zhong.sino@gmail.com" title="E-Mail → mailto:yan.zhong.sino@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

      <div class="wechat_channel">
        <br>
        <!-- 这里添加你的二维码图片 -->
        <img src ="/images/wechat_channel.jpg?raw=true">
        <span>欢迎关注微信公众号</span>
      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南方枝叶</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">627k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">9:30</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://yanzhongsino.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://example.com/2023/03/14/omics_organelle_recombination.frequency/";
    this.page.identifier = "2023/03/14/omics_organelle_recombination.frequency/";
    this.page.title = "线粒体的重复介导重组的鉴定和计算重组频率";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://yanzhongsino.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
