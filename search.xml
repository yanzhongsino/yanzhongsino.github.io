<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>重装windows系统</title>
    <url>/2020/12/29/Windows_system_reinstall.windows/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=418550511&auto=1&height=66"></iframe></div>

<h1 id="1-小白就一键重装"><a href="#1-小白就一键重装" class="headerlink" title="1. 小白就一键重装"></a>1. 小白就一键重装</h1><p>自己用过黑鲨装机软件，360装机软件等，都有绑定，需要重装之后卸载绑定的软件。<br>一键重装只能在电脑正常可进入桌面和使用软件的情况下进行，许多情况下不适用。</p>
<h1 id="2-U盘重装"><a href="#2-U盘重装" class="headerlink" title="2. U盘重装"></a>2. U盘重装</h1><p>但强烈不建议一键重装，除非纯小白，建议在正常运行的电脑上制作启动U盘，然后使用U盘启动和安装需要更换系统的电脑：</p>
<h2 id="2-1-【推荐】微软官方工具"><a href="#2-1-【推荐】微软官方工具" class="headerlink" title="2.1. 【推荐】微软官方工具"></a>2.1. 【推荐】微软官方工具</h2><p>可用微软官方的制作工具，<a href="https://www.microsoft.com/zh-cn/software-download/windows10">微软官方工具</a>，速度比msdn网站快。</p>
<h3 id="2-1-1-创建启动U盘的步骤"><a href="#2-1-1-创建启动U盘的步骤" class="headerlink" title="2.1.1. 创建启动U盘的步骤"></a>2.1.1. 创建启动U盘的步骤</h3><p>进入网站，根据<strong>使用该工具创建安装介质(USB闪存驱动器、DVD或ISO文件），以在其他电脑上安装Windows10</strong>指引操作，用一个&gt;&#x3D;8G的空U盘制作U盘启动盘。</p>
<ol>
<li>插上&gt;&#x3D;8G的空白U盘（U盘会被格式化）</li>
<li>选择<strong>立即下载工具</strong>，选择<strong>运行</strong>（需要管理员权限）</li>
<li>同意许可条款</li>
<li>选择<strong>为另一台电脑创建安装介质</strong>，选择<strong>下一步</strong></li>
<li>选择Window10的语言、版本和体系结构（64&#x2F;32位）</li>
<li>选择介质类型（USB闪存驱动器或ISO文件，其中ISO文件用于创建启动DVD），选择USB闪存驱动器。</li>
<li>等待创建完成</li>
</ol>
<h3 id="2-1-2-U盘启动安装"><a href="#2-1-2-U盘启动安装" class="headerlink" title="2.1.2. U盘启动安装"></a>2.1.2. U盘启动安装</h3><p>根据网站上接下来的<strong>使用您所创建的安装介质</strong>，为电脑安装新的Window10系统，步骤如下</p>
<ol>
<li>需要安装系统的电脑的所有硬盘需要备份。</li>
<li>把制作好的启动U盘连接到等待安装系统的电脑上</li>
<li>重启电脑</li>
<li>有时电脑会自动引导至USB介质启动安装；如果电脑没有自动引导至 USB 或 DVD 介质，可能需要打开引导菜单或在电脑 BIOS 或 UEFI 设置中更改引导顺序。</li>
<li>若要打开引导菜单或更改引导顺序，需要在重启&#x2F;开机后，在出现Dell&#x2F;Lenovo等商家界面后立即按下按键（例如 F2、F12、Delete 或 ESC）进入BIOS界面（不同品牌电脑不一样，可查询各厂家进入BIOS界面的快捷键），选择U盘对应名称，一步步按照指导进行系统安装。如果没有看到 USB 或 DVD 介质设备在引导选项中列出，可能需要联系电脑制造商来获取在 BIOS 设置中暂时禁用“安全引导”的说明。</li>
<li>在<strong>安装Windows</strong>页面上，选择语言、时间和键盘首选项，然后选择<strong>下一步</strong>；</li>
<li>选择<strong>安装Windows</strong>。</li>
</ol>
<h2 id="2-2-msdn下载系统镜像-rufus制作启动U盘"><a href="#2-2-msdn下载系统镜像-rufus制作启动U盘" class="headerlink" title="2.2. msdn下载系统镜像+rufus制作启动U盘"></a>2.2. msdn下载系统镜像+rufus制作启动U盘</h2><p>这里可以替代上一步中的<strong>创建启动U盘的步骤</strong>；制作完成后<strong>U盘启动安装</strong>与上一步一致。</p>
<p>在<a href="https://msdn.itellyou.cn/">msdn网站</a>下载需要的操作系统版本的ISO文件；然后用<a href="https://rufus.ie/">Rufus</a>软件制作U盘。</p>
<p>下好系统镜像和rufus软件后，插上U盘在rufus软件上依次操作制作启动U盘。</p>
<p>几个需要注意的选项：</p>
<ul>
<li>目标系统类型选择UEFI启动(Legacy BIOS启动时间更长)，分区类型选择GPT(比MBR好在可以识别和使用2T以上磁盘)，Legacy BIOS+MBR组合较旧，不推荐。</li>
<li>用软件Rufus制作U盘启动盘（大约30-60分钟），制作完成后插入需装系统的电脑（台式机建议插后面的USB接口）</li>
</ul>
<h2 id="2-3-notes："><a href="#2-3-notes：" class="headerlink" title="2.3. notes："></a>2.3. notes：</h2><ul>
<li>不同电脑主板进入BIOS界面的快捷键不一样，需要查询。</li>
<li>进入BIOS界面后，有些主板不显示U盘，可以UEFI设置的“Secure Boot”选项disable掉。</li>
<li>有些主板不支持U盘是NTFS文件格式使用UEFI启动，但FAT32最大支持4G文件，所以网上有建议U盘分区，把系统文件放在NTFS区，启动文件放在FAT32区，但我亲试用Rufus制作的NTFS格式U盘可以在Dell inspire 3881上使用（UltraISO制作的就不行）。</li>
<li>如果选择U盘名称后键盘鼠标不工作，可以换个USB接口试试，可能系统内的USB驱动版本不匹配。</li>
</ul>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>Windows</category>
        <category>system</category>
      </categories>
      <tags>
        <tag>tutorial</tag>
        <tag>reinstall</tag>
        <tag>Windows</tag>
        <tag>system</tag>
      </tags>
  </entry>
  <entry>
    <title>R及相关软件的安装</title>
    <url>/2021/12/28/R_install/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=27853350&auto=1&height=32"></iframe></div>

<h1 id="1-R"><a href="#1-R" class="headerlink" title="1. R"></a>1. R</h1><p>R是常用于统计和画图的计算机语言。</p>
<h2 id="1-1-R包存储库"><a href="#1-1-R包存储库" class="headerlink" title="1.1. R包存储库"></a>1.1. R包存储库</h2><p>R 语言可以通过各种宏包来拓展功能，一般通过中央软件存储库下载R包，如R基金会资助的最常用的<a href="https://cran.r-project.org/"><strong>The Comprehensive R Archive Network (CRAN)</strong></a>和存储R开发的生物数据分析包的生物专业软件存储库<a href="https://www.bioconductor.org/"><strong>Bioconductor</strong></a>。</p>
<h2 id="1-2-R相关"><a href="#1-2-R相关" class="headerlink" title="1.2. R相关"></a>1.2. R相关</h2><h3 id="1-2-1-RStudio"><a href="#1-2-1-RStudio" class="headerlink" title="1.2.1. RStudio"></a>1.2.1. RStudio</h3><ul>
<li>RStudio 是 R 的集成开发环境 (IDE)。</li>
<li>它包括一个控制台、支持直接代码执行的语法高亮编辑器，以及用于绘图、历史、调试和工作区管理的工具。</li>
<li>有两种格式：RStudio Desktop 是一个常规的桌面应用程序，而 RStudio Server 运行在远程服务器上，并允许使用Web 浏览器访问 RStudio。</li>
</ul>
<h3 id="1-2-2-Rtools"><a href="#1-2-2-Rtools" class="headerlink" title="1.2.2. Rtools"></a>1.2.2. Rtools</h3><ul>
<li>Rtools是 Windows 上从源代码构建 R 包所需的一组程序。</li>
<li>Rtools为 Windows 平台提供了一个与 R 兼容的工具链，使得Windows平台R的使用与UNIX-ish平台R的使用许多命令一致。它主要包括 GNU make、GNU gcc 和其他在 UNIX-ish 平台上常用的实用程序。</li>
<li>如果只使用CRAN 或 Bioconductor 上提供的R包，则无需Rtools，如果使用需要编译的R包（比如ROracle）或者制作自己的R包，则需要Rtools。</li>
</ul>
<h1 id="2-R的安装和配置"><a href="#2-R的安装和配置" class="headerlink" title="2. R的安装和配置"></a>2. R的安装和配置</h1><h2 id="2-1-R-for-Windows"><a href="#2-1-R-for-Windows" class="headerlink" title="2.1. R for Windows"></a>2.1. R for Windows</h2><h3 id="2-1-1-安装R"><a href="#2-1-1-安装R" class="headerlink" title="2.1.1. 安装R"></a>2.1.1. 安装R</h3><p><a href="https://www.r-project.org/">R官网</a>或者<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/">R清华镜像</a>下载安装最新版本的R(现在最新版是R4.1.2)。<br>双击之后按步骤安装。</p>
<h3 id="2-1-2-安装RStudio-Desktop"><a href="#2-1-2-安装RStudio-Desktop" class="headerlink" title="2.1.2. 安装RStudio Desktop"></a>2.1.2. 安装RStudio Desktop</h3><p><a href="https://www.rstudio.com/">RStudio官网</a>下载安装最新版本的Rstudio Desktop。<br>双击之后按步骤安装。</p>
<h3 id="2-1-3-安装Rtools"><a href="#2-1-3-安装Rtools" class="headerlink" title="2.1.3. 安装Rtools"></a>2.1.3. 安装Rtools</h3><ol>
<li>安装Rtools</li>
</ol>
<ul>
<li><a href="https://cran.r-project.org/bin/windows/Rtools/rtools40.html">Rtools4</a>下载安装最新版本的Rtools。</li>
<li>双击之后按步骤安装。</li>
</ul>
<ol start="2">
<li>把Rtools加进环境变量</li>
</ol>
<ul>
<li>R下运行<code>writeLines(&#39;PATH=&quot;$&#123;RTOOLS40_HOME&#125;\\usr\\bin;$&#123;PATH&#125;&quot;&#39;, con = &quot;~/.Renviron&quot;)</code>，代表把rtools40&#x2F;usr&#x2F;bin作为环境变量写进R的配置文件~&#x2F;.Renviron。</li>
<li>重启R之后输入<code>Sys.which(&quot;make&quot;)</code></li>
<li>如果环境配置成功，会有下述类似信息<code>make &quot;C:\\rtools40\\usr\\bin\\make.exe&quot; </code>,代表make命令可运行。</li>
<li>上面两步都ok，就测试下能不能通过以下方式安装包<code>install.packages(&quot;jsonlite&quot;, type = &quot;source&quot;)</code>，安装成功就说明配置好了。</li>
</ul>
<ol start="3">
<li>如果上面加环境变量不成功，在【我的电脑】-【属性】-【高级系统设置】-【环境变量】，把PATH的值加上自己电脑安装Rtools的路径中保存了make.exe的文件夹，比如<code>C:\\rtools40\\usr\\bin</code>，再重启R即可。</li>
</ol>
<h2 id="2-2-R-for-Linux"><a href="#2-2-R-for-Linux" class="headerlink" title="2.2. R for Linux"></a>2.2. R for Linux</h2><h3 id="2-2-1-安装R"><a href="#2-2-1-安装R" class="headerlink" title="2.2.1. 安装R"></a>2.2.1. 安装R</h3><h4 id="2-2-1-1-安装R"><a href="#2-2-1-1-安装R" class="headerlink" title="2.2.1.1. 安装R"></a>2.2.1.1. 安装R</h4><p><a href="https://cran.r-project.org/">R 官网</a>里参考对应系统的R安装教程。</p>
<ol>
<li>Ubuntu<br><code>apt update</code>,<code>apt upgrade</code>,<code>apt install r-base</code></li>
<li>Centos<br><code>dnf install R</code></li>
<li>Debian<br><code>apt-get update</code>,<code>apt-get install r-base r-base-dev</code></li>
<li>conda安装【推荐】<br><code>conda create -n r r-essentials r-base</code> #创建新环境r，安装r-base(目前是4.1.3版本)，并从CRAN安装所有的r-essentials包，R Essentials 包包含大约 200 个最流行的数据科学 R 包，包括 IRKernel、dplyr、shiny、ggplot2、tidyr、caret 和 nnet。</li>
</ol>
<p>安装R后<code>R --version</code>查看版本，可能非最新版。</p>
<h4 id="2-2-1-2-手动安装R"><a href="#2-2-1-2-手动安装R" class="headerlink" title="2.2.1.2. 手动安装R"></a>2.2.1.2. 手动安装R</h4><p><a href="https://blog.51cto.com/kuxingseng2016/1846326">R source installation ref</a>;<a href="https://xieduo7.github.io/2018-04-02-R%E5%AE%89%E8%A3%85.html">ref2</a>。</p>
<ol>
<li>R的依赖<br>参考R官方文档<a href="https://cran.r-project.org/doc/manuals/r-release/R-admin.html#Essential-and-useful-other-programs-under-a-Unix_002dalike">R installation and administration</a>，包括zlib,bzip,liblzma(XZ),PCRE等。</li>
<li>R下载<br><a href="https://www.r-project.org/">R官网</a>或者<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/">R清华镜像</a>下载安装最新版本的R(现在最新版是R4.1.2)。</li>
<li>R源码安装<br>R源码是C语言写的，需要编译安装。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar zxvf R-4.1.2.tar.gz</span><br><span class="line">cd R-4.1.2</span><br><span class="line">./configure --enable-R-shlib #配置，生成Makefile</span><br><span class="line">make #编译</span><br><span class="line">make install #安装</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-2-2-安装RStudio-Server"><a href="#2-2-2-安装RStudio-Server" class="headerlink" title="2.2.2. 安装RStudio Server"></a>2.2.2. 安装RStudio Server</h3><h4 id="2-2-2-1-安装RStudio-Server"><a href="#2-2-2-1-安装RStudio-Server" class="headerlink" title="2.2.2.1. 安装RStudio Server"></a>2.2.2.1. 安装RStudio Server</h4><p>RStudio Server 运行在远程服务器上，并允许使用Web 浏览器访问 RStudio。</p>
<p>在<a href="https://www.rstudio.com/products/rstudio/download/">RStodio官网</a>上选择RStudio Server，选相应的系统版本下载。</p>
<ol>
<li>Ubuntu<br><code>sudo apt-get install r-base</code> # for Ubuntu 16</li>
<li>CentOS<br><code>wget https://download2.rstudio.org/server/centos8/x86_64/rstudio-server-rhel-2021.09.1-372-x86_64.rpm</code>,<br><code>sudo yum install rstudio-server-rhel-2021.09.1-372-x86_64.rpm</code> # for CentOS 8</li>
</ol>
<h4 id="2-2-2-2-卸载-x2F-更新RStudio-Server"><a href="#2-2-2-2-卸载-x2F-更新RStudio-Server" class="headerlink" title="2.2.2.2. 卸载&#x2F;更新RStudio Server"></a>2.2.2.2. 卸载&#x2F;更新RStudio Server</h4><p>更新也需要先卸载再安装新的版本。</p>
<ol>
<li><code>rstudio-server stop</code> #暂停当前RStudio Server服务</li>
<li><code>yum remove rstudio-server</code> #CentOS卸载，或者 <code>apt-get remove rstudio-server</code> #Ubuntu卸载</li>
</ol>
<h4 id="2-2-2-3-安装后配置RStudio-Server"><a href="#2-2-2-3-安装后配置RStudio-Server" class="headerlink" title="2.2.2.3. 安装后配置RStudio Server"></a>2.2.2.3. 安装后配置RStudio Server</h4><ol>
<li>安装后，通过修改&#x2F;etc&#x2F;rstudio&#x2F;rserver.conf更改端口和R所在路径</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www-port=8787 # 端口, 默认8787</span><br><span class="line">www-address=0.0.0.0</span><br><span class="line">rsession-which-r=/opt/sysoft/R-4.1.2/bin/R # 安装R的路径</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用<code>rstudio-server restart</code>重启服务<br>没有任何信息就表示安装成功了，还可以<code>rstudio-server verify-installation</code>验证，没有输出就是安装成功。</li>
</ol>
<h4 id="2-2-2-4-使用RStudio-Server"><a href="#2-2-2-4-使用RStudio-Server" class="headerlink" title="2.2.2.4. 使用RStudio Server"></a>2.2.2.4. 使用RStudio Server</h4><p><code>ps -aux|grep rstudio-server</code>查看服务是否运行，<code>ipconfig</code>查看服务器IP地址。</p>
<p>安装配置好RStudio Server后，直接在浏览器打开<a href="http://IP:8787，输入服务器的用户名和密码，即可访问RStudio">http://IP:8787，输入服务器的用户名和密码，即可访问RStudio</a> Server服务。</p>
<h1 id="3-R的配置"><a href="#3-R的配置" class="headerlink" title="3. R的配置"></a>3. R的配置</h1><p>类似conda的<code>~/.condarc</code>文件配置conda，R的配置文件是<code>~/.Renviron</code>。<br>每次启动R都会运行配置文件中的设置和命令。<br>打开配置文件进行编辑<code>file.edit(&#39;~/.Renviron&#39;)</code></p>
<h1 id="4-R包安装"><a href="#4-R包安装" class="headerlink" title="4. R包安装"></a>4. R包安装</h1><p>R 语言可以通过各种宏包来拓展功能，一般通过中央软件存储库下载R包，如最常用的R基金会资助的<a href="https://cran.r-project.org/"><strong>The Comprehensive R Archive Network (CRAN)</strong></a>，存储R开发的生物数据分析包的生物专业软件存储库<a href="https://www.bioconductor.org/"><strong>Bioconductor</strong></a>，以及<a href="https://anaconda.org/"><strong>anaconda</strong></a>。</p>
<h2 id="4-1-R包安装位置"><a href="#4-1-R包安装位置" class="headerlink" title="4.1. R包安装位置"></a>4.1. R包安装位置</h2><p>R包安装前先选择默认的R包安装位置，如果R安装在C盘，原有的默认R包安装位置可能因为是不可写目录等原因在之后的R包安装过程中出现报错，所以最好的办法是自己指定一个全英文，无空格，可写的文件夹。</p>
<ol>
<li>查看R包默认安装路径</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">.libpaths<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment">#查看R包默认安装路径，可能有多个</span></span><br><span class="line">C<span class="operator">:</span><span class="operator">/</span>Users<span class="operator">/</span>spider<span class="operator">/</span>Documents<span class="operator">/</span>R<span class="operator">/</span>win<span class="operator">-</span>library<span class="operator">/</span><span class="number">3.5</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">C:/Program Files/R/R-3.5.2/library</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改默认安装路径</li>
</ol>
<ul>
<li><code>file.edit(&#39;~/.Renviron&#39;)</code>打开配置文件进行编辑</li>
<li>在文件中加入一行<code>R_LIBS_USER=&quot;D:/rpackages/&quot;</code>，注意双引号是英文的，保存然后关闭文件。</li>
</ul>
<ol start="3">
<li>重启R后再次查看默认安装路径，如果显示是新的路径即修改成功</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">.libpaths<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment">#查看R包默认安装路径，可能有多个</span></span><br><span class="line">D<span class="operator">:</span><span class="operator">/</span>rpackages</span><br></pre></td></tr></table></figure>

<h2 id="4-2-通过CRAN安装R包"><a href="#4-2-通过CRAN安装R包" class="headerlink" title="4.2. 通过CRAN安装R包"></a>4.2. 通过CRAN安装R包</h2><ol>
<li><code>install.packages(&quot;packagename&quot;)</code> R默认的安装方式，会从CRAN下载包并安装。</li>
<li>同时安装多个包: <code>install.packages(c(&quot;packagename1&quot;,&quot;packagename2&quot;))</code></li>
<li>使用R包下载地址安装: <code>install.packages(&quot;http://cran.r-project.org/src/contrib/Archive/ggplot2/ggplot2_0.9.1.tar.gz&quot;, repos=NULL, type=&quot;source&quot;)</code></li>
<li>下载包到本地后手动安装: <code>install.packages(&quot;ggplot2_0.9.1.tar.gz&quot;, repos = NULL)</code></li>
</ol>
<h2 id="4-3-通过Bioconductor后安装R包"><a href="#4-3-通过Bioconductor后安装R包" class="headerlink" title="4.3. 通过Bioconductor后安装R包"></a>4.3. 通过Bioconductor后安装R包</h2><ol>
<li>安装Bioconductor<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="punctuation">(</span><span class="operator">!</span>requireNamespace<span class="punctuation">(</span><span class="string">&quot;BiocManager&quot;</span><span class="punctuation">,</span> quietly <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">    install.packages<span class="punctuation">(</span><span class="string">&quot;BiocManager&quot;</span><span class="punctuation">)</span></span><br><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span>version <span class="operator">=</span> <span class="string">&quot;3.13&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
BiocManager的版本与R版本一一对应，安装时如果版本不对会有提示，根据提示安装对应版本即可。</li>
<li>查看可用的Bioconductor包：<code>BiocManager::available()</code></li>
<li>安装Bioconductor库里有的R包：<code>BiocManager::install(&quot;packagename&quot;,version=&quot;3.2&quot;)</code></li>
<li>同时安装多个包：<code>BiocManager::install(c(&quot;packagename1&quot;,&quot;packagename2&quot;))</code></li>
</ol>
<h2 id="4-4-通过conda安装R包"><a href="#4-4-通过conda安装R包" class="headerlink" title="4.4. 通过conda安装R包"></a>4.4. 通过conda安装R包</h2><p>在<a href="https://anaconda.org/">anaconda官网</a>查询想要安装的R包，如果库里有可以使用conda安装。</p>
<p>一般需要在包名称前添加r-，比如安装rbokeh和rjava。<br><code>conda install r-rbokeh</code>,<code>conda install r-rjava</code></p>
<h2 id="4-5-更新和卸载R包"><a href="#4-5-更新和卸载R包" class="headerlink" title="4.5. 更新和卸载R包"></a>4.5. 更新和卸载R包</h2><ol>
<li>更新：<code>update.packages()</code>；conda更新R包caret<code>conda update r-caret</code></li>
<li>卸载：<code>remove.packages()</code>。</li>
</ol>
<h1 id="5-R包载入"><a href="#5-R包载入" class="headerlink" title="5. R包载入"></a>5. R包载入</h1><ol>
<li>library(packagename)<br>如果包不存在，library会停止执行，不返回任何值。</li>
<li>require(packagename)<br>require会根据包存在与否返回true或false，并继续下面的语句执行。</li>
</ol>
<h1 id="6-R包使用查询"><a href="#6-R包使用查询" class="headerlink" title="6. R包使用查询"></a>6. R包使用查询</h1><p>R包使用方法: <code>help(package=&quot;packagename&quot;)</code></p>
<h1 id="7-reference"><a href="#7-reference" class="headerlink" title="7. reference"></a>7. reference</h1><ol>
<li><a href="https://www.bioinfo-scrounger.com/archives/435/">https://www.bioinfo-scrounger.com/archives/435/</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>programming</category>
        <category>R</category>
        <category>basic</category>
      </categories>
      <tags>
        <tag>R package</tag>
        <tag>R</tag>
        <tag>RStudio</tag>
        <tag>Rtools</tag>
        <tag>CRAN</tag>
        <tag>Bioconductor</tag>
      </tags>
  </entry>
  <entry>
    <title>进化树相关知识</title>
    <url>/2021/11/20/bio_evolutionary.tree/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=26657608&auto=1&height=32"></iframe></div>

<h1 id="1-进化树"><a href="#1-进化树" class="headerlink" title="1. 进化树"></a>1. 进化树</h1><p>系统树(phylogenetic tree&#x2F;phylogeny)，又叫进化树(evolutionary tree)，是基于形态或遗传特征差异展示物种或其他实体间的进化关系的分支图或树图。</p>
<h1 id="2-进化树分类"><a href="#2-进化树分类" class="headerlink" title="2. 进化树分类"></a>2. 进化树分类</h1><h2 id="2-1-根据有无祖先根分类"><a href="#2-1-根据有无祖先根分类" class="headerlink" title="2.1. 根据有无祖先根分类"></a>2.1. 根据有无祖先根分类</h2><ol>
<li>有根树(rooted tree)<br> 根节点是所有其他节点的父节点，每个带有后代的节点代表这些后代的最近共同祖先。在有根树中，只有根节点的度数（指传入和传出边的总数）是2，其他节点的最小度数都为3。使树生根的常见方式是指定无争议的外类群。</li>
<li>无根树(unrooted tree)<br> 仅说明叶节点的相关性，无需推断祖先。</li>
</ol>
<h2 id="2-2-根据分歧数量分类"><a href="#2-2-根据分歧数量分类" class="headerlink" title="2.2. 根据分歧数量分类"></a>2.2. 根据分歧数量分类</h2><p>有根树和无根树都可以是二叉的，也可以是多叉的。</p>
<ol>
<li>二叉树(bifurcated tree)<br> 有根二叉树每个内部节点都有两个后代，无根二叉树每个内部节点有三个邻近的自由树。</li>
<li>多叉树(multifurcated tree)<br> 有根多叉树在某些内部节点可能有两个以上后代，无根多叉树在某些内部节点可能有三个以上邻近自由树。</li>
</ol>
<h2 id="2-3-根据有无标签"><a href="#2-3-根据有无标签" class="headerlink" title="2.3. 根据有无标签"></a>2.3. 根据有无标签</h2><ol>
<li>标签树(labeled tree)<br> 标签树在叶节点有特定的值。</li>
<li>非标签树(unlabeled tree)<br> 只有树型。</li>
</ol>
<h2 id="2-4-特殊的树的类型"><a href="#2-4-特殊的树的类型" class="headerlink" title="2.4. 特殊的树的类型"></a>2.4. 特殊的树的类型</h2><ol>
<li>树状图(dendrogram)<br> 树状图的总称，无论有无系统发生关系。</li>
<li>分支树(cladogram)<br>只有分支模式，枝长不包含变化量信息，中间节点也不代表祖先。</li>
<li>系统树(phylogram)<br>枝长与变化量&#x2F;碱基替换数成比例。</li>
<li>超度量树&#x2F;时序树(chronogram)<br> 枝长与时长成比例。</li>
<li>速率树(ratogram)<br> 枝长表示替换速率。</li>
<li>达尔格伦树(dahlgrenogram)<br> 系统发育树的部分样品的图。</li>
<li>系统发育网(phylogenetic network)<br> 有向无环图。</li>
<li>罗马树(romerogram)&#x2F;纺锤树(spindle diagram)&#x2F;气泡树(bubble diagram)<br> 横向宽度代表生物的分类学多样性，纵坐标是地质时间。为了反映多个类群的丰度随着时间的变化。由于不适合处理并系类群，被提议不再使用。</li>
<li>生命珊瑚(coral of life)<br> 达尔文提出珊瑚可能比树更适合描绘生命的进化。</li>
</ol>
<h1 id="3-读进化树"><a href="#3-读进化树" class="headerlink" title="3. 读进化树"></a>3. 读进化树</h1><h2 id="3-1-根据树型"><a href="#3-1-根据树型" class="headerlink" title="3.1. 根据树型"></a>3.1. 根据树型</h2><ul>
<li>当树的所有叶节点没有对齐的时候，枝长可能代表变化量&#x2F;碱基替换数(phylogram)&#x2F;替换速率(ratogram)；</li>
<li>当树的所有叶节点对齐的时候，枝长如果一致则无信息(cladogram)，枝长如果不一致可能代表进化时长(chronogram)。</li>
</ul>
<h1 id="4-reference"><a href="#4-reference" class="headerlink" title="4. reference"></a>4. reference</h1><ol>
<li><a href="https://en.wikipedia.org/wiki/Phylogenetic_tree">wiki:Phylogenetic_tree</a></li>
<li><a href="https://www.nature.com/scitable/topicpage/reading-a-phylogenetic-tree-the-meaning-of-41956/">https://www.nature.com/scitable/topicpage/reading-a-phylogenetic-tree-the-meaning-of-41956/</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bio</category>
        <category>evolution</category>
      </categories>
      <tags>
        <tag>phylogeny</tag>
        <tag>evolutionary tree</tag>
        <tag>phylogenetic tree</tag>
        <tag>bifurcated tree</tag>
        <tag>cladogram</tag>
        <tag>phylogram</tag>
        <tag>chronogram</tag>
      </tags>
  </entry>
  <entry>
    <title>热图的简介和绘制</title>
    <url>/2022/11/06/bio_plot_heatmap/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=105140&auto=1&height=32"></iframe></div>


<h1 id="1-热图-heatmap"><a href="#1-热图-heatmap" class="headerlink" title="1. 热图(heatmap)"></a>1. 热图(heatmap)</h1><p>热图(heatmap)是在两个维度用不同颜色展示一种现象的大小的一种数据可视化技术。有两种本质上不同的热图，网格热图(grid heatmap)和空间热图(spatial heatmap)。</p>
<ol>
<li>网格热图(grid heatmap)<br>网格热图用不同颜色代表不同数值的二维矩形图，同时两个维度还可以通过颜色进行聚类。</li>
</ol>
<p>比如不同物种在不同基因上的表达水平。</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/48/Heatmap.png/1024px-Heatmap.png" width=90% title="heatmap集群热图" align=center/>

<p><strong><p align="center">Figure 1. heatmap集群热图</p></strong></p>
<ol start="2">
<li>空间热图(spatial heatmap)<br>空间热图将空间现象的大小通过颜色投射到地图上。</li>
</ol>
<p>比如世界的温度分布图。</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e7/World_heat_map.png/1024px-World_heat_map.png" width=90% title="heatmap空间热图" align=center/>

<p><strong><p align="center">Figure 2. heatmap空间热图</p></strong></p>
<ol start="3">
<li>等值线图(choropleth map)<br>此外，还有与空间热图相似的，常用于地理上可视化的等值线图(choropleth map)。等值线图按照地理边界分组，如国家，州，省或者人为划分的植被区和气候区等，常常具有不规则边界。</li>
</ol>
<p>比如美国各州人口密度图。</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/34/U.S._states_and_territories_by_population_density.svg/1024px-U.S._states_and_territories_by_population_density.svg.png" width=90% title="heatmap空间热图" align=center/>

<p><strong><p align="center">Figure 3. choropleth map等值线图</p></strong></p>
<h1 id="2-绘制热图"><a href="#2-绘制热图" class="headerlink" title="2. 绘制热图"></a>2. 绘制热图</h1><p>这篇文章记录的是绘制网格热图的方法，包括常用的R包pheatmap和ggplot2。</p>
<h2 id="2-1-pheatmap包"><a href="#2-1-pheatmap包" class="headerlink" title="2.1. pheatmap包"></a>2.1. pheatmap包</h2><ol>
<li>输入数据(gene_expression.txt)的格式</li>
</ol>
<ul>
<li>第一行标题行</li>
<li>第一列是基因名称</li>
<li>第二列是数值（比如表达量）</li>
<li>可以是一组数据，则只有第二列；也可以是多组数据，依次是第二列及之后列。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tf ath_1 ath_2 egr_1 egr_2</span><br><span class="line">AP2 1.0043 0 0.942273 0</span><br><span class="line">ARF 1.20516 1.58619 1.13073 1.48129</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>读取数据和聚类</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df<span class="operator">&lt;-</span>read.table<span class="punctuation">(</span><span class="string">&quot;gene_expression.txt&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span> <span class="string">&quot; &quot;</span><span class="punctuation">,</span> header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span>row.names <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">df_row <span class="operator">&lt;-</span> hclust<span class="punctuation">(</span>dist<span class="punctuation">(</span>df<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#对行聚类</span></span><br><span class="line">df <span class="operator">&lt;-</span> df<span class="punctuation">[</span>df_row<span class="operator">$</span>order<span class="punctuation">,</span><span class="punctuation">]</span> <span class="comment">#按行聚类结果排序</span></span><br><span class="line">df_column <span class="operator">&lt;-</span> hclust<span class="punctuation">(</span>dist<span class="punctuation">(</span>t<span class="punctuation">(</span>df<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#对列聚类</span></span><br><span class="line">df <span class="operator">&lt;-</span> df<span class="punctuation">[</span><span class="punctuation">,</span>df_column<span class="operator">$</span>order<span class="punctuation">]</span> <span class="comment">#按列聚类结果排序</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绘制热图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span><span class="string">&quot;pheatmap&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>pheatmap<span class="punctuation">)</span></span><br><span class="line">pheatmap<span class="punctuation">(</span>mat<span class="operator">=</span>df<span class="punctuation">,</span>color <span class="operator">=</span> colorRampPalette<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;lightgreen&quot;</span><span class="punctuation">,</span> <span class="string">&quot;yellow&quot;</span><span class="punctuation">,</span><span class="string">&quot;orange&quot;</span><span class="punctuation">,</span><span class="string">&quot;red&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">(</span><span class="number">20</span><span class="punctuation">)</span><span class="punctuation">,</span>legend_breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> legend_labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;1.0&quot;</span><span class="punctuation">,</span><span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span><span class="string">&quot;3.0&quot;</span><span class="punctuation">,</span><span class="string">&quot;4.0&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> border_color<span class="operator">=</span><span class="string">&quot;white&quot;</span><span class="punctuation">,</span>treeheight_row <span class="operator">=</span> <span class="number">50</span><span class="punctuation">,</span> treeheight_col <span class="operator">=</span> <span class="number">8</span><span class="punctuation">,</span> display_numbers <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> number_color <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span>main <span class="operator">=</span> <span class="string">&quot;TF heatmap&quot;</span><span class="punctuation">,</span>cellwidth <span class="operator">=</span> <span class="number">50</span><span class="punctuation">,</span> cellheight <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 其中color = colorRampPalette(c(&quot;lightgreen&quot;, &quot;yellow&quot;,&quot;orange&quot;,&quot;red&quot;))(20) #设置颜色渐变，值从低到高依次是浅绿色-黄色-橙色-红色，共20个颜色。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更完整的pheatmap参数</p>
</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pheatmap<span class="punctuation">(</span>mat <span class="operator">=</span> mat<span class="punctuation">,</span> <span class="comment"># 表达矩阵</span></span><br><span class="line">               scale <span class="operator">=</span> <span class="string">&quot;row&quot;</span><span class="punctuation">,</span> <span class="comment"># 数据标准化方法（col/row/none）</span></span><br><span class="line">               clustering_method <span class="operator">=</span> <span class="string">&quot;complete&quot;</span><span class="punctuation">,</span> <span class="comment"># 聚类方法（ward/ward.D/ward.D2/single/complete/average/mcquitty/median/centroid）</span></span><br><span class="line">               clustering_distance_rows <span class="operator">=</span> <span class="string">&quot;euclidean&quot;</span><span class="punctuation">,</span> <span class="comment"># 行距离度量（correlation/euclidean）</span></span><br><span class="line">               clustering_distance_cols <span class="operator">=</span> <span class="string">&quot;euclidean&quot;</span><span class="punctuation">,</span> <span class="comment"># 列距离度量（correlation/euclidean）</span></span><br><span class="line">               cluster_cols <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>cluster_rows <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="comment"># 行/列聚类（TRUE/FALSE）</span></span><br><span class="line">               treeheight_col <span class="operator">=</span> <span class="number">35</span><span class="punctuation">,</span>treeheight_row <span class="operator">=</span> <span class="number">45</span><span class="punctuation">,</span> <span class="comment"># 行/列聚类树高度</span></span><br><span class="line">               annotation_col <span class="operator">=</span> coldata<span class="punctuation">,</span> <span class="comment"># 分组矩阵（可不提供）</span></span><br><span class="line">               cutree_cols <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> <span class="comment"># 列等分为2</span></span><br><span class="line">               cutree_rows <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> <span class="comment"># 行等分为2</span></span><br><span class="line">               show_colnames <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>show_rownames <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="comment"># 是否显示行/列标签（TRUE/FALSE）</span></span><br><span class="line">               fontsize_row <span class="operator">=</span> <span class="number">7.5</span><span class="punctuation">,</span>fontsize_col <span class="operator">=</span> <span class="number">7.5</span><span class="punctuation">,</span> <span class="comment"># 横/纵轴标签大小</span></span><br><span class="line">               color <span class="operator">=</span> colorRampPalette<span class="punctuation">(</span>colors <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;blue&quot;</span><span class="punctuation">,</span><span class="string">&quot;white&quot;</span><span class="punctuation">,</span><span class="string">&quot;red&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">(</span><span class="number">100</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 颜色设置</span></span><br><span class="line">               main <span class="operator">=</span> paste<span class="punctuation">(</span><span class="string">&quot;Cluster Heatmap of&quot;</span><span class="punctuation">,</span>nrow<span class="punctuation">(</span>mat<span class="punctuation">)</span><span class="punctuation">,</span><span class="string">&quot;features&quot;</span><span class="punctuation">,</span>sep <span class="operator">=</span> <span class="string">&quot; &quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 标题设置</span></span><br><span class="line">               filename <span class="operator">=</span> <span class="string">&quot;heatmap.pdf&quot;</span><span class="punctuation">,</span> <span class="comment"># 输出文件设置</span></span><br><span class="line">               width <span class="operator">=</span> <span class="number">7</span><span class="punctuation">,</span>height <span class="operator">=</span> <span class="number">7</span><span class="punctuation">)</span> <span class="comment"># 图片长宽设置</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-ggplot2包"><a href="#2-2-ggplot2包" class="headerlink" title="2.2. ggplot2包"></a>2.2. ggplot2包</h2><p>这个我还没试过，把<a href="https://zhuanlan.zhihu.com/p/464964887%E6%8F%90%E5%88%B0%E7%9A%84%E4%BB%A3%E7%A0%81%E6%91%98%E6%8A%84%E5%9C%A8%E8%BF%99%E3%80%82">https://zhuanlan.zhihu.com/p/464964887提到的代码摘抄在这。</a></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Step1 根据实际情况确定是否对数据进行标准化</span></span><br><span class="line">data <span class="operator">&lt;-</span> scale<span class="punctuation">(</span>data<span class="punctuation">,</span>center <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>scale <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step2 数据重排及格式转换</span></span><br><span class="line">row_clust <span class="operator">&lt;-</span> hclust<span class="punctuation">(</span>dist<span class="punctuation">(</span>mat<span class="punctuation">,</span>method <span class="operator">=</span> <span class="string">&quot;euclidean&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>method <span class="operator">=</span> <span class="string">&quot;complete&quot;</span><span class="punctuation">)</span> <span class="comment"># 行(特征)聚类</span></span><br><span class="line">rowInd <span class="operator">&lt;-</span> row_clust<span class="operator">$</span>order <span class="comment"># 行(特征)的顺序</span></span><br><span class="line">col_clust <span class="operator">&lt;-</span> hclust<span class="punctuation">(</span>dist<span class="punctuation">(</span>t<span class="punctuation">(</span>mat<span class="punctuation">)</span><span class="punctuation">,</span>method <span class="operator">=</span> <span class="string">&quot;euclidean&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>method <span class="operator">=</span> <span class="string">&quot;complete&quot;</span><span class="punctuation">)</span> <span class="comment"># 矩阵转置,列(样本)聚类</span></span><br><span class="line">colInd <span class="operator">&lt;-</span> col_clust<span class="operator">$</span>order <span class="comment"># 列(样本)的顺序</span></span><br><span class="line">mat <span class="operator">&lt;-</span> mat<span class="punctuation">[</span>rowInd<span class="punctuation">,</span>colInd<span class="punctuation">]</span> <span class="comment"># 将数据按照聚类结果重新排序</span></span><br><span class="line">melt_mat <span class="operator">&lt;-</span> melt<span class="punctuation">(</span>mat<span class="punctuation">)</span> <span class="comment"># 融合数据,使之适用ggplot</span></span><br><span class="line">colnames<span class="punctuation">(</span>melt_mat<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Feature&quot;</span><span class="punctuation">,</span><span class="string">&quot;Sample&quot;</span><span class="punctuation">,</span><span class="string">&quot;Value&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 聚类方法：ward.D/ward.D2/single/complete/average/mcquitty/median/centroid（后两种可能会出现边为负的情况）</span></span><br><span class="line"><span class="comment"># 距离度量：euclidean/maximum/manhattan/canberra/binary/minkowski</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step3 绘制聚类树</span></span><br><span class="line">h <span class="operator">&lt;-</span> ggtree<span class="punctuation">(</span>row_clust<span class="punctuation">,</span>layout <span class="operator">=</span> <span class="string">&quot;rectangular&quot;</span><span class="punctuation">,</span>branch.length <span class="operator">=</span> <span class="string">&quot;none&quot;</span><span class="punctuation">)</span> <span class="comment"># 行聚类树</span></span><br><span class="line">v <span class="operator">&lt;-</span> ggtree<span class="punctuation">(</span>col_clust<span class="punctuation">)</span><span class="operator">+</span>layout_dendrogram<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment"># 列聚类树</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step4 绘制热图</span></span><br><span class="line">p.ggplot <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>data <span class="operator">=</span> mat_new<span class="punctuation">,</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> Sample<span class="punctuation">,</span>y <span class="operator">=</span> Feature<span class="punctuation">,</span>fill <span class="operator">=</span> Value<span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  geom_tile<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  theme_minimal<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  scale_fill_gradient2<span class="punctuation">(</span>low <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span>high <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span>mid <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span>name <span class="operator">=</span> <span class="string">&quot;Expression&quot;</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  scale_y_discrete<span class="punctuation">(</span>position <span class="operator">=</span> <span class="string">&quot;right&quot;</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>x <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span>y <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span>axis.title <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">15</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        axis.text.y <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span><span class="punctuation">,</span>axis.text.x <span class="operator">=</span> element_text<span class="punctuation">(</span>angle <span class="operator">=</span> <span class="number">90</span><span class="punctuation">,</span>size <span class="operator">=</span> <span class="number">11</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        legend.title <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">15</span><span class="punctuation">)</span><span class="punctuation">,</span>legend.text <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">11</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step5 绘制分组信息条形图（可不提供）</span></span><br><span class="line">p.group <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>data <span class="operator">=</span> coldata<span class="punctuation">,</span>aes<span class="punctuation">(</span>x <span class="operator">=</span> Sample<span class="punctuation">,</span>y <span class="operator">=</span> Condition<span class="punctuation">,</span>fill <span class="operator">=</span> Group<span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  geom_tile<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  scale_y_discrete<span class="punctuation">(</span>position <span class="operator">=</span> <span class="string">&quot;right&quot;</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  theme_minimal<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  theme<span class="punctuation">(</span>axis.text <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span>axis.title <span class="operator">=</span> element_blank<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">        legend.title <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">15</span><span class="punctuation">)</span><span class="punctuation">,</span>legend.text <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">11</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>fill <span class="operator">=</span> <span class="string">&quot;Group&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Step6 拼接图</span></span><br><span class="line">p.all <span class="operator">&lt;-</span> p.ggplot <span class="operator">%&gt;%</span> insert_left<span class="punctuation">(</span>h<span class="punctuation">,</span>width <span class="operator">=</span> <span class="number">0.15</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> insert_top<span class="punctuation">(</span>p.group<span class="punctuation">,</span>height <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> insert_top<span class="punctuation">(</span>v<span class="punctuation">,</span>height <span class="operator">=</span> <span class="number">0.1</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h1 id="3-references"><a href="#3-references" class="headerlink" title="3. references"></a>3. references</h1><ol>
<li><a href="https://en.wikipedia.org/wiki/Heat_map">https://en.wikipedia.org/wiki/Heat_map</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/464964887">https://zhuanlan.zhihu.com/p/464964887</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bio</category>
        <category>plot</category>
      </categories>
      <tags>
        <tag>R package</tag>
        <tag>heatmap</tag>
        <tag>pheatmap</tag>
        <tag>ggplot2</tag>
      </tags>
  </entry>
  <entry>
    <title>分子生物学实验</title>
    <url>/2021/03/27/bio_experiment/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=36307139&auto=1&height=32"></iframe></div>


<h2 id="常用PCR参数"><a href="#常用PCR参数" class="headerlink" title="常用PCR参数"></a>常用PCR参数</h2><ol>
<li>PCR Easy tag 体系(20μl)</li>
</ol>
<ul>
<li>ddH2O 12.2μl</li>
<li>10Xbuffer 2.0μl</li>
<li>dNTP 1.6μl</li>
<li>Easy tag酶 0.2μl</li>
<li>DNA 2μl</li>
<li>Primer-F 1μl</li>
<li>Primer-R 1μl</li>
</ul>
<ol start="2">
<li>PCR常用程序</li>
</ol>
<ul>
<li>预热 94℃ 10min</li>
</ul>
<p>以下步骤循环28-34次</p>
<ul>
<li>解螺旋94℃ 0.5-1min</li>
<li>退火53℃ 30-45seconds</li>
<li>72℃ 1min15seconds</li>
</ul>
<p>循环结束继续以下步骤</p>
<ul>
<li>72℃ 10min</li>
<li>16℃ 10min</li>
</ul>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bio</category>
        <category>experiment</category>
      </categories>
      <tags>
        <tag>experiment</tag>
        <tag>molecular experiment</tag>
        <tag>PCR</tag>
      </tags>
  </entry>
  <entry>
    <title>集合可视化 —— upset图</title>
    <url>/2021/09/29/bio_plot_upset/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1697043&auto=1&height=32"></iframe></div>

<h1 id="1-多集合展示UpSet图"><a href="#1-多集合展示UpSet图" class="headerlink" title="1. 多集合展示UpSet图"></a>1. 多集合展示UpSet图</h1><p>当有多个群组（集合）的数据，想要展示在不同的事物群组（集合）之间的数学或逻辑联系时，可使用韦恩Venn图和UpSet图展示多集合直接的共享关系和各自的独享关系。</p>
<p>当集合数量少于等于5个时，多用韦恩图；当集合数量大于5个时，多用upset图。</p>
<p>韦恩图的绘制推荐使用R包gplots，参考博文<a href="https://yanzhongsino.github.io/2021/09/29/R_plot_venn/">韦恩图</a>；upset图的绘制推荐使用R包UpSetR，参考博文。</p>
<h2 id="1-1-应用场景"><a href="#1-1-应用场景" class="headerlink" title="1.1. 应用场景"></a>1.1. 应用场景</h2><ol>
<li>利用orthofinder找到的不同物种的orthogroups的结果来绘制Venn Diagram韦恩图或者UpSet plot图，查看不同物种间共享的orthogroups的数量关系。</li>
</ol>
<h2 id="1-2-数据准备"><a href="#1-2-数据准备" class="headerlink" title="1.2. 数据准备"></a>1.2. 数据准备</h2><p>UpSetR的输入文件是表格形式，第一列是数据分类信息，后面列是每一个集合占一列（每个物种占一列），表格内容是1&#x2F;0表示集合在每一个类别是否有数据。</p>
<h3 id="1-2-1-UpSetR自带数据"><a href="#1-2-1-UpSetR自带数据" class="headerlink" title="1.2.1. UpSetR自带数据"></a>1.2.1. UpSetR自带数据</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">movies <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;extdata&quot;</span><span class="punctuation">,</span> <span class="string">&quot;movies.csv&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;UpSetR&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span> sep<span class="operator">=</span><span class="string">&quot;;&quot;</span><span class="punctuation">)</span> <span class="comment"># 载入UpSetR包提供的电影数据用作示例。第一行是电影的类别名称，第一列是电影名，第二列是电影上映年度，后面列中的1/0是代表电影是否属于相应的类别。</span></span><br><span class="line">mutations <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;extdata&quot;</span><span class="punctuation">,</span> <span class="string">&quot;mutations.csv&quot;</span><span class="punctuation">,</span> package <span class="operator">=</span> <span class="string">&quot;UpSetR&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;,&quot;</span><span class="punctuation">)</span> <span class="comment"># 载入UpsetR包提供的突变数据用作示例。第一行是不同的基因简称，第一列是基因特征ID，数据中的1/0是代表基因是否有对应的特征。</span></span><br><span class="line"></span><br><span class="line">head<span class="punctuation">(</span>movies<span class="punctuation">)</span> <span class="comment"># 大致浏览一下该数据集,数据集太长，就只看前几列</span></span><br><span class="line">View<span class="punctuation">(</span>movies<span class="punctuation">)</span> <span class="comment"># 弹出窗口，可查看数据。</span></span><br><span class="line"></span><br><span class="line">head<span class="punctuation">(</span>mutations<span class="punctuation">)</span> <span class="comment"># 大致浏览一下该数据集,数据集太长，就只看前几列</span></span><br><span class="line">View<span class="punctuation">(</span>mutations<span class="punctuation">)</span> <span class="comment"># 弹出窗口，可查看数据。</span></span><br></pre></td></tr></table></figure>
<br>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> head<span class="punctuation">(</span>movies<span class="punctuation">)</span></span><br><span class="line">                                Name ReleaseDate Action Adventure Children Comedy Crime Documentary Drama Fantasy Noir Horror Musical Mystery Romance SciFi Thriller War Western AvgRating Watches</span><br><span class="line"><span class="number">1</span>                   Toy Story <span class="punctuation">(</span><span class="number">1995</span><span class="punctuation">)</span>        <span class="number">1995</span>      <span class="number">0</span>         <span class="number">0</span>        <span class="number">1</span>      <span class="number">1</span>     <span class="number">0</span>           <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>     <span class="number">0</span>        <span class="number">0</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">4.15</span>    <span class="number">2077</span></span><br><span class="line"><span class="number">2</span>                     Jumanji <span class="punctuation">(</span><span class="number">1995</span><span class="punctuation">)</span>        <span class="number">1995</span>      <span class="number">0</span>         <span class="number">1</span>        <span class="number">1</span>      <span class="number">0</span>     <span class="number">0</span>           <span class="number">0</span>     <span class="number">0</span>       <span class="number">1</span>    <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>     <span class="number">0</span>        <span class="number">0</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">3.20</span>     <span class="number">701</span></span><br><span class="line"><span class="number">3</span>            Grumpier Old Men <span class="punctuation">(</span><span class="number">1995</span><span class="punctuation">)</span>        <span class="number">1995</span>      <span class="number">0</span>         <span class="number">0</span>        <span class="number">0</span>      <span class="number">1</span>     <span class="number">0</span>           <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">1</span>     <span class="number">0</span>        <span class="number">0</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">3.02</span>     <span class="number">478</span></span><br><span class="line"><span class="number">4</span>           Waiting to Exhale <span class="punctuation">(</span><span class="number">1995</span><span class="punctuation">)</span>        <span class="number">1995</span>      <span class="number">0</span>         <span class="number">0</span>        <span class="number">0</span>      <span class="number">1</span>     <span class="number">0</span>           <span class="number">0</span>     <span class="number">1</span>       <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>     <span class="number">0</span>        <span class="number">0</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">2.73</span>     <span class="number">170</span></span><br><span class="line"><span class="number">5</span> Father of the Bride Part II <span class="punctuation">(</span><span class="number">1995</span><span class="punctuation">)</span>        <span class="number">1995</span>      <span class="number">0</span>         <span class="number">0</span>        <span class="number">0</span>      <span class="number">1</span>     <span class="number">0</span>           <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>     <span class="number">0</span>        <span class="number">0</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">3.01</span>     <span class="number">296</span></span><br><span class="line"><span class="number">6</span>                        Heat <span class="punctuation">(</span><span class="number">1995</span><span class="punctuation">)</span>        <span class="number">1995</span>      <span class="number">1</span>         <span class="number">0</span>        <span class="number">0</span>      <span class="number">0</span>     <span class="number">1</span>           <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>     <span class="number">0</span>        <span class="number">1</span>   <span class="number">0</span>       <span class="number">0</span>      <span class="number">3.88</span>     <span class="number">940</span></span><br><span class="line"><span class="operator">&gt;</span> head<span class="punctuation">(</span>mutations<span class="punctuation">)</span></span><br><span class="line">  Identifier TTN PTEN TP53 EGFR MUC16 FLG RYR2 PCLO PIK3R1 PIK3CA NF1 MUC17 HMCN1 SPTA1 USH2A RB1 PKHD1 OBSCN AHNAK2 RYR3 RELN FRAS1 GPR98 DNAH5 ATRX APOB TCHH SYNE1 LRP2 KEL HRNR DNAH3 COL6A3 MUC5B LAMA1 DSP</span><br><span class="line"><span class="number">1</span>    <span class="number">02</span><span class="operator">-</span><span class="number">0003</span>   <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">1</span>     <span class="number">0</span>   <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span>   <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>   <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"><span class="number">2</span>    <span class="number">02</span><span class="operator">-</span><span class="number">0033</span>   <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span>   <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>   <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"><span class="number">3</span>    <span class="number">02</span><span class="operator">-</span><span class="number">0047</span>   <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span>   <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>   <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"><span class="number">4</span>    <span class="number">02</span><span class="operator">-</span><span class="number">0055</span>   <span class="number">1</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>      <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>   <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>      <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"><span class="number">5</span>    <span class="number">02</span><span class="operator">-</span><span class="number">2470</span>   <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>   <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"><span class="number">6</span>    <span class="number">02</span><span class="operator">-</span><span class="number">2483</span>   <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>      <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">1</span>    <span class="number">1</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>   <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span></span><br><span class="line">  DNAH8 CNTNAP2 SDK1 NBPF10 DNAH2 NLRP5 MLL3 IDH1 HCN1 FCGBP DOCK5 RIMS2 PCDHA1 MXRA5 HEATR7B2 GRIN2A FGD5 TMEM132D STAG2 SEMA3C SCN9A PRDM9 POM121L12 PIK3CG PDGFRA GABRA6 FLG2 FBN3 FBN2 FAT2 DNAH11 DMD COL1A2</span><br><span class="line"><span class="number">1</span>     <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>        <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>        <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>         <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>      <span class="number">1</span>     <span class="number">0</span>        <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>        <span class="number">0</span>     <span class="number">0</span>      <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>         <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>      <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>        <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>        <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>         <span class="number">0</span>      <span class="number">0</span>      <span class="number">1</span>      <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>     <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>        <span class="number">0</span>      <span class="number">0</span>    <span class="number">1</span>        <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>         <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>     <span class="number">0</span>       <span class="number">1</span>    <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>        <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>        <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>         <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">6</span>     <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>    <span class="number">1</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>        <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>        <span class="number">0</span>     <span class="number">0</span>      <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>         <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>   <span class="number">0</span>      <span class="number">0</span></span><br><span class="line">  ABCC9 XIRP2 TSHZ2 TEX15 SLIT3 RBM47 PIK3C2G PCDH11X MYH2 MACF1 KSR2 DNAH9 DCHS2 CSMD3 CDH18 BCOR AHNAK ZAN TRRAP THSD7B TAF1L SPAG17 SLCO5A1 SCN10A RYR1 RIMBP2 PLEKHG4B PCDHB7 NPTX2 NOS1 LZTR1</span><br><span class="line"><span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">4</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>        <span class="number">1</span>      <span class="number">0</span>     <span class="number">0</span>    <span class="number">1</span>     <span class="number">0</span></span><br><span class="line"><span class="number">5</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">1</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>       <span class="number">0</span>      <span class="number">0</span>    <span class="number">0</span>      <span class="number">1</span>        <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span></span><br><span class="line"><span class="number">6</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>      <span class="number">0</span>       <span class="number">1</span>      <span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span>        <span class="number">0</span>      <span class="number">0</span>     <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-orthofinder数据"><a href="#1-2-2-orthofinder数据" class="headerlink" title="1.2.2. orthofinder数据"></a>1.2.2. orthofinder数据</h3><p>从orthofinder的结果文件Results_Aug14&#x2F;Orthogroups&#x2F;Orthogroups.GeneCount.tsv稍加处理就可以作为输入文件，展示不同物种的orthogroups集合的共享情况。</p>
<p><code>sed -E &quot;s/\t[1-9][0-9]*/\t1/g&quot; Orthogroups.GeneCount.tsv |sed &quot;s/\.pep//g&quot; &gt;orthogroups.upset</code> # 把Orthogroups.GeneCount.tsv中的非零数字替换成1。</p>
<p>在R中用<code>mutations &lt;- read.csv(&quot;orthogroups.upset&quot;, header=TRUE, sep = &quot;\t&quot;)</code>读取orthogroups.upset。</p>
<h2 id="1-3-UpSetR包安装"><a href="#1-3-UpSetR包安装" class="headerlink" title="1.3. UpSetR包安装"></a>1.3. UpSetR包安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install.packages(&quot;UpSetR&quot;); # 安装</span><br><span class="line">library(UpSetR); # 载入UpSetR</span><br><span class="line">require(ggplot2); require(plyr); require(gridExtra); require(grid); # 载入包</span><br></pre></td></tr></table></figure>

<h2 id="1-4-UpSetR包使用"><a href="#1-4-UpSetR包使用" class="headerlink" title="1.4. UpSetR包使用"></a>1.4. UpSetR包使用</h2><h3 id="1-4-1-upset函数"><a href="#1-4-1-upset函数" class="headerlink" title="1.4.1. upset函数"></a>1.4.1. upset函数</h3><ol>
<li><p><code>upset(mutations)</code>可以看到upset图的效果</p>
</li>
<li><p>调整参数做指定数据显示</p>
</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">upset<span class="punctuation">(</span>mutations<span class="punctuation">,</span> </span><br><span class="line">sets <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;MUC16&quot;</span><span class="punctuation">,</span><span class="string">&quot;EGFR&quot;</span><span class="punctuation">,</span><span class="string">&quot;TP53&quot;</span><span class="punctuation">,</span><span class="string">&quot;TTN&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="comment"># 查看特定的几个集合/几种电影类别</span></span><br><span class="line">nset <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span> <span class="comment"># 最多展示多少个集合数据</span></span><br><span class="line">nintersects <span class="operator">=</span> <span class="number">20</span><span class="punctuation">,</span> <span class="comment"># 展示数量多的前多少个交集</span></span><br><span class="line">mb.ratio <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.55</span><span class="punctuation">,</span> <span class="number">0.45</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 控制上方条形图以及下方点图的比例</span></span><br><span class="line">order.by <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;degree&quot;</span><span class="punctuation">,</span> <span class="string">&quot;freq&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 交集如何排序，这里先根据degree(数量，交集包含的数字大小)，然后再根据freq(频率，涉及到的交集个数)</span></span><br><span class="line">keep.order <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> <span class="comment"># keep.order按照sets参数的顺序排序</span></span><br><span class="line">decreasing <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="literal">TRUE</span><span class="punctuation">,</span><span class="literal">FALSE</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 变量如何排序；对应order.by参数。这里表示degree降序，freq升序。</span></span><br><span class="line">number.angles <span class="operator">=</span> <span class="number">30</span><span class="punctuation">,</span> <span class="comment"># 调整柱形图上数字角度</span></span><br><span class="line">point.size <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> line.size <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment"># 点和线的大小</span></span><br><span class="line">mainbar.y.label <span class="operator">=</span> <span class="string">&quot;Intersection size of gene family&quot;</span><span class="punctuation">,</span>sets.x.label <span class="operator">=</span> <span class="string">&quot;genome size&quot;</span><span class="punctuation">,</span> <span class="comment"># 坐标轴名称</span></span><br><span class="line">text.scale <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1.3</span><span class="punctuation">,</span> <span class="number">1.3</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1.5</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment"># 六个数字，分别控制c(intersectionsize title, intersection size tick labels, set size title, set size ticklabels, set names, numbers above bars)</span></span><br></pre></td></tr></table></figure>

<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/3cabd7b9fd4f1552a69bf5f1797f489be352717a/source/images/R_plot_upset_movies.png?raw=true" width=100% height=60% title="upset_movies" align=center/>

<p><strong><p align="center">Figure 1. movies upset</p></strong></p>
<h3 id="1-4-2-queries参数"><a href="#1-4-2-queries参数" class="headerlink" title="1.4.2. queries参数"></a>1.4.2. queries参数</h3><p>upset函数中可以添加queries参数，用于突出显示（上色）部分数据。</p>
<ol>
<li><p>queries<br>queries是一个由多个query组成的list；每个query也是一个list，作为一次查询数据并突出显示的请求。</p>
</li>
<li><p>query<br>query也是list格式，由查询函数query和其他参数（param,color,active,query.name）组成，其中query,param是必须设置的参数。</p>
<ul>
<li>query: 指定查询函数，UpSetR有内置(比如intersects)，也可以自定义函数后调用。</li>
<li>param: list格式, 指定query作用的数据。</li>
<li>color：设置颜色，可选设置。</li>
<li>active：显示类型，TRUE&#x2F;T表示用颜色覆盖条形图，FALSE&#x2F;F表示在条形图顶端显示三角形。</li>
<li>query.name：添加query图例名称。</li>
</ul>
</li>
<li><p>queries参数示例</p>
</li>
</ol>
<ul>
<li>把”EGFR”和”TP53”两个基因共同拥有的突变标上蓝色；把”TTN”基因特有的突变在直方图上标为红色。</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">upset<span class="punctuation">(</span>mutations<span class="punctuation">,</span> sets<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;MUC16&quot;</span><span class="punctuation">,</span><span class="string">&quot;EGFR&quot;</span><span class="punctuation">,</span><span class="string">&quot;TP53&quot;</span><span class="punctuation">,</span><span class="string">&quot;TTN&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">queries <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>query <span class="operator">=</span> intersects<span class="punctuation">,</span>  </span><br><span class="line">params <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;EGFR&quot;</span><span class="punctuation">,</span> <span class="string">&quot;TP53&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 指定作用的数据</span></span><br><span class="line">color <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span> <span class="comment"># 设置颜色，未设置会调用默认调色板</span></span><br><span class="line">active <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span>   <span class="comment"># 条形图被颜色覆盖</span></span><br><span class="line">query.name <span class="operator">=</span> <span class="string">&quot;share EGFR and TP53&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 添加query图例</span></span><br><span class="line"><span class="built_in">list</span><span class="punctuation">(</span>query <span class="operator">=</span> intersects<span class="punctuation">,</span> params<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;TTN&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> color<span class="operator">=</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span> active<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/R_plot_upset_mutations.png?raw=true" width=100% height=60% title="upset_mutations" align=center/>

<p><strong><p align="center">Figure 2. mutations upset</p></strong></p>
<ul>
<li>把同属Drama和Thriller的电影突出显示，把1970-1980的电影标红。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">between &lt;- function(row, min, max)&#123;</span><br><span class="line">  newData &lt;- (row[&quot;ReleaseDate&quot;] &lt; max) &amp; (row[&quot;ReleaseDate&quot;] &gt; min)</span><br><span class="line">&#125; # 自定义between函数</span><br><span class="line"></span><br><span class="line">upset(movies, sets=c(&quot;Drama&quot;,&quot;Comedy&quot;,&quot;Action&quot;,&quot;Thriller&quot;,&quot;Western&quot;,&quot;Documentary&quot;),</span><br><span class="line">      queries = list(list(query = intersects, params = list(&quot;Drama&quot;, &quot;Thriller&quot;)),</span><br><span class="line">                     list(query = between, params=list(1970,1980), color=&quot;red&quot;, active=TRUE)))</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/R_plot_upset_movies2.png?raw=true" width=100% height=60% title="upset_movies2" align=center/>

<p><strong><p align="center">Figure 3. movies upset 2</p></strong></p>
<h3 id="1-4-3-添加属性图"><a href="#1-4-3-添加属性图" class="headerlink" title="1.4.3. 添加属性图"></a>1.4.3. 添加属性图</h3><ol>
<li>添加箱线图<br>每次最多添加两个箱线图<br><code>upset(movies, boxplot.summary = c(&quot;AvgRating&quot;, &quot;ReleaseDate&quot;)) </code></li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/R_plot_upset_boxplot.png?raw=true" width=100% height=70% title="upset_boxplot" align=center/>

<p><strong><p align="center">Figure 4. movies upset boxplot</p></strong></p>
<h4 id="1-4-3-1-attribute-plots参数"><a href="#1-4-3-1-attribute-plots参数" class="headerlink" title="1.4.3.1. attribute.plots参数"></a>1.4.3.1. attribute.plots参数</h4><p>attribute.plots参数用于添加属性图，内置有柱形图，散点图，热图等。<br>如果想添加密度曲线图，可以自定义plot函数后添加。</p>
<ol>
<li>添加柱形图和散点图<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">upset<span class="punctuation">(</span>movies<span class="punctuation">,</span> sets<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Drama&quot;</span><span class="punctuation">,</span><span class="string">&quot;Comedy&quot;</span><span class="punctuation">,</span><span class="string">&quot;Action&quot;</span><span class="punctuation">,</span><span class="string">&quot;Thriller&quot;</span><span class="punctuation">,</span><span class="string">&quot;Western&quot;</span><span class="punctuation">,</span><span class="string">&quot;Documentary&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">      queries <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>query <span class="operator">=</span> intersects<span class="punctuation">,</span> params <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;Drama&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Thriller&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                     <span class="built_in">list</span><span class="punctuation">(</span>query <span class="operator">=</span> between<span class="punctuation">,</span> params<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span><span class="number">1970</span><span class="punctuation">,</span><span class="number">1980</span><span class="punctuation">)</span><span class="punctuation">,</span> color<span class="operator">=</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span> active<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">      attribute.plots<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span>gridrows<span class="operator">=</span><span class="number">60</span><span class="punctuation">,</span> <span class="comment"># 添加属性图</span></span><br><span class="line">      plots<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span></span><br><span class="line">        <span class="built_in">list</span><span class="punctuation">(</span>plot<span class="operator">=</span>scatter_plot<span class="punctuation">,</span> <span class="comment"># 散点图</span></span><br><span class="line">        x<span class="operator">=</span><span class="string">&quot;ReleaseDate&quot;</span><span class="punctuation">,</span> y<span class="operator">=</span><span class="string">&quot;AvgRating&quot;</span><span class="punctuation">,</span> <span class="comment"># 指定横纵坐标</span></span><br><span class="line">        queries <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># T表示显示queries定义的颜色</span></span><br><span class="line">        <span class="built_in">list</span><span class="punctuation">(</span>plot<span class="operator">=</span> histogram<span class="punctuation">,</span> x<span class="operator">=</span><span class="string">&quot;ReleaseDate&quot;</span><span class="punctuation">,</span> queries <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 直方图</span></span><br><span class="line">        ncols <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 添加的图分两列</span></span><br><span class="line">      query.legend <span class="operator">=</span> <span class="string">&quot;top&quot;</span><span class="punctuation">)</span> <span class="comment"># query图例放在上方</span></span><br></pre></td></tr></table></figure></li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/3cabd7b9fd4f1552a69bf5f1797f489be352717a/source/images/R_plot_upset_scatter_histogram.png?raw=true" width=100% height=70% title="upset_scatter_histograms" align=center/>

<p><strong><p align="center">Figure 5. movies upset scatter histograms</p></strong></p>
<ol start="2">
<li>添加密度曲线图</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#自定义密度曲线</span></span><br><span class="line">another.plot <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>data<span class="punctuation">,</span> x<span class="punctuation">,</span> y<span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    data<span class="operator">$</span>decades <span class="operator">&lt;-</span> round_any<span class="punctuation">(</span><span class="built_in">as.integer</span><span class="punctuation">(</span>unlist<span class="punctuation">(</span>data<span class="punctuation">[</span>y<span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="built_in">ceiling</span><span class="punctuation">)</span></span><br><span class="line">    data <span class="operator">&lt;-</span> data<span class="punctuation">[</span>which<span class="punctuation">(</span>data<span class="operator">$</span>decades <span class="operator">&gt;=</span> <span class="number">1970</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line">    myplot <span class="operator">&lt;-</span> <span class="punctuation">(</span>ggplot<span class="punctuation">(</span>data<span class="punctuation">,</span> aes_string<span class="punctuation">(</span>x <span class="operator">=</span> x<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> geom_density<span class="punctuation">(</span>aes<span class="punctuation">(</span>fill <span class="operator">=</span> factor<span class="punctuation">(</span>decades<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">        alpha <span class="operator">=</span> <span class="number">0.4</span><span class="punctuation">)</span> <span class="operator">+</span> theme<span class="punctuation">(</span>plot.margin <span class="operator">=</span> unit<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> legend.key.size <span class="operator">=</span> unit<span class="punctuation">(</span><span class="number">0.4</span><span class="punctuation">,</span> <span class="string">&quot;cm&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>plyr<span class="punctuation">)</span></span><br><span class="line">upset<span class="punctuation">(</span>movies<span class="punctuation">,</span> main.bar.color <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span> mb.ratio <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.5</span><span class="punctuation">,</span> <span class="number">0.5</span><span class="punctuation">)</span><span class="punctuation">,</span> queries <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>query <span class="operator">=</span> intersects<span class="punctuation">,</span> </span><br><span class="line">    params <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;Drama&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> active <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span>query <span class="operator">=</span> intersects<span class="punctuation">,</span> </span><br><span class="line">    params <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;Action&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Drama&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> active <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span>query <span class="operator">=</span> intersects<span class="punctuation">,</span> </span><br><span class="line">    params <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;Drama&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Comedy&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Action&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> color <span class="operator">=</span> <span class="string">&quot;orange&quot;</span><span class="punctuation">,</span> active <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">    attribute.plots <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>gridrows <span class="operator">=</span> <span class="number">50</span><span class="punctuation">,</span> plots <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>plot <span class="operator">=</span> histogram<span class="punctuation">,</span> </span><br><span class="line">        x <span class="operator">=</span> <span class="string">&quot;ReleaseDate&quot;</span><span class="punctuation">,</span> queries <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span>plot <span class="operator">=</span> scatter_plot<span class="punctuation">,</span> x <span class="operator">=</span> <span class="string">&quot;ReleaseDate&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        y <span class="operator">=</span> <span class="string">&quot;AvgRating&quot;</span><span class="punctuation">,</span> queries <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span>plot <span class="operator">=</span> another.plot<span class="punctuation">,</span> x <span class="operator">=</span> <span class="string">&quot;AvgRating&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        y <span class="operator">=</span> <span class="string">&quot;ReleaseDate&quot;</span><span class="punctuation">,</span> queries <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> ncols <span class="operator">=</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/3cabd7b9fd4f1552a69bf5f1797f489be352717a/source/images/R_plot_upset_density.png?raw=true" width=100% height=70% title="upset_density" align=center/>

<p><strong><p align="center">Figure 6. movies upset density</p></strong></p>
<h1 id="2-references"><a href="#2-references" class="headerlink" title="2. references"></a>2. references</h1><ol>
<li><a href="https://github.com/hms-dbmi/UpSetR">https://github.com/hms-dbmi/UpSetR</a></li>
<li><a href="https://www.jianshu.com/p/324aae3d5ea4">https://www.jianshu.com/p/324aae3d5ea4</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35303590">https://zhuanlan.zhihu.com/p/35303590</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>
]]></content>
      <categories>
        <category>bio</category>
        <category>plot</category>
      </categories>
      <tags>
        <tag>R package</tag>
        <tag>R</tag>
        <tag>plot</tag>
        <tag>UpSetR</tag>
      </tags>
  </entry>
  <entry>
    <title>Circos圈图绘制</title>
    <url>/2021/11/16/bio_plot_Circos/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=4278314&auto=1&height=32"></iframe></div>

<h1 id="1-介绍circos圈图"><a href="#1-介绍circos圈图" class="headerlink" title="1. 介绍circos圈图"></a>1. 介绍circos圈图</h1><p>介绍基因组的文章里常常出现下面的circos圈图，这篇博客记录了如何绘制这种圈图。</p>
<img src="http://circos.ca/img/circos-sample-panel.png" title="Circos圈图" width="100%"/>

<p><strong><p align="center">Figure 1. circos圈图示例 图源：<a href="http://circos.ca/">circos官网</a></p></strong></p>
<p>circos圈图的内核是把矩形掰弯成环状，矩形信息的展示以行和列为基础，环形除了行和列，还可以增加环的不同位置之间的关系，比如基因组特征的Circos图中间常见的染色体共线性关系的展示。</p>
<h1 id="2-绘制circos圈图的软件和包"><a href="#2-绘制circos圈图的软件和包" class="headerlink" title="2. 绘制circos圈图的软件和包"></a>2. 绘制circos圈图的软件和包</h1><p>有许多可以绘制circos圈图的软件和包。常见的有<a href="http://circos.ca/">Circos软件</a>,TBtools，R包circlize，python版本的Circos等。</p>
<h2 id="2-1-Circos-——-从名字就可以看出是circos绘制软件的霸王"><a href="#2-1-Circos-——-从名字就可以看出是circos绘制软件的霸王" class="headerlink" title="2.1. Circos —— 从名字就可以看出是circos绘制软件的霸王"></a>2.1. Circos —— 从名字就可以看出是circos绘制软件的霸王</h2><p><a href="http://circos.ca/">Circos软件</a>是2009年Michael Smith Genome Sciences Centre的Martin Krzywinski开发的一款基于perl的做比较基因组Circos圈图绘制的软件，功能完备，被文章里使用的非常多。Martin Krzywinski是生物信息学家和专业摄影师双重身份，所以Circos软件的审美设计是非常可靠的（当然得在合理的配色和布局下，我就用过同一套数据生成两个美学差异极大的图）。</p>
<p>Circos有在线版本<a href="http://mkweb.bcgsc.ca/tableviewer/">Circos Online</a>，在线使用时是把表格转为圈图，不过只允许最大75行和75列。</p>
<p>下面记录了用Circos绘制基因组圈图的基础操作。</p>
<h3 id="2-1-1-Circos安装"><a href="#2-1-1-Circos安装" class="headerlink" title="2.1.1. Circos安装"></a>2.1.1. Circos安装</h3><p><code>conda create -c bioconda -n circos circos</code> #单独环境安装</p>
<p><code>circos -V</code> #确认版本</p>
<h3 id="2-1-2-Circos运行"><a href="#2-1-2-Circos运行" class="headerlink" title="2.1.2. Circos运行"></a>2.1.2. Circos运行</h3><p><code>circos -conf circos.conf</code></p>
<p>会生成circos.png和circos.svg两个文件。</p>
<h3 id="2-1-3-Circos模块化绘制"><a href="#2-1-3-Circos模块化绘制" class="headerlink" title="2.1.3. Circos模块化绘制"></a>2.1.3. Circos模块化绘制</h3><p>Circos是模块化绘制的方式，即通过增添数据和设置来实现每个部分的绘制。</p>
<p>基因组圈图中的几个基础模块：染色体模块，特征图模块，共线性模块。</p>
<ul>
<li>染色体模块显示了染色体的数量和长度，常常添加标尺，通常在最外圈。</li>
<li>特征图模块可以有多圈，可以是折线图(line)，散点图(scatter)，直方图(histogram)和热图(heatmap)等。通常用直方图或者热图展示基因密度，重复序列密度，GC占比等信息。</li>
<li>共线性模块通常放在中心，代表不同染色体间的共线性关系。如果有多个物种，则可以体现物种间的共线性关系。</li>
</ul>
<h3 id="2-1-4-Circos输入文件"><a href="#2-1-4-Circos输入文件" class="headerlink" title="2.1.4. Circos输入文件"></a>2.1.4. Circos输入文件</h3><p>输入文件包括数据文件和配置文件。</p>
<p>需要展示的模块数据都保存在单独的数据文件中，然后在配置文件circos.conf中调用数据文件。</p>
<p>有些教程会建议多制作几个不同类别的配置文件，然后在circos.conf调用其他配置文件。<br>比如单独设置ticks.conf,links.conf，然后在circos.conf里加入下面内容调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;include ticks.conf&gt;&gt;</span><br><span class="line">&lt;&lt;include links.conf&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>比如单独设置plots_histogram.conf，plots_heatmap.conf，plots_text.conf，然后在circos.conf里加入下面内容调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plots&gt;</span><br><span class="line">&lt;&lt;include plots_histogram.conf&gt;&gt;</span><br><span class="line"> &lt;&lt;include plots_heatmap.conf&gt;&gt;</span><br><span class="line"> &lt;&lt;include plots_text.conf&gt;&gt;</span><br><span class="line">&lt;/plots&gt;</span><br></pre></td></tr></table></figure>

<p>但如果不是设置特别复杂，直接使用circos.conf一个配置文件即可，所有设置都可以写在circos.conf。</p>
<h4 id="2-1-4-1-主配置文件circos-conf"><a href="#2-1-4-1-主配置文件circos-conf" class="headerlink" title="2.1.4.1. 主配置文件circos.conf"></a>2.1.4.1. 主配置文件circos.conf</h4><h5 id="2-1-4-1-1-circos-conf由几个部分组成"><a href="#2-1-4-1-1-circos-conf由几个部分组成" class="headerlink" title="2.1.4.1.1. circos.conf由几个部分组成"></a>2.1.4.1.1. circos.conf由几个部分组成</h5><ul>
<li><ideogram>绘制染色体</li>
<li><ticks>绘制染色体刻度</li>
<li><links>绘制染色体间连线（通常代表共线性）</li>
<li><plots>绘制图形</li>
</ul>
<h5 id="2-1-4-1-2-circos-conf示例"><a href="#2-1-4-1-2-circos-conf示例" class="headerlink" title="2.1.4.1.2. circos.conf示例"></a>2.1.4.1.2. circos.conf示例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 1. 染色体和刻度的设置</span><br><span class="line">karyotype = karyotype.txt #指定染色体数据文件</span><br><span class="line">chromosomes_order = scaf001,scaf002,scaf003,scaf004,contig003,contig006 #指定染色体顺序，若不指定则按照染色体数据文件karyotype.txt的顺序</span><br><span class="line">chromosomes_reverse = /scaf/ #染色体坐标默认是从0到最大值，通过正则匹配把染色体坐标改成最大值到0</span><br><span class="line">chromosomes_scale = /scaf/=0.5rn,/contig/=0.5rn #设置染色体缩放，scaf的所有染色体占据50%的空间，contig的所有染色体占据50%的空间。</span><br><span class="line"></span><br><span class="line">&lt;&lt;include etc/colors_fonts_patterns.conf&gt;&gt;</span><br><span class="line">&lt;&lt;include etc/housekeeping.conf&gt;&gt;</span><br><span class="line"></span><br><span class="line">chromosomes_units = 1000000 #定义长度单位，后面使用u赋值长度</span><br><span class="line">show_ticks = yes #显示染色体刻度</span><br><span class="line">show_tick_labels = yes #显示刻度标签</span><br><span class="line"></span><br><span class="line"># 2. ideogram模块，用于染色体设置</span><br><span class="line">&lt;ideogram&gt;</span><br><span class="line">&lt;spacing&gt;</span><br><span class="line">default = 1u #染色体间间距</span><br><span class="line"> &lt;pairwise scaf001 contig001&gt;</span><br><span class="line">  spacing = 10u</span><br><span class="line"> &lt;/pairwise&gt; # 在scaf001和contig001之间流出10u的间距（其他染色体默认是1u）</span><br><span class="line"> &lt;pairwise scaf004 contig006&gt;</span><br><span class="line">  spacing = 10u</span><br><span class="line"> &lt;/pairwise&gt; # 在scaf004和contig006之间流出10u的间距（其他染色体默认是1u）</span><br><span class="line">&lt;/spacing&gt;</span><br><span class="line">radius = 0.90r #染色体位置</span><br><span class="line">thickness = 20p #染色体的厚</span><br><span class="line">fill = yes</span><br><span class="line">stroke_color = dgrey #颜色</span><br><span class="line">stroke_thickness = 2p</span><br><span class="line"></span><br><span class="line">show_label = yes #显示label，染色体名称</span><br><span class="line">label_font = default #字体</span><br><span class="line">label_radius = dims(ideogram,radius) + 0.05r #染色体标签位置</span><br><span class="line">label_size = 48 #字体大小</span><br><span class="line">label_parallel = yes #是否平行</span><br><span class="line">label_format = eval(sprintf(&quot;%s&quot;,var(chr))) #格式</span><br><span class="line"></span><br><span class="line">&lt;/ideogram&gt;</span><br><span class="line"></span><br><span class="line"># 3. ticks模块，用于染色体刻度设置</span><br><span class="line">&lt;ticks&gt;</span><br><span class="line">radius = 1r #刻度位置</span><br><span class="line">color = black #刻度颜色</span><br><span class="line">thickness = 2p #刻度厚度</span><br><span class="line">multiplier = 1e-6 #输出标签为实际长度与其相乘，实际位置为chromosomes_units*multiplier</span><br><span class="line">format = %d # %d表示显示整数</span><br><span class="line"></span><br><span class="line">&lt;tick&gt;</span><br><span class="line">spacing = 1u #刻度间距离，1u表示一个长度单位，即1chromosomes_units</span><br><span class="line">size = 5p #tick的长度</span><br><span class="line">&lt;/tick&gt;</span><br><span class="line"></span><br><span class="line">&lt;tick&gt;</span><br><span class="line">spacing = 5u</span><br><span class="line">size = 10p</span><br><span class="line">show_label = yes #是否展示标签</span><br><span class="line">label_size = 20p #标签尺寸</span><br><span class="line">label_offset = 10p #让标签往外偏移一点</span><br><span class="line">format = %d #显示整数</span><br><span class="line">&lt;/tick&gt;</span><br><span class="line">&lt;/ticks&gt;</span><br><span class="line"></span><br><span class="line"># 4. image模块，用于输出设置</span><br><span class="line">&lt;image&gt;</span><br><span class="line">dir* = . #输出目录，参数后*表示覆盖已有设置</span><br><span class="line">radius* = 1500p #输出图片半径</span><br><span class="line">angle_offset* = -85 #默认情况下，第一个染色体从-90°位置开始，但设置scaf001和contig001之间的空隙为10u会导致图看起来不对称，通过angle_offset调整角度使图对称。</span><br><span class="line">&lt;&lt;include etc/image.conf&gt;&gt;</span><br><span class="line">&lt;/image&gt;</span><br><span class="line"></span><br><span class="line"># 5. plots模块，用于特征图形设置</span><br><span class="line">&lt;plots&gt;</span><br><span class="line">&lt;plot&gt;</span><br><span class="line">show = True #是否展示该图形，默认展示</span><br><span class="line">type = scatter #展示的图形类型，折线图(line)，散点图(scatter)，直方图(histogram)和热图(heatmap)</span><br><span class="line">file = genes_num.txt #数据文件</span><br><span class="line">r1 = 0.98r #在圈图中的位置，外径</span><br><span class="line">r0 = 0.89r #在圈图中的位置，内径</span><br><span class="line">min = 10 #展示的数据下限</span><br><span class="line">max = 1000 #展示的数据上限</span><br><span class="line">glyph = circle #散点图的符号类型，圆(circle), 矩形(rectangle), 三角形(triangle)</span><br><span class="line">glyph_size = 2p #散点图符号大小，单位为p</span><br><span class="line">color = pastel1-5-qual-2 #散点图符号颜色，直方图外部线的颜色</span><br><span class="line">stroke_color = pastel1-5-qual-2 #对于散点图，符号外部的颜色</span><br><span class="line">stroke_thickness = 1p #对于散点图，符号外部线的厚度</span><br><span class="line">&lt;/plot&gt;</span><br><span class="line"></span><br><span class="line">&lt;plot&gt;</span><br><span class="line">type = histogram #直方图</span><br><span class="line">file = gc_rate.txt #数据文件</span><br><span class="line">fill_color = pastel1-5-qual-1 #直方图填充色</span><br><span class="line">color = pastel1-5-qual-2 #散点图符号颜色，直方图外部线的颜色</span><br><span class="line">r1 = 0.78r</span><br><span class="line">r0 = 0.69r</span><br><span class="line">&lt;/plot&gt;</span><br><span class="line"></span><br><span class="line">&lt;plot&gt;</span><br><span class="line">type = heatmap #热图</span><br><span class="line">file = repeats_num.txt #数据文件</span><br><span class="line">fill_color = pastel1-5-qual-2</span><br><span class="line">r1 = 0.88r</span><br><span class="line">r0 = 0.79r</span><br><span class="line">&lt;/plot&gt;</span><br><span class="line"></span><br><span class="line">&lt;plot&gt;</span><br><span class="line">type = line #折线图</span><br><span class="line">file = col.txt #数据文件</span><br><span class="line">fill_color = pastel1-5-qual-4</span><br><span class="line">r1 = 0.68r</span><br><span class="line">r0 = 0.59r</span><br><span class="line">&lt;/plot&gt;</span><br><span class="line">&lt;/plots&gt;</span><br><span class="line"></span><br><span class="line"># 6. links模块，用于共线性设置</span><br><span class="line">&lt;links&gt;</span><br><span class="line">&lt;link&gt;</span><br><span class="line">file = anchors.simple_link.txt #共线性数据文件</span><br><span class="line">radius = 0.58r #位置外界</span><br><span class="line">color = blue_a4 #颜色</span><br><span class="line">ribbon = yes</span><br><span class="line"></span><br><span class="line"># 6plus. rules模块，放在link内部，用于为共线性模块不同染色体用不同颜色渲染</span><br><span class="line">&lt;rules&gt;</span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf001&quot; #判断link文件中左侧染色体`var(chr1)`的名字是不是`eq` &quot;scaf001&quot;，如果是颜色就进行下面设置。</span><br><span class="line">color = pastel1-9-qual-9 #颜色</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf002&quot;</span><br><span class="line">color = pastel1-9-qual-7</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf003&quot;</span><br><span class="line">color = pastel1-9-qual-6</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf004&quot;</span><br><span class="line">color = pastel1-9-qual-8</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf005&quot;</span><br><span class="line">color = pastel1-9-qual-5</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf006&quot;</span><br><span class="line">color = pastel1-9-qual-4</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf007&quot;</span><br><span class="line">color = pastel1-9-qual-3</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf008&quot;</span><br><span class="line">color = pastel1-9-qual-2</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf009&quot;</span><br><span class="line">color = pastel1-9-qual-1</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf010&quot;</span><br><span class="line">color = pastel1-5-qual-5</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf011&quot;</span><br><span class="line">color = pastel1-5-qual-4</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf012&quot;</span><br><span class="line">color = pastel1-5-qual-3</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf013&quot;</span><br><span class="line">color = pastel1-5-qual-2</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">&lt;rule&gt;</span><br><span class="line">condition = var(chr1) eq &quot;scaf014&quot;</span><br><span class="line">color = pastel1-5-qual-1</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line">&lt;/rules&gt;</span><br><span class="line"></span><br><span class="line">&lt;/link&gt;</span><br><span class="line">&lt;/links&gt;</span><br></pre></td></tr></table></figure>

<h5 id="2-1-4-1-3-circos-conf参数详解"><a href="#2-1-4-1-3-circos-conf参数详解" class="headerlink" title="2.1.4.1.3. circos.conf参数详解"></a>2.1.4.1.3. circos.conf参数详解</h5><ol>
<li>颜色选择<br>Circos的颜色用的是<a href="https://colorbrewer2.org/">colorbrewer2网站</a>的颜色，也可以参考<a href="http://circos.ca/documentation/tutorials/configuration/colors/images">circos的colors网址</a>。</li>
</ol>
<p>Circos中颜色的命名格式为PALETTE-NUMCOLORS-TYPE-IDX：</p>
<ul>
<li>PALETTE:调色版名，如rdylbu</li>
<li>NUMCOLORS: 颜色数目, 11</li>
<li>调色版类型: div(diverging), seq(sequential), qual(qualitative)</li>
<li>IDX: 调色版中的颜色索引</li>
</ul>
<p>所以brbg-3-div-1代表的是<a href="http://circos.ca/documentation/tutorials/configuration/colors/images">circos的colors网址</a>里的brbg-div的3组的第一个颜色。</p>
<ol start="2">
<li>长度单位<br>控制图形不同元素大小的三个单位，p,r,u。</li>
</ol>
<ul>
<li>p(pixels), 表示绝对大小；如果使用p作为单位，需要参考circos.conf中设置输出图形模块的<image>里定义的radius输出图片半径。</li>
<li>r(relative), 相对大小；会随着最终图形大小而发生变换。</li>
<li>u(chromosome unit)，定义chromosome unit之后使用；一般在显示刻度时使用。。</li>
</ul>
<h4 id="2-1-4-2-数据文件-——-染色体文件karyotype-txt"><a href="#2-1-4-2-数据文件-——-染色体文件karyotype-txt" class="headerlink" title="2.1.4.2. 数据文件 —— 染色体文件karyotype.txt"></a>2.1.4.2. 数据文件 —— 染色体文件karyotype.txt</h4><p>染色体文件karyotype.txt用于生成染色体模块。</p>
<h5 id="2-1-4-2-1-染色体文件karyotype-txt的获取"><a href="#2-1-4-2-1-染色体文件karyotype-txt的获取" class="headerlink" title="2.1.4.2.1. 染色体文件karyotype.txt的获取"></a>2.1.4.2.1. 染色体文件karyotype.txt的获取</h5><p>从genome.fa.fai里生成karyotype.txt文件<code>head -12 genome.fa.fai |awk &#39;&#123;print &quot;chr - &quot;$1&quot; &quot;$1&quot; 0 &quot;$2&quot; set3-12-qual-12&quot;&#125;&#39; &gt;karyotype.txt</code>，取前12条染色体。</p>
<p>修改最后一列来定义染色体颜色，推荐<code>set3-12-qual</code>系列，一共12种，可以依次给到12条染色体。</p>
<h4 id="2-1-4-3-数据文件-——-线性关系文件-link-txt"><a href="#2-1-4-3-数据文件-——-线性关系文件-link-txt" class="headerlink" title="2.1.4.3. 数据文件 —— 线性关系文件_link.txt"></a>2.1.4.3. 数据文件 —— 线性关系文件_link.txt</h4><p>线性关系文件_link.txt用于生成共线性模块。</p>
<p>格式是六列数据，用tab分隔，每行都代表一条线，由具有共线性的两组染色体ID、起始位置和终止位置组成。</p>
<p><code>contig003  7719    355757  contig014   3459    349346</code></p>
<h5 id="2-1-4-3-1-线性关系文件-link-txt的获取"><a href="#2-1-4-3-1-线性关系文件-link-txt的获取" class="headerlink" title="2.1.4.3.1. 线性关系文件_link.txt的获取"></a>2.1.4.3.1. 线性关系文件_link.txt的获取</h5><p>可以用jcvi生成simple文件，然后用脚本simple2links.py转换成_link.txt文件。</p>
<p><code>pip install jcvi</code>安装jcvi，可以参考博文<a href="https://yanzhongsino.github.io/2021/11/05/bioinfo_MCscan/">MCscan</a>。</p>
<ol>
<li><p>准备sample.bed和sample.cds两个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m jcvi.formats.gff bed --type=gene --key=ID sample.gff3 &gt;sample.bed #gff2bed</span><br><span class="line">python -m jcvi.formats.bed uniq sample.bed #生成sample.uniq.bed</span><br><span class="line">seqkit grep -f &lt;(cut -f 4 sample.uniq.bed )  sample.cds.fa | seqkit seq -i &gt; sample.cds #提取cds</span><br><span class="line">mv sample.uniq.bed sample.bed</span><br><span class="line">rm sample.leftover.bed</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行共线性分析</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m jcvi.compara.catalog ortholog --no_strip_names --cpu=1 sample sample #生成sample.sample.anchors，单个物种就用sample sample，两个物种就准备两套.bed和.cds文件，用sample1 sample2。</span><br><span class="line">python -m jcvi.compara.synteny screen --minspan=30 --simple sample.sample.anchors sample.sample.anchors.new #生成sample.sample.anchors.simple</span><br></pre></td></tr></table></figure>
</li>
<li><p>MCScanX<br>从MCScanX结果sample.collinearity中生成类似MCSCAN结果的bv.simple。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -C 1 &quot;#&quot; sample.collinearity |grep -v &quot;^-&quot;  &gt;sample.col</span><br><span class="line">tail -1 sample.collinearity &gt;&gt; sample.col</span><br><span class="line">cat sample.col |sed -e &quot;s/#.* /#/g&quot; -e &quot;s/[^b]*bv/bv/&quot; |tr &#x27;\n&#x27; &#x27; &#x27;|sed &quot;s/ #/\n/g&quot;|awk &#x27;&#123;print $2,$3,$5,$6&quot; 200 &quot;$1&#125;&#x27;|sed -e &quot;s/plus/+/g&quot; -e &quot;s/minus/-/g&quot; |grep -v &quot;#&quot; &gt;sample.simple</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>simple2links<br><code>python simple2links.py sample.sample.anchors.simple #生成sample.sample.anchors.simple_link.txt</code></li>
</ol>
<p>sample.sample.anchors.simple_link.txt可以作为circos画共线性的输入文件</p>
<p><a href="https://github.com/xuzhougeng/myscripts/blob/master/simple2links.py">simple2links.py脚本地址</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># simple2links.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv</span><br><span class="line"></span><br><span class="line">simple_file = argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">ref_bed = simple_file.split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>] + <span class="string">&quot;.bed&quot;</span></span><br><span class="line">qry_bed = simple_file.split(<span class="string">&quot;.&quot;</span>)[<span class="number">1</span>] + <span class="string">&quot;.bed&quot;</span></span><br><span class="line"></span><br><span class="line">ref_dict = &#123;line.split(<span class="string">&quot;\t&quot;</span>)[<span class="number">3</span>]:line.split(<span class="string">&quot;\t&quot;</span>)[<span class="number">0</span>:<span class="number">3</span>] <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(ref_bed)&#125;</span><br><span class="line">qry_dict = &#123;line.split(<span class="string">&quot;\t&quot;</span>)[<span class="number">3</span>]:line.split(<span class="string">&quot;\t&quot;</span>)[<span class="number">0</span>:<span class="number">3</span>] <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(qry_bed)&#125;</span><br><span class="line"></span><br><span class="line">fo = <span class="built_in">open</span>(simple_file + <span class="string">&quot;_link.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(simple_file):</span><br><span class="line">    <span class="keyword">if</span> line.startswith(<span class="string">&quot;#&quot;</span>):</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    items = line.strip().split(<span class="string">&quot;\t&quot;</span>) </span><br><span class="line">    ref_start_gene = items[<span class="number">0</span>]</span><br><span class="line">    ref_end_gene = items[<span class="number">1</span>]</span><br><span class="line">    qry_start_gene = items[<span class="number">2</span>]</span><br><span class="line">    qry_end_gene = items[<span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    ref_chr, ref_start = ref_dict[ref_start_gene][<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    ref_end = ref_dict[ref_end_gene][<span class="number">2</span>]</span><br><span class="line">    qry_chr, qry_start = qry_dict[qry_start_gene][<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    qry_end = qry_dict[qry_end_gene][<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    circos_input = [ref_chr, ref_start, ref_end, qry_chr, qry_start, qry_end]</span><br><span class="line">    fo.writelines(<span class="string">&#x27;\t&#x27;</span>.join(circos_input) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure>

<h4 id="2-1-4-4-数据文件-——-特征图文件"><a href="#2-1-4-4-数据文件-——-特征图文件" class="headerlink" title="2.1.4.4. 数据文件 —— 特征图文件"></a>2.1.4.4. 数据文件 —— 特征图文件</h4><p>特征图文件用于生成折线图(line)，散点图(scatter)，直方图(histogram)和热图(heatmap)等特征图模块。</p>
<h5 id="2-1-4-4-1-获取特征图文件"><a href="#2-1-4-4-1-获取特征图文件" class="headerlink" title="2.1.4.4.1. 获取特征图文件"></a>2.1.4.4.1. 获取特征图文件</h5><p>特征图文件格式相同，由四列组成，染色体ID(chr)，起始位置(start)，终止位置(end)，特征数据(value[options])。</p>
<p>前三列是bed格式，最后一列是特征数据，比如在这个位置有几个基因。通常用法是展示染色体的基因密度信息、重复序列密度和GC含量等信息。</p>
<ol>
<li><p>准备</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cut -d &#x27; &#x27; -f 3,6 karyotype.txt | tr &#x27; &#x27; &#x27;\t&#x27; &gt;genome.txt #获取基因组文件</span><br><span class="line">bedtools makewindows -g genome.txt -w 100000 &gt;genome.windows #以100kb为滑窗，沿染色体创建窗口</span><br></pre></td></tr></table></figure></li>
<li><p>基因密度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zgrep &#x27;[[:blank:]]gene[[:blank:]]&#x27; sample.gff3 |awk &#x27;&#123;print $1&quot;\t&quot;$4&quot;\t&quot;$5&#125;&#x27; &gt;genes.bed #提取基因位置信息</span><br><span class="line">bedtools coverage -a genome.windows -b genes.bed | cut -f 1-4 &gt;genes_num.txt #按照滑窗统计基因密度</span><br></pre></td></tr></table></figure></li>
<li><p>重复序列密度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk &#x27;&#123;print $1&quot;\t&quot;$4&quot;\t&quot;$5&#125;&#x27; repeats.gff |grep -v &quot;#&quot; &gt;repeats.bed #提取重复位置信息</span><br><span class="line">bedtools coverage -a genome.windows -b repeats.bed | cut -f 1-4 &gt;repeats_num.txt #按照滑窗统计重复密度</span><br></pre></td></tr></table></figure></li>
<li><p>GC含量<br><code>bedtools nuc -fi genome.fa -bed genome.windows | cut -f 1-3,5 | sed &#39;1d&#39; &gt; gc_rate.txt #按照滑窗统计GC含量</code></p>
</li>
<li><p>共线性区块的基因密度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat bv.col|sed -e &quot;s/#.* /#/g&quot; -e &quot;s/[^b]*bv/bv/&quot; |tr &#x27;\n&#x27; &#x27; &#x27;|sed &quot;s/ #/\n/g&quot;|awk &#x27;&#123;print $2,$3,$5,$6&#125;&#x27;|grep -v &quot;#&quot; |sed &quot;s/ /\n/g&quot;|sed &quot;/^$/d&quot; |sort |uniq &gt;bv.col.list #获取共线性区块包含的基因列表</span><br><span class="line">grep -f col.list Bauhinia.variegata.gene.gff3 |awk &#x27;$3 == &quot;gene&quot; &#123;print $1&quot;\t&quot;$4&quot;\t&quot;$5&#125;&#x27; &gt;col.bed #获取基因的位置信息</span><br><span class="line">bedtools coverage -a genome.windows -b col.bed |cut -f 1-4 &gt;col.txt #统计共线性基因密度</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="3-references"><a href="#3-references" class="headerlink" title="3. references"></a>3. references</h1><ol>
<li>Circos paper：<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2752132/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2752132/</a></li>
<li>xuzhougeng 1：<a href="https://www.jianshu.com/p/3a31ceef711b">https://www.jianshu.com/p/3a31ceef711b</a></li>
<li>xuzhougeng 2：<a href="https://www.jianshu.com/p/4b3d3809ac07">https://www.jianshu.com/p/4b3d3809ac07</a></li>
<li>xuzhougeng 3：<a href="https://www.jianshu.com/p/ea3a8933ace9">https://www.jianshu.com/p/ea3a8933ace9</a></li>
<li>xuzhougeng 4：<a href="https://www.jianshu.com/p/1658e702ba17">https://www.jianshu.com/p/1658e702ba17</a></li>
<li>xuzhougeng 5：<a href="https://www.jianshu.com/p/31f26d1e5974">https://www.jianshu.com/p/31f26d1e5974</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bio</category>
        <category>plot</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>plot</tag>
        <tag>Circos</tag>
      </tags>
  </entry>
  <entry>
    <title>集合可视化 —— 文氏图/韦恩图(Venn Diagram)</title>
    <url>/2021/09/29/bio_plot_venn/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1697043&auto=1&height=32"></iframe></div>

<h1 id="1-文氏图-x2F-韦恩图-Venn-Diagram-——-5个集合内的可视化"><a href="#1-文氏图-x2F-韦恩图-Venn-Diagram-——-5个集合内的可视化" class="headerlink" title="1. 文氏图&#x2F;韦恩图(Venn Diagram) —— 5个集合内的可视化"></a>1. 文氏图&#x2F;韦恩图(Venn Diagram) —— 5个集合内的可视化</h1><p>当有多个群组（集合）的数据，想要展示在不同的事物群组（集合）之间的数学或逻辑联系时，可使用韦恩Venn图和UpSet图展示多集合直接的共享关系和各自的独享关系。</p>
<p>当集合数量少于等于5个时，多用韦恩图；当集合数量大于5个时，多用upset图。</p>
<p>韦恩图的绘制推荐使用R包gplots；upset图的绘制推荐使用R包UpSetR，参考博文<a href="https://yanzhongsino.github.io/2021/09/29/R_plot_upset/">upset图</a>。</p>
<h2 id="1-1-应用场景"><a href="#1-1-应用场景" class="headerlink" title="1.1. 应用场景"></a>1.1. 应用场景</h2><ol>
<li>利用orthofinder找到的不同物种的orthogroups的结果来绘制Venn Diagram韦恩图或者UpSet plot图，查看不同物种间共享的orthogroups的数量关系。</li>
</ol>
<h2 id="1-2-数据准备"><a href="#1-2-数据准备" class="headerlink" title="1.2. 数据准备"></a>1.2. 数据准备</h2><p>从orthofinder的结果文件Results_date&#x2F;Orthogroups&#x2F;Orthogroups.GeneCount.tsv（每个物种拥有每种orthogroups的基因数量的统计）中提取每个物种拥有的orthogroups信息；并合并作为venn的输入文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">species=($(<span class="built_in">head</span> -1 Orthogroups.GeneCount.tsv|sed <span class="string">&quot;s/.pep//g&quot;</span>)) <span class="comment">#读取Orthogroups.GeneCount.tsv第一行表头写入species列表中</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 `<span class="built_in">expr</span> <span class="variable">$&#123;#species[@]&#125;</span> - 2`); <span class="keyword">do</span> awk -v awka=`<span class="built_in">expr</span> <span class="variable">$i</span> + 1` <span class="string">&#x27;$awka != 0 &#123;print $1&#125;&#x27;</span> Orthogroups.GeneCount.tsv  |sed <span class="string">&quot;1s/.*/<span class="variable">$&#123;species[$i]&#125;</span>/&quot;</span> &gt;<span class="variable">$&#123;species[$i]&#125;</span>.temp; <span class="keyword">done</span> <span class="comment">#第二到倒数第二列（物种数据所在列）不为0时，输出第一列内容（OG的ID号）。</span></span><br><span class="line"><span class="built_in">paste</span> *.temp &gt;orthogroups.venn <span class="comment">#把提取的所有物种横向拼接成一个文件，即为venn的输入。</span></span><br><span class="line"><span class="built_in">rm</span> *.temp <span class="comment">#删除临时文件</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-韦恩图绘制"><a href="#1-3-韦恩图绘制" class="headerlink" title="1.3. 韦恩图绘制"></a>1.3. 韦恩图绘制</h2><h3 id="1-3-1-在线画韦恩图"><a href="#1-3-1-在线画韦恩图" class="headerlink" title="1.3.1. 在线画韦恩图"></a>1.3.1. 在线画韦恩图</h3><ol>
<li><a href="http://bioinformatics.psb.ugent.be/webtools/Venn/">http://bioinformatics.psb.ugent.be/webtools/Venn/</a></li>
<li><a href="http://jvenn.toulouse.inra.fr/app/example.html">http://jvenn.toulouse.inra.fr/app/example.html</a></li>
</ol>
<p>快和方便，但图不好看。</p>
<h3 id="1-3-2-R包画韦恩图"><a href="#1-3-2-R包画韦恩图" class="headerlink" title="1.3.2. R包画韦恩图"></a>1.3.2. R包画韦恩图</h3><h4 id="1-3-2-1-R包gplots"><a href="#1-3-2-1-R包gplots" class="headerlink" title="1.3.2.1. R包gplots"></a>1.3.2.1. R包gplots</h4><p>R包gplots画韦恩图方便快捷参数少，缺点是画出来的图黑白无填充色，适合初期查看数据。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;gplots&quot;</span><span class="punctuation">)</span> <span class="comment">#安装gplots包</span></span><br><span class="line">library<span class="punctuation">(</span>gplots<span class="punctuation">)</span> <span class="comment">#载入gplots包</span></span><br><span class="line">setwd<span class="punctuation">(</span><span class="string">&quot;D:/R/&quot;</span><span class="punctuation">)</span> <span class="comment">#设置工作目录</span></span><br><span class="line">data <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;orthogroups.venn&quot;</span><span class="punctuation">,</span> header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;\t&quot;</span><span class="punctuation">)</span> <span class="comment">#读入数据文件</span></span><br><span class="line">head<span class="punctuation">(</span>data<span class="punctuation">)</span> <span class="comment">#查看数据文件</span></span><br><span class="line">attach<span class="punctuation">(</span>data<span class="punctuation">)</span> <span class="comment">#把数据用于全局</span></span><br><span class="line">venn<span class="punctuation">(</span>data <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>Athaliana<span class="punctuation">,</span>Graimondii<span class="punctuation">,</span>Ppersica<span class="punctuation">,</span>Mtruncatula<span class="punctuation">,</span>Vvinifera<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#画韦恩图，需要几维就填入几列数据，黑白无填充图，根据data的表头，即第一行来填写。</span></span><br></pre></td></tr></table></figure>
<br>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> head<span class="punctuation">(</span>data<span class="punctuation">)</span></span><br><span class="line">  Athaliana  Csativus Csinensis Graimondii Mguttatus Mtruncatula  Ppersica Ptrichocarpa Vvinifera</span><br><span class="line"><span class="number">1</span> OG0000001 OG0000001 OG0000001  OG0000001 OG0000000   OG0000000 OG0000001    OG0000001 OG0000001</span><br><span class="line"><span class="number">2</span> OG0000002 OG0000002 OG0000002  OG0000002 OG0000001   OG0000001 OG0000002    OG0000002 OG0000002</span><br><span class="line"><span class="number">3</span> OG0000003 OG0000003 OG0000003  OG0000003 OG0000002   OG0000002 OG0000003    OG0000003 OG0000003</span><br><span class="line"><span class="number">4</span> OG0000004 OG0000004 OG0000004  OG0000004 OG0000003   OG0000003 OG0000004    OG0000004 OG0000004</span><br><span class="line"><span class="number">5</span> OG0000005 OG0000005 OG0000005  OG0000005 OG0000004   OG0000004 OG0000005    OG0000005 OG0000005</span><br><span class="line"><span class="number">6</span> OG0000007 OG0000007 OG0000007  OG0000007 OG0000005   OG0000005 OG0000007    OG0000007 OG0000006</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-2-R包VennDiagram"><a href="#1-3-2-2-R包VennDiagram" class="headerlink" title="1.3.2.2. R包VennDiagram"></a>1.3.2.2. R包VennDiagram</h4><p>R包VennDiagram画韦恩图参数较多，适合做用于发表的韦恩图。</p>
<ol>
<li><p>准备工作</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;VennDiagram&quot;</span><span class="punctuation">)</span> <span class="comment">#安装VennDiagram包</span></span><br><span class="line">library<span class="punctuation">(</span>VennDiagram<span class="punctuation">)</span> <span class="comment">#载入VennDiagram包</span></span><br><span class="line">library<span class="punctuation">(</span>grid<span class="punctuation">)</span> <span class="comment">#载入grid包</span></span><br><span class="line">data <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;orthogroups.venn&quot;</span><span class="punctuation">,</span> header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;\t&quot;</span><span class="punctuation">)</span> <span class="comment">#读入数据文件</span></span><br><span class="line">head<span class="punctuation">(</span>data<span class="punctuation">)</span> <span class="comment">#查看数据文件</span></span><br><span class="line">attach<span class="punctuation">(</span>data<span class="punctuation">)</span> <span class="comment">#把数据用于全局</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一维韦恩图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grid.newpage<span class="punctuation">(</span><span class="punctuation">)</span>; <span class="comment">#清除已有图形，开始新的空白页</span></span><br><span class="line">venn.single.plot <span class="operator">&lt;-</span> venn.diagram<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>Athaliana<span class="operator">=</span>Athaliana<span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment">#等号前面是图上显示的数据名称，等号后面是数据源。</span></span><br><span class="line">  filename <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  col <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span> <span class="comment">#图的边界颜色</span></span><br><span class="line">  lwd <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  fontface <span class="operator">=</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">,</span></span><br><span class="line">  fill <span class="operator">=</span> <span class="string">&quot;grey&quot;</span><span class="punctuation">,</span> <span class="comment">#填充色</span></span><br><span class="line">  aplha <span class="operator">=</span> <span class="number">0.75</span><span class="punctuation">,</span> <span class="comment">#透明度</span></span><br><span class="line">  cex <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">  cat.cex <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  cat.fontface <span class="operator">=</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">)</span>; <span class="comment">#一维韦恩图</span></span><br><span class="line">grid.draw<span class="punctuation">(</span>venn.single.plot<span class="punctuation">)</span>; <span class="comment">#用venn.plot绘图</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>二维韦恩图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grid.newpage<span class="punctuation">(</span><span class="punctuation">)</span>; <span class="comment">#清除已有图形，开始新的空白页</span></span><br><span class="line">venn.pairwise.plot <span class="operator">&lt;-</span> venn.diagram<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>Graimondii<span class="operator">=</span>Graimondii<span class="punctuation">,</span> Ppersica<span class="operator">=</span>Ppersica<span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment">#等号前面是图上显示的数据名称，等号后面是数据源。</span></span><br><span class="line">  filename <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  lwd <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">  fill <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;cornflowerblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkorchid1&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment">#填充色</span></span><br><span class="line">  aplha <span class="operator">=</span> <span class="number">0.75</span><span class="punctuation">,</span> <span class="comment">#透明度</span></span><br><span class="line">  label.col <span class="operator">=</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span></span><br><span class="line">  cex <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">  fontfamily <span class="operator">=</span> <span class="string">&quot;serif&quot;</span><span class="punctuation">,</span></span><br><span class="line">  fontface <span class="operator">=</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">,</span></span><br><span class="line">  cat.col <span class="operator">=</span>  <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;cornflowerblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkorchid1&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  cat.cex <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  cat.fontfamily <span class="operator">=</span> <span class="string">&quot;serif&quot;</span><span class="punctuation">,</span></span><br><span class="line">  cat.fontface <span class="operator">=</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">,</span></span><br><span class="line">  cat.dist <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.03</span><span class="punctuation">,</span> <span class="number">0.03</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  cat.pos <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">20</span><span class="punctuation">,</span><span class="number">14</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span>; <span class="comment">#二维韦恩图</span></span><br><span class="line">grid.draw<span class="punctuation">(</span>venn.pairwise.plot<span class="punctuation">)</span>; <span class="comment">#用venn.plot绘图</span></span><br></pre></td></tr></table></figure></li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/R_plot_venn_2.png?raw=true" width=50% title="venn_2" align=center/>

<p><strong><p align="center">Figure 1. Venn diagram with 2 groups</p></strong></p>
<ol start="4">
<li>三维韦恩图<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grid.newpage<span class="punctuation">(</span><span class="punctuation">)</span>; <span class="comment">#清除已有图形，开始新的空白页</span></span><br><span class="line">venn.triple.plot <span class="operator">&lt;-</span> venn.diagram<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>Athaliana<span class="operator">=</span>Athaliana<span class="punctuation">,</span> Ppersica<span class="operator">=</span>Ppersica<span class="punctuation">,</span> Graimondii<span class="operator">=</span>Graimondii<span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment">#等号前面是图上显示的数据名称，等号后面是数据源。</span></span><br><span class="line">  filename <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  col <span class="operator">=</span> <span class="string">&quot;transparent&quot;</span><span class="punctuation">,</span></span><br><span class="line">  fill <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;green&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  alpha <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">,</span></span><br><span class="line">  label.col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;darkred&quot;</span><span class="punctuation">,</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkgreen&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  cex <span class="operator">=</span> <span class="number">2.5</span><span class="punctuation">,</span></span><br><span class="line">  fontfamily <span class="operator">=</span> <span class="string">&quot;serif&quot;</span><span class="punctuation">,</span></span><br><span class="line">  fontface <span class="operator">=</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">,</span></span><br><span class="line">  cat.default.pos <span class="operator">=</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">  cat.col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;darkred&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkgreen&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  cat.cex <span class="operator">=</span> <span class="number">2.5</span><span class="punctuation">,</span></span><br><span class="line">  cat.fontfamily <span class="operator">=</span> <span class="string">&quot;serif&quot;</span><span class="punctuation">,</span></span><br><span class="line">  cat.dist <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.06</span><span class="punctuation">,</span> <span class="number">0.06</span><span class="punctuation">,</span> <span class="number">0.03</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  cat.pos <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">)</span>;</span><br><span class="line">grid.draw<span class="punctuation">(</span>venn.triple.plot<span class="punctuation">)</span>; <span class="comment">#用venn.plot绘图</span></span><br></pre></td></tr></table></figure></li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/R_plot_venn_3.png?raw=true" width=60% title="venn_3" align=center/>

<p><strong><p align="center">Figure 2. Venn diagram with 3 groups</p></strong></p>
<ol start="5">
<li>四维韦恩图<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grid.newpage<span class="punctuation">(</span><span class="punctuation">)</span>; <span class="comment">#清除已有图形，开始新的空白页</span></span><br><span class="line">venn.quad.plot <span class="operator">&lt;-</span> venn.diagram<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>Mtruncatula<span class="operator">=</span>Mtruncatula<span class="punctuation">,</span> Vvinifera<span class="operator">=</span>Vvinifera<span class="punctuation">,</span> Graimondii<span class="operator">=</span>Graimondii<span class="punctuation">,</span> Ppersica<span class="operator">=</span>Ppersica<span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment">#等号前面是图上显示的数据名称，等号后面是数据源，数据顺序与图上顺序一致。</span></span><br><span class="line">  filename <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span></span><br><span class="line">  col <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span></span><br><span class="line">  lty <span class="operator">=</span> <span class="string">&quot;dotted&quot;</span><span class="punctuation">,</span> <span class="comment">#边框线类型</span></span><br><span class="line">  lwd <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">  fill <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;cornflowerblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;green&quot;</span><span class="punctuation">,</span> <span class="string">&quot;yellow&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkorchid1&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  alpha <span class="operator">=</span> <span class="number">0.50</span><span class="punctuation">,</span></span><br><span class="line">  label.col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;orange&quot;</span><span class="punctuation">,</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkorchid4&quot;</span><span class="punctuation">,</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> <span class="string">&quot;white&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkgreen&quot;</span><span class="punctuation">,</span> <span class="string">&quot;white&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  cex <span class="operator">=</span> <span class="number">2.5</span><span class="punctuation">,</span></span><br><span class="line">  fontfamily <span class="operator">=</span> <span class="string">&quot;serif&quot;</span><span class="punctuation">,</span></span><br><span class="line">  fontface <span class="operator">=</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">,</span></span><br><span class="line">  cat.col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;darkblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkgreen&quot;</span><span class="punctuation">,</span> <span class="string">&quot;orange&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkorchid4&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  cat.cex <span class="operator">=</span> <span class="number">2.5</span><span class="punctuation">,</span> <span class="comment">#分类名称字体大小</span></span><br><span class="line">  cat.fontfamily <span class="operator">=</span> <span class="string">&quot;serif&quot;</span></span><br><span class="line"><span class="punctuation">)</span>; <span class="comment"># 四维韦恩图</span></span><br><span class="line">grid.draw<span class="punctuation">(</span>venn.quad.plot<span class="punctuation">)</span>; <span class="comment">#用venn.plot绘图</span></span><br></pre></td></tr></table></figure></li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/R_plot_venn_4.png?raw=true" width=60% title="venn_4" align=center/>

<p><strong><p align="center">Figure 3. Venn diagram with 4 groups</p></strong></p>
<ol start="6">
<li>五维韦恩图<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">grid.newpage<span class="punctuation">(</span><span class="punctuation">)</span>; <span class="comment">#清除已有图形，开始新的空白页</span></span><br><span class="line">venn.quintuple.plot <span class="operator">&lt;-</span> venn.diagram<span class="punctuation">(</span></span><br><span class="line">  x <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span>Athaliana<span class="operator">=</span>Athaliana<span class="punctuation">,</span> Ppersica<span class="operator">=</span>Ppersica<span class="punctuation">,</span> Graimondii<span class="operator">=</span>Graimondii<span class="punctuation">,</span> Mtruncatula<span class="operator">=</span>Mtruncatula<span class="punctuation">,</span> Vvinifera<span class="operator">=</span>Vvinifera<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">  filename <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> <span class="comment"># 韦恩图结果文件保存路径和名称</span></span><br><span class="line">  col <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span> <span class="comment">#指定图形的圆周边缘颜色，transparent透明</span></span><br><span class="line">  fill <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;dodgerblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;goldenrod1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkorange1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;seagreen3&quot;</span><span class="punctuation">,</span> <span class="string">&quot;orchid3&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment"># 填充颜色</span></span><br><span class="line">  alpha <span class="operator">=</span> <span class="number">0.50</span><span class="punctuation">,</span> <span class="comment">#透明度</span></span><br><span class="line">  cex <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1.5</span><span class="punctuation">,</span> <span class="number">1.5</span><span class="punctuation">,</span> <span class="number">1.5</span><span class="punctuation">,</span> <span class="number">1.5</span><span class="punctuation">,</span> <span class="number">1.5</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span></span><br><span class="line">          <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.55</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.55</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.55</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.55</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">0.55</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">1.5</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment">#每个区域label名称的大小</span></span><br><span class="line">  cat.col <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;dodgerblue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;goldenrod1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;darkorange1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;seagreen3&quot;</span><span class="punctuation">,</span> <span class="string">&quot;orchid3&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment">#分类颜色</span></span><br><span class="line">  cat.cex <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span> <span class="comment">#每个分类名称大小</span></span><br><span class="line">  cat.dist <span class="operator">=</span> <span class="number">0.07</span><span class="punctuation">,</span> <span class="comment">#分类名称距离边的距离</span></span><br><span class="line">  cat.just <span class="operator">=</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">0.5</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment">#分类名称的位置，圈内或圈外</span></span><br><span class="line">  cat.fontface <span class="operator">=</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">,</span></span><br><span class="line">  cat.fontfamily <span class="operator">=</span> <span class="string">&quot;serif&quot;</span><span class="punctuation">,</span> <span class="comment"># 分类字体</span></span><br><span class="line">  margin <span class="operator">=</span> <span class="number">0.2</span> <span class="comment">#图距离边缘的距离</span></span><br><span class="line"><span class="punctuation">)</span>; <span class="comment"># 五维韦恩图</span></span><br><span class="line">grid.draw<span class="punctuation">(</span>venn.quintuple.plot<span class="punctuation">)</span>; <span class="comment">#用venn.plot绘图</span></span><br></pre></td></tr></table></figure></li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/R_plot_venn_5.png?raw=true" width=60% title="venn_5" align=center/>

<p><strong><p align="center">Figure 4. Venn diagram with 5 groups</p></strong></p>
<h4 id="1-3-2-3-保存R生成的图"><a href="#1-3-2-3-保存R生成的图" class="headerlink" title="1.3.2.3. 保存R生成的图"></a>1.3.2.3. 保存R生成的图</h4><p>在RStudio里作图，选择Export-Save as PDF<br>一般参数：PDF Size(A4)+Orientation(Landscape)<br>保存图像为pdf即可。</p>
<h1 id="2-references"><a href="#2-references" class="headerlink" title="2. references"></a>2. references</h1><ol>
<li><a href="https://www.jianshu.com/p/79fb263e41ff">https://www.jianshu.com/p/79fb263e41ff</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bio</category>
        <category>plot</category>
      </categories>
      <tags>
        <tag>R package</tag>
        <tag>R</tag>
        <tag>plot</tag>
        <tag>Venn</tag>
        <tag>gplots</tag>
        <tag>VennDiagram</tag>
      </tags>
  </entry>
  <entry>
    <title>鉴定全基因复制事件(WGD)后保留的复制基因</title>
    <url>/2022/10/18/bioinfo_WGD_geneRetention/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=28996523&auto=1&height=32"></iframe></div>

<h1 id="1-全基因组复制事件-WGD"><a href="#1-全基因组复制事件-WGD" class="headerlink" title="1. 全基因组复制事件(WGD)"></a>1. 全基因组复制事件(WGD)</h1><p>全基因组复制事件(WGD)是指在生物进化历史上发生的全基因组范围的染色体加倍、基因复制的事件，根据目前研究现状，WGD在植物进化历史上是很常见的。</p>
<h1 id="2-WGD后保留的复制基因"><a href="#2-WGD后保留的复制基因" class="headerlink" title="2. WGD后保留的复制基因"></a>2. WGD后保留的复制基因</h1><p>全基因组复制事件（WGD）后基因的命运有所不同。有些复制的基因对中的一个会发生变异、甚至假基因化，从而使得目前我们观察到的基因组上这类基因是单拷贝的；有些复制的基因对则保留到现在，成为WGD的证据。</p>
<h1 id="3-思路"><a href="#3-思路" class="headerlink" title="3. 思路"></a>3. 思路</h1><h2 id="3-1-参考"><a href="#3-1-参考" class="headerlink" title="3.1. 参考"></a>3.1. 参考</h2><p>通过参考焦远年团队的文章: <a href="https://www.sciencedirect.com/science/article/pii/S1674205219303594">https://www.sciencedirect.com/science/article/pii/S1674205219303594</a> 的 Methods部分，构建了以下分析思路，用来实现对发生特定WGD事件的物种的基因复制保留分析。</p>
<ul>
<li>实现的目的是：找到某物种基因组上那些在进化历史上发生特定WGD事件后保留至今的基因对，尽可能减少假阳性和假阴性。</li>
<li>文章里用了多个软件，目前Orthofinder2可以实现第2，3，4，5步骤。</li>
</ul>
<h2 id="3-2-步骤"><a href="#3-2-步骤" class="headerlink" title="3.2. 步骤"></a>3.2. 步骤</h2><ol>
<li>数据</li>
</ol>
<ul>
<li>多个物种的基因组。最少两个物种，除了发生WGD的被分析物种外，还要包括至少一个不共享此次WGD的外类群。</li>
<li>如果要分析多个物种各自的WGDs，也可以一起构建物种树和基因树，在各自筛选基因树做各自WGD保留基因的根系。</li>
</ul>
<ol start="2">
<li>基因家族（gene family）同源关系的鉴定</li>
</ol>
<ul>
<li>用软件OrthoFinder2或者OrthoMCL可以实现基因家族和基因的直系同源关系的推断。</li>
<li>推断将会得到所有物种的orthogroups，包括通过考虑每个orthogroup的基因的最近共同祖先来推断orthogroup的拓扑。</li>
<li>关于软件OrthoFinder2可以参考博客：<a href="https://yanzhongsino.github.io/2021/12/06/bioinfo_orthology.inference_OrthoFinder2/">https://yanzhongsino.github.io/2021/12/06/bioinfo_orthology.inference_OrthoFinder2/</a></li>
</ul>
<ol start="3">
<li>构建物种树</li>
</ol>
<ul>
<li>文章用的APG系统的物种树。</li>
<li>发现OrthoFinder2可以直接实现物种树构建。</li>
<li>或者用单拷贝基因构建，RAxML-NG和IQ-TREE等软件都可。</li>
</ul>
<ol start="4">
<li>构建基因树</li>
</ol>
<ul>
<li>文章里是用的是，通过OrthoMCL鉴定出来的orthogroups，筛除掉少于4个基因和不包含外类群的orthogroups来构建。</li>
<li>我发现OrthoFinder2可以直接实现基因树构建，但基因树的筛选需要手动进行。</li>
</ul>
<ol start="5">
<li>根据物种树整理基因树的节点</li>
</ol>
<ul>
<li>通过与物种树的节点比较，对基因树的节点进行整理，保持与物种树一致。</li>
<li>文章是用软件Notung2.9来根据物种树的拓扑，融合OrthoMCL的基因树结果。</li>
</ul>
<ol start="6">
<li>根据物种树拓扑筛选基因树</li>
</ol>
<ul>
<li>通过指定一些标准，从OrthoFinder2或者OrthoMCL的结果中筛选符合物种树的基因树，使用这些基因树的基因对作为有发生基因复制事件证据的基因对。</li>
<li>文章里的标准是，两个子枝(child branches)需要拥有来自至少一个最近共同祖先的基因，父母节点(parental node)和至少一个子节点（child nodes）有超过50%的支持率。</li>
<li>这个也需要手动进行。</li>
</ul>
<ol start="7">
<li>移除串联重复（tandem duplications）</li>
</ol>
<ul>
<li>移除串联重复tandem，这些不是全基因组复制事件中产生。</li>
<li>文章里对tandem的鉴定用的标准是两个基因的位置在五个基因以内即做看作tandem。</li>
<li>操作上，我是通过基因ID来实现的（如果基因ID的编号相差在5以内就被看作tandem，这种基因树被删除）。注释基因组时对基因ID根据位置进行排序和整理的好处这个时候就体现了。</li>
</ul>
<ol start="8">
<li>鉴定基因复制事件的基因</li>
</ol>
<ul>
<li>通过以上4，5，6，7步骤的筛选，我们获得代表WGD的基因树，这也就意味着得到了WGD后保留的复制基因（基因树上那些基因）。</li>
<li>把得到的基因树上的基因根据位置提取出来，分别从两个child branches中各提取一个基因，组成一个基因对。有些基因树上只有一个基因对，有些可能不止两个基因，会产生多于一个基因对。</li>
</ul>
<ol start="9">
<li>多次WGDs</li>
</ol>
<ul>
<li>如果系统发育树的同一枝上有超过一次的WGD事件（比如某物种特有两次WGDs），则通过计算鉴定出来的复制基因对的Ks，通过Ks区分这些WGDs。</li>
<li>例如一次WGD的Ks峰值在0.2，另一次在0.7，则可一刀切的把Ks大于两者平均值$$0.45&#x3D;(0.2+0.7)&#x2F;2$$的那些基因对算作0.7那次WGD保留的，Ks小于0.45的算作0.2那次保留的。</li>
<li>这个是没有其他更好的解决办法的处理方式，在文章中对水稻等发生两次WGDs的物种也是这样处理的。</li>
</ul>
<ol start="10">
<li>TF分析【可选】</li>
</ol>
<ul>
<li>得到WGD后保留的基因对后，还可以进行转录因子（transcription factor，TF）的WGD后保留分析。</li>
</ul>
<p>notes：其中第4，5，6，7步骤都是在对基因树进行筛选，把那些代表了特定WGD的基因树筛选出来，避免其他基因树的干扰（比如tandem）。把代表WGD的基因树筛选出来后，也就意味着得到了WGD后保留的复制基因（基因树上那些基因）。</p>
<h1 id="4-实战"><a href="#4-实战" class="headerlink" title="4. 实战"></a>4. 实战</h1><h2 id="4-1-准备"><a href="#4-1-准备" class="headerlink" title="4.1. 准备"></a>4.1. 准备</h2><ul>
<li>数据准备：物种A有两次物种特有的WGDs，不共享这两次WGD的外类群B。至少这两个物种的基因组数据。有其他物种的也可以一起用。</li>
</ul>
<h2 id="4-2-orthofinder2构建物种树和基因树"><a href="#4-2-orthofinder2构建物种树和基因树" class="headerlink" title="4.2. orthofinder2构建物种树和基因树"></a>4.2. orthofinder2构建物种树和基因树</h2><h3 id="4-2-1-OrthoFinder2运行"><a href="#4-2-1-OrthoFinder2运行" class="headerlink" title="4.2.1. OrthoFinder2运行"></a>4.2.1. OrthoFinder2运行</h3><ul>
<li>注意运行orthofinder2时要指定比对软件，推断基因树的方法，和画树软件。</li>
<li>建议参数：<code>orthofinder -f ./workdirectory -t 24 -a 8 -M msa -S blast -A mafft -T raxml-ng</code></li>
<li>参考博客：<a href="https://yanzhongsino.github.io/2021/12/06/bioinfo_orthology.inference_OrthoFinder2/">https://yanzhongsino.github.io/2021/12/06/bioinfo_orthology.inference_OrthoFinder2/</a></li>
<li>如果之前跑过orthofinder但没推断基因树和物种树的可以指定步骤重新运行。</li>
</ul>
<h3 id="4-2-2-结果文件"><a href="#4-2-2-结果文件" class="headerlink" title="4.2.2. 结果文件"></a>4.2.2. 结果文件</h3><p>要用的主要是三个个文件，在&#x2F;OrthoFinder&#x2F;Results_xx&#x2F;Gene_Duplication_Events&#x2F;目录下的Duplications.tsv和SpeciesTree_Gene_Duplications_0.5_Support.txt，以及&#x2F;OrthoFinder&#x2F;Results_xx&#x2F;Orthogroups下的Orthogroups.txt。</p>
<ol>
<li>Duplications.tsv</li>
</ol>
<ul>
<li>是一个制表符分隔的文本文件，它列出了通过检查每个正群基因树的每个节点识别出的所有基因复制事件，每行代表至少一次基因复制事件。</li>
<li>七列内容分别是：</li>
<li>1.Orthogroup的ID</li>
<li>2.Species Tree node：发生复制的物种树的分支，参见Species_Tree&#x2F;SpeciesTree_rooted_node_labels.txt</li>
<li>3.Gene tree node：与基因复制事件对应的节点，参见相应的orthogroup Resolved_Gene_Trees&#x2F; 中的树；</li>
<li>4.Support：存在复制基因的两个副本的预期物种的比例</li>
<li>5.Type：”Terminal”：物种树终端分支上的重复；”Non-Terminal”：物种树内部分支上的重复，因此被多个物种共享；”Non-Terminal”：STRIDE检查基因树的拓扑结构在复制后应该是什么；</li>
<li>6.Genes 1：基因列表来自复制基因的一个副本，逗号分隔；</li>
<li>7.Genes 2：基因列表来自复制基因的另一个副本，逗号分隔。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Orthogroup      Species Tree Node       Gene Tree Node  Support Type    Genes 1 Genes 2</span><br><span class="line">OG0000000       N5      n62     0.5     Non-Terminal    Mcandidum_pep_mc33950   Mdodecandrum_pep_DR005872, Mcandidum_pep_mc01326, Mdodecandrum_pep_DR006000, Mcandidum_pep_mc01492</span><br><span class="line">OG0000000       N5      n63     1.0     Non-Terminal    Mdodecandrum_pep_DR005872, Mcandidum_pep_mc01326        Mdodecandrum_pep_DR006000, Mcandidum_pep_mc01492</span><br><span class="line">OG0000000       N5      n177    0.5     Non-Terminal    Mdodecandrum_pep_DR002276, Mdodecandrum_pep_DR013872, Mcandidum_pep_mc36653, Mdodecandrum_pep_DR026891, Mcandidum_pep_mc22876, Mcandidum_pep_mc37513, Mdodecandrum_pep_DR026886 Mdodecandrum_pep_DR004265</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>SpeciesTree_Gene_Duplications_0.5_Support.txt</li>
</ol>
<ul>
<li>提供了物种树分支上的上述重复的总和。</li>
<li>它是一个 newick 格式的文本文件。</li>
<li>每个节点或物种名称后面的数字是在导致节点&#x2F;物种的分支上发生的具有至少 50% 支持度的基因复制事件的数量。</li>
<li>分支长度是标准分支长度，如 Species_Tree&#x2F;SpeciesTree_rooted.txt 中给出的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(((((Mcandidum.pep_7199:1,Mdodecandrum.pep_3425:1)N5_9299:1,Egrandis.pep_12485:1)N3_296:1,((Ptrichocarpa.pep_13300:1,(Csinensis.pep_5628:1,(Graimondii.pep_15253:1,Athaliana.pep_8750:1)N10_30:1)N8_5:1)N6_61:1,(Ppersica.pep_5798:1,(Mtruncatula.pep_23336:1,Csativus.pep_3576:1)N9_48:1)N7_12:1)N4_19:1)N2_96:1,Vvinifera.pep_7596:1)N1_535:1,Mguttatus.pep_8911:1)N0_1806;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Orthogroups.txt</li>
</ol>
<ul>
<li>Orthogroups.txt保存了鉴别的orthogroups的信息。</li>
<li>第一列是OG开头的orthogroups的ID号，冒号结束；后面不同数量的列是此orthogroup包含的各物种的基因ID。</li>
</ul>
<h2 id="4-3-筛选基因复制事件和复制的基因对"><a href="#4-3-筛选基因复制事件和复制的基因对" class="headerlink" title="4.3. 筛选基因复制事件和复制的基因对"></a>4.3. 筛选基因复制事件和复制的基因对</h2><h3 id="4-3-1-筛选基因家族"><a href="#4-3-1-筛选基因家族" class="headerlink" title="4.3.1. 筛选基因家族"></a>4.3.1. 筛选基因家族</h3><p>从Orthogroups.txt文件中筛选符合标准的orthogroups，提取orthogroups的ID号。</p>
<ol>
<li>筛选标准</li>
</ol>
<ul>
<li>每个基因家族至少包含四个基因。</li>
<li>每个基因家族至少包含一个外类群基因。</li>
</ul>
<ol start="2">
<li>筛选命令</li>
</ol>
<ul>
<li><code>cat /path/to/OrthoFinder/Results_xx/Orthogroups/Orthogroups.txt |awk &#39;NF&gt;4 &#123;print $0&#125;&#39; |grep &quot;OUTGROUP&quot;|sed &quot;s/:.*//g&quot; &gt;orthogroups_filter.list</code></li>
<li>其中<code>awk &#39;NF&gt;4 &#123;print $0&#125;&#39;</code>代表提取列数大于4的行，即包含至少4个基因的基因家族。</li>
<li>其中<code>grep &quot;OUTGROUP&quot;</code>代表提取有OUTGROUP字符串的行，这里提取包含外类群基因ID特征(比如Eugr)前缀的行。</li>
<li>其中<code>sed &quot;s/:.*//g&quot;</code>代表把冒号及之后的所有信息删除，只保留orthogroups的ID信息。</li>
</ul>
<h3 id="4-3-2-筛选基因复制事件"><a href="#4-3-2-筛选基因复制事件" class="headerlink" title="4.3.2. 筛选基因复制事件"></a>4.3.2. 筛选基因复制事件</h3><p>从Duplications.tsv文件中筛选符合标准的基因复制事件，提取基因复制事件中发生复制的基因。</p>
<ol>
<li>提取特定枝上的基因复制事件</li>
</ol>
<ul>
<li>比如这里是要筛选Mcandidum和Mdodecandrum的最近共同祖先发生的WGDs事件，在上面SpeciesTree_Gene_Duplications_0.5_Support.txt文件的例子中，是N5代表的节点。</li>
<li>则可以通过<code>cat Duplications.tsv|awk -v FS=&#39;\t&#39; &#39;$2==&quot;N5&quot; &#123;print $0&#125;&#39; &gt;N5.tsv</code>来获取第二列是N5的复制事件</li>
</ul>
<ol start="2">
<li>其他筛选标准</li>
</ol>
<ul>
<li>两个子枝（child branch）都有来自分析物种A的基因。都有才代表物种A的基因复制了。</li>
<li>支持率（这里用Duplications.tsv第4列Support值）大于等于0.5。</li>
</ul>
<ol start="3">
<li>筛选命令</li>
</ol>
<ul>
<li><code>cat N5.tsv|awk -v FS=&#39;\t&#39; &#39;$4&gt;=0.5 &amp;&amp; $6 ~ &quot;mc&quot; &amp;&amp; $7 ~ &quot;mc&quot; &#123;print $0&#125;&#39; &gt;N5_filter.tsv</code></li>
<li>其中<code>$6 ~ &quot;mc&quot; &amp;&amp; $7 ~ &quot;mc&quot;</code>代表模糊匹配第六列和第七列都包含mc字段的行。这里的mc是我们想要筛选的物种的基因ID的前缀。即实现了筛选两个子枝（child branch）都有来自分析物种A的基因。</li>
<li>其中<code>$4&gt;=0.5</code>代表第四列大于等于0.5的行。即实现了筛选支持率大于等于0.5的行。</li>
</ul>
<ol start="3">
<li>由于OrthoFinder2运行时也会有一些基础的筛选，所以有可能这步筛选结束后与筛选前完全一致。</li>
</ol>
<h3 id="4-3-3-整理数据"><a href="#4-3-3-整理数据" class="headerlink" title="4.3.3. 整理数据"></a>4.3.3. 整理数据</h3><ol>
<li>取以上基因家族和基因复制事件筛选结果的交集</li>
</ol>
<ul>
<li><code>grep -f orthogroups_filter.list N5_filter.tsv |awk &#39;&#123;print &quot;dup&quot;NR&quot;dup&quot;,$0&#125;&#39; |sed &quot;s/ /\t/g&quot; &gt;N5_filter_OG_dup.tsv</code></li>
<li>其中<code>awk &#39;&#123;print &quot;dup&quot;NR&quot;dup&quot;,$0&#125;&#39;</code>代表在行首加上<code>dup12dup</code>这列，其中12是行号，目的是为每一行的基因复制事件取一个不重复的ID。</li>
</ul>
<ol start="2">
<li>整理数据</li>
</ol>
<ul>
<li>把N5_filter_OG_dup.tsv整理成基因对格式的文件genepairs.tsv。</li>
<li>genepairs.tsv是tab分隔的文本文件，包含三列，第一列是N5_filter_OG_dup.tsv的第一列，这里是<code>dup12dup</code>形式的基因复制事件的ID；第二列和第三列分别是两个子枝（child branch）中各取一个基因生成的基因对，迭代生成所有可能的基因对。</li>
<li>写了一个python小脚本来实现N5_filter_OG_dup.tsv到genepairs.tsv的转换。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此脚本用于从文本文件中提取指定列的内容，并根据需要迭代生成新格式。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys, math, os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析文件的列内容</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;N5_filter_OG_dup.tsv&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f: <span class="comment">#读取N5_filter_OG_dup.tsv文件</span></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> f.readlines(): <span class="comment">#按行提取</span></span><br><span class="line">        line = l.strip()</span><br><span class="line">        dr = line.split(<span class="string">&quot;\t&quot;</span>)[<span class="number">0</span>] <span class="comment">#提取每行的第一列，写入dr</span></span><br><span class="line">        genes1 = line.split(<span class="string">&quot;\t&quot;</span>)[<span class="number">6</span>] <span class="comment">#提取每行的第七列，写入genes1</span></span><br><span class="line">        genes2 = line.split(<span class="string">&quot;\t&quot;</span>)[<span class="number">7</span>] <span class="comment">#提取每行的第八列，写入genes2</span></span><br><span class="line">        gene_1 = <span class="built_in">list</span>(genes1.split(<span class="string">&quot;,&quot;</span>)) <span class="comment">#提取genes1中的geneID，保存成list格式</span></span><br><span class="line">        gene_2 = <span class="built_in">list</span>(genes2.split(<span class="string">&quot;,&quot;</span>)) <span class="comment">#提取genes2中的geneID，保存成list格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代生成基因对</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gene_1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gene_2)):</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;genepairs.tsv&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> gp:</span><br><span class="line">                    gp.write(dr+<span class="string">&#x27;\t&#x27;</span>+gene_1[i]+<span class="string">&#x27;\t&#x27;</span>+gene_2[j]+<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-3-4-筛除串联重复（tandem-duplications）"><a href="#4-3-4-筛除串联重复（tandem-duplications）" class="headerlink" title="4.3.4. 筛除串联重复（tandem duplications）"></a>4.3.4. 筛除串联重复（tandem duplications）</h3><p>从上面的结果文件genepairs.tsv中筛除鉴定为串联重复产生的基因对，生成genepairs_del_tandem.tsv。（ps：也可以从N5_filter_OG_dup.tsv筛除）</p>
<ol>
<li>串联重复的标准</li>
</ol>
<ul>
<li>取的文章里的标准：在两个子枝（child branch）中的基因在五个基因范围内则被看作是串联重复导致的。</li>
</ul>
<ol start="2">
<li>筛除</li>
</ol>
<ul>
<li>由于我注释基因组的时候，基因ID是根据位置排序产生的，所以这里筛除就直接把genepairs.tsv文件的第二列和第三列的数字相减再取绝对值，如果数字小于等于5的话就把这行删除。另外注意一下染色体首尾的基因就好。</li>
<li>如果是注释基因组时基因ID命名没有规则，就需要自行想办法了。</li>
</ul>
<h3 id="4-3-5-基因复制树和复制的基因对"><a href="#4-3-5-基因复制树和复制的基因对" class="headerlink" title="4.3.5. 基因复制树和复制的基因对"></a>4.3.5. 基因复制树和复制的基因对</h3><p>到这里，就获得了物种A发生特定WGD后保留的基因复制事件（N5_filter_OG_dup.tsv）和相应的基因对（genepairs.tsv或者进行筛除串联重复后的genepairs_del_tandem.tsv）。</p>
<h2 id="4-4-多个WGDs的情况"><a href="#4-4-多个WGDs的情况" class="headerlink" title="4.4. 多个WGDs的情况"></a>4.4. 多个WGDs的情况</h2><p>如果同一个枝（branch）上发生了两次或以上的WGDs事件，通过基因树和物种树无法区分这两次WGDs，此时就需要通过计算基因对的Ks后通过Ks来区分。</p>
<h3 id="4-4-1-计算基因对的Ks"><a href="#4-4-1-计算基因对的Ks" class="headerlink" title="4.4.1. 计算基因对的Ks"></a>4.4.1. 计算基因对的Ks</h3><ol>
<li>文件准备</li>
</ol>
<ul>
<li>此前得到了genepairs.tsv文件（或者进行筛除串联重复后的genepairs_del_tandem.tsv），即有了基因对ID文件。</li>
</ul>
<ol start="2">
<li>运行</li>
</ol>
<ul>
<li>参考博客：<a href="https://yanzhongsino.github.io/2022/09/07/bioinfo_Ks_batch.calculation.Ks/">https://yanzhongsino.github.io/2022/09/07/bioinfo_Ks_batch.calculation.Ks/</a></li>
</ul>
<h3 id="4-4-2-区分两次WGDs"><a href="#4-4-2-区分两次WGDs" class="headerlink" title="4.4.2. 区分两次WGDs"></a>4.4.2. 区分两次WGDs</h3><p>通过两次WGDs的Ks峰值来区分，比如两次WGDs的峰值分别为0.2和0.7，取平均值是0.45，则把Ks大于等于0.45的看作0.7代表的WGD，把Ks小于0.45的看作0.2代表的WGD。</p>
<p>有两种方式区分，一种是把基因复制事件分类到两次WGDs中，一种是把基因对分类到两次WGDs中。我之前用的基因复制事件，但想想用基因对可能更准确。</p>
<ol>
<li>把基因复制事件分类到两次WGDs</li>
</ol>
<ul>
<li>计算得到基因对的Ks后，把每次基因复制事件的所有基因对的Ks取平均值，根据Ks平均值来区分。</li>
</ul>
<ol start="2">
<li>把基因对分类到两次WGDs</li>
</ol>
<ul>
<li>直接根据基因对的Ks来区分。</li>
</ul>
<h2 id="4-5-WGD后保留基因的分析"><a href="#4-5-WGD后保留基因的分析" class="headerlink" title="4.5. WGD后保留基因的分析"></a>4.5. WGD后保留基因的分析</h2><p>得到特定WGD后保留的基因对后，可以用富集分析或其他分析看保留了一些什么基因，是否有进化意义，或者是否与适应、特定的遗传性状等相关。</p>
<h2 id="4-6-WGD后保留TF的分析"><a href="#4-6-WGD后保留TF的分析" class="headerlink" title="4.6. WGD后保留TF的分析"></a>4.6. WGD后保留TF的分析</h2><p>分析WGD后保留的基因中的转录因子（transcription factor，TF）也是一个可考虑的点。<br>除了直接看WGD后保留的基因中包含了什么种类和多少数量的TF外，还可以通过利用转录因子数据库PlantTFDB来做WGD后保留的每种TF的保留模式的进一步分析。</p>
<p>详情可参考博客：<a href="https://yanzhongsino.github.io/2022/10/18/bioinfo_transcriptionFactor/">https://yanzhongsino.github.io/2022/10/18/bioinfo_transcriptionFactor/</a></p>
<h1 id="5-references"><a href="#5-references" class="headerlink" title="5. references"></a>5. references</h1><ol>
<li>paper: <a href="https://www.sciencedirect.com/science/article/pii/S1674205219303594">https://www.sciencedirect.com/science/article/pii/S1674205219303594</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>WGD</category>
      </categories>
      <tags>
        <tag>WGD</tag>
        <tag>gene duplication event</tag>
        <tag>OrthoFinder2</tag>
      </tags>
  </entry>
  <entry>
    <title>批量计算Ka和Ks</title>
    <url>/2022/09/07/bioinfo_Ks_batch.calculation.Ks/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1901371647&auto=1&height=32"></iframe></div>

<h1 id="1-ParaAT"><a href="#1-ParaAT" class="headerlink" title="1. ParaAT"></a>1. ParaAT</h1><p>参考blog.ParaAT：<a href="https://yanzhongsino.github.io/2021/10/29/bioinfo_align_pep2cds/">https://yanzhongsino.github.io/2021/10/29/bioinfo_align_pep2cds/</a></p>
<h1 id="2-KaKs-Calculator-2-0"><a href="#2-KaKs-Calculator-2-0" class="headerlink" title="2. KaKs_Calculator 2.0"></a>2. KaKs_Calculator 2.0</h1><p>KaKs_Calculator 2.0工具包包含了17种计算Ka和Ks的方法，包含Gamma系列，并可识别基于蛋白编码序列的滑动窗口，基于C++和Java，在Windows和Linux平台都可使用。</p>
<h1 id="3-Ka和Ks计算"><a href="#3-Ka和Ks计算" class="headerlink" title="3. Ka和Ks计算"></a>3. Ka和Ks计算</h1><ul>
<li>ParaAT比对指定的基因对的氨基酸序列，并转化成比对的CDS序列，并可指定输出格式，如axt格式。</li>
<li>KaKs_Calculator用于计算比对好的基因对的kaks。</li>
</ul>
<p>用还会用到两个脚本:</p>
<ul>
<li>axt2one-line.py:<a href="https://github.com/scbgfengchao/4DTv/blob/master/axt2one-line.py%E8%BD%AC%E6%8D%A2axt%E6%A0%BC%E5%BC%8F%E4%B8%BA%E5%8D%95%E8%A1%8C">https://github.com/scbgfengchao/4DTv/blob/master/axt2one-line.py转换axt格式为单行</a></li>
<li>calculate_4DTV_correction.pl:<a href="https://github.com/JinfengChen/Scripts/blob/master/FFgenome/03.evolution/distance_kaks_4dtv/bin/calculate_4DTV_correction.pl%E8%AE%A1%E7%AE%974dtv%E3%80%82">https://github.com/JinfengChen/Scripts/blob/master/FFgenome/03.evolution/distance_kaks_4dtv/bin/calculate_4DTV_correction.pl计算4dtv。</a></li>
</ul>
<h1 id="4-软件准备"><a href="#4-软件准备" class="headerlink" title="4. 软件准备"></a>4. 软件准备</h1><ol>
<li>安装ParaAT.pl</li>
</ol>
<ul>
<li>参考blog.ParaAT：<a href="https://yanzhongsino.github.io/2021/10/29/bioinfo_align_pep2cds/">https://yanzhongsino.github.io/2021/10/29/bioinfo_align_pep2cds/</a></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget ftp://download.big.ac.cn/bigd/tools/ParaAT2.0.tar.gz</span><br><span class="line">tar -zxf ParaAT2.0.tar.gz</span><br><span class="line">cd ParaAT2.0</span><br><span class="line">ParaAT.pl -h</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装KaKs_Calculator2.0<br>KaKs_Calculator2.0下载地址：<a href="https://sourceforge.net/projects/kakscalculator2/?source=typ_redirect">https://sourceforge.net/projects/kakscalculator2/?source=typ_redirect</a></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://altushost-swe.dl.sourceforge.net/project/kakscalculator2/KaKs_Calculator2.0.tar.gz</span><br><span class="line">tar -zxf KaKs_Calculator2.0.tar.gz</span><br><span class="line">chmod 777 ./KaKs_Calculator2.0/bin/Linux/KaKs_Calculator</span><br><span class="line">chmod 777 ./KaKs_Calculator2.0/src/AXTConvertor</span><br></pre></td></tr></table></figure>

<ul>
<li>然后把<code>./KaKs_Calculator2.0/bin/Linux/</code>和<code>./KaKs_Calculator2.0/src/</code>添加到环境变量即可使用<code>KaKs_Calculator</code>和<code>AXTConvertor</code>命令。</li>
</ul>
<h1 id="5-文件准备"><a href="#5-文件准备" class="headerlink" title="5. 文件准备"></a>5. 文件准备</h1><p>ParaAT.pl需要三个输入文件，参考blog.ParaAT：<a href="https://yanzhongsino.github.io/2021/10/29/bioinfo_align_pep2cds/">https://yanzhongsino.github.io/2021/10/29/bioinfo_align_pep2cds/</a></p>
<ol>
<li>sample.id</li>
</ol>
<ul>
<li>两列，每行对应两条要做成对比对的序列ID；</li>
<li>任意行，ParaAT可以批量处理多个成对比对。</li>
<li>一个例子：<code>cat sample.collinearity |grep &quot;species_prefix&quot;|cut -f2,3 &gt;sample.id</code> 用MCScanX的结果文件提取blocks的同源gene对，获得sample.id文件。</li>
</ul>
<ol start="2">
<li>cds.fa</li>
</ol>
<ul>
<li>包括所有需要比对的cds序列的文件</li>
</ul>
<ol start="3">
<li>pep.fa</li>
</ol>
<ul>
<li>包括所有需要比对的蛋白序列的文件</li>
</ul>
<h1 id="6-操作步骤"><a href="#6-操作步骤" class="headerlink" title="6. 操作步骤"></a>6. 操作步骤</h1><h2 id="6-1-用ParaAT获取基因对比对序列"><a href="#6-1-用ParaAT获取基因对比对序列" class="headerlink" title="6.1. 用ParaAT获取基因对比对序列"></a>6.1. 用ParaAT获取基因对比对序列</h2><p>ParaAT比对sample.id指定的基因对的氨基酸序列，并转化成比对的CDS序列，并可指定输出为axt格式。</p>
<ol>
<li>命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;24&quot; &gt;proc #指定ParaAT.pl使用线程</span><br><span class="line">ParaAT.pl -g -t -h sample.id -n cds.fa -a pep.fa -m mafft -p proc -f axt -o sample.paraat 2&gt; paraat.log &amp; #用ParaAT.pl调用mafft做每对基因的蛋白比对，并把蛋白比对转化成cds比对，输出axt格式。-g移除比对有gap的密码子，-t移除mismatched codons；-o指定生成目录；</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>notes</li>
</ol>
<ul>
<li>axt格式包括三行，第一行两个序列ID之间用短横杠-相连，第二行第一条序列，第三行第二条序列。</li>
<li>建议加上-g和-t，免得后面计算Ks时报错<code>Error. The size of two sequences in &#39;ctg00816-ctg08844&#39; is not equal。</code></li>
<li>ParaAT.pl命令中加上-k参数可以在获得axt文件后自动调用KaKs_Calculator计算kaks值，使用MA模型，比YN模型慢很多，推荐不加-k参数，而是手动用KaKs_Calculator的YN模型，生成sample.axt_yn.kaks文件。</li>
</ul>
<h2 id="6-2-用KaKs-Calculator计算基因对的Ka、Ks和4dtv值"><a href="#6-2-用KaKs-Calculator计算基因对的Ka、Ks和4dtv值" class="headerlink" title="6.2. 用KaKs_Calculator计算基因对的Ka、Ks和4dtv值"></a>6.2. 用KaKs_Calculator计算基因对的Ka、Ks和4dtv值</h2><p>ParaAT.pl的-k参数只能指定KaKs_Calculator的MA模型计算kaks值，如果需要指定其他的模型，则可以手动运行计算。</p>
<p>KaKs_Calculator可计算比对好的CDS序列的Ka和Ks。</p>
<ol>
<li>计算Ka和Ks</li>
</ol>
<ul>
<li>获得all.kaks文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd sample.paraat # 进入ParaAT.pl生成的文件夹</span><br><span class="line">for i in `ls *axt`;do KaKs_Calculator -i $i -o $&#123;i&#125;_yn.kaks -m YN;done #用YN模型计算每个gene对的KaKs，生成四列数据，gene对，Ka，Ks，Ka/Ks</span><br><span class="line">for i in `ls |grep &quot;_yn.kaks&quot;`;do awk &#x27;NR&gt;1&#123;print $1&quot;\t&quot;$3&quot;\t&quot;$4&quot;\t&quot;$5&#125;&#x27; $i &gt;&gt;../all.kaks;done #合并kaks到all.kaks文件</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>计算4dtv</li>
</ol>
<ul>
<li>获得all.4dtv文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd sample.paraat # 进入ParaAT.pl生成的文件夹</span><br><span class="line">for i in `ls *axt`;do axt2one-line.py $i $&#123;i&#125;.one-line;done #多行axt文件转换成单行</span><br><span class="line">ls |grep &quot;axt.one-line&quot;|while read id;do calculate_4DTV_correction.pl $id &gt; $&#123;id%%one-line&#125;4dtv;done #计算4dtv值，生成两列数据，gene对，4dtv</span><br><span class="line">for i in `ls |grep &quot;4dtv&quot;`;do awk &#x27;NR&gt;1&#123;print $1&quot;\t&quot;$3&#125;&#x27; $i &gt;&gt;../all.4dtv;done #合并4dtv值到all.4dtv</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>合并和整理结果</li>
</ol>
<ul>
<li>获得all.results文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd .. #返回上一级目录</span><br><span class="line">join all.kaks all.4dtv |sed &quot;s/ /\t/g&quot; |awk &#x27;$3 != &quot;NA&quot; &#123;print $0&#125;&#x27; |sed &#x27;1i\genepair\tKa\tKs\tKa/Ks\t4dtv_corrected&#x27; &gt;all.results #以gene对为基准，join合并kaks和4dtv值到一个文件，然后过滤Ks值为NA的无效数据，添加标题行。</span><br><span class="line">rm all.kaks* all.4dtv* #删除中间文件</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="7-references"><a href="#7-references" class="headerlink" title="7. references"></a>7. references</h1><ol>
<li>ParaAT paper：<a href="https://www.sciencedirect.com/science/article/pii/S0006291X12003518">https://www.sciencedirect.com/science/article/pii/S0006291X12003518</a></li>
<li>KaKs_Calculator2.0 github：<a href="https://github.com/kullrich/kakscalculator2">https://github.com/kullrich/kakscalculator2</a></li>
<li>KaKs_Calculator2.0 paper：<a href="https://www.sciencedirect.com/science/article/pii/S1672022910600083?via=ihub">https://www.sciencedirect.com/science/article/pii/S1672022910600083?via%3Dihub</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>Ks</category>
      </categories>
      <tags>
        <tag>Ks</tag>
        <tag>Ka</tag>
        <tag>4dtv</tag>
        <tag>ParaAT</tag>
        <tag>KaKs_Calculator</tag>
      </tags>
  </entry>
  <entry>
    <title>多序列比对(Multiple Sequence Alignment,MSA)</title>
    <url>/2021/09/06/bioinfo_align_MSA/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1697043&auto=1&height=32"></iframe></div>

<p><strong>写在前面</strong>：</p>
<ul>
<li>比对软件的选择：<br>  要是是基因组大数据的序列做比对，优先选择<strong>MAFFT</strong>（快速且兼顾准确）；要是少量序列比对，优先选择<strong>PRANK</strong>（准确）；要是极少数序列比对，哪个方便选哪个，一般<strong>Clustal和MUSCLE</strong>（方便）会整合到许多软件里，会更方便使用。</li>
<li>过滤软件的选择：<br>  目前暂时优先选<strong>trimAl</strong>。</li>
</ul>
<p>update-20211006:今天发现PRANK这个软件比对过后序列的顺序会被打乱，后续处理要小心。</p>
<h1 id="1-序列比对-sequence-alignment"><a href="#1-序列比对-sequence-alignment" class="headerlink" title="1. 序列比对(sequence alignment)"></a>1. 序列比对(sequence alignment)</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1. 概念"></a>1.1. 概念</h2><p>在生物信息学中，序列比对(sequence alignment)是指根据相似性排列DNA,RNA或者protein序列，通过在序列中插入空格(gap)来使得相似的碱基&#x2F;氨基酸在相同列对齐的一种方法。</p>
<h2 id="1-2-方法"><a href="#1-2-方法" class="headerlink" title="1.2. 方法"></a>1.2. 方法</h2><p>比对方法通常包括全局比对(global alignments)和局部比对(local alignments)。</p>
<ol>
<li>全局比对(global alignments)<br>全局比对强制要求比对跨越所有序列的整个长度，尽量对齐每条序列的每个碱基，当序列碱基和长度大致相似时最有用。通常全局比对用Needleman-Wunsch算法，是一种动态规划算法。</li>
<li>局部比对(local alignments)<br>局部比对则确认通常有较大分歧的长序列内的相似性，有更多的计算相似性区域的额外的挑战。通常在较长序列包含相似序列基序的差异较大序列中更有用，常见的是Smith-Waterman算法，也是一种动态规划算法。</li>
<li>混合比对(Hybrid methods)<br>全局和局部比对都使用的方法。</li>
</ol>
<h2 id="1-3-类型"><a href="#1-3-类型" class="headerlink" title="1.3. 类型"></a>1.3. 类型</h2><p>按照序列的数量分为成对比对(pairwise alignment)和多序列比对(multiple sequence alignment)。</p>
<ol>
<li>成对比对(pairwise alignment)</li>
</ol>
<ul>
<li>两条序列的比对。因为计算效率很高，通常不需要高精度方法。</li>
<li>常见的三种方法是点阵法(dot-matrix methods)，动态规划法(dynamic programming)和字节法(word methods)。</li>
</ul>
<ol start="2">
<li>多序列比对(multiple sequence alignment)</li>
</ol>
<ul>
<li>三条及以上序列的比对，是成对比对的扩展，算法上有些差异，以及更复杂。是这篇博客主要讲的内容。</li>
</ul>
<h1 id="2-多序列比对-Multiple-Sequence-Alignment-MSA"><a href="#2-多序列比对-Multiple-Sequence-Alignment-MSA" class="headerlink" title="2. 多序列比对(Multiple Sequence Alignment,MSA)"></a>2. 多序列比对(Multiple Sequence Alignment,MSA)</h1><h2 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1. 概念"></a>2.1. 概念</h2><p>多序列比对(Multiple Sequence Alignment,MSA)是对三个以上的生物学序列（biological sequence），如蛋白质序列、DNA序列或RNA序列所作的序列比对。<br>目的是在不改变序列顺序的前提下，尽可能地把不同序列的相同碱基或者氨基酸排在同一列，并认为同一列的序列在进化上是同源的，有共同的祖先。</p>
<h2 id="2-2-用途"><a href="#2-2-用途" class="headerlink" title="2.2. 用途"></a>2.2. 用途</h2><p>比对之后的序列，可用于进化学研究。比如，比较序列差异来推断序列进化历史（eg. 分化时间）和进化方式(突变&#x2F;插入缺失&#x2F;倒置等)。</p>
<p>常见的应用：</p>
<ul>
<li>构建系统发育树：亲缘关系的分析。</li>
<li>比较基因功能：比较不同物种间的基因功能。</li>
<li>预测蛋白质结构，分类和注释蛋白和ncRNA：通过与已知功能的基因序列的相似性比对，进行基因功能的预测和注释。</li>
<li>序列拼接：通过比对，组装基因组。</li>
<li>突变分析：不同个体基因组间的差异；不同物种基因组间的共线性和结构变异。</li>
<li>检测适应性进化</li>
</ul>
<h2 id="2-3-重要性"><a href="#2-3-重要性" class="headerlink" title="2.3. 重要性"></a>2.3. 重要性</h2><p>多序列比对的准确性与进化分析的准确性息息相关，不同比对软件和过滤软件的结果不同。</p>
<p>Blackburner和Whelan在2013年发表在MBE上的文章《Class of Multiple Sequence Alignment Algorithm Affects Genomic Analysis》对不同的比对算法和软件进行了比较分析，提出多序列比对MSA方法对下游分析至关重要，系统发育树和分支长度的推断高度依赖使用的多序列比对MSA类别，基于相似性的比对软件倾向于识别适应性进化（正选择）。</p>
<p>简单的对齐后过滤不能解决不同MSA方法间的差异。</p>
<h1 id="3-多序列比对-Multiple-Sequence-Alignment-MSA-的算法"><a href="#3-多序列比对-Multiple-Sequence-Alignment-MSA-的算法" class="headerlink" title="3. 多序列比对(Multiple Sequence Alignment,MSA)的算法"></a>3. 多序列比对(Multiple Sequence Alignment,MSA)的算法</h1><p>多序列比对是双序列比对的扩展。</p>
<h2 id="3-1-动态规划算法-dynamic-programming-——-主要用于双序列比对"><a href="#3-1-动态规划算法-dynamic-programming-——-主要用于双序列比对" class="headerlink" title="3.1. 动态规划算法(dynamic programming) —— 主要用于双序列比对"></a>3.1. 动态规划算法(dynamic programming) —— 主要用于双序列比对</h2><p>算法特点：</p>
<ul>
<li>可以给出最优解。</li>
<li>将一个二维的动态规划矩阵扩展到三维或多维，即可用于多序列比对。</li>
<li>比对序列超过3个，需要的存储空间和运算时间都使得比对应用无法实现。<h3 id="3-1-1-基于全局比对的算法：Needleman-Wunsch算法"><a href="#3-1-1-基于全局比对的算法：Needleman-Wunsch算法" class="headerlink" title="3.1.1. 基于全局比对的算法：Needleman-Wunsch算法"></a>3.1.1. 基于全局比对的算法：Needleman-Wunsch算法</h3></li>
</ul>
<ol>
<li><p><strong>全局比对</strong><br> 全局比对是指将参与比对的两条序列里面的所有字符进行比对。全局比对在全局范围内对两条序列进行比对打分，找出最佳比对，主要被用来寻找关系密切的序列。其可以用来鉴别或证明新序列与已知序列家族的同源性，是进行分子进化分析的重要前提。其代表是Needleman-Wunsch算法。</p>
</li>
<li><p>全局比对算法特点：</p>
</li>
</ol>
<ul>
<li>打分矩阵：罚分分值不同，比对结果不同。</li>
<li>计算比对最高得分的算法：常用Needleman-Wunsch算法。</li>
<li>打印出最高得分相应的序列比对结果：根据得分矩阵回溯，找到最高得分结果。</li>
</ul>
<h3 id="3-1-2-基于局部比对的算法：Smith-Waterman算法"><a href="#3-1-2-基于局部比对的算法：Smith-Waterman算法" class="headerlink" title="3.1.2. 基于局部比对的算法：Smith-Waterman算法"></a>3.1.2. 基于局部比对的算法：Smith-Waterman算法</h3><ol>
<li><p><strong>局部比对</strong><br> 与全局比对不同，局部比对不必对两个完整的序列进行比对，而是在每个序列中使用某些局部区域片段进行比对。其产生的需求在于、人们发现有的蛋白序列虽然在序列整体上表现出较大的差异性，但是在某些局部区域能独立的发挥相同的功能，序列相当保守。这时候依靠全局比对明显不能得到这些局部相似序列的。其次，在真核生物的基因中，内含子片段表现出了极大变异性，外显子区域却较为保守，这时候全局比对表现出了其局限性，无法找出这些局部相似性序列。其代表是Smith-Waterman局部比对算法。BLAST是局部比对的一种推广。</p>
</li>
<li><p>Smith-Waterman算法特点</p>
</li>
</ol>
<ul>
<li>是一种用来寻找并比较具有局部相似性区域的动态规划算法，适用于亲缘关系较远，整体上不具有相似性而在一些较小区域存在局部相似性的两条序列。</li>
<li>使用迭代方法计算出每个序列的相似分值，保存在一个得分矩阵M中，然后根据这个得分矩阵，通过动态规划的方法回溯找到最优的比对序列。</li>
</ul>
<h2 id="3-2-启发式搜索算法-heuristic-algorithm-：BWT算法和BLAST算法"><a href="#3-2-启发式搜索算法-heuristic-algorithm-：BWT算法和BLAST算法" class="headerlink" title="3.2. 启发式搜索算法(heuristic algorithm)：BWT算法和BLAST算法"></a>3.2. 启发式搜索算法(heuristic algorithm)：BWT算法和BLAST算法</h2><p>一个基于直观或经验构造的算法，在可接受的花费下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度一般不能被预计；目前绝大多数应用的比对软件都是启发式算法。</p>
<ul>
<li>渐进式算法(progressive methods): Clustal W,MUSCLE,T-Coffee,DiAlign</li>
<li>迭代算法(iterative methods): MUSCLE,PRRP算法</li>
<li>星对比算法</li>
</ul>
<h2 id="3-3-随机算法"><a href="#3-3-随机算法" class="headerlink" title="3.3. 随机算法"></a>3.3. 随机算法</h2><p>对构造好的目标函数进行最优解搜索。</p>
<ul>
<li>遗传算法：借鉴生物界进化规律演化来的全局意义上的自适应随机搜索方法。</li>
<li>模拟退火算法：用一物质系统的退火过程来模拟优化问题的寻优方法，当物质系统达到最小能量状态时，优化问题的目标函数也相应地达到了全局最优解。</li>
<li>粒子群算法</li>
</ul>
<h2 id="3-4-其他算法"><a href="#3-4-其他算法" class="headerlink" title="3.4. 其他算法"></a>3.4. 其他算法</h2><p>还有一些其他不常见的算法</p>
<ol>
<li>分治算法</li>
<li>蚁群算法</li>
</ol>
<h1 id="4-序列选择和比对前处理"><a href="#4-序列选择和比对前处理" class="headerlink" title="4. 序列选择和比对前处理"></a>4. 序列选择和比对前处理</h1><p>一般来说，同源序列、同一家族的序列才会进行比对。</p>
<p><strong>通用的序列选择标准</strong>：</p>
<ul>
<li>如果是编码区序列，优先选蛋白序列。因为蛋白序列短且含有20种氨基酸信息，比DNA的4种核苷酸信息更多。</li>
<li>如果是数据库里选序列，尽量选择有详细注释的，可以在后续分析中提供更多信息。</li>
<li>多序列比对选用10-15条开始比对。如果比对结果不错，再加其他序列比对；如果比对结果不好，对现有序列处理（比如删除，剪辑等）。比对序列数量不是越多越好，多了可能增加比对软件出错概率。</li>
<li>如果有一条序列与半数以上其他序列一致性低于30%，比对会有问题。（一般氨基酸序列一致性在30-70%，E-value在10^-40-10^-5，仅供参考）。</li>
<li>如果有序列间一致性太高的，多序列比对也没什么价值，结果一直不错。</li>
<li>很多比对软件擅长比对总长度类似的序列，对长短不一的序列可以尝试比对前剪辑。</li>
<li>一般的比对软件对有重复片段的多序列比对时会有问题，尤其是序列间重复次数不同时问题更大，需要人工提取这部分手工比对。</li>
</ul>
<h1 id="5-多序列比对软件"><a href="#5-多序列比对软件" class="headerlink" title="5. 多序列比对软件"></a>5. 多序列比对软件</h1><h2 id="5-1-比对软件概况"><a href="#5-1-比对软件概况" class="headerlink" title="5.1. 比对软件概况"></a>5.1. 比对软件概况</h2><ol>
<li>基于相似性的比对(similarity-MSAMs)</li>
</ol>
<ul>
<li>经典渐进式比对(progressive alignment)软件：ClustalW</li>
<li>现代渐进式比对软件：DIALIGN-TX, MUSCLE</li>
<li>一致性比对软件(Consistency methods)：MUMMALS,ProbAlign,ProbCons,MAFFT,T-Coffee。</li>
</ul>
<ol start="2">
<li>基于进化关系的比对</li>
</ol>
<ul>
<li>PRANK</li>
<li>BAli-Phy</li>
<li>StatAlign</li>
</ul>
<ol start="3">
<li>其他</li>
</ol>
<ul>
<li>MACSE</li>
<li>基于隐马尔可夫模型(Profile HMM Methods)的比对：SEPP, TIPP, UPP, HIPPI</li>
</ul>
<h2 id="5-2-基于相似性的比对-similarity-MSAMs"><a href="#5-2-基于相似性的比对-similarity-MSAMs" class="headerlink" title="5.2. 基于相似性的比对(similarity-MSAMs)"></a>5.2. 基于相似性的比对(similarity-MSAMs)</h2><h3 id="5-2-1-Clustal-1994"><a href="#5-2-1-Clustal-1994" class="headerlink" title="5.2.1. Clustal(1994)"></a>5.2.1. Clustal(1994)</h3><p>Clustal版本有X、W系列，目前最新的Omega表现最好。</p>
<p>基于渐进式比对(progressive alignment)，由引导树(guide tree)确定将序列添加到不断增长的MSA中的顺序，此算法通过成对的序列(sequence)-序列，序列-剖面(profile)，剖面-剖面的比对实现。</p>
<ol>
<li>算法流程</li>
</ol>
<ul>
<li>先进行序列两两比对，构建距离矩阵；</li>
<li>基于两两比对距离矩阵，通过计算构建系统进化引导树(guide tree)，对关系密切的序列进行加权；</li>
<li>从关系最近的两条序列开始，逐渐加入关系远的序列并不断重新构建多序列比对，直到所有序列都被加入为止。</li>
</ul>
<ol start="2">
<li>算法特点</li>
</ol>
<ul>
<li>是一种试探算法，渐进式比对算法都不能保证得到最优的比对。</li>
<li>比对准确性高度依赖开始的两两比对，适用于<strong>亲缘关系较近</strong>的序列。</li>
</ul>
<h3 id="5-2-2-MUSCLE-2004"><a href="#5-2-2-MUSCLE-2004" class="headerlink" title="5.2.2. MUSCLE(2004)"></a>5.2.2. MUSCLE(2004)</h3><p>特点：</p>
<ul>
<li>采用迭代方法进行比对运算，每一次最优化过程就是迭代过程，通过不断使用动态规划法重排来纠正错误，同时对这些亚类群进行比对以获得所有序列的全局比对。</li>
<li>相对Clustal，在比对速度和精度上都更优。</li>
<li>相对Clustal，添加了额外的步骤，包括改进起始树(starting tree)，重新选择树的分支和重新对齐任一剖面的改进步骤。</li>
</ul>
<h3 id="5-2-3-MAFFT-2002"><a href="#5-2-3-MAFFT-2002" class="headerlink" title="5.2.3. MAFFT(2002)"></a>5.2.3. MAFFT(2002)</h3><p>特点：</p>
<ul>
<li>基于渐进式比对的算法，用快速傅里叶变换(fast Fourier transform)对序列进行聚类，再实现成对比对(pairwise alignments)；</li>
<li>之后的版本增加了其他算法和操作模式，包括快速、精确模式，非编码RNA序列比对及在现有比对中添加新的序列。</li>
<li>实现了两种算法，累进方法（FFT‐NS‐2）和迭代优化方法（FFT‐NS‐i）</li>
<li>比对精度比MUSCLE高，速度也快。</li>
</ul>
<h3 id="5-2-4-T-Coffee-2000"><a href="#5-2-4-T-Coffee-2000" class="headerlink" title="5.2.4. T-Coffee (2000)"></a>5.2.4. T-Coffee (2000)</h3><p>与MAFFT功能类似，但包括更复杂的成对比对评分函数，MSA必须描述一组一致的成对比对。</p>
<h2 id="5-3-基于进化关系的比对-——-统计比对-statistical-alignment"><a href="#5-3-基于进化关系的比对-——-统计比对-statistical-alignment" class="headerlink" title="5.3. 基于进化关系的比对 —— 统计比对(statistical alignment)"></a>5.3. 基于进化关系的比对 —— 统计比对(statistical alignment)</h2><h3 id="5-3-1-统计比对的特点"><a href="#5-3-1-统计比对的特点" class="headerlink" title="5.3.1. 统计比对的特点"></a>5.3.1. 统计比对的特点</h3><ul>
<li>统计比对(statistical alignment)是在进化学语境下描述序列的变化，能够确定各序列在与其共同祖先分化后发生的插入、替换和删除的过程，在系统发育树上明确建模。</li>
<li>可以根据序列的差异性灵活地使用不同地比对标准（评分矩阵与罚分），基于渐进式的比对无法做到</li>
<li>基于进化关系，准确性优于渐进式比对，但由于计算量大，很少使用在基因组数据上。</li>
</ul>
<h3 id="5-3-2-BAli-Phy-2005"><a href="#5-3-2-BAli-Phy-2005" class="headerlink" title="5.3.2. BAli-Phy(2005)"></a>5.3.2. BAli-Phy(2005)</h3><ul>
<li>贝叶斯后验比对</li>
<li>利用马尔科夫链蒙特卡罗来探索给定分子序列数据的比对和系统发育的联合空间，同时估计消除了对不准确的比对引导树的偏差，在比对过程中采用了更复杂的替换模型，并自动利用共享插入&#x2F;删除中的信息来帮助推断系统发育关系</li>
<li>准确度和PRANK差不多？</li>
</ul>
<h3 id="5-3-3-PRANK-2008"><a href="#5-3-3-PRANK-2008" class="headerlink" title="5.3.3. PRANK(2008)"></a>5.3.3. PRANK(2008)</h3><p>特点：</p>
<ul>
<li>针对DNA,密码子(codon)和氨基酸序列的概率多重比对软件（有密码子和氨基酸模式）；</li>
<li>可以重新构建祖先序列，有DNA翻译(DNA translation)和回译(back-translation)选项；</li>
<li>对完全统计对齐的启发式(heuristic)方法；</li>
<li>准确度高，但非常耗时，不适合基因组数据；</li>
</ul>
<p>p.s.：PRANK比对过后序列顺序会被打乱，与比对前不一致，做后续处理时要小心。</p>
<h3 id="5-3-4-StatAlign-2008"><a href="#5-3-4-StatAlign-2008" class="headerlink" title="5.3.4. StatAlign(2008)"></a>5.3.4. StatAlign(2008)</h3><h2 id="5-4-MACSE"><a href="#5-4-MACSE" class="headerlink" title="5.4. MACSE"></a>5.4. MACSE</h2><p>了解得不多，先摘录在这里。</p>
<ul>
<li>第一个可以用于自动调整含有移码变异以及假基因的蛋白编码序列，而不破坏潜在密码子结构。</li>
<li>在核苷酸水平上对DNA序列进行比对，但有可能包括不是三个碱基倍数的间隙长度（即产生移码），同时基于其氨基酸翻译对产生的核苷酸比对进行评分。</li>
<li>这可以产生保留潜在密码子结构的核苷酸比对，同时受益于氨基酸序列的更高相似性。</li>
<li>已被用于基因组分析中</li>
<li>OrthoMAM v8&#x2F;v10数据库采用这个软件的分析流程</li>
</ul>
<h2 id="5-5-基于隐马尔可夫模型-Profile-HMM-Methods-的比对"><a href="#5-5-基于隐马尔可夫模型-Profile-HMM-Methods-的比对" class="headerlink" title="5.5. 基于隐马尔可夫模型(Profile HMM Methods)的比对"></a>5.5. 基于隐马尔可夫模型(Profile HMM Methods)的比对</h2><h3 id="5-5-1-SEPP-SATe-enabled-Phylogenetic-Placement"><a href="#5-5-1-SEPP-SATe-enabled-Phylogenetic-Placement" class="headerlink" title="5.5.1. SEPP(SATe-enabled Phylogenetic Placement)"></a>5.5.1. SEPP(SATe-enabled Phylogenetic Placement)</h3><p>解决将short reads放进参考序列和树的系统发育问题</p>
<h3 id="5-5-2-TIPP-Taxonomic-Identification-and-Phylogenetic-Profiling"><a href="#5-5-2-TIPP-Taxonomic-Identification-and-Phylogenetic-Profiling" class="headerlink" title="5.5.2. TIPP(Taxonomic Identification and Phylogenetic Profiling)"></a>5.5.2. TIPP(Taxonomic Identification and Phylogenetic Profiling)</h3><p>解决元组数据的分类识别和丰度分析问题</p>
<h3 id="5-5-3-UPP-Ultra-large-alignments-using-Phylogeny-aware-Profiles"><a href="#5-5-3-UPP-Ultra-large-alignments-using-Phylogeny-aware-Profiles" class="headerlink" title="5.5.3. UPP(Ultra-large alignments using Phylogeny-aware Profiles)"></a>5.5.3. UPP(Ultra-large alignments using Phylogeny-aware Profiles)</h3><p>解决非常大的数据集对齐的问题，这些数据集可能包括零碎数据，可以将数据集多达1,000,000条序列对齐；</p>
<h3 id="5-5-4-HIPPI-Highly-Accurate-Protein-Family-Classificatio-with-Ensembles-of-HMMs"><a href="#5-5-4-HIPPI-Highly-Accurate-Protein-Family-Classificatio-with-Ensembles-of-HMMs" class="headerlink" title="5.5.4. HIPPI(Highly Accurate Protein Family Classificatio with Ensembles of HMMs)"></a>5.5.4. HIPPI(Highly Accurate Protein Family Classificatio with Ensembles of HMMs)</h3><p>解决蛋白质家族分类问题</p>
<h1 id="6-Trimming-质量过滤软件"><a href="#6-Trimming-质量过滤软件" class="headerlink" title="6. Trimming - 质量过滤软件"></a>6. Trimming - 质量过滤软件</h1><p>在比对完成后，使用质量过滤软件过滤一些低质量以及高变异度的序列区域，仅保留进化保守的区域用于后续分析。</p>
<h2 id="6-1-产生低质量区域的原因"><a href="#6-1-产生低质量区域的原因" class="headerlink" title="6.1. 产生低质量区域的原因"></a>6.1. 产生低质量区域的原因</h2><ul>
<li>序列特征：远缘物种的序列在一些位置（例如第一个或最后一个外显子）有很大差异，这种真实存在的差异由于受到选择的影响，不适用于推断系统发育树（希望用保守区域推断系统发育关系）。</li>
<li>各种错误：包括测序错误、基因组组装错误、基因预测错误和多序列比对错误等。</li>
</ul>
<h2 id="6-2-多序列比对后过滤软件"><a href="#6-2-多序列比对后过滤软件" class="headerlink" title="6.2. 多序列比对后过滤软件"></a>6.2. 多序列比对后过滤软件</h2><h3 id="6-2-1-常见过滤软件"><a href="#6-2-1-常见过滤软件" class="headerlink" title="6.2.1. 常见过滤软件"></a>6.2.1. 常见过滤软件</h3><ol>
<li><strong>block-filtering</strong>: trimAl,Gblocks</li>
<li><strong>segment filtering</strong>: HmmCleaner,PREQUAL（基于隐马尔可夫模型的算法）</li>
<li><strong>sliding window analysis</strong>: FasParser2</li>
</ol>
<h3 id="6-2-2-Gblocks-2000"><a href="#6-2-2-Gblocks-2000" class="headerlink" title="6.2.2. Gblocks(2000)"></a>6.2.2. Gblocks(2000)</h3><ul>
<li>删除大片段非保守性或非同源性片段（6-10bp的非同源片段识别得不好），还对block(即一段连续不含Gap的列)的长度进行了限制。</li>
<li>不足：武断地规定了某个具体阈值来判断比对片段的保留或删除，对所有基因和所有片段一刀切式的处理，没有考虑不同片段的不同进化速率。</li>
</ul>
<h3 id="6-2-3-trimAl-2009"><a href="#6-2-3-trimAl-2009" class="headerlink" title="6.2.3. trimAl(2009)"></a>6.2.3. trimAl(2009)</h3><ul>
<li>优点：速度快，准确度高。</li>
<li>比起Gblocks，可自动选择每个特定比对中的参数，包括Gap比例和氨基酸相似性水平，从而优化signal-to-noise ratio。</li>
</ul>
<h3 id="6-2-4-HmmCleaner"><a href="#6-2-4-HmmCleaner" class="headerlink" title="6.2.4. HmmCleaner"></a>6.2.4. HmmCleaner</h3><ul>
<li>基于隐马尔可夫模型的新过滤算法。</li>
<li>只能过滤氨基酸序列。</li>
</ul>
<h3 id="6-2-5-PREQUAL"><a href="#6-2-5-PREQUAL" class="headerlink" title="6.2.5. PREQUAL"></a>6.2.5. PREQUAL</h3><ul>
<li>基于隐马尔可夫模型的新过滤算法。</li>
<li>针对非比对的蛋白编码序列及氨基酸序列。</li>
</ul>
<h3 id="6-2-6-FasParser2-2018"><a href="#6-2-6-FasParser2-2018" class="headerlink" title="6.2.6. FasParser2(2018)"></a>6.2.6. FasParser2(2018)</h3><ul>
<li>有图形界面。</li>
<li>包括有效过滤序列比对质量模块（滑窗分析），可实现大规模检测序列中经历正选择的位点并清除。</li>
</ul>
<h1 id="7-references"><a href="#7-references" class="headerlink" title="7. references"></a>7. references</h1><ol>
<li><a href="https://en.wikipedia.org/wiki/Sequence_alignment">https://en.wikipedia.org/wiki/Sequence_alignment</a></li>
<li><a href="https://zh.wikipedia.org/zh-hans/%E5%A4%9A%E9%87%8D%E5%BA%8F%E5%88%97%E6%AF%94%E5%B0%8D">https://zh.wikipedia.org/zh-hans/%E5%A4%9A%E9%87%8D%E5%BA%8F%E5%88%97%E6%AF%94%E5%B0%8D</a></li>
<li><a href="https://academic.oup.com/mbe/article/30/3/642/1038709?login=true">https://academic.oup.com/mbe/article/30/3/642/1038709?login=true</a></li>
<li><a href="https://www.jianshu.com/p/430f21cce4f5">https://www.jianshu.com/p/430f21cce4f5</a></li>
<li><a href="https://www.jianshu.com/p/31fb919f1c91">https://www.jianshu.com/p/31fb919f1c91</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/150579075">https://zhuanlan.zhihu.com/p/150579075</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>align</category>
      </categories>
      <tags>
        <tag>Multiple Sequence Alignment</tag>
        <tag>MSA</tag>
        <tag>sequence alignment</tag>
        <tag>trimming</tag>
        <tag>Clustal</tag>
        <tag>MUSCLE</tag>
        <tag>MAFFT</tag>
        <tag>PRANK</tag>
        <tag>Gblocks</tag>
        <tag>trimAl</tag>
      </tags>
  </entry>
  <entry>
    <title>蛋白质比对转换成CDS比对 —— ParaAT,PAL2NAL</title>
    <url>/2021/10/29/bioinfo_align_pep2cds/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=17059176&auto=1&height=32"></iframe></div>

<h1 id="1-序列比对-sequence-alignment"><a href="#1-序列比对-sequence-alignment" class="headerlink" title="1. 序列比对(sequence alignment)"></a>1. 序列比对(sequence alignment)</h1><p>序列比对的知识可以参考另一篇博文的内容。<br><a href="https://yanzhongsino.github.io/2021/09/06/bioinfo_MSA/">Multiple Sequence Alignment</a></p>
<p>如果序列间差异较大，为了获得更精准的比对，有时我们会先做蛋白质的比对，然后根据蛋白质比对，转化成CDS比对。这篇博客就是记录把蛋白质比对转换成CDS比对的软件和使用。</p>
<h1 id="2-蛋白比对转CDS比对"><a href="#2-蛋白比对转CDS比对" class="headerlink" title="2. 蛋白比对转CDS比对"></a>2. 蛋白比对转CDS比对</h1><h2 id="2-1-成对比对-pairwise-alignment"><a href="#2-1-成对比对-pairwise-alignment" class="headerlink" title="2.1. 成对比对(pairwise alignment)"></a>2.1. 成对比对(pairwise alignment)</h2><h3 id="2-1-1-应用场景"><a href="#2-1-1-应用场景" class="headerlink" title="2.1.1. 应用场景"></a>2.1.1. 应用场景</h3><p>如果是两条序列比对的转化，批量处理，可以用ParaAT脚本。</p>
<p>比如用MCScanX软件做了共线性分析找到物种间的homologs基因对，或者WGD分析找到物种内的paralogs基因对，想要根据蛋白比对做对应的CDS比对。比对之后用于计算Ka和Ks。</p>
<h3 id="2-1-2-成对比对软件"><a href="#2-1-2-成对比对软件" class="headerlink" title="2.1.2. 成对比对软件"></a>2.1.2. 成对比对软件</h3><h4 id="2-1-2-1-ParaAT"><a href="#2-1-2-1-ParaAT" class="headerlink" title="2.1.2.1. ParaAT"></a>2.1.2.1. ParaAT</h4><p>ParaAT是中科院基因组所张章课题组在2012年开发，2014年更新了2.0版本，是一个perl脚本。</p>
<p><a href="https://ngdc.cncb.ac.cn/tools/paraat">ParaAT download</a><br><a href="https://www.sciencedirect.com/science/article/pii/S0006291X12003518">ParaAT paper</a></p>
<h4 id="2-1-2-2-ParaAT下载"><a href="#2-1-2-2-ParaAT下载" class="headerlink" title="2.1.2.2. ParaAT下载"></a>2.1.2.2. ParaAT下载</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget ftp://download.big.ac.cn/bigd/tools/ParaAT2.0.tar.gz</span><br><span class="line">tar -zxf ParaAT2.0.tar.gz</span><br><span class="line">cd ParaAT2.0</span><br><span class="line">ParaAT.pl -h</span><br></pre></td></tr></table></figure>

<p>ParaAT2.0目录下有两个脚本，ParaAT.pl用于成对比对的转换（可以批量处理），目录下还有另一个多序列转换脚本Epal2nal.pl（好像是pal2nal.pl的V13版本）。</p>
<h4 id="2-1-2-3-ParaAT使用"><a href="#2-1-2-3-ParaAT使用" class="headerlink" title="2.1.2.3. ParaAT使用"></a>2.1.2.3. ParaAT使用</h4><ol>
<li>输入文件<br>三个输入文件,sample.id,cds.fa,pep.fa，三个文件的序列id要一致。</li>
</ol>
<ul>
<li>sample.id文件<br>两列，每行对应两条要做成对比对的序列ID，任意行，ParaAT可以批量处理多个成对比对。</li>
</ul>
<p><code>cat sample.collinearity |grep &quot;species_prefix&quot;|cut -f2,3 &gt;sample.id</code> 用MCScanX的结果文件提取blocks的同源gene对，获得sample.id文件。</p>
<ul>
<li>cds.fa<br>包括所有需要比对的cds序列的文件</li>
<li>pep.fa<br>包括所有需要比对的蛋白序列的文件</li>
</ul>
<ol start="2">
<li>运行</li>
</ol>
<ul>
<li><p><code>echo &quot;12&quot; &gt;proc</code><br>指定ParaAT.pl使用线程，也可以不指定，默认是6个线程</p>
</li>
<li><p><code>ParaAT.pl -g -t -h sample.id -n cds.fa -a pep.fa -m mafft -p proc -f axt -o paraat 2&gt;paraat.log</code><br>先根据sample.id指定的id做蛋白的成对比对，然后根据蛋白的比对结果转换成对应的CDS的比对结果。</p>
</li>
</ul>
<p>参数：</p>
<ul>
<li>-h sample.id：指定基因对文件</li>
<li>-n cds.fa：指定CDS序列文件，包含所有sample.id涉及的基因的CDS序列；</li>
<li>-a pep.fa：指定氨基酸序列文件，包含所有sample.id涉及的基因的氨基酸序列；</li>
<li>-m mafft：指定比对软件</li>
<li>-p proc：指定线程</li>
<li>-f axt：指定输出比对的CDS序列的格式（WGD计算KaKs一般用axt格式比较多）</li>
<li>-o paraat：指定输出文件目录(如果不存在会新建目录)。</li>
</ul>
<p>其他参数：</p>
<ul>
<li>-g：移除比对后包含gap的密码子；建议加上-g和-t，免得后面计算Ks时报错Error. The size of two sequences in ‘ctg00816-ctg08844’ is not equal。</li>
<li>-t：移除mismatched codons；建议加上-g和-t，免得后面计算Ks时报错Error. The size of two sequences in ‘ctg00816-ctg08844’ is not equal。</li>
<li>-k：用KaKs_Calculator计算(需要输出axt格式)Ka和Ks，获得axt文件后自动计算kaks值，使用MA模型，比YN模型慢，推荐输出axt后自己用KaKs_Calculator计算并用YN模型。</li>
<li>-c 1：指定编码方式，不同生物的编码方式不同，默认是标准型1。</li>
</ul>
<ol start="3">
<li>报错<br>ERROR: inconsistency between the following pep and nuc seqs</li>
</ol>
<h2 id="2-2-多序列比对-multiple-sequence-alignment"><a href="#2-2-多序列比对-multiple-sequence-alignment" class="headerlink" title="2.2. 多序列比对(multiple sequence alignment)"></a>2.2. 多序列比对(multiple sequence alignment)</h2><h3 id="2-2-1-应用场景"><a href="#2-2-1-应用场景" class="headerlink" title="2.2.1. 应用场景"></a>2.2.1. 应用场景</h3><p>如果是多序列的转化，可以使用PAL2NAL脚本。</p>
<p>比如做了orthofinder2找到多个物种的orthogroups，要对每一组orthogroups进行蛋白比对转换成CDS比对。</p>
<h3 id="2-2-2-多序列比对软件"><a href="#2-2-2-多序列比对软件" class="headerlink" title="2.2.2. 多序列比对软件"></a>2.2.2. 多序列比对软件</h3><h4 id="2-2-2-1-PAL2NAL"><a href="#2-2-2-1-PAL2NAL" class="headerlink" title="2.2.2.1. PAL2NAL"></a>2.2.2.1. PAL2NAL</h4><p><a href="http://www.bork.embl.de/pal2nal/">PAL2NAL介绍</a></p>
<ul>
<li>PAL2NAL可以将蛋白的多序列比对转换成CDS比对，如果输入的是一对序列，还会通过paml的codeml程序自动计算dn和ds。</li>
<li>如果数据量少，可以通过上面的网页进行转换。</li>
</ul>
<h4 id="2-2-2-2-PAL2NAL下载"><a href="#2-2-2-2-PAL2NAL下载" class="headerlink" title="2.2.2.2. PAL2NAL下载"></a>2.2.2.2. PAL2NAL下载</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://www.bork.embl.de/pal2nal/distribution/pal2nal.v14.tar.gz</span><br><span class="line">tar -zxvf pal2nal.v14.tar.gz</span><br><span class="line">pal2nal.pl -h</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-3-PAL2NAL使用"><a href="#2-2-2-3-PAL2NAL使用" class="headerlink" title="2.2.2.3. PAL2NAL使用"></a>2.2.2.3. PAL2NAL使用</h4><p><code>pal2nal.pl -nogap -nomismatch pep.aln nuc.fa -output fasta &gt;nuc.aln</code></p>
<p>需要已经做好比对的蛋白质序列pep.aln和ID一致的cds序列nuc.fa</p>
<p>参数：</p>
<ul>
<li>-output (clustal|paml|fasta|codon) # Output format; default &#x3D; clustal</li>
<li>-nogap  # remove columns with gaps and inframe stop codons</li>
<li>-nomismatch # remove mismatched codons (mismatch between pep and cDNA) from the output</li>
</ul>
<h1 id="3-references"><a href="#3-references" class="headerlink" title="3. references"></a>3. references</h1><ol>
<li><a href="https://en.wikipedia.org/wiki/Sequence_alignment">https://en.wikipedia.org/wiki/Sequence_alignment</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>align</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>tutorial</tag>
        <tag>ParaAT</tag>
        <tag>sequence alignment</tag>
        <tag>protein</tag>
        <tag>CDS</tag>
        <tag>PAL2NAL</tag>
      </tags>
  </entry>
  <entry>
    <title>富集分析：（三）clusterProfiler概述</title>
    <url>/2021/12/13/bioinfo_enrichment_clusterProfiler.intro/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1336867002&auto=1&height=32"></iframe></div>

<p>clusterProfiler相关的博客共有三篇，共同食用，效果更好 :wink: ：</p>
<ul>
<li>博客<a href="https://yanzhongsino.github.io/2021/12/13/bioinfo_enrichment_clusterProfiler.intro/">富集分析：（三）clusterProfiler概述</a></li>
<li>博客<a href="https://yanzhongsino.github.io/2022/04/26/bioinfo_enrichment_clusterProfiler.species/">富集分析：（四） clusterProfiler：不同物种的GO+KEGG富集分析</a></li>
<li>博客<a href="https://yanzhongsino.github.io/2022/04/28/bioinfo_enrichment_clusterProfiler.visualization/">富集分析：（五）clusterProfiler：Visualization</a></li>
</ul>
<h1 id="1-基因富集分析-gene-set-enrichment-analysis-GSEA"><a href="#1-基因富集分析-gene-set-enrichment-analysis-GSEA" class="headerlink" title="1. 基因富集分析(gene set enrichment analysis, GSEA)"></a>1. 基因富集分析(gene set enrichment analysis, GSEA)</h1><p>富集分析概述参考<a href="https://yanzhongsino.github.io/2021/11/12/bioinfo_enrichment_intro/">博客：富集分析：（一）概述</a>。</p>
<h1 id="2-clusterProfiler介绍"><a href="#2-clusterProfiler介绍" class="headerlink" title="2. clusterProfiler介绍"></a>2. clusterProfiler介绍</h1><p>clusterProfiler是一个R包，是一个解释组学数据的通用富集工具许多基因集的功能注释和富集分析，以及富集分析结果的可视化。</p>
<p>2021年07月发布了clusterProfiler 4.0版本。</p>
<img src="https://yulab-smu.top/biomedical-knowledge-mining-book/figures/clusterProfiler-diagram.png" width=100% title="clusterProfiler function and workflow" alt="clusterProfiler function and workflow" align=center/>

<p><strong><p align="center">Figure 1. clusterProfiler function and workflow</strong><br>图片来源： <a href="https://yulab-smu.top/biomedical-knowledge-mining-book/">yulab’s book</a></p></p>
<h1 id="3-clusterProfiler支持的基因集-gene-sets-或基因通路数据库"><a href="#3-clusterProfiler支持的基因集-gene-sets-或基因通路数据库" class="headerlink" title="3. clusterProfiler支持的基因集(gene sets)或基因通路数据库"></a>3. clusterProfiler支持的基因集(gene sets)或基因通路数据库</h1><ol>
<li>Gene Ontology(GO)</li>
<li>Kyoto Encyclopedia of Genes and Genomes(KEGG)</li>
<li>Disease Ontology(DO)</li>
<li>Disease Gene Network(DisGeNET)</li>
<li>Molecular Signatures Database(MSigDb)</li>
<li>wikiPathways<br>… …</li>
</ol>
<h1 id="4-clusterProfiler功能-——-富集分析-enrichment-analysis"><a href="#4-clusterProfiler功能-——-富集分析-enrichment-analysis" class="headerlink" title="4. clusterProfiler功能 —— 富集分析(enrichment analysis)"></a>4. clusterProfiler功能 —— 富集分析(enrichment analysis)</h1><h2 id="4-1-过表达分析-Over-Representation-Analysis-ORA"><a href="#4-1-过表达分析-Over-Representation-Analysis-ORA" class="headerlink" title="4.1. 过表达分析(Over Representation Analysis, ORA)"></a>4.1. 过表达分析(Over Representation Analysis, ORA)</h2><p>过表达分析是用于采用超几何分布检验判断已知的生物功能或过程(例如GO&#x2F;KEGG)在实验产生的基因列表(例如差异表达基因列表: differentially expressed genes, DEGs)中是否过表达(over-represented&#x3D;enriched)的常用方法。</p>
<p>所有基因（或全基因组）作为背景总数N，被注释到已知基因集(例如GO&#x2F;KEGG)某一子集的基因总数是M，差异表达的基因数量是n，差异表达基因中属于M的数量是k。<br>过表达分析就是用统计学的方法判断GO&#x2F;KEGG的每一个子类中是否k&#x2F;n显著高于M&#x2F;N，显著高于就是这个子类过表达。</p>
<p>差异表达基因通常是前期通过比较转录组分析等手段获取的不同转录组间有表达差异的基因列表。</p>
<h2 id="4-2-基因集富集分析-Gene-Set-Enrichment-Analysis-GSEA"><a href="#4-2-基因集富集分析-Gene-Set-Enrichment-Analysis-GSEA" class="headerlink" title="4.2. 基因集富集分析(Gene Set Enrichment Analysis, GSEA)"></a>4.2. 基因集富集分析(Gene Set Enrichment Analysis, GSEA)</h2><p>对于差异很大的基因，可以使用ORA分析，但差异较小的基因也可能具有意义，很多相关表型差异是通过一组基因中微小但一致的变化(small but consistent changes)来表现的。</p>
<p>基因集富集分析汇总一个基因集中每个基因的统计数据，可以检测预先定义的基因集(例如GO&#x2F;KEGG)中所有基因以一种较小但协调的(small but coordinated)方式发生变化的情况。</p>
<p>基因根据表型进行排序，给定先验定义的基因集(例如共享相同GO&#x2F;KEGG类别的基因)，GSEA的目标是确定S的成员是随机分布在排序的基因列表L中，还是主要分布在顶部或者底部。</p>
<h2 id="4-3-leading-edge分析和核心富集基因-Leading-edge-analysis-and-core-enriched-genes"><a href="#4-3-leading-edge分析和核心富集基因-Leading-edge-analysis-and-core-enriched-genes" class="headerlink" title="4.3. leading edge分析和核心富集基因(Leading edge analysis and core enriched genes)"></a>4.3. leading edge分析和核心富集基因(Leading edge analysis and core enriched genes)</h2><p>包（clusterProfiler,DOSE,meshes,ReactomePA）支持Leading edge分析并可以提供GSEA分析中的核心富集基因core enriched genes结果。</p>
<ol>
<li>Leading edge分析可以获取：</li>
</ol>
<ul>
<li>Tags显示对富集分数有贡献的基因的百分比</li>
<li>List显示获得富集分数在列表中的位置</li>
<li>Signal显示富集信号强度</li>
</ul>
<h1 id="5-clusterProfiler安装"><a href="#5-clusterProfiler安装" class="headerlink" title="5. clusterProfiler安装"></a>5. clusterProfiler安装</h1><p>启动R后输入下面命令安装</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="punctuation">(</span><span class="operator">!</span>requireNamespace<span class="punctuation">(</span><span class="string">&quot;BiocManager&quot;</span><span class="punctuation">,</span> quiet <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">    install.packages<span class="punctuation">(</span><span class="string">&quot;BiocManager&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span><span class="string">&quot;clusterProfiler&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h1 id="6-clusterProfiler的GO和KEGG富集分析"><a href="#6-clusterProfiler的GO和KEGG富集分析" class="headerlink" title="6. clusterProfiler的GO和KEGG富集分析"></a>6. clusterProfiler的GO和KEGG富集分析</h1><p>clusterProfiler支持对许多ontology&#x2F;pathway的hypergeometric test和gene set enrichment analyses，包括数据库GO,KEGG,DO,DisGeNET,MSigDb,wikiPathways。</p>
<p>使用支持的数据库时，需要检查分析样本是否在已有物种列表中。不在物种列表的物种数据，以及其他不在数据库列表的数据库，做分析时使用通用的富集分析(Universal enrichment analysis)模块。</p>
<p>分析前，先用命令<code>library(clusterProfiler)</code>载入clusterProfiler包。</p>
<h2 id="6-1-背景数据库选择"><a href="#6-1-背景数据库选择" class="headerlink" title="6.1. 背景数据库选择"></a>6.1. 背景数据库选择</h2><p>参考博客<a href="https://yanzhongsino.github.io/2022/04/26/bioinfo_GSEA_clusterProfiler.species/">基因富集分析(gene set enrichment analysis, GSEA) —— clusterProfiler：不同物种的GO+KEGG富集分析</a>。</p>
<h2 id="6-2-GO富集分析"><a href="#6-2-GO富集分析" class="headerlink" title="6.2. GO富集分析"></a>6.2. GO富集分析</h2><h3 id="6-2-1-GO的ORA分析"><a href="#6-2-1-GO的ORA分析" class="headerlink" title="6.2.1. GO的ORA分析"></a>6.2.1. GO的ORA分析</h3><h4 id="6-2-1-1-输入文件"><a href="#6-2-1-1-输入文件" class="headerlink" title="6.2.1.1. 输入文件"></a>6.2.1.1. 输入文件</h4><p>ORA分析的输入文件是gene ID list，比如差异表达分析(DESeq2)获得的差异表达基因列表，保存为内容为一列数据的文本文件gene.list，数据内容可以是OrgDb支持的任意ID类型（常用的都支持，ENSEMBL，ENTREZID，GENETYPE，GO，PFAM），具体参考<a href="http://yulab-smu.top/biomedical-knowledge-mining-book/useful-utilities.html#id-convert">ID</a>。<br>分析的是列表中基因在GO&#x2F;KEGG各个子分类单元是否被过度代表还是代表不足。</p>
<h4 id="6-2-1-2-bitr格式转换"><a href="#6-2-1-2-bitr格式转换" class="headerlink" title="6.2.1.2. bitr格式转换"></a>6.2.1.2. bitr格式转换</h4><p>如果需要，也可以用bitr功能函数实现各种ID格式的转换。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;gene.list&quot;</span><span class="punctuation">,</span>header<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span> <span class="comment">#单列基因名文件</span></span><br><span class="line">data<span class="operator">$</span>V1 <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>data<span class="operator">$</span>V1<span class="punctuation">)</span> <span class="comment">#需要character格式，然后进行ID转化</span></span><br><span class="line">test <span class="operator">=</span> bitr<span class="punctuation">(</span>data<span class="operator">$</span>V1<span class="punctuation">,</span> fromType<span class="operator">=</span><span class="string">&quot;SYMBOL&quot;</span><span class="punctuation">,</span> toType<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;ENSEMBL&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ENTREZID&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> OrgDb<span class="operator">=</span> org.At.tair.db<span class="punctuation">)</span> <span class="comment">#将SYMBOL格式转为ENSEMBL和ENTERZID格式 </span></span><br><span class="line">head<span class="punctuation">(</span>test<span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">    SYMBOL         ENSEMBL ENTREZID</span><br><span class="line"><span class="number">1</span>    AASDH ENSG00000157426   <span class="number">132949</span></span><br><span class="line"><span class="number">2</span>   ABCB11 ENSG00000073734     <span class="number">8647</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-1-3-GO分类"><a href="#6-2-1-3-GO分类" class="headerlink" title="6.2.1.3. GO分类"></a>6.2.1.3. GO分类</h4><p>groupGO()函数可以基于GO在指定水平范围内的分布进行基因分类。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;gene.list&quot;</span><span class="punctuation">,</span>header<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#读取gene ID list，内容为一列ENSEMBL格式的基因ID名称</span></span><br><span class="line">genes <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>data<span class="operator">$</span>V1<span class="punctuation">)</span> <span class="comment">#转换成字符格式</span></span><br><span class="line">ggo <span class="operator">&lt;-</span> groupGO<span class="punctuation">(</span>gene <span class="operator">=</span> genes<span class="punctuation">,</span> OrgDb <span class="operator">=</span> org.Hs.eg.db<span class="punctuation">,</span> ont <span class="operator">=</span> <span class="string">&quot;CC&quot;</span><span class="punctuation">,</span> level <span class="operator">=</span> <span class="number">3</span><span class="punctuation">,</span> readable <span class="operator">=</span> TURE<span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>ggo<span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">                   ID       Description Count GeneRatio geneID</span><br><span class="line">GO<span class="operator">:</span><span class="number">0000003</span> GO<span class="operator">:</span><span class="number">0000003</span>      reproduction     <span class="number">0</span>     <span class="number">0</span><span class="operator">/</span><span class="number">929</span>       </span><br><span class="line">GO<span class="operator">:</span><span class="number">0008152</span> GO<span class="operator">:</span><span class="number">0008152</span> metabolic process     <span class="number">0</span>     <span class="number">0</span><span class="operator">/</span><span class="number">929</span>       </span><br><span class="line">GO<span class="operator">:</span><span class="number">0001906</span> GO<span class="operator">:</span><span class="number">0001906</span>      cell killing     <span class="number">0</span>     <span class="number">0</span><span class="operator">/</span><span class="number">929</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-1-4-ORA分析"><a href="#6-2-1-4-ORA分析" class="headerlink" title="6.2.1.4. ORA分析"></a>6.2.1.4. ORA分析</h4><ol>
<li>读取输入文件</li>
</ol>
<ul>
<li>读取基因ID的list文件</li>
<li>这些ID会在enrichGO的分析中被自动去重，所以文件是否有重复结果都一样。</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;gene.list&quot;</span><span class="punctuation">,</span>header<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#读取gene ID list，内容为一列ENSEMBL格式的基因ID名称</span></span><br><span class="line">genes <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>data<span class="operator">$</span>V1<span class="punctuation">)</span> <span class="comment">#转换成字符格式</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>支持物种的标准分析 enrichGO()</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ego <span class="operator">&lt;-</span> enrichGO<span class="punctuation">(</span>gene          <span class="operator">=</span> genes<span class="punctuation">,</span> <span class="comment"># list of entrez gene id</span></span><br><span class="line">                OrgDb         <span class="operator">=</span> org.At.tair.db<span class="punctuation">,</span> <span class="comment"># 背景使用分析物种的org包，这里示例使用拟南芥的数据库</span></span><br><span class="line">                keyType       <span class="operator">=</span> <span class="string">&#x27;ENSEMBL&#x27;</span><span class="punctuation">,</span> <span class="comment"># 输入基因的类型，命令keytypes(org.Hs.eg.db)会列出可用的所有类型；</span></span><br><span class="line">                ont           <span class="operator">=</span> <span class="string">&quot;BP&quot;</span><span class="punctuation">,</span> <span class="comment"># &quot;BP&quot;, &quot;MF&quot;, &quot;CC&quot;, &quot;ALL&quot;。GO三个子类。如果选ALL，会同时获得三个子类的结果(相当于单独做三个子类的结果合并在一起)，结果中增加一列ONTOLOGY为子类。</span></span><br><span class="line">                pAdjustMethod <span class="operator">=</span> <span class="string">&quot;BH&quot;</span><span class="punctuation">,</span> <span class="comment"># 指定多重假设检验矫正的方法，选项包含 &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;</span></span><br><span class="line">                pvalueCutoff  <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span> <span class="comment"># 富集分析的pvalue，默认是pvalueCutoff = 0.05，更严格可选择0.01</span></span><br><span class="line">                qvalueCutoff  <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="comment"># 富集分析显著性的qvalue，默认是qvalueCutoff = 0.2，更严格可选择0.05</span></span><br><span class="line">                readable      <span class="operator">=</span> <span class="literal">TRUE</span> <span class="punctuation">)</span> <span class="comment"># 是否将gene ID转换到 gene symbol</span></span><br><span class="line">head<span class="punctuation">(</span>ego<span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">     ONTOLOGY         ID                                                Description</span><br><span class="line">GO<span class="operator">:</span><span class="number">0002887</span>       BP GO<span class="operator">:</span><span class="number">0002887</span> negative regulation of myeloid leukocyte mediated immunity</span><br><span class="line">GO<span class="operator">:</span><span class="number">0033004</span>       BP GO<span class="operator">:</span><span class="number">0033004</span>                negative regulation of mast cell activation</span><br><span class="line">           GeneRatio  BgRatio      pvalue  p.adjust    qvalue                   geneID Count</span><br><span class="line">GO<span class="operator">:</span><span class="number">0002887</span>     <span class="number">2</span><span class="operator">/</span><span class="number">121</span> <span class="number">10</span><span class="operator">/</span><span class="number">11461</span> <span class="number">0.004706555</span> <span class="number">0.7796682</span> <span class="number">0.7796682</span>              CD300A<span class="operator">/</span>CD84     <span class="number">2</span></span><br><span class="line">GO<span class="operator">:</span><span class="number">0033004</span>     <span class="number">2</span><span class="operator">/</span><span class="number">121</span> <span class="number">10</span><span class="operator">/</span><span class="number">11461</span> <span class="number">0.004706555</span> <span class="number">0.7796682</span> <span class="number">0.7796682</span>              CD300A<span class="operator">/</span>CD84     <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>提供注释文件go_annotation.txt的非模式物种分析 enricher()</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">go_anno <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;go_annotation.txt&quot;</span><span class="punctuation">,</span>header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span>sep <span class="operator">=</span> <span class="string">&quot;\t&quot;</span><span class="punctuation">)</span></span><br><span class="line">go2gene <span class="operator">&lt;-</span> go_anno<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">go2name <span class="operator">&lt;-</span> go_anno<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">ego <span class="operator">&lt;-</span> enricher<span class="punctuation">(</span>genes<span class="punctuation">,</span> TERM2GENE <span class="operator">=</span> go2gene<span class="punctuation">,</span> TERM2NAME <span class="operator">=</span> go2name<span class="punctuation">,</span> pAdjustMethod <span class="operator">=</span> <span class="string">&quot;BH&quot;</span><span class="punctuation">,</span>pvalueCutoff  <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span> qvalueCutoff  <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>ego结果文件解释</p>
</li>
</ol>
<ul>
<li>ONTOLOGY：CC  BP  MF </li>
<li>ID: Gene Ontology数据库中唯一的标号信息</li>
<li>Description ：Gene Ontology功能的描述信息</li>
<li>GeneRatio：差异基因中与该Term相关的基因数与整个差异基因总数的比值</li>
<li>BgRatio：所有（ bg）基因中与该Term相关的基因数与所有（ bg）基因的比值</li>
<li>pvalue: 富集分析统计学显著水平，一般情况下， P-value &lt; 0.05 该功能为富集项</li>
<li>p.adjust 矫正后的P-Value</li>
<li>qvalue：对p值进行统计学检验的q值</li>
<li>geneID：与该Term相关的基因</li>
<li>Count：与该Term相关的基因数</li>
</ul>
<ol start="5">
<li>输出结果保存为csv表格<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">write.table<span class="punctuation">(</span>as.data.frame<span class="punctuation">(</span>ego<span class="punctuation">)</span><span class="punctuation">,</span><span class="string">&quot;go_enrich.csv&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span>row.names <span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span><span class="built_in">quote</span><span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#保存到文件go_enrich.csv。其中as.data.frame(ego)把ego对象转换成数据框dataframe</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="6-2-1-5-结果整理和筛选"><a href="#6-2-1-5-结果整理和筛选" class="headerlink" title="6.2.1.5. 结果整理和筛选"></a>6.2.1.5. 结果整理和筛选</h4><ol>
<li>如果没使用keyType参数，可以在得到结果后使用</li>
<li>如果没使用readable&#x3D;True参数，可以在得到结果后用函数setReadable()将GeneID转换为symbol。<code>ego &lt;- setReadable(ego, OrgDb = org.At.tair.db)</code></li>
<li>函数dropGO可以移除enrichGO结果中特定的GO term或GO level</li>
<li>函数gofilter()可以将结果限定在特定的GO level</li>
<li>函数simplify可以去除冗余，<code>ego_rm &lt;- simplify(ego, cutoff=0.7, by=&quot;p.adjust&quot;, select_fun=min)</code></li>
</ol>
<h3 id="6-2-2-GO的GSEA分析"><a href="#6-2-2-GO的GSEA分析" class="headerlink" title="6.2.2. GO的GSEA分析"></a>6.2.2. GO的GSEA分析</h3><p>GSEA分析通过置换检验来计算p值</p>
<h4 id="6-2-2-1-GSEA的输入文件"><a href="#6-2-2-1-GSEA的输入文件" class="headerlink" title="6.2.2.1. GSEA的输入文件"></a>6.2.2.1. GSEA的输入文件</h4><ol>
<li>GSEA分析的输入文件是一个基因排序列表，有三个要点：</li>
</ol>
<ul>
<li>numeric vector：倍数变化或者其他类型的数字变量，比如差异表达分析里的logFC值</li>
<li>named vector：每个数字对应的gene ID命名</li>
<li>sorted vector；数字应该以降序排序<br>即包含两列，一列基因ID名称，一列数据，并以数据降序排序。</li>
</ul>
<ol start="2">
<li>获取输入文件的示例：</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">d <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span>your_csv_file<span class="punctuation">)</span></span><br><span class="line"><span class="comment">## assume that 1st column is ID (no duplicated allowed)</span></span><br><span class="line"><span class="comment">## 2nd column is fold change</span></span><br><span class="line"><span class="comment">## feature 1: numeric vector</span></span><br><span class="line">geneList <span class="operator">&lt;-</span> d<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">## feature 2: named vector</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>geneList<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>d<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">## feature 3: decreasing order</span></span><br><span class="line">geneList <span class="operator">&lt;-</span> sort<span class="punctuation">(</span>geneList<span class="punctuation">,</span> decreasing <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> head<span class="punctuation">(</span>mydata<span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">  gene_name     female     male    logFC</span><br><span class="line"><span class="number">1</span>   CG32548 <span class="number">0.02310383</span> <span class="number">72.43205</span> <span class="number">11.61428</span></span><br><span class="line"><span class="number">2</span>   CG15892 <span class="number">0.02624160</span> <span class="number">57.22716</span> <span class="number">11.09063</span></span><br><span class="line"><span class="number">3</span>   CR43803 <span class="number">0.02474626</span> <span class="number">34.09726</span> <span class="number">10.42823</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="comment">#GSEA的基因排序列表</span></span><br><span class="line"><span class="operator">&gt;</span> genelist <span class="operator">&lt;-</span> mydata<span class="operator">$</span>logFC <span class="comment">#numeric vector</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">names</span><span class="punctuation">(</span>genelist<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>mydata<span class="operator">$</span>gene_name<span class="punctuation">)</span> <span class="comment">#named vector</span></span><br><span class="line"><span class="operator">&gt;</span> genelist <span class="operator">&lt;-</span> sort<span class="punctuation">(</span>genelist<span class="punctuation">,</span>decreasing<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span> <span class="comment">#decreasing order</span></span><br><span class="line"><span class="operator">&gt;</span> head<span class="punctuation">(</span>genelist<span class="punctuation">)</span></span><br><span class="line"> CG32548  CG15892  CR43803  CG15136   CG4983  CG13989 </span><br><span class="line"><span class="number">11.61428</span> <span class="number">11.09063</span> <span class="number">10.42823</span> <span class="number">10.34305</span> <span class="number">10.29130</span> <span class="number">10.00569</span></span><br></pre></td></tr></table></figure>

<h4 id="6-2-2-2-GSEA分析"><a href="#6-2-2-2-GSEA分析" class="headerlink" title="6.2.2.2. GSEA分析"></a>6.2.2.2. GSEA分析</h4><ol>
<li><p>读取输入文件</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span><span class="string">&quot;geneList.csv&quot;</span><span class="punctuation">)</span></span><br><span class="line">geneList <span class="operator">&lt;-</span> d<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>geneList<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>d<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">geneList <span class="operator">&lt;-</span> sort<span class="punctuation">(</span>geneList<span class="punctuation">,</span> decreasing <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>支持物种的标准分析 gseGO()</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">gsego <span class="operator">&lt;-</span> gseGO<span class="punctuation">(</span>geneList     <span class="operator">=</span> geneList<span class="punctuation">,</span></span><br><span class="line">              OrgDb        <span class="operator">=</span> org.At.tair.db<span class="punctuation">,</span></span><br><span class="line">              ont           <span class="operator">=</span> <span class="string">&quot;BP&quot;</span><span class="punctuation">,</span> <span class="comment"># &quot;BP&quot;, &quot;MF&quot;, &quot;CC&quot;, &quot;ALL&quot;。GO三个子类。如果选ALL，会同时获得三个子类的结果(相当于单独做三个子类的结果合并在一起)，结果中增加一列ONTOLOGY为子类。</span></span><br><span class="line">              keyType      <span class="operator">=</span> <span class="string">&quot;SYMBOL&quot;</span><span class="punctuation">,</span>  <span class="comment"># 输入基因的类型，命令keytypes(org.Hs.eg.db)会列出可用的所有类型；</span></span><br><span class="line">              nPerm        <span class="operator">=</span> <span class="number">1000</span><span class="punctuation">,</span> <span class="comment"># permutation numbers 置换次数</span></span><br><span class="line">              minGSSize    <span class="operator">=</span> <span class="number">100</span><span class="punctuation">,</span> <span class="comment"># 富集基因数量的下限</span></span><br><span class="line">              maxGSSize    <span class="operator">=</span> <span class="number">500</span><span class="punctuation">,</span> <span class="comment"># 富集基因数量的上限</span></span><br><span class="line">              pvalueCutoff <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span></span><br><span class="line">              verbose      <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> <span class="comment"># 不输出结果</span></span><br><span class="line">              by           <span class="operator">=</span> <span class="string">&quot;fgsea&quot;</span><span class="punctuation">)</span> <span class="comment"># 选项fgsea或DOSE</span></span><br><span class="line"></span><br><span class="line">head<span class="punctuation">(</span>gsego<span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span>;<span class="built_in">dim</span><span class="punctuation">(</span>gsego<span class="punctuation">)</span></span><br><span class="line">                   ID        Description setSize enrichmentScore</span><br><span class="line">GO<span class="operator">:</span><span class="number">0003674</span> GO<span class="operator">:</span><span class="number">0003674</span> molecular_function     <span class="number">323</span>       <span class="number">0.9462411</span></span><br><span class="line">                NES      pvalue    p.adjust qvalues rank</span><br><span class="line">GO<span class="operator">:</span><span class="number">0003674</span> <span class="number">1.716837</span> <span class="number">0.000999001</span> <span class="number">0.000999001</span>      <span class="literal">NA</span>  <span class="number">579</span></span><br><span class="line">                              leading_edge</span><br><span class="line">GO<span class="operator">:</span><span class="number">0003674</span> tags<span class="operator">=</span><span class="number">100</span><span class="operator">%, list=11%</span><span class="punctuation">,</span> signal<span class="operator">=</span><span class="number">95</span>%</span><br><span class="line">core_enrichment</span><br><span class="line">GO<span class="operator">:</span><span class="number">0003674</span> CG15892<span class="operator">/</span>CG15136<span class="operator">/</span>CG4983<span class="operator">/</span>CG43851<span class="operator">/</span>…</span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="number">53</span> <span class="number">11</span></span><br><span class="line"></span><br><span class="line">head<span class="punctuation">(</span>data.frame<span class="punctuation">(</span>gsego<span class="operator">$</span>ID<span class="punctuation">,</span>gsego<span class="operator">$</span>Description<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">   gsego.ID gsego.Description</span><br><span class="line"><span class="number">1</span> GO<span class="operator">:</span><span class="number">0003674</span> molecular_function</span><br><span class="line"><span class="number">2</span> GO<span class="operator">:</span><span class="number">0005488</span>            binding</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供注释文件go_annotation.txt的非模式物种分析 GSEA()</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;go_annotation.txt&quot;</span><span class="punctuation">,</span>header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span>sep <span class="operator">=</span> <span class="string">&quot;\t&quot;</span><span class="punctuation">,</span><span class="built_in">quote</span><span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">go2gene <span class="operator">&lt;-</span> data<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">go2name <span class="operator">&lt;-</span> data<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">gsego <span class="operator">&lt;-</span> GSEA<span class="punctuation">(</span>genes<span class="punctuation">,</span> TERM2GENE <span class="operator">=</span> go2gene<span class="punctuation">,</span> TERM2NAME <span class="operator">=</span> go2name<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>gsego结果文件解释</p>
</li>
</ol>
<ul>
<li>ID: Gene Ontology数据库中唯一的标号信息</li>
<li>Description：Gene Ontology功能的描述信息</li>
<li>setSize</li>
<li>enrichmentScore：富集分数</li>
<li>NES</li>
<li>pvalue: 富集分析统计学显著水平，一般情况下， P-value &lt; 0.05 该功能为富集项</li>
<li>p.adjust：矫正后的P-Value</li>
<li>qvalues：对p值进行统计学检验的q值</li>
<li>rank</li>
<li>leading_edge</li>
<li>core_enrichment</li>
</ul>
<h3 id="6-2-3-GO富集结果可视化"><a href="#6-2-3-GO富集结果可视化" class="headerlink" title="6.2.3. GO富集结果可视化"></a>6.2.3. GO富集结果可视化</h3><p><code>goplot(ego)</code>简单可视化结果为有向无环图。</p>
<h2 id="6-3-KEGG富集分析"><a href="#6-3-KEGG富集分析" class="headerlink" title="6.3. KEGG富集分析"></a>6.3. KEGG富集分析</h2><p>clusterProfiler通过<a href="https://www.kegg.jp/kegg/rest/keggapi.html">KEGG数据库的API</a>来获取KEGG的注释信息，包括一个物种所有基因对应的pathway注释文件，比如人的：<a href="http://rest.kegg.jp/link/hsa/pathway%EF%BC%9B%E5%92%8Cpathway%E5%AF%B9%E5%BA%94%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF%EF%BC%8C%E6%AF%94%E5%A6%82%E4%BA%BA%E7%9A%84%EF%BC%9Ahttp://rest.kegg.jp/list/pathway/hsa%E3%80%82">http://rest.kegg.jp/link/hsa/pathway；和pathway对应的描述信息，比如人的：http://rest.kegg.jp/list/pathway/hsa。</a></p>
<h3 id="6-3-1-支持的物种"><a href="#6-3-1-支持的物种" class="headerlink" title="6.3.1. 支持的物种"></a>6.3.1. 支持的物种</h3><ol>
<li>clusterProfiler包支持的物种<br>只需要将物种缩写输入给clusterProfiler，clusterProfiler包支持自动联网调取<a href="https://www.genome.jp/kegg/catalog/org_list.html">kegg注释物种</a>列出物种的pathway注释信息，网站可以查看物种列表和缩写，或者用clusterProfiler包提供search_kegg_organism()函数来帮助搜索支持的生物。</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">search_kegg_organism<span class="punctuation">(</span><span class="string">&#x27;osa&#x27;</span><span class="punctuation">,</span> by<span class="operator">=</span><span class="string">&#x27;kegg_code&#x27;</span><span class="punctuation">)</span> <span class="comment">#查询kegg_code为osa的记录，水稻</span></span><br><span class="line">search_kegg_organism<span class="punctuation">(</span><span class="string">&#x27;Escherichia coli&#x27;</span><span class="punctuation">,</span> by<span class="operator">=</span><span class="string">&#x27;scientific_name&#x27;</span><span class="punctuation">)</span> <span class="comment">#查询学名为Escherichia coli的记录</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用户提供KEGG pathway注释数据<br>如果分析的物种不支持自动调取，可以自己做KEGG pathway注释后提供注释文件，比如interproscan、eggnog-mapper等软件的注释结果，整理成clusterProfiler支持的输入格式即可。</li>
</ol>
<p>clusterProfiler需要导入的KEGG pathway注释文件pathway_annotation.txt的格式如下：</p>
<table>
<thead>
<tr>
<th>GeneID</th>
<th>Pathway</th>
<th>Path_Description</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>ko:00001</td>
<td>spindle</td>
</tr>
<tr>
<td>2</td>
<td>ko:00002</td>
<td>mitotic spindle</td>
</tr>
<tr>
<td>3</td>
<td>ko:00003</td>
<td>kinetochore</td>
</tr>
</tbody></table>
<p>data.frame格式，包含三列，第一列为Gene ID，第二列为 KEGG Pathway ID，第三列为Path_Description，顺序无要求。</p>
<h3 id="6-3-2-KEGG-pathway的ORA分析"><a href="#6-3-2-KEGG-pathway的ORA分析" class="headerlink" title="6.3.2. KEGG pathway的ORA分析"></a>6.3.2. KEGG pathway的ORA分析</h3><h4 id="6-3-2-1-KEGG输入ID的格式转换"><a href="#6-3-2-1-KEGG输入ID的格式转换" class="headerlink" title="6.3.2.1. KEGG输入ID的格式转换"></a>6.3.2.1. KEGG输入ID的格式转换</h4><p>ID转换函数</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>clusterProfiler<span class="punctuation">)</span></span><br><span class="line">bitr_kegg<span class="punctuation">(</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span>fromType <span class="operator">=</span> <span class="string">&quot;kegg&quot;</span><span class="punctuation">,</span>toType <span class="operator">=</span> <span class="string">&#x27;ncbi-proteinid&#x27;</span><span class="punctuation">,</span>organism<span class="operator">=</span><span class="string">&#x27;hsa&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">library<span class="punctuation">(</span>org.Hs.eg.db<span class="punctuation">)</span></span><br><span class="line">keytypes<span class="punctuation">(</span>org.Hs.eg.db<span class="punctuation">)</span> <span class="comment">#查看支持的ID类型</span></span><br><span class="line">bitr<span class="punctuation">(</span>gene<span class="punctuation">,</span> fromType <span class="operator">=</span> <span class="string">&quot;ENTREZID&quot;</span><span class="punctuation">,</span> toType <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;ENSEMBL&quot;</span><span class="punctuation">,</span> <span class="string">&quot;SYMBOL&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> OrgDb <span class="operator">=</span> org.Hs.eg.db<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以上看出ID转换输入时，可以向量的形式，也可以单列基因名list导入</span></span><br><span class="line">gene <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;AASDH&quot;</span><span class="punctuation">,</span><span class="string">&quot;ABCB11&quot;</span><span class="punctuation">,</span><span class="string">&quot;ADAM12&quot;</span><span class="punctuation">,</span><span class="string">&quot;ADAMTS16&quot;</span><span class="punctuation">,</span><span class="string">&quot;ADAMTS18&quot;</span><span class="punctuation">)</span></span><br><span class="line">genes  <span class="operator">&lt;-</span>  gene<span class="operator">$</span>V1 <span class="comment">#字符串</span></span><br><span class="line"><span class="comment">#也可以是内置数据</span></span><br><span class="line">data<span class="punctuation">(</span>geneList<span class="punctuation">,</span> package<span class="operator">=</span><span class="string">&quot;DOSE&quot;</span><span class="punctuation">)</span> <span class="comment">#富集分析的背景基因集</span></span><br><span class="line">genes <span class="operator">&lt;-</span> <span class="built_in">names</span><span class="punctuation">(</span>geneList<span class="punctuation">)</span><span class="punctuation">[</span><span class="built_in">abs</span><span class="punctuation">(</span>geneList<span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">2</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h4 id="6-3-2-2-KEGG-pathway的ORA分析"><a href="#6-3-2-2-KEGG-pathway的ORA分析" class="headerlink" title="6.3.2.2. KEGG pathway的ORA分析"></a>6.3.2.2. KEGG pathway的ORA分析</h4><p>输入文件与GO的ORA分析输入文件一样。</p>
<ol>
<li>导入输入文件</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;gene.list&quot;</span><span class="punctuation">,</span>header<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#读取gene ID list，内容为一列ENSEMBL格式的基因ID名称</span></span><br><span class="line">genes <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>data<span class="operator">$</span>V1<span class="punctuation">)</span> <span class="comment">#转换成字符格式</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>支持物种的标准分析 enrichKEGG()</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">kk <span class="operator">&lt;-</span> enrichKEGG<span class="punctuation">(</span>gene         <span class="operator">=</span> genes<span class="punctuation">,</span></span><br><span class="line">                 keyType      <span class="operator">=</span> <span class="string">&quot;kegg&quot;</span><span class="punctuation">,</span> <span class="comment"># 输入基因的类型，命令keytypes(org.Hs.eg.db)会列出可用的所有类型；</span></span><br><span class="line">                 organism     <span class="operator">=</span> <span class="string">&#x27;hsa&#x27;</span><span class="punctuation">,</span></span><br><span class="line">                 pvalueCutoff <span class="operator">=</span> <span class="number">0.05</span></span><br><span class="line">                 pAdjustMethod<span class="operator">=</span> <span class="string">&quot;BH&quot;</span><span class="punctuation">,</span></span><br><span class="line">                 qvalueCutoff <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>kk<span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">              ID                                      Description GeneRatio  BgRatio</span><br><span class="line">hsa04750 hsa04750 Inflammatory mediator regulation of TRP channels      <span class="number">5</span><span class="operator">/</span><span class="number">53</span>  <span class="number">97</span><span class="operator">/</span><span class="number">7387</span></span><br><span class="line">hsa04020 hsa04020                        Calcium signaling pathway      <span class="number">6</span><span class="operator">/</span><span class="number">53</span> <span class="number">182</span><span class="operator">/</span><span class="number">7387</span></span><br><span class="line">               pvalue   p.adjust    qvalue                              geneID Count</span><br><span class="line">hsa04750 <span class="number">0.0006135305</span> <span class="number">0.08589427</span> <span class="number">0.0807277</span>             <span class="number">40</span><span class="operator">/</span><span class="number">3556</span><span class="operator">/</span><span class="number">3708</span><span class="operator">/</span><span class="number">5608</span><span class="operator">/</span><span class="number">79054</span>     <span class="number">5</span></span><br><span class="line">hsa04020 <span class="number">0.0018078040</span> <span class="number">0.12654628</span> <span class="number">0.1189345</span>        <span class="number">493</span><span class="operator">/</span><span class="number">1129</span><span class="operator">/</span><span class="number">2066</span><span class="operator">/</span><span class="number">3707</span><span class="operator">/</span><span class="number">3708</span><span class="operator">/</span><span class="number">4842</span>     <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>输入的ID类型默认是kegg gene id，也可以是ncbi-geneid或ncbi-proteinid或者uniprot等，可以通过上一步格式转换转换ID类型。<br>organism对应物种的三字母缩写，其他参数与GO的ORA分析参数一致。</p>
<p>不像enrichGO()函数有readable()参数，enrichKEGG()函数没有这个参数，当待分析物种在OrgDb数据库中可用时，可以用setReadable()函数把gene ID转换成gene Name。</p>
<ol start="3">
<li>提供注释文件pathway_annotation.txt的非模式物种分析 enricher()</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pathway_anno <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;pathway_annotation.txt&quot;</span><span class="punctuation">,</span>header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span>sep <span class="operator">=</span> <span class="string">&quot;\t&quot;</span><span class="punctuation">)</span></span><br><span class="line">go2gene <span class="operator">&lt;-</span> pathway_anno<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">go2name <span class="operator">&lt;-</span> pathway_anno<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">kk <span class="operator">&lt;-</span> enricher<span class="punctuation">(</span>gene<span class="punctuation">,</span> TERM2GENE <span class="operator">=</span> go2gene<span class="punctuation">,</span>TERM2NAME <span class="operator">=</span> go2name<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>结果输出到csv文件<br><code>write.table(as.data.frame(kk),&quot;KEGG_enrich.csv&quot;,sep=&quot;\t&quot;,row.names =F,quote=F)</code> #保存到文件KEGG_enrich.csv。其中as.data.frame(kk)把kk对象转换成数据框dataframe</li>
</ol>
<h3 id="6-3-3-KEGG-pathway的GSEA分析"><a href="#6-3-3-KEGG-pathway的GSEA分析" class="headerlink" title="6.3.3. KEGG pathway的GSEA分析"></a>6.3.3. KEGG pathway的GSEA分析</h3><ol>
<li><p>读取输入文件</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data <span class="operator">&lt;-</span> read.csv<span class="punctuation">(</span><span class="string">&quot;geneList.csv&quot;</span><span class="punctuation">)</span></span><br><span class="line">geneList <span class="operator">&lt;-</span> d<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>geneList<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>d<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">geneList <span class="operator">&lt;-</span> sort<span class="punctuation">(</span>geneList<span class="punctuation">,</span> decreasing <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>支持物种的标准分析 gseKEGG()</p>
</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">kks <span class="operator">&lt;-</span> gseKEGG<span class="punctuation">(</span>geneList     <span class="operator">=</span> geneList<span class="punctuation">,</span></span><br><span class="line">               keyType      <span class="operator">=</span> <span class="string">&quot;kegg&quot;</span><span class="punctuation">,</span> <span class="comment"># 输入基因的类型，命令keytypes(org.Hs.eg.db)会列出可用的所有类型；</span></span><br><span class="line">               organism     <span class="operator">=</span> <span class="string">&#x27;hsa&#x27;</span><span class="punctuation">,</span></span><br><span class="line">               nPerm        <span class="operator">=</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line">               minGSSize    <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">               maxGSSize    <span class="operator">=</span> <span class="number">500</span><span class="punctuation">,</span></span><br><span class="line">               pvalueCutoff <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span></span><br><span class="line">               pAdjustMethod<span class="operator">=</span> <span class="string">&quot;BH&quot;</span><span class="punctuation">,</span></span><br><span class="line">               verbose      <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>kk2<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>提供注释文件pathway_annotation.txt的非模式物种分析 GSEA()<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;pathway_annotation.txt&quot;</span><span class="punctuation">,</span>header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span>sep <span class="operator">=</span> <span class="string">&quot;\t&quot;</span><span class="punctuation">)</span></span><br><span class="line">go2gene <span class="operator">&lt;-</span> data<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">go2name <span class="operator">&lt;-</span> data<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">kks <span class="operator">&lt;-</span> GSEA<span class="punctuation">(</span>gene<span class="punctuation">,</span> TERM2GENE <span class="operator">=</span> go2gene<span class="punctuation">,</span> TERM2NAME <span class="operator">=</span> go2name<span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="6-3-4-KEGG-module的ORA分析"><a href="#6-3-4-KEGG-module的ORA分析" class="headerlink" title="6.3.4. KEGG module的ORA分析"></a>6.3.4. KEGG module的ORA分析</h3><p><a href="https://www.genome.jp/kegg/module.html">KEGG Module</a>是手动定义的功能单元的集合。在某些情况下，KEGG 模块有更直接的解释。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mkk <span class="operator">&lt;-</span> enrichMKEGG<span class="punctuation">(</span>gene <span class="operator">=</span> gene<span class="punctuation">,</span></span><br><span class="line">                   organism <span class="operator">=</span> <span class="string">&#x27;hsa&#x27;</span><span class="punctuation">,</span></span><br><span class="line">                   pvalueCutoff <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span></span><br><span class="line">                   qvalueCutoff <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>mkk<span class="punctuation">)</span></span><br><span class="line"><span class="comment">##            ID                                             Description GeneRatio</span></span><br><span class="line"><span class="comment">## M00912 M00912      NAD biosynthesis, tryptophan =&gt; quinolinate =&gt; NAD       2/9</span></span><br><span class="line"><span class="comment">## M00095 M00095          C5 isoprenoid biosynthesis, mevalonate pathway       1/9</span></span><br><span class="line"><span class="comment">## M00053 M00053 Pyrimidine deoxyribonuleotide biosynthesis, CDP =&gt; dCTP       1/9</span></span><br><span class="line"><span class="comment">## M00938 M00938 Pyrimidine deoxyribonuleotide biosynthesis, UDP =&gt; dTTP       1/9</span></span><br><span class="line"><span class="comment">## M00003 M00003            Gluconeogenesis, oxaloacetate =&gt; fructose-6P       1/9</span></span><br><span class="line"><span class="comment">## M00049 M00049     Adenine ribonucleotide biosynthesis, IMP =&gt; ADP,ATP       1/9</span></span><br><span class="line"><span class="comment">##        BgRatio      pvalue   p.adjust     qvalue     geneID Count</span></span><br><span class="line"><span class="comment">## M00912  12/829 0.006541756 0.03925053 0.03443029 23475/3620     2</span></span><br><span class="line"><span class="comment">## M00095  10/829 0.103949536 0.20710097 0.18166751       3158     1</span></span><br><span class="line"><span class="comment">## M00053  11/829 0.113796244 0.20710097 0.18166751       6241     1</span></span><br><span class="line"><span class="comment">## M00938  14/829 0.142761862 0.20710097 0.18166751       6241     1</span></span><br><span class="line"><span class="comment">## M00003  18/829 0.180072577 0.20710097 0.18166751       5105     1</span></span><br><span class="line"><span class="comment">## M00049  21/829 0.207100966 0.20710097 0.18166751      26289     1             </span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-5-KEGG-module的GSEA分析"><a href="#6-3-5-KEGG-module的GSEA分析" class="headerlink" title="6.3.5. KEGG module的GSEA分析"></a>6.3.5. KEGG module的GSEA分析</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mkk2 <span class="operator">&lt;-</span> gseMKEGG<span class="punctuation">(</span>geneList <span class="operator">=</span> geneList<span class="punctuation">,</span></span><br><span class="line">                 organism <span class="operator">=</span> <span class="string">&#x27;hsa&#x27;</span><span class="punctuation">,</span></span><br><span class="line">                 pvalueCutoff <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>mkk2<span class="punctuation">)</span></span><br><span class="line"><span class="comment">##            ID                                                      Description</span></span><br><span class="line"><span class="comment">## M00001 M00001        Glycolysis (Embden-Meyerhof pathway), glucose =&gt; pyruvate</span></span><br><span class="line"><span class="comment">## M00035 M00035                                           Methionine degradation</span></span><br><span class="line"><span class="comment">## M00002 M00002         Glycolysis, core module involving three-carbon compounds</span></span><br><span class="line"><span class="comment">## M00938 M00938          Pyrimidine deoxyribonuleotide biosynthesis, UDP =&gt; dTTP</span></span><br><span class="line"><span class="comment">## M00104 M00104 Bile acid biosynthesis, cholesterol =&gt; cholate/chenodeoxycholate</span></span><br><span class="line"><span class="comment">## M00009 M00009                           Citrate cycle (TCA cycle, Krebs cycle)</span></span><br><span class="line"><span class="comment">##        setSize enrichmentScore       NES      pvalue  p.adjust   qvalues rank</span></span><br><span class="line"><span class="comment">## M00001      24       0.5739036  1.683936 0.005050296 0.1616095 0.1488508 2886</span></span><br><span class="line"><span class="comment">## M00035      10       0.6784636  1.637462 0.025966367 0.2710124 0.2496167 1555</span></span><br><span class="line"><span class="comment">## M00002      11       0.6421781  1.585841 0.032455383 0.2710124 0.2496167 1381</span></span><br><span class="line"><span class="comment">## M00938      10       0.6648004  1.604486 0.033876549 0.2710124 0.2496167  648</span></span><br><span class="line"><span class="comment">## M00104      10      -0.5876900 -1.338409 0.128747795 0.6564103 0.6045884  961</span></span><br><span class="line"><span class="comment">## M00009      22       0.4504911  1.315039 0.138271605 0.6564103 0.6045884 3514</span></span><br><span class="line"><span class="comment">##                          leading_edge</span></span><br><span class="line"><span class="comment">## M00001 tags=54%, list=23%, signal=42%</span></span><br><span class="line"><span class="comment">## M00035 tags=50%, list=12%, signal=44%</span></span><br><span class="line"><span class="comment">## M00002 tags=55%, list=11%, signal=49%</span></span><br><span class="line"><span class="comment">## M00938  tags=40%, list=5%, signal=38%</span></span><br><span class="line"><span class="comment">## M00104  tags=50%, list=8%, signal=46%</span></span><br><span class="line"><span class="comment">## M00009 tags=50%, list=28%, signal=36%</span></span><br><span class="line"><span class="comment">##                                                         core_enrichment</span></span><br><span class="line"><span class="comment">## M00001 5214/3101/2821/7167/2597/5230/2023/5223/5315/3099/5232/2027/5211</span></span><br><span class="line"><span class="comment">## M00035                                           875/1789/191/1788/1786</span></span><br><span class="line"><span class="comment">## M00002                                    7167/2597/5230/2023/5223/5315</span></span><br><span class="line"><span class="comment">## M00938                                              6241/7298/4830/1841</span></span><br><span class="line"><span class="comment">## M00104                                        6342/10998/1581/3295/8309</span></span><br><span class="line"><span class="comment">## M00009            3418/50/4190/3419/2271/3421/55753/3417/1431/6389/4191</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-6-KEGG-pathways富集结果的可视化"><a href="#6-3-6-KEGG-pathways富集结果的可视化" class="headerlink" title="6.3.6. KEGG pathways富集结果的可视化"></a>6.3.6. KEGG pathways富集结果的可视化</h3><p>enrichplot包可以实现几种方法，可以用在GO,KEGG,MSigDb等基因集注释上。</p>
<ol>
<li><p>browseKEGG()函数会打开网络浏览器突出显示富集的基因的KEGG通路，用hsa04110基因举例：<br><code>browseKEGG(kk, &#39;hsa04110&#39;)</code></p>
</li>
<li><p>pathview::pathview()可视化富集的KEGG通路</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">library(&quot;pathview&quot;)</span><br><span class="line">hsa04110 &lt;- pathview(gene.data  = geneList,</span><br><span class="line">                     pathway.id = &quot;hsa04110&quot;,</span><br><span class="line">                     species    = &quot;hsa&quot;,</span><br><span class="line">                     limit      = list(gene=max(abs(geneList)), cpd=1))</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="6-4-通用的富集分析-Universal-enrichment-analysis"><a href="#6-4-通用的富集分析-Universal-enrichment-analysis" class="headerlink" title="6.4. 通用的富集分析(Universal enrichment analysis)"></a>6.4. 通用的富集分析(Universal enrichment analysis)</h2><p>除GO,KEGG基因集外，clusterProfiler还支持WikiPathways，Reactome，Disease，MeSH等数据库的富集分析。</p>
<p>虽然clusterProfiler支持对许多ontology&#x2F;pathway的hypergeometric test和gene set enrichment analyses，但是还有很多数据，包括不支持的物种、不支持的ontologies&#x2F;pathways或自定义注释等。<br>clusterProfiler提供了用于hypergeometric test的enricher()函数和用于基因集富集分析的GSEA()函数，用于接受用户定义的注释。</p>
<p>另外两个参数TERM2GENE和TERM2NAME:</p>
<ul>
<li>TERM2GENE是一个必需的data.frame，第一列为term ID，第二列为对应映射基因；</li>
<li>TERM2NAME是一个可选的data.frame，第一列为term ID，第二列为对应term name。</li>
</ul>
<p>在GO和KEGG富集分析的用户自行提供注释文件的分析部分，使用的enricher()和GSEA()函数。</p>
<h1 id="7-references"><a href="#7-references" class="headerlink" title="7. references"></a>7. references</h1><ol>
<li>GSEA wiki: <a href="https://en.wikipedia.org/wiki/Gene_set_enrichment_analysis">https://en.wikipedia.org/wiki/Gene_set_enrichment_analysis</a></li>
<li>enrichment: <a href="https://www.jianshu.com/p/47b5ea646932">https://www.jianshu.com/p/47b5ea646932</a></li>
<li>clusterProfiler github: <a href="https://github.com/YuLab-SMU/clusterProfiler">https://github.com/YuLab-SMU/clusterProfiler</a></li>
<li>clusterProfiler paper: <a href="https://www.cell.com/the-innovation/fulltext/S2666-6758(21)00066-7?_returnURL=https://linkinghub.elsevier.com/retrieve/pii/S2666675821000667?showall=true">https://www.cell.com/the-innovation/fulltext/S2666-6758(21)00066-7?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS2666675821000667%3Fshowall%3Dtrue</a></li>
<li>clusterProfiler book: <a href="http://yulab-smu.top/biomedical-knowledge-mining-book/index.html">http://yulab-smu.top/biomedical-knowledge-mining-book/index.html</a></li>
<li>clusterProfiler manual: <a href="https://bioconductor.org/packages/devel/bioc/manuals/clusterProfiler/man/clusterProfiler.pdf">https://bioconductor.org/packages/devel/bioc/manuals/clusterProfiler/man/clusterProfiler.pdf</a> </li>
<li>clusterProfiler ducumentation: <a href="https://guangchuangyu.github.io/software/clusterProfiler/documentation/">https://guangchuangyu.github.io/software/clusterProfiler/documentation/</a></li>
<li>clusterProfiler blog: <a href="https://guangchuangyu.github.io/2016/01/go-analysis-using-clusterprofiler/">https://guangchuangyu.github.io/2016/01/go-analysis-using-clusterprofiler/</a></li>
<li>tutorial: <a href="https://www.cnblogs.com/jessepeng/p/12159139.html">https://www.cnblogs.com/jessepeng/p/12159139.html</a></li>
<li>函数simplify: <a href="http://guangchuangyu.github.io/2015/10/use-simplify-to-remove-redundancy-of-enriched-go-terms/">http://guangchuangyu.github.io/2015/10/use-simplify-to-remove-redundancy-of-enriched-go-terms/</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>enrichment</category>
      </categories>
      <tags>
        <tag>gene set enrichment analysis</tag>
        <tag>GSEA</tag>
        <tag>enrichment analysis</tag>
        <tag>over representation analysis</tag>
        <tag>ORA</tag>
        <tag>clusterProfiler</tag>
      </tags>
  </entry>
  <entry>
    <title>富集分析：（四）clusterProfiler：不同物种的GO+KEGG富集分析</title>
    <url>/2022/04/26/bioinfo_enrichment_clusterProfiler.species/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=283092&auto=1&height=32"></iframe></div>

<p>clusterProfiler相关的博客共有三篇，共同食用，效果更好 :wink: ：</p>
<ul>
<li>博客<a href="https://yanzhongsino.github.io/2021/12/13/bioinfo_enrichment_clusterProfiler.intro/">富集分析：（三）clusterProfiler概述</a></li>
<li>博客<a href="https://yanzhongsino.github.io/2022/04/26/bioinfo_enrichment_clusterProfiler.species/">富集分析：（四） clusterProfiler：不同物种的GO+KEGG富集分析</a></li>
<li>博客<a href="https://yanzhongsino.github.io/2022/04/28/bioinfo_enrichment_clusterProfiler.visualization/">富集分析：（五）clusterProfiler：Visualization</a></li>
</ul>
<p><strong>总结</strong></p>
<p>用clusterProfiler进行GO&#x2F;KEGG富集分析中的过表达分析(ORA)时，根据分析的物种来选择和准备背景数据集。</p>
<ol>
<li>GO数据库过表达分析(ORA)根据物种选择背景数据集：</li>
</ol>
<ul>
<li>先在Bioconductor库查询是否已有OrgDb的物种(大部分是模式物种)</li>
<li>如果没有，再在AnnotationHub上查询是否有在线注释可以创建OrgDb对象</li>
<li>如果没有，就准备分析物种基因组的功能注释集，通过AnnotationForge创建OrgDb包；或者通过通用富集分析函数enricher进行富集分析</li>
</ul>
<ol start="2">
<li>KEGG数据库过表达分析(ORA)根据物种选择背景数据集：</li>
</ol>
<ul>
<li>先在KEGG数据库查询是否已有基因组物种</li>
<li>如果没有，就准备分析物种基因组的功能注释集，通过AnnotationForge创建OrgDb包；或者通过通用富集分析函数enricher进行富集分析</li>
</ul>
<h1 id="1-GO数据库过表达分析-ORA-的背景数据集选择"><a href="#1-GO数据库过表达分析-ORA-的背景数据集选择" class="headerlink" title="1. GO数据库过表达分析(ORA)的背景数据集选择"></a>1. GO数据库过表达分析(ORA)的背景数据集选择</h1><p>GO富集分析需要物种的注释数据库作为背景，根据分析物种的具体情况，选择不同的数据库作为背景数据库。</p>
<p>groupGO(),enrichGO(),gseGO()函数支持具有OrgDb数据库的生物物种，enricher()和gseGO()函数支持用户自己提供的GO注释文件。</p>
<h2 id="1-1-已有OrgDb的物种-——-Bioconductor"><a href="#1-1-已有OrgDb的物种-——-Bioconductor" class="headerlink" title="1.1. 已有OrgDb的物种 —— Bioconductor"></a>1.1. 已有OrgDb的物种 —— Bioconductor</h2><ol>
<li><p>查询<br><a href="http://bioconductor.org/packages/release/BiocViews.html#___OrgDb">OrgDb数据库</a>查询，目前Bioconductor大概有20个，都是模式物种，植物只有拟南芥<strong>org.At.tair.db</strong>一个数据库。</p>
</li>
<li><p>安装和加载<br>OrgDb数据库本质是一个R包，需要<code>BiocManager::install(&quot;org.At.tair.db&quot;)</code>安装和<code>library(org.At.tair.db)</code>加载后才能使用。</p>
</li>
<li><p>使用<br>如果有的话，加载后在<code>groupGO(OrgDb = org.At.eg.db)</code>,<code>enrichGO(OrgDb = org.At.eg.db)</code>,<code>gseGO(OrgDb = org.At.eg.db)</code>等函数里直接赋值给<code>OrgDb</code>参数即可使用。</p>
</li>
</ol>
<h2 id="1-2-获取在线注释创建OrgDb对象-——-AnnotationHub"><a href="#1-2-获取在线注释创建OrgDb对象-——-AnnotationHub" class="headerlink" title="1.2. 获取在线注释创建OrgDb对象 —— AnnotationHub"></a>1.2. 获取在线注释创建OrgDb对象 —— AnnotationHub</h2><p>如果物种不在Bioconductor的OrgDb列表里，可以用<a href="http://bioconductor.org/packages/release/bioc/html/AnnotationHub.html">AnnotationHub</a>包在线查询和获取其他可用的物种注释信息，并制作OrgDb包使用。<br>AnnotationHub包连接的Bioconductor数据库是实时更新的，所以需要用到的时候再在线查询和使用。</p>
<ol>
<li><p>查询和制作OrgDb库</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span><span class="string">&quot;AnnotationHub&quot;</span><span class="punctuation">)</span> <span class="comment">#安装AnnotationHub</span></span><br><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span><span class="string">&quot;AnnotationDbi&quot;</span><span class="punctuation">)</span> <span class="comment">#安装AnnotationDbi</span></span><br><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span><span class="string">&quot;rtracklayer&quot;</span><span class="punctuation">)</span> <span class="comment">#安装rtracklayer</span></span><br><span class="line">library<span class="punctuation">(</span>AnnotationHub<span class="punctuation">)</span> <span class="comment">#加载AnnotationHub</span></span><br><span class="line">hub <span class="operator">&lt;-</span> AnnotationHub<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment">#建立AnnotationHub对象保存到hub</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看AnnotationHub内容</span></span><br><span class="line">display<span class="punctuation">(</span>hub<span class="punctuation">)</span> <span class="comment">#会调出一个网页，以交互式表格的形式查看，但有些服务器不支持</span></span><br><span class="line">unique<span class="punctuation">(</span>hub<span class="operator">$</span>species<span class="punctuation">)</span> <span class="comment">#查看hub里包含的所有物种，目前有2700+个物种。</span></span><br><span class="line">unique<span class="punctuation">(</span>hub<span class="operator">$</span>rdataclass<span class="punctuation">)</span> <span class="comment">#查看hub里的数据类型，我们这里需要的是最后一种OrgDb类型数据</span></span><br><span class="line">hub<span class="punctuation">[</span>hub<span class="operator">$</span>rdataclass <span class="operator">==</span> <span class="string">&quot;OrgDb&quot;</span><span class="punctuation">]</span> <span class="comment">#查看hub里OrgDb类型的数据</span></span><br><span class="line"></span><br><span class="line">query<span class="punctuation">(</span>hub<span class="punctuation">,</span> <span class="string">&quot;Cricetulus&quot;</span><span class="punctuation">)</span> <span class="comment">#查询包含Cricetulus的物种信息，一共查询到229条信息。输出如下：</span></span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">AnnotationHub with <span class="number">229</span> records</span><br><span class="line"><span class="comment"># snapshotDate(): 2021-10-20</span></span><br><span class="line"><span class="comment"># $dataprovider: Ensembl, ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/, UCSC, FANTO...</span></span><br><span class="line"><span class="comment"># $species: cricetulus griseus crigri, cricetulus griseus chok1gshd, cricetu...</span></span><br><span class="line"><span class="comment"># $rdataclass: TwoBitFile, GRanges, SQLiteFile, OrgDb, Inparanoid8Db, ChainFile</span></span><br><span class="line"><span class="comment"># additional mcols(): taxonomyid, genome, description,</span></span><br><span class="line"><span class="comment">#   coordinate_1_based, maintainer, rdatadateadded, preparerclass, tags,</span></span><br><span class="line"><span class="comment">#   rdatapath, sourceurl, sourcetype</span></span><br><span class="line"><span class="comment"># retrieve records with, e.g., &#x27;object[[&quot;AH10393&quot;]]&#x27;</span></span><br><span class="line"></span><br><span class="line">            title</span><br><span class="line">  AH10393 <span class="operator">|</span> hom.Cricetulus_griseus.inp8.sqlite</span><br><span class="line">  AH13980 <span class="operator">|</span> criGri1.2bit</span><br><span class="line">  AH14346 <span class="operator">|</span> criGri1ToHg19.over.chain.gz</span><br><span class="line">  AH57104 <span class="operator">|</span> Cricetulus_griseus_chok1gshd.CHOK1GS_HDv1.90.abinitio.gtf</span><br><span class="line">  AH57105 <span class="operator">|</span> Cricetulus_griseus_chok1gshd.CHOK1GS_HDv1.90.gtf</span><br><span class="line">  ...       ...</span><br><span class="line">  AH99348 <span class="operator">|</span> Cricetulus_griseus_crigri.CriGri_1.0.ncrna.2bit</span><br><span class="line">  AH99349 <span class="operator">|</span> Cricetulus_griseus_picr.CriGri<span class="operator">-</span>PICR.cdna.all.2bit</span><br><span class="line">  AH99350 <span class="operator">|</span> Cricetulus_griseus_picr.CriGri<span class="operator">-</span>PICR.dna_rm.toplevel.2bit</span><br><span class="line">  AH99351 <span class="operator">|</span> Cricetulus_griseus_picr.CriGri<span class="operator">-</span>PICR.dna_sm.toplevel.2bit</span><br><span class="line">  AH99352 <span class="operator">|</span> Cricetulus_griseus_picr.CriGri<span class="operator">-</span>PICR.ncrna.2bi</span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line"></span><br><span class="line">query<span class="punctuation">(</span>hub<span class="punctuation">[</span>hub<span class="operator">$</span>rdataclass <span class="operator">==</span> <span class="string">&quot;OrgDb&quot;</span><span class="punctuation">]</span> <span class="punctuation">,</span> <span class="string">&quot;Cricetulus&quot;</span><span class="punctuation">)</span> <span class="comment">#query(hub, &quot;Cricetulus&quot;)的查询结果中有各种类型的数据，如果我们需要OrgDb类型，可以这样筛选后查询，也可以这样`query(hub,&#x27;org.Cricetulus&#x27;)`搜索。输出如下：</span></span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">AnnotationHub with <span class="number">2</span> records</span><br><span class="line"><span class="comment"># snapshotDate(): 2021-10-20</span></span><br><span class="line"><span class="comment"># $dataprovider: ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/</span></span><br><span class="line"><span class="comment"># $species: Cricetulus griseus, Cricetulus barabensis_griseus</span></span><br><span class="line"><span class="comment"># $rdataclass: OrgDb</span></span><br><span class="line"><span class="comment"># additional mcols(): taxonomyid, genome, description,</span></span><br><span class="line"><span class="comment">#   coordinate_1_based, maintainer, rdatadateadded, preparerclass, tags,</span></span><br><span class="line"><span class="comment">#   rdatapath, sourceurl, sourcetype</span></span><br><span class="line"><span class="comment"># retrieve records with, e.g., &#x27;object[[&quot;AH96227&quot;]]&#x27;</span></span><br><span class="line"></span><br><span class="line">            title</span><br><span class="line">  AH96227 <span class="operator">|</span> org.Cricetulus_barabensis_griseus.eg.sqlite</span><br><span class="line">  AH96228 <span class="operator">|</span> org.Cricetulus_griseus.eg.sqlite</span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line"></span><br><span class="line">Cgriseus <span class="operator">&lt;-</span> hub<span class="punctuation">[[</span><span class="string">&quot;AH96228&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="comment">#制作Cricetulus_griseus的OrgDb库。AH96228是Cricetulus_griseus对应的编号。下载和检索后即保存在缓存目录下（我这是/home/user/.cache/R/AnnotationHub/5f01212f7210_102705）。</span></span><br><span class="line">Cgriseus <span class="comment">#查看Cgriseus，输出如下：</span></span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line">OrgDb object<span class="operator">:</span></span><br><span class="line"><span class="operator">|</span> DBSCHEMAVERSION<span class="operator">:</span> <span class="number">2.1</span></span><br><span class="line"><span class="operator">|</span> DBSCHEMA<span class="operator">:</span> NOSCHEMA_DB</span><br><span class="line"><span class="operator">|</span> ORGANISM<span class="operator">:</span> Cricetulus barabensis_griseus</span><br><span class="line"><span class="operator">|</span> SPECIES<span class="operator">:</span> Cricetulus barabensis_griseus</span><br><span class="line"><span class="operator">|</span> CENTRALID<span class="operator">:</span> GID</span><br><span class="line"><span class="operator">|</span> Taxonomy ID<span class="operator">:</span> <span class="number">10029</span></span><br><span class="line"><span class="operator">|</span> Db type<span class="operator">:</span> OrgDb</span><br><span class="line"><span class="operator">|</span> Supporting package<span class="operator">:</span> AnnotationDbi</span><br><span class="line"></span><br><span class="line">Please see<span class="operator">:</span> help<span class="punctuation">(</span><span class="string">&#x27;select&#x27;</span><span class="punctuation">)</span> <span class="keyword">for</span> usage information</span><br><span class="line"><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span><span class="operator">-</span></span><br><span class="line"></span><br><span class="line">library<span class="punctuation">(</span>AnnotationDbi<span class="punctuation">)</span></span><br><span class="line">saveDb<span class="punctuation">(</span>Cgriseus<span class="punctuation">,</span>file<span class="operator">=</span><span class="string">&quot;Cgriseus.OrgDb&quot;</span><span class="punctuation">)</span> <span class="comment">#把Cgriseus对象保存成Cgriseus.OrgDb文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>载入和查看<br>保存为文件后使用时加载Cgriseus.OrgDb文件即可使用。常用的函数包括columns()，keys()，keytypes()，select()等。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>AnnotationDbi<span class="punctuation">)</span></span><br><span class="line">Cgriseus<span class="operator">&lt;-</span>loadDb<span class="punctuation">(</span>file<span class="operator">=</span><span class="string">&quot;Cgriseus.OrgDb&quot;</span><span class="punctuation">)</span> <span class="comment">#载入Cgriseus.OrgDb文件，保存到Cgriseus</span></span><br><span class="line"><span class="built_in">length</span><span class="punctuation">(</span>keys<span class="punctuation">(</span>Cgriseus<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#查看包含的基因数量</span></span><br><span class="line">columns<span class="punctuation">(</span>Cgriseus<span class="punctuation">)</span> <span class="comment">#查看OrgDb对象的数据类型</span></span><br><span class="line">keys<span class="punctuation">(</span>Cgriseus<span class="punctuation">,</span> keytype <span class="operator">=</span> <span class="string">&quot;GO&quot;</span><span class="punctuation">)</span> <span class="comment">#查看GO数据集下的ID</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<br>载入后在<code>groupGO(OrgDb = Cgriseus)</code>,<code>enrichGO(OrgDb = Cgriseus)</code>,<code>gseGO(OrgDb = Cgriseus)</code>等函数里直接赋值给<code>OrgDb</code>参数即可。</p>
</li>
</ol>
<h2 id="1-3-通用富集分析（非模式物种）——-AnnotationForge"><a href="#1-3-通用富集分析（非模式物种）——-AnnotationForge" class="headerlink" title="1.3. 通用富集分析（非模式物种）—— AnnotationForge"></a>1.3. 通用富集分析（非模式物种）—— AnnotationForge</h2><ul>
<li>如果以上两个方法都没有找到你分析的物种，可以选择近缘种来代替。</li>
<li>如果有分析物种的基因组注释数据，更好的方案是使用通用富集分析。</li>
<li>AnnotationForge是用来创建OrgDb包的R包。</li>
</ul>
<h3 id="1-3-1-安装"><a href="#1-3-1-安装" class="headerlink" title="1.3.1. 安装"></a>1.3.1. 安装</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&#x27;GO.db&#x27;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>GO.db<span class="punctuation">)</span></span><br><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span><span class="string">&quot;AnnotationForge&quot;</span><span class="punctuation">)</span> <span class="comment">#安装</span></span><br><span class="line">library<span class="punctuation">(</span>AnnotationForge<span class="punctuation">)</span> <span class="comment">#加载</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-准备"><a href="#1-3-2-准备" class="headerlink" title="1.3.2. 准备"></a>1.3.2. 准备</h3><ul>
<li>这里使用的基因组注释数据是eggNOG注释结果emapper.annotations.tsv。</li>
<li>准备步骤之后的步骤大多在R环境里操作，有些需要在shell环境处理，建议开两个shell窗口操作。</li>
</ul>
<ol>
<li><p>删除冗余<br>把emapper.annotations.tsv的##开头的行和标题行前的#删除，保存到文件eggnog.anno。<br><code>sed &#39;/^##/d&#39; emapper.annotations.tsv |sed &#39;s/#//&#39; &gt;eggnog.anno</code></p>
</li>
<li><p>读取数据</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">egg<span class="operator">&lt;-</span>read.csv<span class="punctuation">(</span><span class="string">&quot;eggnog.anno&quot;</span><span class="punctuation">,</span>header<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">)</span> <span class="comment">#如果用read.csv报错，尝试read.table(&quot;eggnog.anno&quot;,header=T,sep=&quot;\t&quot;)，或者试试egg &lt;- rio::import(&#x27;emapper.annotations.tsv&#x27;)。</span></span><br><span class="line">egg<span class="punctuation">[</span>egg<span class="operator">==</span><span class="string">&quot;&quot;</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="literal">NA</span> <span class="comment">#把空行标记上NA</span></span><br><span class="line"></span><br><span class="line">colnames<span class="punctuation">(</span>egg<span class="punctuation">)</span> <span class="comment">#列出标题行</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;query&quot;</span>          <span class="string">&quot;seed_ortholog&quot;</span>  <span class="string">&quot;evalue&quot;</span>         <span class="string">&quot;score&quot;</span></span><br><span class="line"> <span class="punctuation">[</span><span class="number">5</span><span class="punctuation">]</span> <span class="string">&quot;eggNOG_OGs&quot;</span>     <span class="string">&quot;max_annot_lvl&quot;</span>  <span class="string">&quot;COG_category&quot;</span>   <span class="string">&quot;Description&quot;</span></span><br><span class="line"> <span class="punctuation">[</span><span class="number">9</span><span class="punctuation">]</span> <span class="string">&quot;Preferred_name&quot;</span> <span class="string">&quot;GOs&quot;</span>            <span class="string">&quot;EC&quot;</span>             <span class="string">&quot;KEGG_ko&quot;</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">13</span><span class="punctuation">]</span> <span class="string">&quot;KEGG_Pathway&quot;</span>   <span class="string">&quot;KEGG_Module&quot;</span>    <span class="string">&quot;KEGG_Reaction&quot;</span>  <span class="string">&quot;KEGG_rclass&quot;</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">17</span><span class="punctuation">]</span> <span class="string">&quot;BRITE&quot;</span>          <span class="string">&quot;KEGG_TC&quot;</span>        <span class="string">&quot;CAZy&quot;</span>           <span class="string">&quot;BiGG_Reaction&quot;</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">21</span><span class="punctuation">]</span> <span class="string">&quot;PFAMs&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-3-3-提取注释的GO信息"><a href="#1-3-3-提取注释的GO信息" class="headerlink" title="1.3.3. 提取注释的GO信息"></a>1.3.3. 提取注释的GO信息</h3><p>从egg中提取GO注释并整理成gene2go.txt文件</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>dplyr<span class="punctuation">)</span></span><br><span class="line">gene_info <span class="operator">&lt;-</span> egg <span class="operator">%&gt;%</span>dplyr<span class="operator">::</span>select<span class="punctuation">(</span>GID <span class="operator">=</span> query<span class="punctuation">,</span> GENENAME <span class="operator">=</span> seed_ortholog<span class="punctuation">)</span> <span class="operator">%&gt;%</span> na.omit<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment">#根据egg第一和第二列的标题提取前两列。</span></span><br><span class="line">goterms <span class="operator">&lt;-</span> egg <span class="operator">%&gt;%</span>dplyr<span class="operator">::</span>select<span class="punctuation">(</span>query<span class="punctuation">,</span> GOs<span class="punctuation">)</span> <span class="operator">%&gt;%</span> na.omit<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> filter<span class="punctuation">(</span>str_detect<span class="punctuation">(</span>GO<span class="punctuation">,</span><span class="string">&quot;GO&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#根据egg第一列和GO列的标题提取基因的GO注释。后面的`%&gt;% filter(str_detect(GO,&quot;GO&quot;))`是筛选GO列值包含&quot;GO&quot;的行，删除空值。</span></span><br><span class="line"></span><br><span class="line">library<span class="punctuation">(</span>stringr<span class="punctuation">)</span></span><br><span class="line">all_go_list<span class="operator">=</span>str_split<span class="punctuation">(</span>goterms<span class="operator">$</span>GOs<span class="punctuation">,</span><span class="string">&quot;,&quot;</span><span class="punctuation">)</span> <span class="comment">#分隔goterms的GOs值，逗号是分隔符</span></span><br><span class="line">gene2go <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>GID <span class="operator">=</span> <span class="built_in">rep</span><span class="punctuation">(</span>goterms<span class="operator">$</span>query<span class="punctuation">,</span> times <span class="operator">=</span> sapply<span class="punctuation">(</span>all_go_list<span class="punctuation">,</span> <span class="built_in">length</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> GO <span class="operator">=</span> unlist<span class="punctuation">(</span>all_go_list<span class="punctuation">)</span><span class="punctuation">,</span> EVIDENCE <span class="operator">=</span> <span class="string">&quot;IEA&quot;</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> filter<span class="punctuation">(</span>str_detect<span class="punctuation">(</span>GOs<span class="punctuation">,</span><span class="string">&quot;GO&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#注释换成单个GO编号一行的格式。eggnog里每个基因一行注释，GOs注释里可能有多个GO编号信息，要转换成每个GO编号一行的格式（看下面）。</span></span><br><span class="line">write.table<span class="punctuation">(</span>gene2go<span class="punctuation">,</span>file<span class="operator">=</span><span class="string">&quot;gene2go.txt&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span>row.names<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span><span class="built_in">quote</span><span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#保存成文件gene2go.txt</span></span><br><span class="line"></span><br><span class="line">head<span class="punctuation">(</span>gene2go<span class="punctuation">)</span> <span class="comment">#查看gene2go前六行</span></span><br><span class="line">      GID         GO EVIDENCE</span><br><span class="line"><span class="number">1</span> mc00002 GO<span class="operator">:</span><span class="number">0000003</span>      IEA</span><br><span class="line"><span class="number">2</span> mc00002 GO<span class="operator">:</span><span class="number">0000323</span>      IEA</span><br><span class="line"><span class="number">3</span> mc00002 GO<span class="operator">:</span><span class="number">0000325</span>      IEA</span><br><span class="line"><span class="number">4</span> mc00002 GO<span class="operator">:</span><span class="number">0002376</span>      IEA</span><br><span class="line"><span class="number">5</span> mc00002 GO<span class="operator">:</span><span class="number">0003006</span>      IEA</span><br><span class="line"><span class="number">6</span> mc00002 GO<span class="operator">:</span><span class="number">0003674</span>      IEA</span><br></pre></td></tr></table></figure>

<h3 id="1-3-4-提取注释的KEGG信息"><a href="#1-3-4-提取注释的KEGG信息" class="headerlink" title="1.3.4. 提取注释的KEGG信息"></a>1.3.4. 提取注释的KEGG信息</h3><p>从egg中提取KEGG注释并整理成gene2pathway.txt文件</p>
<ol>
<li><p>提取KEGG信息</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">koterms <span class="operator">&lt;-</span> egg <span class="operator">%&gt;%</span>dplyr<span class="operator">::</span>select<span class="punctuation">(</span>GID <span class="operator">=</span> query<span class="punctuation">,</span> KO<span class="operator">=</span>KEGG_ko<span class="punctuation">)</span><span class="operator">%&gt;%</span>na.omit<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">%&gt;%</span> filter<span class="punctuation">(</span>str_detect<span class="punctuation">(</span>KO<span class="punctuation">,</span><span class="string">&quot;ko&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#根据egg第一列和KEGG_ko列的标题提取基因的KEGG注释。</span></span><br><span class="line">head<span class="punctuation">(</span>koterms<span class="punctuation">)</span> <span class="comment">#查看koterms前六行</span></span><br><span class="line">      GID                  KO</span><br><span class="line"><span class="number">1</span> mc00001 ko<span class="operator">:</span>K14524<span class="punctuation">,</span>ko<span class="operator">:</span>K22674</span><br><span class="line"><span class="number">2</span> mc00002           ko<span class="operator">:</span>K16292</span><br><span class="line"><span class="number">3</span> mc00003           ko<span class="operator">:</span>K16392</span><br><span class="line"><span class="number">4</span> mc00004           ko<span class="operator">:</span>K16167</span><br><span class="line"><span class="number">5</span> mc00006           ko<span class="operator">:</span>K16253</span><br><span class="line"><span class="number">6</span> mc00007 ko<span class="operator">:</span>K14664<span class="punctuation">,</span>ko<span class="operator">:</span>K21604</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载ko00001.json<br>在网页<a href="https://www.genome.jp/kegg-bin/get_htext?ko00001%E7%82%B9%E5%87%BB**Download">https://www.genome.jp/kegg-bin/get_htext?ko00001点击**Download</a> json**即可下载ko00001.json，是KEGG的K与ko，ko与通路的对应关系。</p>
</li>
<li><p>运行R脚本ko_json2data.R<br><code>Rscript ko_json2data.R</code>运行R脚本ko_json2data.R，用ko00001.json生成ko与通路和ko与K的对应关系文件kegg_info.RData。</p>
</li>
</ol>
<ul>
<li>ko_json2data.R脚本如下：<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span><span class="punctuation">(</span><span class="operator">!</span>file.exists<span class="punctuation">(</span><span class="string">&#x27;kegg_info.RData&#x27;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  </span><br><span class="line">  library<span class="punctuation">(</span>jsonlite<span class="punctuation">)</span></span><br><span class="line">  library<span class="punctuation">(</span>purrr<span class="punctuation">)</span></span><br><span class="line">  library<span class="punctuation">(</span>RCurl<span class="punctuation">)</span></span><br><span class="line">  </span><br><span class="line">  update_kegg <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>json <span class="operator">=</span> <span class="string">&quot;ko00001.json&quot;</span><span class="punctuation">,</span>file<span class="operator">=</span><span class="literal">NULL</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    pathway2name <span class="operator">&lt;-</span> tibble<span class="punctuation">(</span>Pathway <span class="operator">=</span> character<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span> Name <span class="operator">=</span> character<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">    ko2pathway <span class="operator">&lt;-</span> tibble<span class="punctuation">(</span>Ko <span class="operator">=</span> character<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span> Pathway <span class="operator">=</span> character<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">    </span><br><span class="line">    kegg <span class="operator">&lt;-</span> fromJSON<span class="punctuation">(</span>json<span class="punctuation">)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="punctuation">(</span>a <span class="keyword">in</span> <span class="built_in">seq_along</span><span class="punctuation">(</span>kegg<span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">      A <span class="operator">&lt;-</span> kegg<span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;name&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>a<span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> <span class="punctuation">(</span>b <span class="keyword">in</span> <span class="built_in">seq_along</span><span class="punctuation">(</span>kegg<span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>a<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">        B <span class="operator">&lt;-</span> kegg<span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>a<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;name&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>b<span class="punctuation">]</span><span class="punctuation">]</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> <span class="punctuation">(</span><span class="built_in">c</span> <span class="keyword">in</span> <span class="built_in">seq_along</span><span class="punctuation">(</span>kegg<span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>a<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>b<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">          pathway_info <span class="operator">&lt;-</span> kegg<span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>a<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>b<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;name&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="built_in">c</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">          </span><br><span class="line">          pathway_id <span class="operator">&lt;-</span> str_match<span class="punctuation">(</span>pathway_info<span class="punctuation">,</span> <span class="string">&quot;ko[0-9]&#123;5&#125;&quot;</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">          pathway_name <span class="operator">&lt;-</span> str_replace<span class="punctuation">(</span>pathway_info<span class="punctuation">,</span> <span class="string">&quot; \\[PATH:ko[0-9]&#123;5&#125;\\]&quot;</span><span class="punctuation">,</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> str_replace<span class="punctuation">(</span><span class="string">&quot;[0-9]&#123;5&#125; &quot;</span><span class="punctuation">,</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">          pathway2name <span class="operator">&lt;-</span> rbind<span class="punctuation">(</span>pathway2name<span class="punctuation">,</span> tibble<span class="punctuation">(</span>Pathway <span class="operator">=</span> pathway_id<span class="punctuation">,</span> Name <span class="operator">=</span> pathway_name<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">          </span><br><span class="line">          kos_info <span class="operator">&lt;-</span> kegg<span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>a<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span>b<span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;children&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="built_in">c</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="string">&quot;name&quot;</span><span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">          </span><br><span class="line">          kos <span class="operator">&lt;-</span> str_match<span class="punctuation">(</span>kos_info<span class="punctuation">,</span> <span class="string">&quot;K[0-9]*&quot;</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">          </span><br><span class="line">          ko2pathway <span class="operator">&lt;-</span> rbind<span class="punctuation">(</span>ko2pathway<span class="punctuation">,</span> tibble<span class="punctuation">(</span>Ko <span class="operator">=</span> kos<span class="punctuation">,</span> Pathway <span class="operator">=</span> <span class="built_in">rep</span><span class="punctuation">(</span>pathway_id<span class="punctuation">,</span> <span class="built_in">length</span><span class="punctuation">(</span>kos<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    </span><br><span class="line">    save<span class="punctuation">(</span>pathway2name<span class="punctuation">,</span> ko2pathway<span class="punctuation">,</span> file <span class="operator">=</span> file<span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  </span><br><span class="line">  update_kegg<span class="punctuation">(</span>json <span class="operator">=</span> <span class="string">&quot;ko00001.json&quot;</span><span class="punctuation">,</span>file<span class="operator">=</span><span class="string">&quot;kegg_info.RData&quot;</span><span class="punctuation">)</span></span><br><span class="line">  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><p>读取kegg_info.RData文件<br>在R里用<code>load(&quot;kegg_info.RData&quot;)</code>读取kegg_info.RData文件，会得到ko2pathway和pathway2name两个对象。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">head<span class="punctuation">(</span>ko2pathway<span class="punctuation">)</span> <span class="comment">#查看前六行</span></span><br><span class="line"><span class="comment"># A tibble: 6 × 2</span></span><br><span class="line">  Ko     Pathway</span><br><span class="line">  <span class="operator">&lt;</span>chr<span class="operator">&gt;</span>  <span class="operator">&lt;</span>chr<span class="operator">&gt;</span></span><br><span class="line"><span class="number">1</span> K00844 ko00010</span><br><span class="line"><span class="number">2</span> K12407 ko00010</span><br><span class="line"><span class="number">3</span> K00845 ko00010</span><br><span class="line"><span class="number">4</span> K25026 ko00010</span><br><span class="line"><span class="number">5</span> K01810 ko00010</span><br><span class="line"><span class="number">6</span> K06859 ko00010</span><br><span class="line"></span><br><span class="line">head<span class="punctuation">(</span>pathway2name<span class="punctuation">)</span> <span class="comment">#查看前六行</span></span><br><span class="line"><span class="comment"># A tibble: 6 × 2</span></span><br><span class="line">  Pathway Name</span><br><span class="line">  <span class="operator">&lt;</span>chr<span class="operator">&gt;</span>   <span class="operator">&lt;</span>chr<span class="operator">&gt;</span></span><br><span class="line"><span class="number">1</span> ko00010 Glycolysis <span class="operator">/</span> Gluconeogenesis</span><br><span class="line"><span class="number">2</span> ko00020 Citrate cycle <span class="punctuation">(</span>TCA cycle<span class="punctuation">)</span></span><br><span class="line"><span class="number">3</span> ko00030 Pentose phosphate pathway</span><br><span class="line"><span class="number">4</span> ko00040 Pentose and glucuronate interconversions</span><br><span class="line"><span class="number">5</span> ko00051 Fructose and mannose metabolism</span><br><span class="line"><span class="number">6</span> ko00052 Galactose metabolism</span><br><span class="line"></span><br><span class="line">write.table<span class="punctuation">(</span>pathway2name<span class="punctuation">,</span>file<span class="operator">=</span><span class="string">&quot;pathway2name.txt&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span>row.names<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span><span class="built_in">quote</span><span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#【optional】保存成文件pathway2name.txt，可以给通用KEGG富集分析的结果注释KEGG Pathway的描述(Name)用。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获得gene2pathway</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>stringr<span class="punctuation">)</span></span><br><span class="line">colnames<span class="punctuation">(</span>ko2pathway<span class="punctuation">)</span><span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;KO&quot;</span><span class="punctuation">,</span><span class="string">&#x27;Pathway&#x27;</span><span class="punctuation">)</span> <span class="comment">#把ko2pathway的列名改为KO和Pathway，与koterms一致。</span></span><br><span class="line">koterms<span class="operator">$</span>KO<span class="operator">=</span>str_replace_all<span class="punctuation">(</span>koterms<span class="operator">$</span>KO<span class="punctuation">,</span><span class="string">&quot;ko:&quot;</span><span class="punctuation">,</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span> <span class="comment">#把koterms的KO值的前缀ko:去掉，与ko2pathway格式一致。</span></span><br><span class="line">gene2pathway <span class="operator">&lt;-</span> koterms <span class="operator">%&gt;%</span> left_join<span class="punctuation">(</span>ko2pathway<span class="punctuation">,</span> by <span class="operator">=</span> <span class="string">&quot;KO&quot;</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span>dplyr<span class="operator">::</span>select<span class="punctuation">(</span>GID<span class="punctuation">,</span> Pathway<span class="punctuation">)</span> <span class="operator">%&gt;%</span>na.omit<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment">#合并koterms和ko2pathway到gene2pathway，将基因与pathway的对应关系整理出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##【optional】下面为可选步骤</span></span><br><span class="line">gene2pathway_name<span class="operator">&lt;-</span>left_join<span class="punctuation">(</span>gene2pathway<span class="punctuation">,</span>pathway2name<span class="punctuation">,</span>by<span class="operator">=</span><span class="string">&quot;Pathway&quot;</span><span class="punctuation">)</span> <span class="comment">#合并gene2pathway和pathway2name</span></span><br><span class="line">write.table<span class="punctuation">(</span>gene2pathway_name<span class="punctuation">,</span>file<span class="operator">=</span><span class="string">&quot;gene2pathway_name.txt&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span>row.names<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span><span class="built_in">quote</span><span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#【optional】保存成文件gene2pathway_name.txt，可以给通用KEGG富集分析用。</span></span><br><span class="line"></span><br><span class="line">head<span class="punctuation">(</span>gene2pathway<span class="punctuation">)</span>  <span class="comment">#查看前六行</span></span><br><span class="line">       GID Pathway</span><br><span class="line"><span class="number">3</span>  mc00003 ko01002</span><br><span class="line"><span class="number">8</span>  mc00009 ko01002</span><br><span class="line"><span class="number">13</span> mc00016 ko03012</span><br><span class="line"><span class="number">14</span> mc00016 ko03029</span><br><span class="line"><span class="number">16</span> mc00018 ko03037</span><br><span class="line"><span class="number">17</span> mc00018 ko04812</span><br><span class="line"></span><br><span class="line">head<span class="punctuation">(</span>gene2pathway_name<span class="punctuation">)</span> <span class="comment">#查看前六行</span></span><br><span class="line">       GID Pathway                                                Name</span><br><span class="line"><span class="number">1</span> mc01138 ko00511                            Other glycan degradation</span><br><span class="line"><span class="number">2</span> mc00017 ko04142                                            Lysosome</span><br><span class="line"><span class="number">3</span> mc01022 ko00930                             Caprolactam degradation</span><br><span class="line"><span class="number">4</span> mc00072 ko01002              Peptidases and inhibitors <span class="punctuation">[</span>BR<span class="operator">:</span>ko01002<span class="punctuation">]</span></span><br><span class="line"><span class="number">5</span> mc01058 ko00130 Ubiquinone and other terpenoid<span class="operator">-</span>quinone biosynthesis</span><br><span class="line"><span class="number">6</span> mc00288 ko03440                            Homologous recombination</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-3-5-创建OrgDb包"><a href="#1-3-5-创建OrgDb包" class="headerlink" title="1.3.5. 创建OrgDb包"></a>1.3.5. 创建OrgDb包</h3><ol>
<li>参数准备</li>
</ol>
<ul>
<li>Taxonomy ID(tax_id)<br>在<a href="https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi">NCBI的Taxonomy网站</a>，通过搜索物种的学名，点击结果中的学名就可以链接到Taxonomy ID信息，比如Melastoma candidum的Taxonomy ID为119954。</li>
<li>gene_info, gene2go, koterms, gene2pathway是前面步骤生成的四个对象</li>
<li>version：格式是0.0.1</li>
<li>maintainer和author的格式包括名字和邮箱</li>
<li>outputDir是创建的OrgDb包的输出路径</li>
<li>genus是属名，species是种加词。</li>
<li>goTable：生成GO的详细注释信息。需要go参数值的标题行是”GID, GO and EVIDENCE”。</li>
</ul>
<ol start="2">
<li>创建命令<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">makeOrgPackage<span class="punctuation">(</span>gene_info<span class="operator">=</span>gene_info<span class="punctuation">,</span> go<span class="operator">=</span>gene2go<span class="punctuation">,</span> ko<span class="operator">=</span>koterms<span class="punctuation">,</span>  pathway<span class="operator">=</span>gene2pathway<span class="punctuation">,</span> version<span class="operator">=</span><span class="string">&quot;0.0.1&quot;</span><span class="punctuation">,</span> maintainer<span class="operator">=</span><span class="string">&#x27;yanzhong &lt;yan.zhong.sino@gmail.com&gt;&#x27;</span><span class="punctuation">,</span> author<span class="operator">=</span><span class="string">&#x27;yanzhong &lt;yan.zhong.sino@gmail.com&gt;&#x27;</span><span class="punctuation">,</span>outputDir<span class="operator">=</span><span class="string">&quot;.&quot;</span><span class="punctuation">,</span> tax_id<span class="operator">=</span><span class="string">&quot;119954&quot;</span><span class="punctuation">,</span> genus<span class="operator">=</span><span class="string">&quot;Melastoma&quot;</span><span class="punctuation">,</span> species<span class="operator">=</span><span class="string">&quot;candidum&quot;</span><span class="punctuation">,</span>goTable<span class="operator">=</span><span class="string">&quot;go&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>生成org.Mcandidum.eg.db文件夹，即为制作的Orgdb包。</p>
<ul>
<li>notes:如果报错<code>GO Ids must be formatted like &#39;GO:XXXXXXX&#39;</code>则需要检查gene2go数据的GO值是否有冗余或污染。</li>
</ul>
<h3 id="1-3-6-使用OrgDb包"><a href="#1-3-6-使用OrgDb包" class="headerlink" title="1.3.6. 使用OrgDb包"></a>1.3.6. 使用OrgDb包</h3><ol>
<li>安装加载</li>
</ol>
<ul>
<li>创建的org.Mcandidum.eg.db文件夹本质上是个R包，需要安装和加载才能使用。</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&#x27;org.Mcandidum.eg.db&#x27;</span><span class="punctuation">,</span>repos <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> type<span class="operator">=</span><span class="string">&quot;source&quot;</span><span class="punctuation">)</span> <span class="comment">#安装包</span></span><br><span class="line">library<span class="punctuation">(</span>org.Mcandidum.eg.db<span class="punctuation">)</span> <span class="comment">#加载包</span></span><br></pre></td></tr></table></figure>

<ul>
<li>安装后会在R包存放位置生成org.Mcandidum.eg.db文件夹，这个位置下面<code>C:\Users\name\Documents\R\win-library\4.1</code>，以后使用即可直接加载包</li>
</ul>
<ol start="2">
<li>用于GO分析</li>
</ol>
<p><code>enrichGO(gene = genes, keyType=&quot;GID&quot;, OrgDb = org.Mcandidum.eg.db, ont = &quot;ALL&quot;, pAdjustMethod = &quot;BH&quot;, pvalueCutoff  = 0.05, qvalueCutoff  = 0.2)</code></p>
<p>加载后在<code>groupGO(keyType=&quot;GID&quot;, OrgDb = org.Mcandidum.eg.db)</code>,<code>enrichGO(keyType=&quot;GID&quot;, OrgDb = org.Mcandidum.eg.db)</code>,<code>gseGO(keyType=&quot;GID&quot;, OrgDb = org.Mcandidum.eg.db)</code>等函数里把包赋值给<code>OrgDb</code>参数，<code>keyType</code>参数指定GID即可使用。</p>
<ol start="3">
<li>用于KEGG分析<br>waiting…</li>
</ol>
<h2 id="1-4-GO富集分析"><a href="#1-4-GO富集分析" class="headerlink" title="1.4. GO富集分析"></a>1.4. GO富集分析</h2><p>上面三种方法获取了背景数据集，接下来就可以使用enrichGO()函数进行GO富集分析。</p>
<p>下面是用enrichGO做go富集分析的例子。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>clusterProfiler<span class="punctuation">)</span></span><br><span class="line">data <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;gene.list&quot;</span><span class="punctuation">,</span>header<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#读取gene ID list</span></span><br><span class="line">genes <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>data<span class="operator">$</span>V1<span class="punctuation">)</span> <span class="comment">#转换成字符格式</span></span><br><span class="line">ego <span class="operator">&lt;-</span> enrichGO<span class="punctuation">(</span>gene          <span class="operator">=</span> genes<span class="punctuation">,</span> <span class="comment"># list of entrez gene id</span></span><br><span class="line">                OrgDb         <span class="operator">=</span> org.Mcandidum.eg.db<span class="punctuation">,</span> <span class="comment"># 背景使用分析物种的org包</span></span><br><span class="line">                keyType       <span class="operator">=</span> <span class="string">&#x27;GID&#x27;</span><span class="punctuation">,</span> <span class="comment"># 输入基因的类型，命令keytypes(org.Mcandidum.eg.db)会列出可用的所有类型，如果按上面步骤制备的数据库，则使用GID；</span></span><br><span class="line">                ont           <span class="operator">=</span> <span class="string">&quot;ALL&quot;</span><span class="punctuation">,</span> <span class="comment">#  &quot;BP&quot;, &quot;MF&quot;, &quot;CC&quot;, &quot;ALL&quot;。GO三个子类。如果选ALL，会同时获得三个子类的结果(相当于单独做三个子类的结果合并在一起)，结果中增加一列ONTOLOGY为子类。</span></span><br><span class="line">                pAdjustMethod <span class="operator">=</span> <span class="string">&quot;BH&quot;</span><span class="punctuation">,</span> <span class="comment"># 指定多重假设检验矫正的方法，选项包含 &quot;holm&quot;, &quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;</span></span><br><span class="line">                pvalueCutoff  <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span> <span class="comment"># 富集分析的pvalue，默认是pvalueCutoff = 0.05，更严格可选择0.01</span></span><br><span class="line">                qvalueCutoff  <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="comment"># 富集分析显著性的qvalue，默认是qvalueCutoff = 0.2，更严格可选择0.05</span></span><br><span class="line">                readable      <span class="operator">=</span> <span class="literal">TRUE</span> <span class="punctuation">)</span> <span class="comment"># 是否将gene ID转换到 gene symbol</span></span><br><span class="line">write.table<span class="punctuation">(</span>as.data.frame<span class="punctuation">(</span>ego<span class="punctuation">)</span><span class="punctuation">,</span><span class="string">&quot;go_enrich.tsv&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span>row.names <span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span><span class="built_in">quote</span><span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#保存到文件go_enrich.csv。其中as.data.frame(ego)把ego对象转换成数据框dataframe</span></span><br></pre></td></tr></table></figure>

<h1 id="2-KEGG数据库过表达分析-ORA-的背景数据集选择"><a href="#2-KEGG数据库过表达分析-ORA-的背景数据集选择" class="headerlink" title="2. KEGG数据库过表达分析(ORA)的背景数据集选择"></a>2. KEGG数据库过表达分析(ORA)的背景数据集选择</h1><h2 id="2-1-支持的物种"><a href="#2-1-支持的物种" class="headerlink" title="2.1. 支持的物种"></a>2.1. 支持的物种</h2><p>有些物种在KEGG数据库里有参考基因组数据库的支持，可以直接用于KEGG分析。</p>
<h3 id="2-1-1-查询"><a href="#2-1-1-查询" class="headerlink" title="2.1.1. 查询"></a>2.1.1. 查询</h3><ol>
<li>网页查看</li>
</ol>
<ul>
<li>通过<a href="http://www.genome.jp/kegg/catalog/org_list.html">KEGG Organisms</a>访问 KEGG 支持的生物的完整列表，目前包含700+真核生物。</li>
<li>ctrl+F搜索学名来查看是不是已有参考基因组</li>
<li>如果在其中，就记录下物种简写(kegg_code,比如hsa)</li>
</ul>
<ol start="2">
<li>代码搜索</li>
</ol>
<ul>
<li>clusterProfiler包提供search_kegg_organism()可以搜索支持的物种。<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>clusterProfiler<span class="punctuation">)</span></span><br><span class="line">search_kegg_organism<span class="punctuation">(</span><span class="string">&#x27;Eucalyptus&#x27;</span><span class="punctuation">,</span> by<span class="operator">=</span><span class="string">&#x27;scientific_name&#x27;</span><span class="punctuation">)</span></span><br><span class="line">    kegg_code    scientific_name common_name</span><br><span class="line"><span class="number">313</span>       egr Eucalyptus grandis    rose gum</span><br></pre></td></tr></table></figure></li>
<li>记录物种对应的物种简写(kegg_code,这里是egr)</li>
</ul>
<h3 id="2-1-2-使用"><a href="#2-1-2-使用" class="headerlink" title="2.1.2. 使用"></a>2.1.2. 使用</h3><p>查询到有分析物种时，在<code>enrichKEGG(organism=&#39;egr&#39;)</code>,<code>gseKEGG(organism=&#39;egr&#39;)</code>,<code>enrichMKEGG(organism=&#39;egr&#39;)</code>,<code>gseMKEGG(organism=&#39;egr&#39;)</code>函数里直接把物种简写(kegg_code)赋值给<code>organism</code>参数即可使用。</p>
<h2 id="2-2-其他物种"><a href="#2-2-其他物种" class="headerlink" title="2.2. 其他物种"></a>2.2. 其他物种</h2><p>如果分析物种不在上面支持的物种里，那么就选择下面的通用富集分析 —— enricher()和GSEA()啦~</p>
<h1 id="3-通用富集分析-——-enricher-和GSEA"><a href="#3-通用富集分析-——-enricher-和GSEA" class="headerlink" title="3. 通用富集分析 —— enricher()和GSEA()"></a>3. 通用富集分析 —— enricher()和GSEA()</h1><ul>
<li>以上介绍的方法都是寻找&#x2F;创建OrgDb对象或已有数据集，并用enrichGO(),enrichKEGG(),gseGO(),gseKEGG()函数实现GO和KEGG分析的。</li>
<li>clusterProfiler开发者还专门开发了通用的富集分析函数enricher()和GSEA()，可以实现适用性更广的分析。</li>
</ul>
<p>基因组功能注释的软件和输出参考这篇博客:<a href="https://yanzhongsino.github.io/2021/05/17/omics_genome.annotation_function/">基因组功能注释</a></p>
<h2 id="3-1-enricher的背景数据集"><a href="#3-1-enricher的背景数据集" class="headerlink" title="3.1. enricher的背景数据集"></a>3.1. enricher的背景数据集</h2><p>整理分析物种基因组的功能注释成enricher接受的格式。</p>
<ol>
<li>注释文件annotation.txt的格式</li>
</ol>
<ul>
<li>数据表格data.frame格式，包含三列。</li>
<li>第一列为Gene ID，第二列为 GO ID(单个GO ID)，第三列为GO_Description(如果没有可以用任意单词替代，富集分析后再做GO到GO_Description的注释)，行间的顺序无要求。</li>
<li>enricher同样适用KEGG的富集分析，注释文件格式是一样的，第一列Gene ID，第二列为单个KEGG Pathway ID(ko01001)，第三列为KEGG_Pathway_Description(如果没有也可以用任意单词替代)。</li>
</ul>
<table>
<thead>
<tr>
<th>GeneID</th>
<th>GO</th>
<th>GO_Description</th>
</tr>
</thead>
<tbody><tr>
<td>gene00001</td>
<td>GO:0005819</td>
<td>spindle</td>
</tr>
<tr>
<td>gene00002</td>
<td>GO:0072686</td>
<td>mitotic spindle</td>
</tr>
<tr>
<td>gene00003</td>
<td>GO:0000776</td>
<td>kinetochore</td>
</tr>
</tbody></table>
<ol start="2">
<li>PANNZER功能注释整理</li>
</ol>
<ul>
<li>pannzer2_GO.out.txt是pannzer2的GO注释结果，提取第1(Gene ID)，3(GO ID)，4(description)列，保存为pannzer_go_annotation.txt。<br><code>cat pannzer2_GO.out.txt |awk &#39;&#123;print $1&quot;\tGO:&quot;$3&quot;\t&quot;$4&#125;&#39; &gt;pannzer_go_annotation.txt</code></li>
<li>PANNZER的注释是一个GO ID一行的格式，所以不需更多整理了。</li>
</ul>
<ol start="3">
<li>Interproscan功能注释整理</li>
</ol>
<ul>
<li>iprscan.tsv是interproscan的注释结果，提取第1(Gene ID)和第14(GO IDs)列，保存为iprscan_gos.txt。<br><code>cat interproscan/mc.iprscan.tsv |cut -f1,14 |grep &quot;GO&quot;|sed &quot;s/|/,/g&quot; &gt;iprscan_gos.txt</code></li>
<li>Interproscan的注释是一个基因的所有GO IDs都在第14列，所以需要处理成单个GO ID一行的格式。下面的R脚本示例处理iprscan_gos.txt成iprscan_go_annotation.txt文件。<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>stringr<span class="punctuation">)</span></span><br><span class="line">iprscan_go<span class="operator">&lt;-</span>read.table<span class="punctuation">(</span><span class="string">&quot;iprscan_gos.txt&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span>header<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span></span><br><span class="line">all_go_list<span class="operator">=</span>str_split<span class="punctuation">(</span>iprscan_go<span class="operator">$</span>V2<span class="punctuation">,</span><span class="string">&quot;,&quot;</span><span class="punctuation">)</span> <span class="comment">#分隔iprscan_go的GOs值，逗号是分隔符</span></span><br><span class="line">ip_gene2go <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>GID <span class="operator">=</span> <span class="built_in">rep</span><span class="punctuation">(</span>iprscan_go<span class="operator">$</span>V1<span class="punctuation">,</span> times <span class="operator">=</span> sapply<span class="punctuation">(</span>all_go_list<span class="punctuation">,</span> <span class="built_in">length</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> GO <span class="operator">=</span> unlist<span class="punctuation">(</span>all_go_list<span class="punctuation">)</span><span class="punctuation">,</span> EVIDENCE <span class="operator">=</span> <span class="string">&quot;IEA&quot;</span><span class="punctuation">)</span> <span class="comment">#把多个GO编号一行的格式转换成每个GO编号一行的格式，并添加标题行，添加EVIDENCE列作为GO_Description。</span></span><br><span class="line">write.table<span class="punctuation">(</span>ip_gene2go<span class="punctuation">,</span>file<span class="operator">=</span><span class="string">&quot;iprscan_go_annotation.txt&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span>row.names<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span><span class="built_in">quote</span><span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#保存成文件iprscan_go_annotation.txt</span></span><br><span class="line">head<span class="punctuation">(</span>ip_gene2go<span class="punctuation">)</span> <span class="comment">#查看ip_gene2go前六行</span></span><br><span class="line">      GID         GO EVIDENCE</span><br><span class="line"><span class="number">1</span> mc16959 GO<span class="operator">:</span><span class="number">0003779</span>      IEA</span><br><span class="line"><span class="number">2</span> mc16959 GO<span class="operator">:</span><span class="number">0003779</span>      IEA</span><br><span class="line"><span class="number">3</span> mc32011 GO<span class="operator">:</span><span class="number">0000148</span>      IEA</span><br><span class="line"><span class="number">4</span> mc32011 GO<span class="operator">:</span><span class="number">0003843</span>      IEA</span><br><span class="line"><span class="number">5</span> mc32011 GO<span class="operator">:</span><span class="number">0006075</span>      IEA</span><br><span class="line"><span class="number">6</span> mc32011 GO<span class="operator">:</span><span class="number">0016020</span>      IEA</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li>其他功能注释</li>
</ol>
<ul>
<li>功能注释软件有很多，结果文件的格式也各有差别，如果有注释到GO，都可以整理成这种格式，作为背景数据集，用作enricher的富集分析。</li>
<li>在前面节<strong>通用富集分析 —— AnnotationForge</strong>中从eggNOG注释结果中提取的gene2go.txt文件格式与这里也一致，适用于enricher分析。</li>
</ul>
<h2 id="3-2-enricher富集分析"><a href="#3-2-enricher富集分析" class="headerlink" title="3.2. enricher富集分析"></a>3.2. enricher富集分析</h2><p>可以使用enricher()和gseGO()函数进行ORA和GSEA分析。</p>
<p>下面是用enricher做go富集分析的例子，KEGG的enricher富集分析也类似。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;gene.list&quot;</span><span class="punctuation">,</span>header<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#读取gene ID list</span></span><br><span class="line">genes <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>data<span class="operator">$</span>V1<span class="punctuation">)</span> <span class="comment">#转换成字符格式</span></span><br><span class="line">go_anno <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;go_annotation.txt&quot;</span><span class="punctuation">,</span>header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span>sep <span class="operator">=</span> <span class="string">&quot;\t&quot;</span><span class="punctuation">)</span> <span class="comment">#读取go_annotation.txt，可以是pannzer_go_annotation.txt或者iprscan_go_annotation.txt</span></span><br><span class="line">go2gene <span class="operator">&lt;-</span> go_anno<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">]</span> <span class="comment">#读取第1，2列</span></span><br><span class="line">go2name <span class="operator">&lt;-</span> go_anno<span class="punctuation">[</span><span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">]</span> <span class="comment">#读取第2，3列</span></span><br><span class="line">ego <span class="operator">&lt;-</span> enricher<span class="punctuation">(</span>genes<span class="punctuation">,</span> TERM2GENE <span class="operator">=</span> go2gene<span class="punctuation">,</span> TERM2NAME <span class="operator">=</span> go2name<span class="punctuation">,</span> pAdjustMethod <span class="operator">=</span> <span class="string">&quot;BH&quot;</span><span class="punctuation">,</span>pvalueCutoff  <span class="operator">=</span> <span class="number">0.05</span><span class="punctuation">,</span> qvalueCutoff  <span class="operator">=</span> <span class="number">0.2</span><span class="punctuation">)</span> <span class="comment">#enricher分析，并保存在ego。</span></span><br><span class="line">write.table<span class="punctuation">(</span>as.data.frame<span class="punctuation">(</span>ego<span class="punctuation">)</span><span class="punctuation">,</span><span class="string">&quot;go_enrich.csv&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span>row.names <span class="operator">=</span><span class="built_in">F</span><span class="punctuation">,</span><span class="built_in">quote</span><span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#保存到文件go_enrich.csv。其中as.data.frame(ego)把ego对象转换成数据框dataframe</span></span><br></pre></td></tr></table></figure>

<h1 id="4-GO和KEGG描述查询"><a href="#4-GO和KEGG描述查询" class="headerlink" title="4. GO和KEGG描述查询"></a>4. GO和KEGG描述查询</h1><p>如果在通用富集分析中准备的背景数据集第三列描述栏没有信息，可以在富集结果出来后根据GO ID或者KEGG Pathway ID查询。</p>
<h2 id="4-1-GO-term-查询"><a href="#4-1-GO-term-查询" class="headerlink" title="4.1. GO term 查询"></a>4.1. GO term 查询</h2><ol>
<li>AmiGO2查询</li>
</ol>
<ul>
<li>在<a href="http://geneontology.org/">GO官网</a>)使用的<a href="http://amigo.geneontology.org/amigo/landing">AmiGO2网站</a>查询GO ID和GO term信息。</li>
<li><a href="https://wego.genomics.cn/">WEGO 2.0</a>也可以查询。</li>
<li><strong>查询方法</strong>：在<a href="http://amigo.geneontology.org/amigo/landing">AmiGO2网站</a>的搜索框输入GO ID(格式是 GO:0000000)即可查到GO term information。</li>
</ul>
<h2 id="4-2-KEGG-Pathway-查询"><a href="#4-2-KEGG-Pathway-查询" class="headerlink" title="4.2. KEGG Pathway 查询"></a>4.2. KEGG Pathway 查询</h2><ol>
<li>KEGG官网查询</li>
</ol>
<ul>
<li><a href="https://www.kegg.jp/kegg/">KEGG网站</a>提供了KEGG信息查询入口，包括<a href="https://www.kegg.jp/kegg/pathway.html">KEGG Pathway</a>中查询KEGG Pathway ID(格式是 ko00000)的详细信息。</li>
<li><strong>查询方法</strong>：把<a href="https://www.kegg.jp/kegg/pathway.html">KEGG Pathway</a>的搜索前缀(Select prefix)改成ko，在搜索框(Enter keywords)输入KEGG Pathway ID(格式是5个数字 00000)，点击查询Go即可得到KEGG Pathway information。</li>
<li>官网查询只发现了单个查询的方法，批量查询还是推荐使用文件查询方法。</li>
</ul>
<ol start="2">
<li>文件查询【推荐】<br>使用前面<strong>提取注释的KEGG信息</strong>第4步骤得到的pathway2name.txt文件，获取KEGG Pathway ID对应的描述信息(Name列)。</li>
</ol>
<h1 id="5-references"><a href="#5-references" class="headerlink" title="5. references"></a>5. references</h1><ol>
<li>clusterProfiler github：<a href="https://github.com/YuLab-SMU/clusterProfiler">https://github.com/YuLab-SMU/clusterProfiler</a></li>
<li>clusterProfiler paper：<a href="https://www.cell.com/the-innovation/fulltext/S2666-6758(21)00066-7?_returnURL=https://linkinghub.elsevier.com/retrieve/pii/S2666675821000667?showall=true">https://www.cell.com/the-innovation/fulltext/S2666-6758(21)00066-7?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS2666675821000667%3Fshowall%3Dtrue</a></li>
<li>clusterProfiler book：<a href="http://yulab-smu.top/biomedical-knowledge-mining-book/index.html">http://yulab-smu.top/biomedical-knowledge-mining-book/index.html</a></li>
<li>clusterProfiler manual：<a href="https://bioconductor.org/packages/devel/bioc/manuals/clusterProfiler/man/clusterProfiler.pdf">https://bioconductor.org/packages/devel/bioc/manuals/clusterProfiler/man/clusterProfiler.pdf</a> </li>
<li>clusterProfiler ducumentation：<a href="https://guangchuangyu.github.io/software/clusterProfiler/documentation/">https://guangchuangyu.github.io/software/clusterProfiler/documentation/</a></li>
<li>用AnnotationForge进行非模式物种注释构建：<a href="https://www.jieandze1314.com/post/cnposts/208/">https://www.jieandze1314.com/post/cnposts/208/</a></li>
<li>用AnnotationHub获取非模式物种注释信息：<a href="https://www.bioinfo-scrounger.com/archives/512/">https://www.bioinfo-scrounger.com/archives/512/</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>enrichment</category>
      </categories>
      <tags>
        <tag>gene set enrichment analysis</tag>
        <tag>GSEA</tag>
        <tag>enrichment analysis</tag>
        <tag>over representation analysis</tag>
        <tag>ORA</tag>
        <tag>clusterProfiler</tag>
        <tag>GO</tag>
        <tag>KEGG</tag>
        <tag>AnnotationHub</tag>
        <tag>AnnotationForge</tag>
        <tag>enricher</tag>
      </tags>
  </entry>
  <entry>
    <title>富集分析：（五）clusterProfiler：Visualization</title>
    <url>/2022/04/28/bioinfo_enrichment_clusterProfiler.visualization/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=283091&auto=1&height=32"></iframe></div>

<p>(全文约4000字)</p>
<p>clusterProfiler相关的博客共有三篇，共同食用，效果更好 :wink: ：</p>
<ul>
<li>博客<a href="https://yanzhongsino.github.io/2021/12/13/bioinfo_enrichment_clusterProfiler.intro/">富集分析：（三）clusterProfiler概述</a></li>
<li>博客<a href="https://yanzhongsino.github.io/2022/04/26/bioinfo_enrichment_clusterProfiler.species/">富集分析：（四） clusterProfiler：不同物种的GO+KEGG富集分析</a></li>
<li>博客<a href="https://yanzhongsino.github.io/2022/04/28/bioinfo_enrichment_clusterProfiler.visualization/">富集分析：（五）clusterProfiler：Visualization</a></li>
</ul>
<h1 id="1-可视化的输入数据"><a href="#1-可视化的输入数据" class="headerlink" title="1. 可视化的输入数据"></a>1. 可视化的输入数据</h1><p>clusterProfiler的可视化一般只支持clusterProfiler富集分析结果的可视化，通过认识clusterProfiler可视化接受的输入数据的格式，可以修改其他富集分析结果文件的格式，来用clusterProfiler进行可视化绘图。</p>
<h2 id="1-1-可视化输入数据格式"><a href="#1-1-可视化输入数据格式" class="headerlink" title="1.1. 可视化输入数据格式"></a>1.1. 可视化输入数据格式</h2><ol>
<li>查看ego格式<br>clusterProfiler的可视化包接受的输入数据是前面富集分析得到的结果(比如ego&#x2F;kk)，用<code>str(ego)</code>或<code>class(ego)</code>可以看到ego的格式是叫enrichResult的R的数据类型。<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>clusterProfiler<span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">class</span><span class="punctuation">(</span>ego<span class="punctuation">)</span> <span class="comment">#查看ego的数据类型/类</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;enrichResult&quot;</span></span><br><span class="line"><span class="built_in">attr</span><span class="punctuation">(</span><span class="punctuation">,</span><span class="string">&quot;package&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="string">&quot;DOSE&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果手头没有ego数据，可以用clusterProfiler的样例数据快速得到一个edo，与ego格式一样。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>clusterProfiler<span class="punctuation">)</span></span><br><span class="line">data<span class="punctuation">(</span>geneList<span class="punctuation">)</span> <span class="comment">#导入示例数据</span></span><br><span class="line">de <span class="operator">&lt;-</span> <span class="built_in">names</span><span class="punctuation">(</span>geneList<span class="punctuation">)</span><span class="punctuation">[</span><span class="built_in">abs</span><span class="punctuation">(</span>geneList<span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">2</span><span class="punctuation">]</span> <span class="comment">#得到差异表达的基因</span></span><br><span class="line">edo <span class="operator">&lt;-</span> enrichDGN<span class="punctuation">(</span>de<span class="punctuation">)</span> <span class="comment">#进行富集分析</span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>ego<span class="punctuation">)</span> <span class="comment">#查看edo的数据类型/类</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>enrichResult(R的class类型)格式<br>在DOSE包中查到，enrichResult具体格式如下：</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">setClass<span class="punctuation">(</span><span class="string">&quot;enrichResult&quot;</span><span class="punctuation">,</span></span><br><span class="line">         representation<span class="operator">=</span>representation<span class="punctuation">(</span></span><br><span class="line">           result         <span class="operator">=</span> <span class="string">&quot;data.frame&quot;</span><span class="punctuation">,</span></span><br><span class="line">           pvalueCutoff   <span class="operator">=</span> <span class="string">&quot;numeric&quot;</span><span class="punctuation">,</span>           </span><br><span class="line">           pAdjustMethod  <span class="operator">=</span> <span class="string">&quot;character&quot;</span><span class="punctuation">,</span>           </span><br><span class="line">           qvalueCutoff   <span class="operator">=</span> <span class="string">&quot;numeric&quot;</span><span class="punctuation">,</span>           </span><br><span class="line">           organism       <span class="operator">=</span> <span class="string">&quot;character&quot;</span><span class="punctuation">,</span>           </span><br><span class="line">           style<span class="operator">=</span><span class="string">&quot;margin: 0px; padding: 0px; color: rgb(221, 17, 68);&quot;</span><span class="operator">&gt;</span><span class="string">&quot;character&quot;</span><span class="punctuation">,</span>          </span><br><span class="line">           gene           <span class="operator">=</span> <span class="string">&quot;character&quot;</span><span class="punctuation">,</span>           </span><br><span class="line">           keytype        <span class="operator">=</span> <span class="string">&quot;character&quot;</span><span class="punctuation">,</span>           </span><br><span class="line">           universe       <span class="operator">=</span> <span class="string">&quot;character&quot;</span><span class="punctuation">,</span>           </span><br><span class="line">           gene2Symbol    <span class="operator">=</span> <span class="string">&quot;character&quot;</span><span class="punctuation">,</span>           </span><br><span class="line">           geneSets       <span class="operator">=</span> <span class="string">&quot;list&quot;</span><span class="punctuation">,</span>           </span><br><span class="line">           readable       <span class="operator">=</span> <span class="string">&quot;logical&quot;</span> </span><br><span class="line">         <span class="punctuation">)</span><span class="punctuation">,</span>         </span><br><span class="line">         prototype<span class="operator">=</span>prototype<span class="punctuation">(</span>readable <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>result变量格式<br>enrichResult中最重要的是result，是储存富集结果的dataframe。<br>result变量与clusterProfiler富集分析中保存ego的结果文件是一致的。</p>
</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ego<span class="operator">@</span>result<span class="punctuation">[</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">13</span><span class="punctuation">,</span><span class="number">14</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="comment">#查看ego的result变量的13，14行</span></span><br><span class="line">   ONTOLOGY         ID                        Description GeneRatio   BgRatio   pvalue    p.adjust      qvalue      geneID   Count</span><br><span class="line"><span class="number">13</span>       BP GO<span class="operator">:</span><span class="number">0010051</span> xylem and phloem pattern formation    <span class="number">3</span><span class="operator">/</span><span class="number">349</span> <span class="number">129</span><span class="operator">/</span><span class="number">16975</span>    <span class="number">1.431350e-05</span> <span class="number">0.001294821</span> <span class="number">0.001099880</span>   mc40782<span class="operator">/</span>mc40784<span class="operator">/</span>mc40918   <span class="number">3</span></span><br><span class="line"><span class="number">14</span>       BP GO<span class="operator">:</span><span class="number">0048598</span>            embryonic morphogenesis    <span class="number">2</span><span class="operator">/</span><span class="number">349</span> <span class="number">131</span><span class="operator">/</span><span class="number">16975</span>    <span class="number">1.673394e-05</span> <span class="number">0.001405651</span> <span class="number">0.001194023</span>   mc40784<span class="operator">/</span>mc40918   <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>一般而言result有9列。这里因为用enrichGO富集时ont参数选择ALL，结果就会在第一列前多一列ONTOLOGY。</p>
<ul>
<li>第一列是ID,也就是富集通路的编号(GO:0010222)；</li>
<li>第二列是Description，也就是富集通路的名称；</li>
<li>第三列是GeneRatio，也就是要富集的基因中在对应通路中的比例；</li>
<li>第4列是BgRation,也就是对应通过的基因在全基因组注释中的比例；</li>
<li>第5,6,7列都是统计检验的结果；</li>
<li>第8列是geneID，也就是富集到基因的名字，多个geneID是以斜线隔开的；</li>
<li>第9列是Count，也就是富集到的基因数目。</li>
</ul>
<h2 id="1-2-输入数据准备"><a href="#1-2-输入数据准备" class="headerlink" title="1.2. 输入数据准备"></a>1.2. 输入数据准备</h2><p>根据不同情况为clusterProfiler的可视化准备输入数据。</p>
<ol>
<li><p>接着clusterProfiler富集分析做可视化<br>如果是接着clusterProfiler的enrichGO(),gseGO(),enricher(),gseGO()等函数的结果<code>ego</code>，不要关闭R环境，在R里直接进行用于下一步可视化即可。</p>
</li>
<li><p>保存的clusterProfiler富集分析结果做可视化</p>
</li>
</ol>
<ul>
<li>如果是clusterProfiler的enrichGO(),gseGO(),enricher(),gseGO()等函数的结果<code>ego</code>保存成的文件，已关闭R环境。</li>
<li>可导入文件，新建enrichResult对象ego，再进行下一步可视化。</li>
<li>这里假设用R命令<code>write.table(as.data.frame(ego),&quot;go_enrich.csv&quot;,sep=&quot;\t&quot;,row.names =F,quote=F)</code>保存<code>ego</code>在<code>go_enrich.csv</code>文件。<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">data<span class="operator">&lt;-</span>read.table<span class="punctuation">(</span><span class="string">&quot;go_enrich.csv&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span>header<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">,</span><span class="built_in">quote</span><span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">head<span class="punctuation">(</span>data<span class="punctuation">,</span><span class="number">2</span><span class="punctuation">)</span> <span class="comment">#查看data前2行</span></span><br><span class="line">  ONTOLOGY         ID                                 Description GeneRatio</span><br><span class="line"><span class="number">1</span>       BP GO<span class="operator">:</span><span class="number">0010222</span>      stem vascular tissue pattern formation    <span class="number">12</span><span class="operator">/</span><span class="number">349</span></span><br><span class="line"><span class="number">2</span>       BP GO<span class="operator">:</span><span class="number">0010588</span> cotyledon vascular tissue pattern formation    <span class="number">12</span><span class="operator">/</span><span class="number">349</span></span><br><span class="line">   BgRatio       pvalue     p.adjust       qvalue</span><br><span class="line"><span class="number">1</span> <span class="number">29</span><span class="operator">/</span><span class="number">16975</span> <span class="number">1.792157e-13</span> <span class="number">2.107577e-10</span> <span class="number">1.790270e-10</span></span><br><span class="line"><span class="number">2</span> <span class="number">39</span><span class="operator">/</span><span class="number">16975</span> <span class="number">1.122611e-11</span> <span class="number">6.600951e-09</span> <span class="number">5.607145e-09</span></span><br><span class="line">           geneID</span><br><span class="line"><span class="number">1</span> mc11300<span class="operator">/</span>mc11301<span class="operator">/</span>mc19080<span class="operator">/</span>mc19081<span class="operator">/</span>mc26300<span class="operator">/</span>mc31693<span class="operator">/</span>mc37850<span class="operator">/</span>mc40780<span class="operator">/</span>mc40781<span class="operator">/</span>mc40782<span class="operator">/</span>mc40784<span class="operator">/</span>mc40918</span><br><span class="line"><span class="number">2</span> mc11300<span class="operator">/</span>mc11301<span class="operator">/</span>mc19080<span class="operator">/</span>mc19081<span class="operator">/</span>mc26300<span class="operator">/</span>mc31693<span class="operator">/</span>mc37850<span class="operator">/</span>mc40780<span class="operator">/</span>mc40781<span class="operator">/</span>mc40782<span class="operator">/</span>mc40784<span class="operator">/</span>mc40918</span><br><span class="line">  Count</span><br><span class="line"><span class="number">1</span>    <span class="number">12</span></span><br><span class="line"><span class="number">2</span>    <span class="number">12</span></span><br><span class="line"></span><br><span class="line">geneID_all <span class="operator">&lt;-</span> unlist<span class="punctuation">(</span>apply<span class="punctuation">(</span>as.matrix<span class="punctuation">(</span>data<span class="operator">$</span>geneID<span class="punctuation">)</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> unlist<span class="punctuation">(</span>strsplit<span class="punctuation">(</span>x<span class="punctuation">,</span><span class="string">&#x27;/&#x27;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#得到富集到的所用geneID</span></span><br><span class="line"></span><br><span class="line">ego<span class="operator">&lt;-</span>new<span class="punctuation">(</span><span class="string">&quot;enrichResult&quot;</span><span class="punctuation">,</span> result<span class="operator">=</span>data<span class="punctuation">,</span> gene<span class="operator">=</span>geneID_all<span class="punctuation">,</span> pvalueCutoff<span class="operator">=</span><span class="number">0.01</span><span class="punctuation">,</span>pAdjustMethod<span class="operator">=</span><span class="string">&quot;BH&quot;</span><span class="punctuation">,</span>qvalueCutoff<span class="operator">=</span><span class="number">0.05</span><span class="punctuation">,</span>ontology<span class="operator">=</span><span class="string">&quot;BP&quot;</span><span class="punctuation">,</span>keytype<span class="operator">=</span><span class="string">&quot;GID&quot;</span><span class="punctuation">,</span>universe<span class="operator">=</span><span class="string">&#x27;Unknown&#x27;</span><span class="punctuation">,</span>geneSets<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span>organism<span class="operator">=</span><span class="string">&quot;Unknown&quot;</span><span class="punctuation">,</span>readable<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span> <span class="comment">#把data内容赋值给ego的result，geneID_all赋值给gene，每个富集到的GO对应的gene集应该赋值给geneSets(数据是字典(键值对是GOID和geneIDs)组成的列表，这里直接给了空的)，ontology与enrichGO分析的ont参数一致，这里的pvalueCutoff=0.01,pAdjustMethod=&quot;BH&quot;,qvalueCutoff=0.05根据富集分析参数的设置，或者随意设置或者不设置也不会影响可视化。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>其他来源富集分析结果可视化<br>如果是其他软件的富集分析结果，可以根据ego的result变量格式进行修改格式，改成go_enrich.csv相同的格式的文件，再按照上面的步骤导入文件，并保存到新建的ego对象。即可用clusterProfiler的可视化包可视化其他软件的富集分析结果了。</li>
</ol>
<h1 id="2-功能富集结果可视化"><a href="#2-功能富集结果可视化" class="headerlink" title="2. 功能富集结果可视化"></a>2. 功能富集结果可视化</h1><p>下面的可视化大多基于在R中已获得富集分析的结果ego。</p>
<h2 id="2-1-enrichplot包"><a href="#2-1-enrichplot包" class="headerlink" title="2.1. enrichplot包"></a>2.1. enrichplot包</h2><p>enrichplot包有几种可视化方法来解释富集结果，支持clusterProfiler获得的ORA和GSEA富集结果。</p>
<h3 id="2-1-1-安装和载入"><a href="#2-1-1-安装和载入" class="headerlink" title="2.1.1. 安装和载入"></a>2.1.1. 安装和载入</h3><p>安装和载入enrichplot包</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span><span class="string">&quot;enrichplot&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>enrichplot<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-可视化包"><a href="#2-1-2-可视化包" class="headerlink" title="2.1.2. 可视化包"></a>2.1.2. 可视化包</h3><ul>
<li>推荐dotplot或barplot可视化前10个GO Terms条目。</li>
<li>推荐goplot有向无环图查看富集的GO Terms间的关系。</li>
</ul>
<ol>
<li>可视化barplot —— 条形图<br>将富集分数（例如p 值）和基因计数或比率描述为条形高度和颜色。横轴为该GO term下的差异基因个数，纵轴为富集到的GO Terms的描述信息， showCategory指定展示的GO Terms的个数为20个，默认展示显著富集的top10个，即p.adjust最小的10个。</li>
</ol>
<p><code>barplot(ego, showCategory=20, title=&quot;EnrichmentGO_MF&quot;)</code></p>
<p>使用mutate导出的其他变量也可以用作条形高度或颜色。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mutate<span class="punctuation">(</span>ego<span class="punctuation">,</span> qscore <span class="operator">=</span> <span class="operator">-</span><span class="built_in">log</span><span class="punctuation">(</span>p.adjust<span class="punctuation">,</span> base<span class="operator">=</span><span class="number">10</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">    barplot<span class="punctuation">(</span>x<span class="operator">=</span><span class="string">&quot;qscore&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<img src="http://yulab-smu.top/biomedical-knowledge-mining-book/biomedicalKnowledge_files/figure-html/Barplot-1.png" title="Bar plot of enriched terms" width="90%"/>

<p><strong><p align="center">Figure 1. Bar plot of enriched terms</strong><br>from <a href="http://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html">clusterProfiler book</a></p></p>
<ol start="2">
<li>可视化dotplot —— 点阵图<br><code>dotplot(edo, showCategory=30) + ggtitle(&quot;dotplot for ORA&quot;)</code></li>
</ol>
<p><code>dotplot(edo2, showCategory=30) + ggtitle(&quot;dotplot for GSEA&quot;)</code></p>
<p>散点图，横坐标为GeneRatio，纵坐标为富集到的GO Terms的描述信息，showCategory指定展示的GO Terms的个数，默认展示显著富集的top10个，即p.adjust最小的10个。</p>
<img src="http://yulab-smu.top/biomedical-knowledge-mining-book/biomedicalKnowledge_files/figure-html/Dotplotcap-1.png" title="Dot plot of enriched terms" width="90%"/>

<p><strong><p align="center">Figure 2. Dot plot of enriched terms</strong><br>from <a href="http://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html">clusterProfiler book</a></p></p>
<ol start="3">
<li>可视化cnetplot —— 类别网络图<br>cnetplot 将基因和生物学概念（例如 GO 术语或 KEGG 通路）的联系描述为一个网络（有助于查看哪些基因涉及富集通路和可能属于多个注释类别的基因）。对于基因和富集的GO terms之间的对应关系进行展示，如果一个基因位于一个GO Terms下，则将该基因与GO连线。图中灰色的点代表基因，黄色的点代表富集到的GO terms, 默认画top5富集到的GO terms, GO 节点的大小对应富集到的基因个数。</li>
</ol>
<p><code>cnetplot(ego, categorySize = &quot;pvalue&quot;, foldChange = gene_list</code></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">## convert gene ID to Symbol</span></span><br><span class="line">edox <span class="operator">&lt;-</span> setReadable<span class="punctuation">(</span>ego<span class="punctuation">,</span> <span class="string">&#x27;org.Hs.eg.db&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;ENTREZID&#x27;</span><span class="punctuation">)</span></span><br><span class="line">p1 <span class="operator">&lt;-</span> cnetplot<span class="punctuation">(</span>edox<span class="punctuation">,</span> foldChange<span class="operator">=</span>geneList<span class="punctuation">)</span></span><br><span class="line"><span class="comment">## categorySize can be scaled by &#x27;pvalue&#x27; or &#x27;geneNum&#x27;</span></span><br><span class="line">p2 <span class="operator">&lt;-</span> cnetplot<span class="punctuation">(</span>edox<span class="punctuation">,</span> categorySize<span class="operator">=</span><span class="string">&quot;pvalue&quot;</span><span class="punctuation">,</span> foldChange<span class="operator">=</span>geneList<span class="punctuation">)</span></span><br><span class="line">p3 <span class="operator">&lt;-</span> cnetplot<span class="punctuation">(</span>edox<span class="punctuation">,</span> foldChange<span class="operator">=</span>geneList<span class="punctuation">,</span> circular <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> colorEdge <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span> </span><br><span class="line">cowplot<span class="operator">::</span>plot_grid<span class="punctuation">(</span>p1<span class="punctuation">,</span> p2<span class="punctuation">,</span> p3<span class="punctuation">,</span> ncol<span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span> labels<span class="operator">=</span><span class="built_in">LETTERS</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">3</span><span class="punctuation">]</span><span class="punctuation">,</span> rel_widths<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">.8</span><span class="punctuation">,</span> <span class="number">.8</span><span class="punctuation">,</span> <span class="number">1.2</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<img src="http://yulab-smu.top/biomedical-knowledge-mining-book/biomedicalKnowledge_files/figure-html/Networkplot-1.png" title="Network plot of enriched terms" width="90%"/>

<p><strong><p align="center">Figure 3. Network plot of enriched terms</strong><br>from <a href="http://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html">clusterProfiler book</a></p></p>
<ol start="4">
<li>可视化heatplot —— 类热图功能分类<br>同样使用edox。<br>heatplot类似cnetplot，而显示为热图的关系。<br>如果用户想要显示大量重要术语，那么类别网络图可能会过于复杂。在heatplot能够简化结果和更容易识别的表达模式。</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p1 <span class="operator">&lt;-</span> heatplot<span class="punctuation">(</span>edox<span class="punctuation">,</span> showCategory<span class="operator">=</span><span class="number">5</span><span class="punctuation">)</span></span><br><span class="line">p2 <span class="operator">&lt;-</span> heatplot<span class="punctuation">(</span>edox<span class="punctuation">,</span> foldChange<span class="operator">=</span>geneList<span class="punctuation">,</span> showCategory<span class="operator">=</span><span class="number">5</span><span class="punctuation">)</span></span><br><span class="line">cowplot<span class="operator">::</span>plot_grid<span class="punctuation">(</span>p1<span class="punctuation">,</span> p2<span class="punctuation">,</span> ncol<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span> labels<span class="operator">=</span><span class="built_in">LETTERS</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<img src="http://yulab-smu.top/biomedical-knowledge-mining-book/biomedicalKnowledge_files/figure-html/Heatplot-1.png" title="Heatmap plot of enriched terms" width="90%"/>

<p><strong><p align="center">Figure 4. Heatmap plot of enriched terms</strong><br>from <a href="http://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html">clusterProfiler book</a></p></p>
<ol start="5">
<li>可视化treeplot —— 树状图<br>treeplot()函数执行丰富术语的层次聚类。它依赖于pairwise_termsim()函数计算的丰富项的成对相似性，默认情况下使用 Jaccard 的相似性指数 (JC)。如果支持，用户还可以使用语义相似度值（例如，GO、DO和MeSH）。</li>
</ol>
<p>默认聚合方法treeplot()是ward.D，用户可以通过hclust_method参数指定其他方法（例如，’average’、’complete’、’median’、’centroid’等。</p>
<p>treeplot()函数会将树切割成几个子树（由nCluster参数指定（默认为 5））并使用高频词标记子树。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">edox2 <span class="operator">&lt;-</span> pairwise_termsim<span class="punctuation">(</span>edox<span class="punctuation">)</span></span><br><span class="line">p1 <span class="operator">&lt;-</span> treeplot<span class="punctuation">(</span>edox2<span class="punctuation">)</span></span><br><span class="line">p2 <span class="operator">&lt;-</span> treeplot<span class="punctuation">(</span>edox2<span class="punctuation">,</span> hclust_method <span class="operator">=</span> <span class="string">&quot;average&quot;</span><span class="punctuation">)</span></span><br><span class="line">aplot<span class="operator">::</span>plot_list<span class="punctuation">(</span>p1<span class="punctuation">,</span> p2<span class="punctuation">,</span> tag_levels<span class="operator">=</span><span class="string">&#x27;A&#x27;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<img src="http://yulab-smu.top/biomedical-knowledge-mining-book/biomedicalKnowledge_files/figure-html/treeplot-1.png" title="Tree plot of enriched terms" width="90%"/>

<p><strong><p align="center">Figure 5. Tree plot of enriched terms</strong><br>from <a href="http://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html">clusterProfiler book</a></p></p>
<ol start="6">
<li>可视化emapplot —— 富集图<br>对于富集到的GO terms之间的基因重叠关系进行展示，如果两个GO terms系的差异基因存在重叠，说明这两个节点存在overlap关系，在图中用线条连接起来。每个节点是一个富集到的GO term, 默认画top30个富集到的GO terms, 节点大小对应该GO terms下富集到的差异基因个数，节点的颜色对应p.adjust的值，从小到大，对应蓝色到红色。</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ego2 <span class="operator">&lt;-</span> pairwise_termsim<span class="punctuation">(</span>ego<span class="punctuation">)</span></span><br><span class="line">p1 <span class="operator">&lt;-</span> emapplot<span class="punctuation">(</span>ego2<span class="punctuation">)</span></span><br><span class="line">p2 <span class="operator">&lt;-</span> emapplot<span class="punctuation">(</span>ego2<span class="punctuation">,</span> cex_category<span class="operator">=</span><span class="number">1.5</span><span class="punctuation">)</span></span><br><span class="line">p3 <span class="operator">&lt;-</span> emapplot<span class="punctuation">(</span>ego2<span class="punctuation">,</span> layout<span class="operator">=</span><span class="string">&quot;kk&quot;</span><span class="punctuation">)</span></span><br><span class="line">p4 <span class="operator">&lt;-</span> emapplot<span class="punctuation">(</span>ego2<span class="punctuation">,</span> cex_category<span class="operator">=</span><span class="number">1.5</span><span class="punctuation">,</span>layout<span class="operator">=</span><span class="string">&quot;kk&quot;</span><span class="punctuation">)</span> </span><br><span class="line">cowplot<span class="operator">::</span>plot_grid<span class="punctuation">(</span>p1<span class="punctuation">,</span> p2<span class="punctuation">,</span> p3<span class="punctuation">,</span> p4<span class="punctuation">,</span> ncol<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span> labels<span class="operator">=</span><span class="built_in">LETTERS</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<img src="http://yulab-smu.top/biomedical-knowledge-mining-book/biomedicalKnowledge_files/figure-html/Enrichment-1.png" title="Plot for results obtained from hypergeometric test and gene set enrichment analysis" width="90%"/>

<p><strong><p align="center">Figure 6. Plot for results obtained from hypergeometric test and gene set enrichment analysis. default (A), cex_category&#x3D;1.5 (B), layout&#x3D;”kk” (C) and cex_category&#x3D;1.5,layout&#x3D;”kk” (D).</strong><br>from <a href="http://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html">clusterProfiler book</a></p></p>
<ol start="7">
<li>可视化upsetplot —— upset图<br>upsetplot是cnetplot可视化基因和基因集之间复杂关联的替代方法。它强调不同基因集之间的基因重叠。</li>
</ol>
<p><code>upsetplot(ego)</code></p>
<img src="http://yulab-smu.top/biomedical-knowledge-mining-book/biomedicalKnowledge_files/figure-html/upsetORA-1.png" title=" Upsetplot for over-representation analysis" width="90%"/>

<p><strong><p align="center">Figure 7. Upsetplot for over-representation analysis.</strong><br>from <a href="http://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html">clusterProfiler book</a></p></p>
<ol start="8">
<li>可视化ridgeplot —— 脊线图<br>ridgeplot将可视化核心富集基因的表达分布为GSEA富集类别。它帮助用户解释上调&#x2F;下调的途径。</li>
</ol>
<p><code>ridgeplot(ego)</code></p>
<img src="http://yulab-smu.top/biomedical-knowledge-mining-book/biomedicalKnowledge_files/figure-html/ridgeplot-1.png" title=" Ridgeplot for gene set enrichment analysis" width="90%"/>

<p><strong><p align="center">Figure 8. Ridgeplot for gene set enrichment analysis.</strong><br>from <a href="http://yulab-smu.top/biomedical-knowledge-mining-book/enrichplot.html">clusterProfiler book</a></p></p>
<h2 id="2-2-可视化plotGOgraph-x2F-goplot-——-有向无环图"><a href="#2-2-可视化plotGOgraph-x2F-goplot-——-有向无环图" class="headerlink" title="2.2. 可视化plotGOgraph&#x2F;goplot —— 有向无环图"></a>2.2. 可视化plotGOgraph&#x2F;goplot —— 有向无环图</h2><ol>
<li><code>plotGOgraph(ego, firstSigNodes=10)</code></li>
</ol>
<ul>
<li>有向无环图(Directed acyclic graph, DAG)，矩形代表富集到的top10个GO Terms，颜色从黄到红，对应p值从大到小。和<a href="https://yanzhongsino.github.io/2021/11/13/bioinfo_GSEA_topGO/">topGO做富集分析</a>的DAG图一样。</li>
</ul>
<p>当enrichGO富集分析时ont参数选了ALL时，结果文件会在第一列前增加一列ONTOLOGY为子类，这时直接用于plotGOgraph画图会报错。<br><strong>试了下，下面两种方案还是会报错Error in if (!ont %in% c(“BP”, “MF”, “CC”)) { :argument is of length zero。</strong>。还是尽量在enrichGO分析时就用ont&#x3D;”BP”吧。</p>
<ul>
<li>可以在结果文件中筛选出特定子类(比如BP)的结果行，并删除第一列ONTOLOGY后保存文件，再读进R用于plotGOgraph画图。</li>
<li>也可以在R内用命令<code>ego2&lt;-ego%&gt;%filter(ONTOLOGY== &quot;BP&quot;)</code>筛选BP子类，接着用<code>ego3&lt;-ego2%&gt;%select(!ONTOLOGY)</code>或者<code>ego3&lt;-ego2[,-1]</code>删除第一列(即ONTOLOGY列)，然后用<code>plotGOgraph(ego3)</code>作图。</li>
</ul>
<img src="http://guangchuangyu.github.io/blog_images/Bioconductor/clusterProfiler/2016_GO_analysis_using_clusterProfiler_files/figure-markdown_strict/unnamed-chunk-7-4.png" title=" DAG图" width="90%"/>

<p><strong><p align="center">Figure 9. DAG图</strong><br>from <a href="https://guangchuangyu.github.io/2016/01/go-analysis-using-clusterprofiler/">clusterProfiler blog</a></p></p>
<ol start="2">
<li><code>goplot(ego, showCategory = 10)</code></li>
</ol>
<ul>
<li>igraph布局方式的有向无环图</li>
</ul>
<img src="https://yulab-smu.top/biomedical-knowledge-mining-book/biomedicalKnowledge_files/figure-html/goplot-1.png" title=" goplot的DAG图" width="90%"/>

<p><strong><p align="center">Figure 10. goplot的DAG图</strong><br>from <a href="https://yulab-smu.top/biomedical-knowledge-mining-book/clusterprofiler-go.html">clusterProfiler book</a></p></p>
<h2 id="2-3-可视化-——-wordcloud"><a href="#2-3-可视化-——-wordcloud" class="headerlink" title="2.3. 可视化 —— wordcloud"></a>2.3. 可视化 —— wordcloud</h2><p>词云的方式显示结果</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;wordcloud&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>wordcloud<span class="punctuation">)</span></span><br><span class="line">wcdf <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span>text <span class="operator">=</span> ego<span class="operator">$</span>GeneRatio<span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;/&quot;</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">wcdf<span class="operator">$</span>term <span class="operator">&lt;-</span>  ego<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">wordcloud<span class="punctuation">(</span>words <span class="operator">=</span> wcdf<span class="operator">$</span>term<span class="punctuation">,</span> freq <span class="operator">=</span> wcdf<span class="operator">$</span>V1<span class="punctuation">,</span> scale<span class="operator">=</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span> <span class="number">.1</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> colors<span class="operator">=</span>brewer.pal<span class="punctuation">(</span><span class="number">8</span><span class="punctuation">,</span> <span class="string">&quot;Dark2&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> max.words <span class="operator">=</span> <span class="number">25</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/bioinfo_GSEA_clusterProfiler_wordcloud.png?raw=true" title="wordcloud词云图" width="60%"/>

<p><strong><p align="center">Figure 11. wordcloud词云图</strong><br>from <a href="https://learn.gencore.bio.nyu.edu/rna-seq-analysis/over-representation-analysis/">NGS Analysis ebook</a></p></p>
<h1 id="3-导出可视化结果"><a href="#3-导出可视化结果" class="headerlink" title="3. 导出可视化结果"></a>3. 导出可视化结果</h1><ol>
<li>Rstudio</li>
</ol>
<p>如果是在Rstudio中，可以直接看到绘图结果，导出需要的文件格式即可。</p>
<ol start="2">
<li>代码导出<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pdf<span class="punctuation">(</span><span class="string">&quot;ego.pdf&quot;</span><span class="punctuation">)</span> <span class="comment">#如果保存png，就改成png(&quot;ego.png&quot;)</span></span><br><span class="line">ego_fig<span class="operator">&lt;-</span>barplot<span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="comment">#画图函数</span></span><br><span class="line">print<span class="punctuation">(</span>ego_fig<span class="punctuation">)</span> <span class="comment">#画到pdf文件</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment">#关闭pdf画板</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li>clusterProfiler github：<a href="https://github.com/YuLab-SMU/clusterProfiler">https://github.com/YuLab-SMU/clusterProfiler</a></li>
<li>clusterProfiler paper：<a href="https://www.cell.com/the-innovation/fulltext/S2666-6758(21)00066-7?_returnURL=https://linkinghub.elsevier.com/retrieve/pii/S2666675821000667?showall=true">https://www.cell.com/the-innovation/fulltext/S2666-6758(21)00066-7?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS2666675821000667%3Fshowall%3Dtrue</a></li>
<li>clusterProfiler book：<a href="http://yulab-smu.top/biomedical-knowledge-mining-book/index.html">http://yulab-smu.top/biomedical-knowledge-mining-book/index.html</a></li>
<li>clusterProfiler manual：<a href="https://bioconductor.org/packages/devel/bioc/manuals/clusterProfiler/man/clusterProfiler.pdf">https://bioconductor.org/packages/devel/bioc/manuals/clusterProfiler/man/clusterProfiler.pdf</a></li>
<li>clusterProfiler ducumentation：<a href="https://guangchuangyu.github.io/software/clusterProfiler/documentation/">https://guangchuangyu.github.io/software/clusterProfiler/documentation/</a></li>
<li>其他来源结果可视化：<a href="https://cloud.tencent.com/developer/article/1613815">https://cloud.tencent.com/developer/article/1613815</a></li>
<li>wordcloud：<a href="https://learn.gencore.bio.nyu.edu/rna-seq-analysis/over-representation-analysis/">https://learn.gencore.bio.nyu.edu/rna-seq-analysis/over-representation-analysis/</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>
]]></content>
      <categories>
        <category>bioinfo</category>
        <category>enrichment</category>
      </categories>
      <tags>
        <tag>gene set enrichment analysis</tag>
        <tag>GSEA</tag>
        <tag>enrichment analysis</tag>
        <tag>over representation analysis</tag>
        <tag>ORA</tag>
        <tag>clusterProfiler</tag>
        <tag>visualization</tag>
      </tags>
  </entry>
  <entry>
    <title>富集分析：（一）概述</title>
    <url>/2021/11/12/bioinfo_enrichment_intro/</url>
    <content><![CDATA[<div align="middle"><iframe width="298" height="52" src="https://www.youtube.com/embed/wcOM3Rx43ko" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>

<p>（全文约​6600字）</p>
<h1 id="1-富集分析"><a href="#1-富集分析" class="headerlink" title="1. 富集分析"></a>1. 富集分析</h1><h2 id="1-1-富集分析概念"><a href="#1-1-富集分析概念" class="headerlink" title="1.1. 富集分析概念"></a>1.1. 富集分析概念</h2><ol>
<li><p>富集分析<br>富集分析，本质上是对数据的分布检验，如果分布集中在某个区域，则认为富集。<br>常用的分布检验方法有卡方检验、Fisher精确检验以及KS检验等方法。</p>
</li>
<li><p>生物信息学领域的富集分析<br>在 <strong>背景基因集(N)</strong> 下获得 <strong>一组特定基因集(S)</strong> ，S可能是基因列表，表达图谱，基因芯片等形式。在预先构建好<strong>基因注释数据库</strong>(例如GO,KEGG等)已对背景基因集(N)根据生物功能或过程进行分类的前提下，通过<strong>统计学算法</strong>找出有那些显著区别于背景基因集(N)的类别(生物组成&#x2F;功能&#x2F;过程)，或者找出这组特定基因集间在生物组成&#x2F;功能&#x2F;过程的共性，经过聚类后去除冗余得到基因富集结果的过程，即为富集分析。</p>
</li>
</ol>
<p>可以这样简单理解富集分析在做什么。全国人口的户籍作为背景数据，我们通过富集分析可以知道相对于全国背景，客家人是不是明显在广东聚集。比如如果广东的客家人数&#x2F;全国客家人数这个比值远超过广东人数&#x2F;全国人数的比值，那么我们可以说客家人在广东是富集的。</p>
<ol start="3">
<li>常用数据</li>
</ol>
<ul>
<li>其中，<strong>背景基因集(N)</strong> 常常是一个物种的基因组注释基因总和。</li>
<li>一组<strong>特定基因集(S)</strong> 常常是差异表达基因集(differentially expressed genes, DEGs)。</li>
<li>预先构建好<strong>基因注释数据库</strong>常用GO或KEGG数据库。</li>
<li>常见的<strong>统计学算法</strong>包括ORA,FCS,PT,NT四种。</li>
</ul>
<ol start="4">
<li>实际应用<br>通常会使用其他分析的结果作为**特定基因集(S)**，做基因富集分析来查看这些基因集是否主要集中在某些类别，这些类别代表的功能是否与表型或者进化事件有关联。比如：</li>
</ol>
<ul>
<li>比较转录组分析得到的差异表达基因集；</li>
<li>比较基因组分析中得到的某物种特有的基因集；</li>
<li>基因家族收缩扩张分析得到的基因组中显著扩张&#x2F;收缩的基因集；</li>
<li>基因组共线性分析中在全基因组复制事件附近的Ks值的基因集等各种分析得到的基因集；</li>
</ul>
<h2 id="1-2-富集分析的算法"><a href="#1-2-富集分析的算法" class="headerlink" title="1.2. 富集分析的算法"></a>1.2. 富集分析的算法</h2><p>富集分析算法经过发展，常见的有四类：</p>
<img src="https://www.sciengine.com/figures/figures-29603243e0234a3cb08e1f7155debca6-picobject1.png" title="富集分析四类算法" width="90%"/>

<p><strong><p align="center">Figure 1. 富集分析四类算法</strong><br>from <a href="https://www.sciengine.com/SSV/article?doi=10.1360/N052016-00139&scroll=">paper:Progress in Gene Functional Enrichment Analysis</a></p></p>
<h3 id="1-2-1-过表达分析-Over-Representation-Analysis-ORA"><a href="#1-2-1-过表达分析-Over-Representation-Analysis-ORA" class="headerlink" title="1.2.1. 过表达分析(Over Representation Analysis, ORA)"></a>1.2.1. 过表达分析(Over Representation Analysis, ORA)</h3><ol>
<li>过表达分析(ORA)概念<br>过表达分析(ORA)是对背景基因集(N)和特定基因集(S)按照已知的基因功能或通路等分组，并鉴定特定基因集(S)在哪些组包含比背景基因集(N)比例更多的基因(过度表达，over-represented，即富集enriched)或更少的基因(表达不足，under-represented)的一种统计学方法。</li>
</ol>
<p>ORA是出现最早，最常用，有完善的统计学理论基础的方法。ORA重点在于通过基因集组成的比例来判断富集程度。</p>
<ol start="2">
<li>过表达分析的分布检验<br>ORA类方法用的是离散分布的检验（Fisher精确检验，依据超几何分布的原理）。</li>
</ol>
<p>超几何分布有很多资料可参考，比如：<a href="https://www.jianshu.com/p/13f46bebebd4">https://www.jianshu.com/p/13f46bebebd4</a></p>
<ol start="3">
<li>过表达分析(ORA)的局限性</li>
</ol>
<ul>
<li>ORA使用的统计方法(例如超几何分布，二项分布，卡方分布)只考虑差异基因数量，忽略了差异程度(不同表达水平)，，需要人为设置阈值，没有一个设置规定，阈值设置有主观性。</li>
<li>通过一刀切的人为规定的阈值，找出差异最显著的单个基因，而忽略其他基因，比如差异小但变化方向一致的基因集，往往后者比前者更重要。</li>
<li>利用的统计学假设每个基因相互独立，但是就生物体本身而言，忽略了基因间内部的复杂的相互作用，并且每个基因在不同的生物学过程中发挥的作用大小不一样，同等看待结果可能会不准确。</li>
<li>假设每条通路都独立其他通路。</li>
</ul>
<ol start="4">
<li>过表达分析(ORA)的实际操作<br>需要四组数据：</li>
</ol>
<ul>
<li>背景基因集(N)：常常是一个物种的基因组注释基因总和</li>
<li>特定基因集(S)：常常是差异表达基因集(differentially expressed genes, DEGs)</li>
<li>背景基因集的分类信息：常常通过注释数据库(GO,KEGG等)和背景基因集获得</li>
<li>特定基因集的分类信息：常常通过注释数据库(GO,KEGG等)和特定基因集获得</li>
</ul>
<p>通过四组数据获得基因数量的2×2列联表，再利用fisher精确检验或超几何分布得到p值。认为设置一个显著性阈值，高于阈值的即为富集基因。</p>
<h3 id="1-2-2-功能分类打分-Functional-Class-Scoring-FCS"><a href="#1-2-2-功能分类打分-Functional-Class-Scoring-FCS" class="headerlink" title="1.2.2. 功能分类打分(Functional Class Scoring,FCS)"></a>1.2.2. 功能分类打分(Functional Class Scoring,FCS)</h3><h4 id="1-2-2-1-功能分类打分-FCS"><a href="#1-2-2-1-功能分类打分-FCS" class="headerlink" title="1.2.2.1. 功能分类打分(FCS)"></a>1.2.2.1. 功能分类打分(FCS)</h4><ol>
<li><p>功能分类打分(FCS)概念和改进<br>功能分类打分(FCS)与ORA相比进行了基本假设的改变，除了考虑单个基因的显著变化外，还考虑微效基因的叠加效果。代表是基因集富集分析(Gene Set Enrichment Analysis, GSEA)</p>
</li>
<li><p>FCS分析的三个步骤</p>
</li>
</ol>
<ul>
<li>计算单个基因表达水平的统计值，采用如衡量差异基因的ANOVA、Q-statistic、t检验、Z-score、信噪比，进行打分或排序，或者直接使用排序好的基因表达谱</li>
<li>同一通路上所有基因的表达水平统计值进行整合，汇集成单个通路水平的分数或统计值，采用基因水平统计的和、均值或中位数，Wilcoxon rank sum, Maxmean statistic, Kolmogorov-Smirnov statistic</li>
<li>对通路水平的显著性进行评估：利用重抽样(bootstrap)的统计学方法</li>
</ul>
<ol start="3">
<li>功能分类打分(FCS)的优势(与ORA相比)</li>
</ol>
<ul>
<li>不需要人为规定的阈值来一刀切显著性</li>
<li>FCS考虑同一通路中基因表达的协调变化，即考虑微效基因的叠加效果。</li>
<li>通过考虑基因表达的协调变化，FCS 方法解释了通路中基因之间的依赖性</li>
</ul>
<ol start="4">
<li>功能分类打分(FCS)的限制</li>
</ol>
<ul>
<li>与 ORA 类似，FCS 独立分析每个通路。一个基因可以在多个通路中发挥作用，这意味着这些通路可以交叉和重叠。</li>
<li>许多 FCS 方法使用基因表达的变化来对给定通路中的基因进行排序，并丢弃进一步分析的变化。例如，假设通路中的两个基因 A 和 B 分别发生 2 倍和 20 倍的变化。只要它们与通路中的其他基因相比具有相同的各自等级，大多数 FCS 方法都会平等地对待它们。</li>
</ul>
<h4 id="1-2-2-2-基因富集分析-gene-set-enrichment-analysis-GSEA"><a href="#1-2-2-2-基因富集分析-gene-set-enrichment-analysis-GSEA" class="headerlink" title="1.2.2.2. 基因富集分析(gene set enrichment analysis, GSEA)"></a>1.2.2.2. 基因富集分析(gene set enrichment analysis, GSEA)</h4><p>基因富集分析(GSEA)是FCS算法中最常用的一种。</p>
<ol>
<li>基因富集分析(GSEA)的原理</li>
</ol>
<ul>
<li>基因排序<br>首先，根据各基因与表型间相关性r或两组间t检验统计量得分值对背景基因集(N)进行降序排列，比如把所有基因在两个分组(或表型)中的差异度从大到小排序，形成排好序的基因列表。</li>
<li>基因富集<br>查看基因注释数据库(GO&#x2F;KEGG)中每个小组基因集(例如GO一个通路一个小组)里的基因是否在排序的背景基因集里均匀分布，或者主要分布在排序背景基因集的顶部&#x2F;底部。均匀分布说明不在这两个分组(或表型)中富集，集中分布在顶部&#x2F;底部说明这个小组基因集在两个分组(表型)之一富集。</li>
<li>富集分析<br>计算每一小组基因集的富集分数(enrichment score,ES)值，然后对ES值进行显著性检验和多重假设检验，计算得出显著富集的基因集。</li>
</ul>
<ol start="2">
<li>基因富集分析(GSEA)分析步骤</li>
</ol>
<ul>
<li>计算富集分数(enrichment score,ES)：对每一个小组基因集，遍历排好序的背景基因集(N)，当基因出现在特定基因集(S)就加分，反之减分，加减分值由基因与表型的相关性决定。</li>
<li>估计ES的统计显著性：基于样品的置换检验可以计算P值。</li>
<li>多重假设检验矫正：根据每一小组基因集的大小对每个基因的ES做标准化，得到标准化NES（normalized enrichment score ，NES）。为了检验每一小组基因集的NES是否显著，将排好序的背景基因集(N)随机打乱排列一定次数，每次都计算每个基因集的NES(ES)，得到每个基因集的NES在随机排序情况下的理论分布，从而计算其p值。若p&lt;0.05，则说明该基因集在有序背景基因集(N)中大都富集在顶部，为富集基因集。FDR则是对p值进行FDR校正之后的p值。</li>
</ul>
<h3 id="1-2-3-通路拓扑-Pathway-Topology-PT"><a href="#1-2-3-通路拓扑-Pathway-Topology-PT" class="headerlink" title="1.2.3. 通路拓扑(Pathway Topology,PT)"></a>1.2.3. 通路拓扑(Pathway Topology,PT)</h3><ol>
<li>背景</li>
</ol>
<ul>
<li>大量公开可用的通路数据库提供的信息超出了每个通路的简单基因列表。与 GO 和分子特征数据库 (MSigDB) 不同，这些知识库还提供有关在给定途径中相互作用的基因产物、它们如何相互作用（例如，激活、抑制等）以及它们在何处相互作用（例如、细胞质、细胞核等）。这些知识库包括 KEGG、MetaCyc、Reactome、RegulonDB、STKE ( <a href="http://stke.sciencemag.org/">http://stke.sciencemag.org</a> )、BioCarta ( <a href="http://www.biocarta.com/">http://www.biocarta.com</a> )、和 PantherDB等。</li>
<li>ORA 和 FCS 方法仅考虑通路中的基因数量或基因共表达来识别重要通路，而忽略这些知识库中可用的附加信息。因此，即使通过基因之间的新联系完全重新绘制了通路，只要它们包含相同的基因组，ORA 和 FCS 也会产生相同的结果。</li>
<li>已经开发的通路拓扑 (PT) 的方法则利用这些通路数据库的附加信息。</li>
<li>通路路径拓扑 (PT) 的方法本质上与 FCS 方法相同，因为它们执行与 FCS 方法相同的三个步骤。两者之间的主要区别在于使用通路拓扑来计算基因水平的统计数据。</li>
</ul>
<ol start="2">
<li>通路拓扑(PT)<br>在通路的富集分析中，一般上游基因的表达水平改变要显著大于下游基因对整个通路的影响。PT方法就是把基因在通路中的位置，和其他基因的互作和调控关系结合在一起，评估每个基因对通路的贡献并算出权重，然后把权重整合到富集分析。</li>
</ol>
<p>代表是SPIA，由于可用数据库的限制，应用还很少。</p>
<h3 id="1-2-4-网络拓扑结构-Network-Topology-NT"><a href="#1-2-4-网络拓扑结构-Network-Topology-NT" class="headerlink" title="1.2.4. 网络拓扑结构(Network Topology,NT)"></a>1.2.4. 网络拓扑结构(Network Topology,NT)</h3><p>利用现有的全基因组范围的生物网络，提取数据库的基因相互作用关系（如：基因连接度、基因在网络中的距离），把基因的生物学属性整合到功能分析。利用网络拓扑结构来计算基因对特定生物通路的重要性并给予相应的权重，再利用传统的ORA 或 FCS 方法来评估特定生物通路的富集程度，如GANPA 和 LEGO。缺点就是算法太复杂，计算速度慢。</p>
<h1 id="2-富集分析常用基因集"><a href="#2-富集分析常用基因集" class="headerlink" title="2. 富集分析常用基因集"></a>2. 富集分析常用基因集</h1><h2 id="2-1-Gene-Ontology-GO"><a href="#2-1-Gene-Ontology-GO" class="headerlink" title="2.1. Gene Ontology(GO)"></a>2.1. Gene Ontology(GO)</h2><h3 id="2-1-1-GO"><a href="#2-1-1-GO" class="headerlink" title="2.1.1. GO"></a>2.1.1. GO</h3><ul>
<li>GO是一个国际标准化的基因功能分类体系，由基因本体联合会(Gene Ontology Consortium，GOC) 负责。它提供了一套动态并可控的词汇表（controlled vocabulary）来全面描述生物体中基因和基因产物的属性，它由一组预先定义好的GO术语（GO term）组成，这组术语对基因产物的功能进行限定和描述。</li>
<li>可在<a href="http://geneontology.org/">GO官网</a>)使用的<a href="http://amigo.geneontology.org/amigo/landing">AmiGO2网站</a>查询GO ID和GO term信息。之前常用的<a href="https://wego.genomics.cn/">WEGO 2.0</a>也可以查询。</li>
</ul>
<p>GO由三个ontology（本体）组成，是由独立的术语表示的，分别描述基因的细胞组分（cellular component，CC）、分子功能（molecular function，MF）、参与的生物过程（biological process，BP）。</p>
<p>GO这三个本体的含义：</p>
<ol>
<li>细胞组成（cellular component，CC）：描述基因产物执行功能的细胞结构相关的位置，比如一个蛋白可能定位在细胞核中，也可能定位在核糖体中；</li>
<li>分子功能（Molecular Function，MF）：描述基因产物发生在分子水平上的活动，例如催化或运输。通常对应于单个基因产物（即蛋白质或RNA）可以进行的活动。常见的宽泛的分子功能描述是催化活性(catalytic activity)和转运活动(transporter activity)。为了避免与基因产物名称混淆，通常分子功能描述后加上”activity”一词。</li>
<li>生物过程（biological process，BP）：描述的是指基因产物所关联的一个大的生物功能，或者说是多个分子活动完成的一个大的生物程序。例如有丝分裂或嘌呤代谢；</li>
</ol>
<h3 id="2-1-2-GO-terms"><a href="#2-1-2-GO-terms" class="headerlink" title="2.1.2. GO terms"></a>2.1.2. GO terms</h3><p>GO terms，它提供生物过程的逻辑结构与相关关系，不同GO terms之间的关系可以通过一个有向无环图来表示。</p>
<p>此处需要注意的是，GO terms是对<strong>基因产物</strong>，而不是基因本身进行描述，因为基因本身的产物有时候不止一种。GO数据库中的GO分类相关信息会得到不断地更新与增加，这个特点要记住，因为不同的GO分析工具使用的数据库版本有可能不一样，造成GO分析结果出现不同。</p>
<h3 id="2-1-3-GO-annotations"><a href="#2-1-3-GO-annotations" class="headerlink" title="2.1.3. GO annotations"></a>2.1.3. GO annotations</h3><p>GO注释（GO annotations）是关于特定基因功能的声明，它主要是将GO terms和基因或基因产物相关联来提供注释，也就是描述这个GO terms关联的基因产物是什么（蛋白质，还是非编码RNA，还是大分子等），有什么功能，如何在分子水平发挥作用，在细胞中的哪个位置发挥作用，以及它有助于执行哪些生物过程(途径、程序)。</p>
<h2 id="2-2-Kyoto-Encyclopedia-of-Genes-and-Genomes-KEGG"><a href="#2-2-Kyoto-Encyclopedia-of-Genes-and-Genomes-KEGG" class="headerlink" title="2.2. Kyoto Encyclopedia of Genes and Genomes(KEGG)"></a>2.2. Kyoto Encyclopedia of Genes and Genomes(KEGG)</h2><h3 id="2-2-1-KEGG"><a href="#2-2-1-KEGG" class="headerlink" title="2.2.1. KEGG"></a>2.2.1. KEGG</h3><ul>
<li>KEGG是处理基因组，生物通路，疾病，药物，化学物质的数据库集合，于1995年由京都大学化学研究所教授Minoru Kanehisa在当时正在进行的日本人类基因组计划下发起。</li>
<li>KEGG 是一种数据库资源，用于从基因组和分子级信息了解生物系统（例如细胞、生物体和生态系统）的高级功能和效用。它是生物系统的计算机表示，由基因和蛋白质（基因组信息）和化学物质（化学信息）的分子构建块组成，它们与相互作用、反应和关系网络（系统信息）的分子接线图知识相结合。它还包含疾病和药物信息（健康信息）作为对生物系统的扰动。</li>
</ul>
<p><a href="https://www.kegg.jp/kegg/">KEGG网站</a>提供了KEGG信息查询入口，包括<a href="https://www.kegg.jp/kegg/pathway.html">KEGG Pathway</a>中查询KEGG Pathway ID(ko00000)的详细信息。</p>
<h3 id="2-2-2-KEGG-Database"><a href="#2-2-2-KEGG-Database" class="headerlink" title="2.2.2. KEGG Database"></a>2.2.2. KEGG Database</h3><p>KEGG 是一个集成的数据库资源，由如下所示的 16 个数据库组成。它们大致分为系统信息、基因组信息、化学信息和健康信息，它们通过网页的颜色编码来区分。</p>
<table>
<caption><h4>KEGG Database</h4></caption>
<thead>
<tr>
<th>Category</th>
<th>Database</th>
<th>Content</th>
<th>Color</th>
</tr>
</thead>
</tbody>
<tr>
<td rowspan="3">Systems information</td>
<td>KEGG PATHWAY</td>
<td>KEGG pathway maps</td>
<td rowspan="3"><font color=green>kegg3</br>green</font></td>
</tr>
<tr>
<td>KEGG BRITE</td>
<td>BRITE hierarchies and tables</td>
</tr>
<tr>
<td>KEGG MODULE</td>
<td>KEGG modules and reaction modules</td>
</tr>
<tr>
<td rowspan="3">Genomic information</td>
<td>KEGG ORTHOLOGY (KO)</td>
<td>Functional orthologs</td>
<td><font color=yellow>kegg4 yellow</font></td>
</tr>
<tr>
<td>KEGG GENES</td>
<td>Genes and proteins</td>
<td rowspan="2"><font color=red>kegg1</br>red</font></td>
</tr>
<tr>
<td>KEGG GENOME</td>
<td>KEGG organisms and viruses</td>
</tr>
<tr>
<td rowspan="4">Chemical information</td>
<td>KEGG COMPOUND</td>
<td>Metabolites and other chemical substances</td>
<td rowspan="4"><font color=blue>kegg2</br>blue</font></td>
</tr>
<tr>
<td>KEGG GLYCAN</td>
<td>Glycans</td>
</tr>
<tr>
<td>KEGG REACTION</br>KEGG RCLASS</td>
<td>Biochemical reactions</br>Reaction class</td>
</tr>
<tr>
<td>KEGG ENZYME</td>
<td>Enzyme nomenclature</td>
</tr>
<tr>
<td rowspan="4">Health information</td>
<td>KEGG NETWORK</td>
<td>Disease-related network variations</td>
<td rowspan="4"><font color=purple>kegg5</br>purle</font></td>
</tr>
<tr>
<td>KEGG VARIANT</td>
<td>Human gene variants</td>
</tr>
<tr>
<td>KEGG DISEASE</td>
<td>Human diseases</td>
</tr>
<tr>
<td>KEGG DRUG</br>KEGG DGROUP</td>
<td>Drugs</br>Drug groups</td>
</tr>
</tbody>
</table>

<h3 id="2-2-3-KEGG-PATHWAY-Database"><a href="#2-2-3-KEGG-PATHWAY-Database" class="headerlink" title="2.2.3. KEGG PATHWAY Database"></a>2.2.3. KEGG PATHWAY Database</h3><p>KEGG PATHWAY Database是KEGG资源的核心，是一组手工绘制的KEGG通路图，代表细胞和生物体的新陈代谢和各种其他功能的实验知识。每个通路图都包含一个分子相互作用和反应网络，旨在将基因组中的基因与通路中的基因产物（主要是蛋白质）联系起来。</p>
<h1 id="3-富集分析程序"><a href="#3-富集分析程序" class="headerlink" title="3. 富集分析程序"></a>3. 富集分析程序</h1><p>目前有许多程序可以用于富集分析。包括NASQAR,PlantRegMap,MSigDB,Broad Institute,WebGestalt,Enrichr,GeneSCF,DAVID,Metascape,AmiGO 2,GREAT,FunRich,FuncAssociate,InterMine,ToppGene Suite,QuSAGE,Blast2GO,g:Profiler。</p>
<p>可以根据需要分析的物种类别和数据库更新选择分析平台，根据需要选择先验基因集。</p>
<p>大部分富集分析程序都只支持已有数据库的物种的富集分析，如果是不在支持物种列表里的物种，可以用富集分析的R包做富集分析。</p>
<p>下面介绍几种常见的。</p>
<h2 id="3-1-NASQAR"><a href="#3-1-NASQAR" class="headerlink" title="3.1. NASQAR"></a>3.1. NASQAR</h2><p>NASQAR (Nucleic Acid SeQuence Analysis Resource)是一个开源的网页平台，可以用R包clusterProfiler做GSEA分析，支持<a href="http://bioconductor.org/packages/release/BiocViews.html#___OrgDb">Org.Db数据库</a>的所有物种的GO Term和KEGG Pathway富集分析。</p>
<h2 id="3-2-PlantRegMap"><a href="#3-2-PlantRegMap" class="headerlink" title="3.2. PlantRegMap"></a>3.2. PlantRegMap</h2><p><a href="http://plantregmap.gao-lab.org/go.php">PlantRegMap</a>，支持165种植物的GO注释和GO富集分析。</p>
<h2 id="3-3-Enrichr"><a href="#3-3-Enrichr" class="headerlink" title="3.3. Enrichr"></a>3.3. Enrichr</h2><p>Enrichr是针对哺乳动物的基因富集分析工具。可以通过API使用，并提供可视化结果。</p>
<h2 id="3-4-GeneSCF"><a href="#3-4-GeneSCF" class="headerlink" title="3.4. GeneSCF"></a>3.4. GeneSCF</h2><p>GeneSCF支持多个物种，实时的功能富集分析工具。不需要额外更新数据库，GeneSCF是实时最新的数据库，并且支持多物种富集分析。结果以文本呈现。</p>
<h2 id="3-5-DAVID"><a href="#3-5-DAVID" class="headerlink" title="3.5. DAVID"></a>3.5. DAVID</h2><p>DAVID是做注释，富集和可视化的整合的数据库。但注释数据库自从2016年10月就没有更新。</p>
<h2 id="3-6-Blast2GO"><a href="#3-6-Blast2GO" class="headerlink" title="3.6. Blast2GO"></a>3.6. Blast2GO</h2><p>Blast2GO可以做组学数据的功能注释和GSEA分析。</p>
<h2 id="3-7-KOBAS-i"><a href="#3-7-KOBAS-i" class="headerlink" title="3.7. KOBAS-i"></a>3.7. KOBAS-i</h2><h3 id="3-7-1-KOBAS-i简介"><a href="#3-7-1-KOBAS-i简介" class="headerlink" title="3.7.1. KOBAS-i简介"></a>3.7.1. KOBAS-i简介</h3><ol>
<li>KOBAS是中科院和北大联合开发的做功能注释和GSEA分析的工具。</li>
<li>目前已经发表了第三个版本，KOBAS-intelligence(KOBAS-i)，KOBAS-i引入了之前发布的基于机器学习的新方法CGPS，并扩展了可视化功能，支持的物种增加到5944个。</li>
<li>KOBAS包含注释模块和富集模块。</li>
</ol>
<ul>
<li>注释模块接受基因列表作为输入，包括 ID 或序列，并根据通路、疾病和GO信息等多个数据库为每个基因生成注释。</li>
<li>富集模块给出了关于哪些通路和 GO 术语与输入基因列表或表达在统计上显着相关的结果。有两种不同的富集分析可用，命名为基因列表富集和 exp-data 富集。</li>
</ul>
<ol start="4">
<li>KOBAS-i有网页版，也有本地版。</li>
</ol>
<h3 id="3-7-2-KOBAS-i网页版【推荐】"><a href="#3-7-2-KOBAS-i网页版【推荐】" class="headerlink" title="3.7.2. KOBAS-i网页版【推荐】"></a>3.7.2. KOBAS-i网页版【推荐】</h3><p>给了两个可用的网址：<a href="http://kobas.cbi.pku.edu.cn/%EF%BC%8Chttp://bioinfo.org/kobas%E3%80%82">http://kobas.cbi.pku.edu.cn/，http://bioinfo.org/kobas。</a><br><a href="http://kobas.cbi.pku.edu.cn/">KOBAS-i</a>。</p>
<h4 id="3-7-2-1-注释-annotation-和富集-Enrichment-的步骤"><a href="#3-7-2-1-注释-annotation-和富集-Enrichment-的步骤" class="headerlink" title="3.7.2.1. 注释(annotation)和富集(Enrichment)的步骤"></a>3.7.2.1. 注释(annotation)和富集(Enrichment)的步骤</h4><ol>
<li>输入<br>注释只有三个输入项：</li>
</ol>
<ul>
<li>选择物种。目前支持5944个物种。</li>
<li>选择输入基因集数据类型。支持核苷酸或者蛋白质的fasta序列，blast的Tabular输出结果，Ensembl Gene ID，Entrez Gene ID，UniProtKB AC，Gene Symbol。</li>
<li>输入基因集。可以粘贴文本，也可以上传文件。</li>
</ul>
<p>富集除了需要上面三个输入项外，还需要选择用哪写先验基因集的数据库来做富集分析。包括PATHWAY,DISEASE,GO。其中KEGG Pathway是所有物种都可以用，其他的只有部份物种可以选。</p>
<ul>
<li>PATHWAY。有四个选项，KEGG Pathway(K),Reactome(R),BioCyc(B),PANTHER(p)。</li>
<li>DISEASE。有三个选项，OMIM(o),KEGG Disease(k),NHGRI GWAS Catalog(N)</li>
<li>GO(G)。<br>此外还有高级选项，可以选择统计学方法和纠错方法。</li>
</ul>
<p>然后点击Run，就可以等待运行结果了。</p>
<ol start="2">
<li>结果<br>运行结束后，点击右上角的Download total terms就可以下载到结果。<br>富集分析还可以点击Visualization得到结果的可视化图。</li>
</ol>
<h2 id="3-8-GOEAST"><a href="#3-8-GOEAST" class="headerlink" title="3.8. GOEAST"></a>3.8. GOEAST</h2><p>在线工具<a href="http://omicslab.genetics.ac.cn/GOEAST/index.php">GOEAST</a></p>
<h1 id="4-富集分析的R包"><a href="#4-富集分析的R包" class="headerlink" title="4. 富集分析的R包"></a>4. 富集分析的R包</h1><p>如果是模式物种，或者已有数据库的物种，推荐在线网站<a href="http://plantregmap.gao-lab.org/go.php">PlantRegMap</a>和<a href="http://kobas.cbi.pku.edu.cn/">KOBAS-i</a>做GO和KEGG的富集分析。</p>
<p>常见的有topGO，clusterProfiler，有一些进行富集分析的程序使用了这些包。</p>
<h2 id="4-1-topGO"><a href="#4-1-topGO" class="headerlink" title="4.1. topGO"></a>4.1. topGO</h2><p>用topGO做富集分析的具体教程可以查看博文<a href="https://yanzhongsino.github.io/2021/11/13/bioinfo_enrichment_topGO/">blog_topGO</a>。</p>
<p>topGO是一个R包，用于半自动的GO terms的富集分析。topGO的结果可以展示为有向无环图。</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Tred-G.svg/800px-Tred-G.svg.png" width=40% title="DAG图" alt="DAG图" align=center/>

<p><strong><p align="center">Figure 2. DAG图示例</strong><br>from <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">wikipedia:directed acyclic graph</a></p></p>
<p>注：对每个GO节点进行富集，在图中用方框表示显著度最高的10个节点，图中还包含其各层对应关系。每个方框（或椭圆）内给出了该GO节点的内容描述和富集显著性值。不同颜色代表不同的富集显著性，颜色越深，显著性越高。</p>
<h2 id="4-2-clusterProfiler"><a href="#4-2-clusterProfiler" class="headerlink" title="4.2. clusterProfiler"></a>4.2. clusterProfiler</h2><p>clusterProfiler包的具体使用参考博文<a href="https://yanzhongsino.github.io/2021/12/13/bioinfo_enrichment_clusterProfiler/">blog_clusterProfiler</a>。</p>
<h3 id="4-2-1-clusterProfiler"><a href="#4-2-1-clusterProfiler" class="headerlink" title="4.2.1. clusterProfiler"></a>4.2.1. clusterProfiler</h3><p>clusterProfiler是一个R包，是一个解释组学数据的通用富集工具，支持Gene Ontology(GO), Kyoto Encyclopedia of Genes and Genomes(KEGG), Disease Ontology(DO), Disease Gene Network(DisGeNET), Molecular Signatures Database(MSigDb), wikiPathways和许多其他的基因集的功能注释和富集分析，以及富集分析结果的可视化。2021年07月发布了clusterProfiler 4.0版本。</p>
<h3 id="4-2-2-clusterProfiler支持的基因集-gene-sets"><a href="#4-2-2-clusterProfiler支持的基因集-gene-sets" class="headerlink" title="4.2.2. clusterProfiler支持的基因集(gene sets)"></a>4.2.2. clusterProfiler支持的基因集(gene sets)</h3><ol>
<li>Gene Ontology(GO)</li>
<li>Kyoto Encyclopedia of Genes and Genomes(KEGG)</li>
<li>Disease Ontology(DO)</li>
<li>Disease Gene Network(DisGeNET)</li>
<li>Molecular Signatures Database(MSigDb)</li>
<li>wikiPathways</li>
</ol>
<h3 id="4-2-3-clusterProfiler功能-——-enrichment-analysis"><a href="#4-2-3-clusterProfiler功能-——-enrichment-analysis" class="headerlink" title="4.2.3. clusterProfiler功能 —— enrichment analysis"></a>4.2.3. clusterProfiler功能 —— enrichment analysis</h3><ol>
<li>Over Representation Analysis, ORA<br>ORA是用于判断已知的生物功能或过程在实验产生的基因列表（例如差异表达基因列表, differentially expressed genes, DEGs）中是否过表达(over-represented&#x3D;enriched)的常用方法。</li>
<li>Gene Set Enrichment Analysis, GSEA</li>
<li>Leading edge analysis and core enriched genes</li>
</ol>
<h1 id="5-references"><a href="#5-references" class="headerlink" title="5. references"></a>5. references</h1><ol>
<li>GSEA wiki：<a href="https://en.wikipedia.org/wiki/Gene_set_enrichment_analysis">https://en.wikipedia.org/wiki/Gene_set_enrichment_analysis</a></li>
<li>paper-Ten Years of Pathway Analysis: Current Approaches and Outstanding Challenges：<a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002375">https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002375</a></li>
<li>paper-Progress in Gene Functional Enrichment Analysis：<a href="https://www.sciengine.com/SSV/article?doi=10.1360/N052016-00139&amp;scroll=">https://www.sciengine.com/SSV/article?doi=10.1360/N052016-00139&amp;scroll=</a></li>
<li>enrichment analysis：<a href="https://www.jianshu.com/p/be8fe1318850">https://www.jianshu.com/p/be8fe1318850</a></li>
<li>enrichment analysis methods：<a href="https://www.jianshu.com/p/042b888d5520">https://www.jianshu.com/p/042b888d5520</a></li>
<li>enrichment analysis methods：<a href="https://blog.csdn.net/fjsd155/article/details/103064166">https://blog.csdn.net/fjsd155/article/details/103064166</a></li>
<li>GOEAST introduction：<a href="https://mp.weixin.qq.com/s?__biz=MzI5MTcwNjA4NQ==&amp;mid=2247484456&amp;idx=1&amp;sn=bbcd0b5d10ba9312d92b7baae777ccde&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzI5MTcwNjA4NQ==&amp;mid=2247484456&amp;idx=1&amp;sn=bbcd0b5d10ba9312d92b7baae777ccde&amp;scene=21#wechat_redirect</a></li>
<li>topGO tutorial：<a href="https://bioconductor.org/packages/release/bioc/vignettes/topGO/inst/doc/topGO.pdf">https://bioconductor.org/packages/release/bioc/vignettes/topGO/inst/doc/topGO.pdf</a></li>
<li>topGO blog：<a href="https://datacatz.wordpress.com/2018/01/19/gene-set-enrichment-analysis-with-topgo-part-1/">https://datacatz.wordpress.com/2018/01/19/gene-set-enrichment-analysis-with-topgo-part-1/</a></li>
<li>R topGO：<a href="https://www.codenong.com/cs105162324/">https://www.codenong.com/cs105162324/</a></li>
<li>enrichment：<a href="https://www.jianshu.com/p/47b5ea646932">https://www.jianshu.com/p/47b5ea646932</a></li>
<li>GO explanation：<a href="https://www.jianshu.com/p/7177c372243f">https://www.jianshu.com/p/7177c372243f</a></li>
<li>GO overview：<a href="http://geneontology.org/docs/ontology-documentation/">http://geneontology.org/docs/ontology-documentation/</a></li>
<li>KEGG：<a href="https://en.wikipedia.org/wiki/KEGG">https://en.wikipedia.org/wiki/KEGG</a></li>
<li>clusterProfiler github：<a href="https://github.com/YuLab-SMU/clusterProfiler">https://github.com/YuLab-SMU/clusterProfiler</a></li>
<li>universal enrichment analysis using clusterProfiler：<a href="http://yulab-smu.top/biomedical-knowledge-mining-book/universal-api.html">http://yulab-smu.top/biomedical-knowledge-mining-book/universal-api.html</a></li>
<li>clusterProfiler paper：<a href="https://www.cell.com/the-innovation/fulltext/S2666-6758(21)00066-7?_returnURL=https://linkinghub.elsevier.com/retrieve/pii/S2666675821000667?showall=true">https://www.cell.com/the-innovation/fulltext/S2666-6758(21)00066-7?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS2666675821000667%3Fshowall%3Dtrue</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>enrichment</category>
      </categories>
      <tags>
        <tag>gene set enrichment analysis</tag>
        <tag>GSEA</tag>
        <tag>topGO</tag>
        <tag>enrichment analysis</tag>
        <tag>over representation analysis</tag>
        <tag>ORA</tag>
        <tag>clusterProfiler</tag>
        <tag>KOBAS-i</tag>
        <tag>GOEAST</tag>
      </tags>
  </entry>
  <entry>
    <title>富集分析：（二）topGO</title>
    <url>/2021/11/13/bioinfo_enrichment_topGO/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=116744&auto=1&height=32"></iframe></div>

<h1 id="1-富集分析-enrichment-analysis"><a href="#1-富集分析-enrichment-analysis" class="headerlink" title="1. 富集分析(enrichment analysis)"></a>1. 富集分析(enrichment analysis)</h1><p>富集分析(enrichment analysis)的概述参考<a href="https://yanzhongsino.github.io/2021/11/12/bioinfo_enrichment_intro/">博客：富集分析概述</a>。</p>
<h1 id="2-topGO"><a href="#2-topGO" class="headerlink" title="2. topGO"></a>2. topGO</h1><h2 id="2-1-topGO简介"><a href="#2-1-topGO简介" class="headerlink" title="2.1. topGO简介"></a>2.1. topGO简介</h2><p>topGO是一个R包，用于半自动的GO terms的富集分析。</p>
<p>因为topGO只用于GO的富集分析，且是半自动化的，推荐使用更方便的在线工具<a href="http://kobas.cbi.pku.edu.cn/">KOBAS-i</a>；<a href="http://bioinfo.org/kobas">KOBAS-i 备用</a>；<a href="http://omicslab.genetics.ac.cn/GOEAST/index.php">GOEAST</a>; 或者功能更完善的clusterProfiler包，参考<a href="https://yanzhongsino.github.io/2021/12/13/bioinfo_enrichment_clusterProfiler/">博客：clusterProfiler包</a>。</p>
<h2 id="2-2-GO-term"><a href="#2-2-GO-term" class="headerlink" title="2.2. GO term"></a>2.2. GO term</h2><p>GO term分为三大类：</p>
<ul>
<li>cellular component(CC)-细胞成分（其中基因产物位于细胞内部）</li>
<li>molecular function(MF)-分子功能（基因产物的功能是什么）</li>
<li>biology process(BP)-生物过程（即基因产物参与的一系列事件）<br>三类都可以用topGO做富集分析。</li>
</ul>
<h2 id="2-3-topGO支持的统计检验方法"><a href="#2-3-topGO支持的统计检验方法" class="headerlink" title="2.3. topGO支持的统计检验方法"></a>2.3. topGO支持的统计检验方法</h2><p>topGO包默认算法用的是weight01，是elim和权重算法的混合。</p>
<table>
<thead>
<tr>
<th>topGO支持的统计方法</th>
<th>fisher</th>
<th>ks</th>
<th>t</th>
<th>globaltest</th>
<th>sum</th>
</tr>
</thead>
<tbody><tr>
<td>classic</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>elim</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>weight</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>weight01</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>lea</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>parentchild</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
<h2 id="2-4-安装topGO"><a href="#2-4-安装topGO" class="headerlink" title="2.4. 安装topGO"></a>2.4. 安装topGO</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装topGO软件包</span></span><br><span class="line"><span class="keyword">if</span> <span class="punctuation">(</span><span class="operator">!</span>requireNamespace<span class="punctuation">(</span><span class="string">&quot;BiocManager&quot;</span><span class="punctuation">,</span> quietly <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  install.packages<span class="punctuation">(</span><span class="string">&quot;BiocManager&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span><span class="string">&quot;topGO&quot;</span><span class="punctuation">,</span> version <span class="operator">=</span> <span class="string">&quot;3.14&quot;</span><span class="punctuation">)</span></span><br><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span><span class="string">&quot;Rgraphviz&quot;</span><span class="punctuation">,</span> version <span class="operator">=</span> <span class="string">&quot;3.8&quot;</span><span class="punctuation">)</span></span><br><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span><span class="string">&quot;GO.db&quot;</span><span class="punctuation">)</span></span><br><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span><span class="string">&quot;biomaRt&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">source<span class="punctuation">(</span><span class="string">&quot;https://bioconductor.org/biocLite.R&quot;</span><span class="punctuation">)</span></span><br><span class="line">biocLite<span class="punctuation">(</span><span class="string">&quot;topGO&quot;</span><span class="punctuation">)</span></span><br><span class="line">biocLite<span class="punctuation">(</span><span class="string">&quot;GO.db&quot;</span><span class="punctuation">)</span></span><br><span class="line">biocLite<span class="punctuation">(</span><span class="string">&quot;biomaRt&quot;</span><span class="punctuation">)</span></span><br><span class="line">biocLite<span class="punctuation">(</span><span class="string">&quot;Rgraphviz&quot;</span><span class="punctuation">)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Load the required R packages</span></span><br><span class="line">library<span class="punctuation">(</span>topGO<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>GO.db<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>biomaRt<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>Rgraphviz<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-topGO做富集分析-ORA"><a href="#2-5-topGO做富集分析-ORA" class="headerlink" title="2.5. topGO做富集分析(ORA)"></a>2.5. topGO做富集分析(ORA)</h2><h3 id="2-5-1-输入文件"><a href="#2-5-1-输入文件" class="headerlink" title="2.5.1. 输入文件"></a>2.5.1. 输入文件</h3><p>两个输入文件</p>
<ul>
<li>genes.list：需要做富集分析的geneID的list，一个基因ID一行</li>
<li>sample.anno：基因及GO注释信息，第一列是geneID，第二列是GO注释，空格分隔，GO注释可以有多个，格式为GO:0000428,GO:0003677,GO:0005506,</li>
</ul>
<h3 id="2-5-2-富集分析"><a href="#2-5-2-富集分析" class="headerlink" title="2.5.2. 富集分析"></a>2.5.2. 富集分析</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置工作目录，后面读取文件什么的就可以直接读取不需要那么长的路径</span></span><br><span class="line">setwd<span class="punctuation">(</span><span class="string">&#x27;D:/test_data&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载包</span></span><br><span class="line">rm<span class="punctuation">(</span><span class="built_in">list</span><span class="operator">=</span>ls<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>topGO<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>Rgraphviz<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输入文件</span></span><br><span class="line">input<span class="operator">=</span><span class="string">&quot;genes.list&quot;</span>  <span class="comment">#待分析基因名称的列表</span></span><br><span class="line">mapfile<span class="operator">=</span><span class="string">&quot;sample.anno&quot;</span>    <span class="comment">#所有基因GO注释结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始分析</span></span><br><span class="line">gene_id <span class="operator">=</span> readMappings<span class="punctuation">(</span>file <span class="operator">=</span> mapfile<span class="punctuation">)</span> <span class="comment">#如果是读取其他文件格式，后面参数还需要修改</span></span><br><span class="line">gene_names <span class="operator">=</span> <span class="built_in">names</span><span class="punctuation">(</span>gene_id<span class="punctuation">)</span></span><br><span class="line">my_genes <span class="operator">=</span> read.table<span class="punctuation">(</span>input<span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">gene_list <span class="operator">=</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="built_in">length</span><span class="punctuation">(</span>gene_id<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>gene_list<span class="punctuation">)</span> <span class="operator">=</span> <span class="built_in">names</span><span class="punctuation">(</span>gene_id<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">gene_list<span class="punctuation">[</span>match<span class="punctuation">(</span>my_genes<span class="punctuation">,</span><span class="built_in">names</span><span class="punctuation">(</span>gene_list<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">]</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">top_diff_genes <span class="operator">=</span> <span class="keyword">function</span><span class="punctuation">(</span>allScore<span class="punctuation">)</span><span class="punctuation">&#123;</span><span class="built_in">return</span><span class="punctuation">(</span>allScore<span class="operator">&lt;</span><span class="number">0.01</span><span class="punctuation">)</span><span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. BP 富集分析</span></span><br><span class="line"><span class="comment">## new() 创建一个 topGO 的对象，然后对这个对象做检验</span></span><br><span class="line">bp_go <span class="operator">=</span> new<span class="punctuation">(</span><span class="string">&quot;topGOdata&quot;</span><span class="punctuation">,</span></span><br><span class="line">                   nodeSize <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">                   ontology<span class="operator">=</span><span class="string">&quot;BP&quot;</span><span class="punctuation">,</span></span><br><span class="line">                   allGenes <span class="operator">=</span> gene_list<span class="punctuation">,</span></span><br><span class="line">                   annot <span class="operator">=</span> annFUN.gene2GO<span class="punctuation">,</span></span><br><span class="line">                   gene2GO <span class="operator">=</span> gene_id<span class="punctuation">,</span></span><br><span class="line">                   geneSel<span class="operator">=</span>top_diff_genes<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 做显著性检验，使用的是elim 的算法，使用 ks 的统计量。可以理解为 p 值</span></span><br><span class="line">result_KS.elim <span class="operator">=</span> runTest<span class="punctuation">(</span>bp_go<span class="punctuation">,</span></span><br><span class="line">                         algorithm <span class="operator">=</span> <span class="string">&quot;elim&quot;</span><span class="punctuation">,</span></span><br><span class="line">                         statistic <span class="operator">=</span> <span class="string">&quot;ks&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 提取基因 table</span></span><br><span class="line">allres <span class="operator">=</span> GenTable<span class="punctuation">(</span>bp_go<span class="punctuation">,</span></span><br><span class="line">                  KS <span class="operator">=</span> result_KS.elim<span class="punctuation">,</span></span><br><span class="line">                  ranksOf <span class="operator">=</span> <span class="string">&quot;classic&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  topNodes <span class="operator">=</span> <span class="built_in">attributes</span><span class="punctuation">(</span>result_KS.elim<span class="punctuation">)</span><span class="operator">$</span>geneData<span class="punctuation">[</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成文件，后面画图都可以用这个表</span></span><br><span class="line">write.table<span class="punctuation">(</span>allres<span class="punctuation">,</span></span><br><span class="line">            file <span class="operator">=</span> paste<span class="punctuation">(</span>input<span class="punctuation">,</span><span class="string">&quot;.BP.xls&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">            sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span> <span class="built_in">quote</span><span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">,</span> col.names<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">,</span> row.names<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出矢量图</span></span><br><span class="line">pdf<span class="punctuation">(</span>paste<span class="punctuation">(</span>input<span class="punctuation">,</span><span class="string">&quot;.BP.pdf&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">showSigOfNodes<span class="punctuation">(</span>bp_go<span class="punctuation">,</span></span><br><span class="line">               score<span class="punctuation">(</span>result_KS.elim<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">               firstSigNodes <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">               useInfo <span class="operator">=</span> <span class="string">&quot;all&quot;</span><span class="punctuation">)</span> <span class="comment">#设置节点数量，10个或者20个更多都可以</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出像素图</span></span><br><span class="line">png<span class="punctuation">(</span>paste<span class="punctuation">(</span>input<span class="punctuation">,</span><span class="string">&quot;.BP.png&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">showSigOfNodes<span class="punctuation">(</span>bp_go<span class="punctuation">,</span> score<span class="punctuation">(</span>result_KS.elim<span class="punctuation">)</span><span class="punctuation">,</span> firstSigNodes <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> useInfo <span class="operator">=</span> <span class="string">&quot;all&quot;</span><span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. MF 富集分析（同理）</span></span><br><span class="line"><span class="comment">## 创建一个 topGO 的对象</span></span><br><span class="line">mf_go <span class="operator">=</span> new<span class="punctuation">(</span><span class="string">&quot;topGOdata&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    nodeSize <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">                    ontology<span class="operator">=</span><span class="string">&quot;MF&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    allGenes <span class="operator">=</span> gene_list<span class="punctuation">,</span></span><br><span class="line">                    annot <span class="operator">=</span> annFUN.gene2GO<span class="punctuation">,</span></span><br><span class="line">                    gene2GO <span class="operator">=</span> gene_id<span class="punctuation">,</span></span><br><span class="line">                    geneSel<span class="operator">=</span>top_diff_genes<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 做检验，使用的是elim 的算法，使用 ks 的统计量。可以理解为 p 值</span></span><br><span class="line">result_KS.elim <span class="operator">=</span> runTest<span class="punctuation">(</span>mf_go<span class="punctuation">,</span></span><br><span class="line">                         algorithm <span class="operator">=</span> <span class="string">&quot;elim&quot;</span><span class="punctuation">,</span></span><br><span class="line">                         statistic <span class="operator">=</span> <span class="string">&quot;ks&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 提取基因 table</span></span><br><span class="line">allres <span class="operator">=</span> GenTable<span class="punctuation">(</span>mf_go <span class="punctuation">,</span></span><br><span class="line">                  KS <span class="operator">=</span> result_KS.elim<span class="punctuation">,</span></span><br><span class="line">                  ranksOf <span class="operator">=</span> <span class="string">&quot;classic&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  topNodes <span class="operator">=</span> <span class="built_in">attributes</span><span class="punctuation">(</span>result_KS.elim<span class="punctuation">)</span><span class="operator">$</span>geneData<span class="punctuation">[</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成文件，后面画图都可以用这个表</span></span><br><span class="line">write.table<span class="punctuation">(</span>allres<span class="punctuation">,</span></span><br><span class="line">            file <span class="operator">=</span> paste<span class="punctuation">(</span>input<span class="punctuation">,</span><span class="string">&quot;.MF.xls&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">            sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span> <span class="built_in">quote</span><span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">,</span> col.names<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">,</span> row.names<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出矢量图</span></span><br><span class="line">pdf<span class="punctuation">(</span>paste<span class="punctuation">(</span>input<span class="punctuation">,</span><span class="string">&quot;.MF.pdf&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">showSigOfNodes<span class="punctuation">(</span>mf_go<span class="punctuation">,</span></span><br><span class="line">               score<span class="punctuation">(</span>result_KS.elim<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">               firstSigNodes <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">               useInfo <span class="operator">=</span> <span class="string">&quot;all&quot;</span><span class="punctuation">)</span> <span class="comment">#设置节点数量，10个或者20个更多都可以</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出像素图</span></span><br><span class="line">png<span class="punctuation">(</span>paste<span class="punctuation">(</span>input<span class="punctuation">,</span><span class="string">&quot;.MF.png&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">showSigOfNodes<span class="punctuation">(</span>mf_go<span class="punctuation">,</span> score<span class="punctuation">(</span>result_KS.elim<span class="punctuation">)</span><span class="punctuation">,</span> firstSigNodes <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> useInfo <span class="operator">=</span> <span class="string">&quot;all&quot;</span><span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. CC节点的富集分析(同理)</span></span><br><span class="line"><span class="comment">## 创建一个 topGO 的对象</span></span><br><span class="line">cc_go <span class="operator">=</span> new<span class="punctuation">(</span><span class="string">&quot;topGOdata&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    nodeSize <span class="operator">=</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">                    ontology<span class="operator">=</span><span class="string">&quot;CC&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    allGenes <span class="operator">=</span> gene_list<span class="punctuation">,</span></span><br><span class="line">                    annot <span class="operator">=</span> annFUN.gene2GO<span class="punctuation">,</span></span><br><span class="line">                    gene2GO <span class="operator">=</span> gene_id<span class="punctuation">,</span></span><br><span class="line">                    geneSel<span class="operator">=</span>top_diff_genes<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 做检验，使用的是elim 的算法，使用 ks 的统计量。可以理解为 p 值</span></span><br><span class="line">result_KS.elim <span class="operator">=</span> runTest<span class="punctuation">(</span>cc_go<span class="punctuation">,</span></span><br><span class="line">                         algorithm <span class="operator">=</span> <span class="string">&quot;elim&quot;</span><span class="punctuation">,</span></span><br><span class="line">                         statistic <span class="operator">=</span> <span class="string">&quot;ks&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 提取基因 table</span></span><br><span class="line">allres <span class="operator">=</span> GenTable<span class="punctuation">(</span>cc_go<span class="punctuation">,</span></span><br><span class="line">                  KS <span class="operator">=</span> result_KS.elim<span class="punctuation">,</span></span><br><span class="line">                  ranksOf <span class="operator">=</span> <span class="string">&quot;classic&quot;</span><span class="punctuation">,</span></span><br><span class="line">                  topNodes <span class="operator">=</span> <span class="built_in">attributes</span><span class="punctuation">(</span>result_KS.elim<span class="punctuation">)</span><span class="operator">$</span>geneData<span class="punctuation">[</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 生成文件，后面画图都可以用这个表</span></span><br><span class="line">write.table<span class="punctuation">(</span>allres<span class="punctuation">,</span></span><br><span class="line">            file <span class="operator">=</span> paste<span class="punctuation">(</span>input<span class="punctuation">,</span><span class="string">&quot;.CC.xls&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">            sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span> <span class="built_in">quote</span><span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">,</span> col.names<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">,</span> row.names<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出矢量图</span></span><br><span class="line">pdf<span class="punctuation">(</span>paste<span class="punctuation">(</span>input<span class="punctuation">,</span><span class="string">&quot;.CC.pdf&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">showSigOfNodes<span class="punctuation">(</span>cc_go<span class="punctuation">,</span></span><br><span class="line">               score<span class="punctuation">(</span>result_KS.elim<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">               firstSigNodes <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">               useInfo <span class="operator">=</span> <span class="string">&quot;all&quot;</span><span class="punctuation">)</span> <span class="comment">#设置节点数量，10个或者20个更多都可以</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出像素图</span></span><br><span class="line">png<span class="punctuation">(</span>paste<span class="punctuation">(</span>input<span class="punctuation">,</span><span class="string">&quot;.CC.png&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">showSigOfNodes<span class="punctuation">(</span>cc_go<span class="punctuation">,</span> score<span class="punctuation">(</span>result_KS.elim<span class="punctuation">)</span><span class="punctuation">,</span> firstSigNodes <span class="operator">=</span> <span class="number">10</span><span class="punctuation">,</span> useInfo <span class="operator">=</span> <span class="string">&quot;all&quot;</span><span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-3-结果解释"><a href="#2-5-3-结果解释" class="headerlink" title="2.5.3. 结果解释"></a>2.5.3. 结果解释</h3><ol>
<li>.xls结果文件中每一列的含义</li>
</ol>
<ul>
<li><p>GO.ID：富集的GO ID</p>
</li>
<li><p>Term：GO ID的描述</p>
</li>
<li><p>Annotated : number of genes in go.db which are annotated with the GO-term.在go.db中被注释到GO-term的基因数量。</p>
</li>
<li><p>Significant : number of genes belonging to your input which are annotated with the GO-term. GO-term被注释到的基因中包含输入的基因的数量</p>
</li>
<li><p>Expected : show an estimate of the number of genes a node of size Annotated would have if the significant genes were to be randomly selected from the gene universe. 对节点基因数量的预期</p>
</li>
<li><p>KS：用KS（Kolmogorov-Smirnov）算法计算得到的p-value值。</p>
<p>KS全称是：Kolmogorov-Smirnov，KS值是通过KS检验所得，KS检验是一种算法。统计方法如下：</p>
<ul>
<li>首先计算每个go节点对应的gene个数，</li>
<li>如果某个节点的子节点也有gene比对上，那么父节点对应的gene个数也要加上子节点的基因数</li>
<li>使用KS统计检验进行p值的计算，文件中的KS值，就是常说的p value，叫KS值的原因，是体现使用的KS检验方法。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>DAG图（矢量图&#x2F;像素图）<br>有向无环图(Directed acyclic graph, DAG)中，从上至下依次有包含关系，只有从上往下的箭头，这个箭头代表包含关系，即<strong>有向</strong>。只有从上往下的箭头，方向是确定的，所以不会形成闭环，即<strong>无环</strong>。</li>
</ol>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fe/Tred-G.svg/800px-Tred-G.svg.png" width=40% title="DAG图示例" alt="DAG图" align=center/>

<p><strong><p align="center">Figure 1. DAG图示例</strong><br>from <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">wikipedia:directed acyclic graph</a></p></p>
<ul>
<li>有向无环图能直观展示基因富集的GO节点（Term）及其层级关系。</li>
<li>在有向无环图中，矩形代表富集到的top10个GO Terms，颜色从黄到红，对应p值从大到小。</li>
<li>分支代表包含关系，从上至下所定义的功能描述范围越来越具体。</li>
<li>箭头代表包含关系，即该节点的所有基因同样注释到其上级节点中。</li>
</ul>
<img src="http://guangchuangyu.github.io/blog_images/Bioconductor/clusterProfiler/2016_GO_analysis_using_clusterProfiler_files/figure-markdown_strict/unnamed-chunk-7-4.png" title=" topGO结果DAG图" width="90%"/>

<p><strong><p align="center">Figure 2. topGO结果DAG图</strong><br>from <a href="https://guangchuangyu.github.io/2016/01/go-analysis-using-clusterprofiler/">clusterProfiler blog</a></p></p>
<p>注：对每个GO节点进行富集，在图中用方框表示显著度最高的10个节点，图中还包含其各层对应关系。每个方框（或椭圆）内给出了该GO节点的内容描述和富集显著性值。不同颜色代表不同的富集显著性，颜色越深，显著性越高。</p>
<h1 id="3-references"><a href="#3-references" class="headerlink" title="3. references"></a>3. references</h1><ol>
<li>topGO tutorial：<a href="https://bioconductor.org/packages/release/bioc/vignettes/topGO/inst/doc/topGO.pdf">https://bioconductor.org/packages/release/bioc/vignettes/topGO/inst/doc/topGO.pdf</a></li>
<li>topGO blog：<a href="https://datacatz.wordpress.com/2018/01/19/gene-set-enrichment-analysis-with-topgo-part-1/">https://datacatz.wordpress.com/2018/01/19/gene-set-enrichment-analysis-with-topgo-part-1/</a></li>
<li>R topGO：<a href="https://www.codenong.com/cs105162324/">https://www.codenong.com/cs105162324/</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>enrichment</category>
      </categories>
      <tags>
        <tag>topGO</tag>
        <tag>enrichment analysis</tag>
        <tag>over representation analysis</tag>
        <tag>ORA</tag>
      </tags>
  </entry>
  <entry>
    <title>GFF3文件处理软件 —— GFF3toolkit工具包的介绍和使用</title>
    <url>/2022/05/24/bioinfo_fileformat_GFF3toolkit/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=283095&auto=1&height=32"></iframe></div>

<h1 id="1-GFF3toolkit-简介"><a href="#1-GFF3toolkit-简介" class="headerlink" title="1. GFF3toolkit 简介"></a>1. GFF3toolkit 简介</h1><p><a href="https://github.com/NAL-i5K/GFF3toolkit">GFF3toolkit</a>是用于处理GFF3格式文件的一个基于python的工具包，功能包括检测GFF3格式错误，修正GFF3格式错误，合并GFF3格式文件，排序GFF3格式文件，用GFF3格式文件生成序列等。</p>
<h1 id="2-GFF3toolkit-安装"><a href="#2-GFF3toolkit-安装" class="headerlink" title="2. GFF3toolkit 安装"></a>2. GFF3toolkit 安装</h1><p><code>pip install gff3tool</code></p>
<h1 id="3-GFF3toolkit-模块"><a href="#3-GFF3toolkit-模块" class="headerlink" title="3. GFF3toolkit 模块"></a>3. GFF3toolkit 模块</h1><p>GFF3toolkit包含许多模块：</p>
<ul>
<li>gff3_QC：检测gff3格式错误</li>
<li>gff3_fix：修正gff3格式错误</li>
<li>gff3_merge：合并两个gff3文件</li>
<li>gff3_sort：根据scaffold，coordinates坐标来排序gff3文件</li>
<li>gff3_to_fasta：根据基因组fasta和注释gff生成gene&#x2F;cds&#x2F;protein&#x2F;exon等序列</li>
</ul>
<h1 id="4-GFF3toolkit-使用"><a href="#4-GFF3toolkit-使用" class="headerlink" title="4. GFF3toolkit 使用"></a>4. GFF3toolkit 使用</h1><h2 id="4-1-gff3-merge"><a href="#4-1-gff3-merge" class="headerlink" title="4.1. gff3_merge"></a>4.1. gff3_merge</h2><p>用于合并两个gff3注释文件。</p>
<ol>
<li><p>命令<br><code>gff3_merge -g1 sample1.gff3 -g2 sample2.gff3 -f genome.fa -og merged.gff3 -r merged.report</code></p>
</li>
<li><p>参数</p>
</li>
</ol>
<ul>
<li>-g1 sample1.gff3：指定待合并的gff3文件1</li>
<li>-g2 sample2.gff3：指定待合并的gff3文件2</li>
<li>-f genome.fa：指定基因组文件</li>
<li>-og merged.gff3：指定合并后结果文件</li>
<li>-r merged.report：指定合并报告结果文件</li>
<li>-noAuto：这个参数关闭添加replace tags的自动任务。默认是开启的。</li>
<li>-a：默认开启添加replace tags的自动任务只应用在没有replace tags的transcript转录本上，-a参数设置为应用在所有转录本上。</li>
</ul>
<ol start="3">
<li>输出</li>
</ol>
<ul>
<li>merged.gff3：合并后的gff文件</li>
<li>merged.report：合并报告</li>
</ul>
<h2 id="4-2-gff3-sort"><a href="#4-2-gff3-sort" class="headerlink" title="4.2. gff3_sort"></a>4.2. gff3_sort</h2><p>用于排序gff3文件。根据scaffold(seqID)，coordinates坐标排序基因，根据特征关系(feature relationship)排序基因内注释。</p>
<p>排序的前提假设：</p>
<ul>
<li>任何没有Parent属性的注释都是父注释。</li>
<li>所有子注释都排在其父注释之后，并在新的父注释之前。</li>
</ul>
<ol>
<li><p>命令<br><code>gff3_sort -g sample.gff3 -og sorted.gff3</code></p>
</li>
<li><p>参数</p>
</li>
</ol>
<ul>
<li>-g sample.gff3：指定输入gff3文件</li>
<li>-og sorted.gff3：指定输出排序好的gff3文件</li>
<li>-t sort_template.txt：指定排序模板，按照指定模板的features进行基因内注释的排序。</li>
<li>-i：按特征类型(feature type)对多亚型基因(multi-isoform gene)进行排序，默认是关闭的。</li>
<li>-r：此参数按gff3文件里scaffold(seqID)出现的顺序排序，默认是按照scaffold的数字排序。</li>
</ul>
<ol start="3">
<li><p>排序模板sort_template.txt文件示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gene pseudogene</span><br><span class="line">mRNA</span><br><span class="line">exon</span><br><span class="line">CDS</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出</p>
</li>
</ol>
<ul>
<li>sorted.gff3：排序结果文件</li>
</ul>
<h2 id="4-3-gff3-QC"><a href="#4-3-gff3-QC" class="headerlink" title="4.3. gff3_QC"></a>4.3. gff3_QC</h2><p>用于检测gff3注释的格式错误</p>
<ol>
<li><p>命令<br><code>nohup gff3_QC -g sample.gff3 -f genome.fa -o sample.qc -s statistic.txt &gt;qc.log 2&gt;&amp;1 &amp;</code></p>
</li>
<li><p>参数</p>
</li>
</ol>
<ul>
<li>-g sample.gff3：指定需要质控的gff文件</li>
<li>-f genome.fa：指定基因组文件</li>
<li>-o sample.qc：指定质控结果输出文件</li>
<li>-s statistic.txt：指定统计输出文件</li>
</ul>
<ol start="3">
<li>输出</li>
</ol>
<ul>
<li>sample.qc：质控结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Line_num	Error_code	Error_level	Error_tag</span><br><span class="line">[&#x27;Line 1&#x27;]	Esf0014	Error	[&quot;##gff-version&quot; missing from the first line]</span><br><span class="line">[&#x27;Line 1&#x27;]	Esf0041	Error	[Unknown reserved (uppercase) attribute: &quot;Augustus_transcriptSupport_percentage&quot;]</span><br><span class="line">[&#x27;Line 749964&#x27;]	Ema0002	Warning	[Protein sequence contains internal stop codons at bp 2397350]</span><br><span class="line">[&#x27;Line 750456&#x27;]	Ema0001	Warning	[Parent feature start and end coordinates exceed those of child features]</span><br><span class="line">[&#x27;Line 18852&#x27;, &#x27;Line 18838&#x27;]	Emr0002	Warning	[Incorrectly split gene parent?]</span><br></pre></td></tr></table></figure>

<ul>
<li>statistic.txt：质控结果的统计</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error_code	Number_of_problematic_models	Error_level	Error_tag</span><br><span class="line">Esf0014	1	Error	##gff-version&quot; missing from the first line</span><br><span class="line">Esf0041	378399	Error	Unknown reserved (uppercase) attribute</span><br><span class="line">Ema0006	9	Info	Wrong phase</span><br><span class="line">Esf0027	8	Error	Phase is required for all CDS features</span><br><span class="line">Ema0002	468	Warning	Protein sequence contains internal stop codons</span><br><span class="line">Ema0001	1024	Warning	Parent feature start and end coordinates exceed those of child features</span><br><span class="line">Emr0002	31	Warning	Incorrectly split gene parent?</span><br></pre></td></tr></table></figure>

<ul>
<li>qc.log：运行log文件，也包含了质控相关信息。</li>
</ul>
<h2 id="4-4-gff3-fix"><a href="#4-4-gff3-fix" class="headerlink" title="4.4. gff3_fix"></a>4.4. gff3_fix</h2><p>用于修正gff3注释文件格式错误</p>
<ol>
<li><p>命令<br><code>nohup gff3_fix -qc_r sample.qc -g sample.gff3 -og corrected.gff3 &gt;fix.log 2&gt;&amp;1 &amp;</code></p>
</li>
<li><p>参数</p>
</li>
</ol>
<ul>
<li>-qc_r sample.qc：指定质控结果文件作为修正参考，这里用gff3_QC的输出文件</li>
<li>-g sample.gff3：指定需要修正的gff文件</li>
<li>-og corrected.gff3：指定输出修正后的gff文件</li>
</ul>
<ol start="3">
<li>输出</li>
</ol>
<ul>
<li>corrected.gff3：修正后的gff文件</li>
<li>fix.log：运行log文件。</li>
</ul>
<h2 id="4-5-gff3-to-fasta"><a href="#4-5-gff3-to-fasta" class="headerlink" title="4.5. gff3_to_fasta"></a>4.5. gff3_to_fasta</h2><p>用于根据基因组fasta和注释gff生成gene&#x2F;cds&#x2F;protein&#x2F;exon等序列，速度很快。</p>
<ol>
<li><p>命令<br><code>gff3_to_fasta -g sample.gff3 -f genome.fa -st all -d simple -o sample</code></p>
</li>
<li><p>参数</p>
</li>
</ol>
<ul>
<li>-g sample.gff3：指定需要修正的gff文件</li>
<li>-f genome.fa：指定基因组文件</li>
<li>-st all：指定输出的序列类型，all&#x2F;gene&#x2F;exon&#x2F;cds&#x2F;pep&#x2F;trans&#x2F;pre_trans&#x2F;user_defined。</li>
<li>-u mRNA CDS：如果用-st user_defined指定了输出自定义的序列，则需要-u参数指定自定义序列名称的parent和child类型。比如-u mRNA CDS会输出CDS序列。</li>
<li>-d simple：指定输出fasta文件的序列ID的格式，simple是只输出gff文件的ID到fasta文件，complete输出完整的信息。</li>
<li>-noQC：默认会执行质控程序，如果不想做质控，加上这个参数。</li>
<li>-o sample：指定输出文件前缀</li>
</ul>
<ol start="3">
<li>输出<br>输出指定序列，比如：</li>
</ol>
<ul>
<li>sample_gene.fa</li>
<li>sample_exon.fa：exon序列是根据注释情况每条注释生成一条exon序列。</li>
<li>sample_cds.fa：cds序列是一个mRNA的一条CDS序列。</li>
<li>sample_pep.fa</li>
<li>sample_trans.fa</li>
<li>sample_pre_trans.fa</li>
</ul>
<h1 id="5-reference"><a href="#5-reference" class="headerlink" title="5. reference"></a>5. reference</h1><ol>
<li>gff3toolkit github：<a href="https://github.com/NAL-i5K/GFF3toolkit">https://github.com/NAL-i5K/GFF3toolkit</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>fileformat</category>
      </categories>
      <tags>
        <tag>GFF3</tag>
        <tag>GFF3toolkit</tag>
      </tags>
  </entry>
  <entry>
    <title>转换GenBank文件为tbl格式，为提交注释做准备</title>
    <url>/2022/06/16/bioinfo_fileformat_gb2tbl/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=157092&auto=1&height=32"></iframe></div>

<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ul>
<li>GenBank格式常常出现在细胞器基因组的注释软件的结果中，但上传细胞器注释到公共数据库（eg NCBI）需要tbl格式文件。</li>
<li>这篇文章介绍了几种把GenBank格式文件转换成tbl格式的方法。包括在线工具GB2sequin（此工具还包含验证和运行tbl2asn功能，可用于准备上传NCBI的注释文件），以及两个python2写的转换脚本。</li>
</ul>
<h2 id="1-1-GenBank格式"><a href="#1-1-GenBank格式" class="headerlink" title="1.1. GenBank格式"></a>1.1. GenBank格式</h2><p>GenBank是美国国立卫生研究院维护的基因序列数据库，数据库中用gb格式文件（后缀.gb，.gbk）记录基因注释信息。</p>
<p>GenBank文件格式标准参考：<a href="https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html">https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html</a></p>
<h2 id="1-2-tbl格式-for-Sequin"><a href="#1-2-tbl格式-for-Sequin" class="headerlink" title="1.2. tbl格式(for Sequin)"></a>1.2. tbl格式(for Sequin)</h2><p>用于提交基因注释到GenBank的一种tab分隔的五栏的特征表（feature table）文件格式（后缀.tbl）。</p>
<p>tbl文件格式标准参考：<a href="https://www.ncbi.nlm.nih.gov/genbank/feature_table/">https://www.ncbi.nlm.nih.gov/genbank/feature_table/</a></p>
<h1 id="2-GB2sequin在线工具【推荐】"><a href="#2-GB2sequin在线工具【推荐】" class="headerlink" title="2. GB2sequin在线工具【推荐】"></a>2. GB2sequin在线工具【推荐】</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1. 简介"></a>2.1. 简介</h2><p>GB2sequin是用于转换GenBank格式文件为NCBI提交格式Sequin（包括tbl文件和sqn文件）的在线工具，包含验证GenBank注释的功能和运行tbl2asn的功能。</p>
<p>网址是：</p>
<p><a href="https://chlorobox.mpimp-golm.mpg.de/GenBank2Sequin.html">https://chlorobox.mpimp-golm.mpg.de/GenBank2Sequin.html</a></p>
<h2 id="2-2-优势"><a href="#2-2-优势" class="headerlink" title="2.2. 优势"></a>2.2. 优势</h2><ol>
<li>通过网页在线转换，方便快捷。</li>
<li>自动对注释进行验证，并生成错误报告，可根据错误报告修正注释。</li>
<li>支持在输入中加入作者信息的template等文件。</li>
<li>自动运行tbl2asn，生成sqn文件，方便提交tbl文件到NCBI。</li>
<li>自动生成标准的GenBank格式文件，去除冗余。</li>
</ol>
<h2 id="2-3-使用步骤"><a href="#2-3-使用步骤" class="headerlink" title="2.3. 使用步骤"></a>2.3. 使用步骤</h2><ol>
<li>上传GenBank格式文件，要在文件末包含注释的序列，否则运行结果空白。</li>
<li>【推荐】上传Author Submission Template。可以在<a href="https://submit.ncbi.nlm.nih.gov/genbank/template/submission/%E4%B8%8A%E5%A1%AB%E5%86%99%E4%BF%A1%E6%81%AF%E5%90%8E%E5%AF%BC%E5%87%BAtemplate.sbt%E6%96%87%E4%BB%B6%E7%94%A8%E4%BA%8E%E4%B8%8A%E4%BC%A0%E3%80%82">https://submit.ncbi.nlm.nih.gov/genbank/template/submission/上填写信息后导出template.sbt文件用于上传。</a></li>
<li>【可选】上传Source Modifier Table，Gene Product Specification Table。</li>
<li>选择分子类别”Molecule Type”，一般默认genomic DNA即可。</li>
<li>选择是否是完整(complete)，环状(circular)的基因。</li>
<li>选择编码方式”Genetic Code”，植物样品选标准Standard。</li>
<li>选择基因位置Location，包括叶绿体chloroplast，线粒体mitochondrion等。</li>
<li>点击Start Conversion，等待几分钟即可得到结果，点击每项结果然后下载（大多是文本文件）。</li>
<li>根据验证结果文件的错误ERROR和警告WARNING逐一修改原始GenBank文件。</li>
<li>再次运行，重复以上操作，直至无错误和警告，即可使用sqn文件上传至NCBI。</li>
</ol>
<p>验证结果的含义（tbl2asn运行的部分）可以参考之前写的<strong>基因组提交的博客</strong>：<a href="https://yanzhongsino.github.io/2022/03/22/omics_genome.submit/">https://yanzhongsino.github.io/2022/03/22/omics_genome.submit/</a></p>
<h2 id="2-4-结果"><a href="#2-4-结果" class="headerlink" title="2.4. 结果"></a>2.4. 结果</h2><p>结果文件包括：</p>
<ol>
<li>FASTA：从GenBank提取的fasta文件。</li>
<li>Annotation Table：tbl文件。</li>
<li>tbl2asn log：tbl2asn运行的log文件。</li>
<li>Sequin：sqn文件，用于提交给NCBI。</li>
<li>GenBank：标准化的GenBank文件。</li>
<li>Validation：验证结果文件，包括细节。</li>
<li>Validation Summary：验证结果的概括。</li>
</ol>
<h1 id="3-genbank2tbl的脚本"><a href="#3-genbank2tbl的脚本" class="headerlink" title="3. genbank2tbl的脚本"></a>3. genbank2tbl的脚本</h1><ul>
<li><strong>只要GB2sequin可以用，就强烈推荐GB2sequin，毕竟自带验证功能和自动运行tbl2asn。</strong></li>
<li>如果GB2sequin不可用（比如要用的时候服务器宕机了之类的原因，我才不会告诉你我就是这么走运才探索了一下脚本），可用脚本进行GenBank到tbl的格式转换。</li>
<li>由于都是陈年老脚本，以下脚本都是用python2写的，并且调用了biopython（提前安装biopython）。</li>
</ul>
<h2 id="脚本gbf2tbl-pl【NCBI-官方出品】"><a href="#脚本gbf2tbl-pl【NCBI-官方出品】" class="headerlink" title="脚本gbf2tbl.pl【NCBI 官方出品】"></a>脚本gbf2tbl.pl【NCBI 官方出品】</h2><ol>
<li>简介</li>
</ol>
<ul>
<li>脚本gbf2tbl.pl是NCBI官方提供的perl脚本。</li>
<li>我暂时还没用过，先记在这。</li>
</ul>
<ol start="2">
<li>下载<br><code>wget ftp://ftp.ncbi.nlm.nih.gov//toolbox/ncbi_tools/converters/scripts/gbf2tbl.pl</code></li>
</ol>
<h2 id="3-1-脚本genbank-to-tbl-py【推荐】"><a href="#3-1-脚本genbank-to-tbl-py【推荐】" class="headerlink" title="3.1. 脚本genbank_to_tbl.py【推荐】"></a>3.1. 脚本genbank_to_tbl.py【推荐】</h2><h3 id="3-1-1-简介"><a href="#3-1-1-简介" class="headerlink" title="3.1.1. 简介"></a>3.1.1. 简介</h3><p>genbank_to_tbl.py脚本用于转换genbank格式的gene，CDS，exon，intron，tRNA，rRNA，pseudo genes等注释为tbl格式。</p>
<h3 id="3-1-2-脚本"><a href="#3-1-2-脚本" class="headerlink" title="3.1.2. 脚本"></a>3.1.2. 脚本</h3><p>下载地址：<a href="https://gist.github.com/nickloman/2660685">https://gist.github.com/nickloman/2660685</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># requires biopython</span></span><br><span class="line"><span class="comment"># run like:</span></span><br><span class="line"><span class="comment">#   genbank_to_tbl.py &quot;my organism name&quot; &quot;my strain ID&quot; &quot;ncbi project id&quot; &lt; my_sequence.gbk</span></span><br><span class="line"><span class="comment">#   writes seq.fsa, seq.tbl as output</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_gene_entry</span>(<span class="params">features, locus_tag</span>):</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> features:</span><br><span class="line">        <span class="keyword">if</span> f.<span class="built_in">type</span> == <span class="string">&#x27;gene&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> f.qualifiers[<span class="string">&#x27;locus_tag&#x27;</span>][<span class="number">0</span>] == locus_tag:</span><br><span class="line">                <span class="keyword">return</span> f</span><br><span class="line">    <span class="built_in">print</span> locus_tag</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line"></span><br><span class="line">coding = [<span class="string">&#x27;CDS&#x27;</span>, <span class="string">&#x27;tRNA&#x27;</span>, <span class="string">&#x27;rRNA&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">go</span>():</span><br><span class="line">    seqid = <span class="number">0</span></span><br><span class="line">    fasta_fh = <span class="built_in">open</span>(<span class="string">&quot;seq.fsa&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    feature_fh = <span class="built_in">open</span>(<span class="string">&quot;seq.tbl&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    allowed_tags = [<span class="string">&#x27;locus_tag&#x27;</span>, <span class="string">&#x27;gene&#x27;</span>, <span class="string">&#x27;product&#x27;</span>, <span class="string">&#x27;pseudo&#x27;</span>, <span class="string">&#x27;protein_id&#x27;</span>, <span class="string">&#x27;gene_desc&#x27;</span>, <span class="string">&#x27;old_locus_tag&#x27;</span>]</span><br><span class="line">    records = <span class="built_in">list</span>(SeqIO.parse(sys.stdin, <span class="string">&quot;genbank&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> rec <span class="keyword">in</span> records:</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> rec.features:</span><br><span class="line">            <span class="keyword">if</span> f.<span class="built_in">type</span> <span class="keyword">in</span> coding <span class="keyword">and</span> <span class="string">&#x27;gene&#x27;</span> <span class="keyword">in</span> f.qualifiers:</span><br><span class="line">                <span class="built_in">print</span> f.qualifiers[<span class="string">&#x27;locus_tag&#x27;</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">                f2 = find_gene_entry(rec.features, f.qualifiers[<span class="string">&#x27;locus_tag&#x27;</span>][<span class="number">0</span>])</span><br><span class="line">                f2.qualifiers[<span class="string">&#x27;gene&#x27;</span>] = f.qualifiers[<span class="string">&#x27;gene&#x27;</span>]</span><br><span class="line"></span><br><span class="line">                <span class="keyword">del</span> f.qualifiers[<span class="string">&#x27;gene&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> rec <span class="keyword">in</span> records:</span><br><span class="line">        seqid += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(rec) &lt;= <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span> &gt;&gt;sys.stderr, <span class="string">&quot;skipping small contig %s&quot;</span> % (rec.<span class="built_in">id</span>,)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#        rec.id = rec.name = &quot;%s%08d&quot; % (sys.argv[4], seqid,)</span></span><br><span class="line"></span><br><span class="line">        circular = rec.annotations.get(<span class="string">&#x27;molecule&#x27;</span>, <span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">        rec.description = <span class="string">&quot;[organism=%s] [strain=%s] [topology=%s] [molecule=DNA] [tech=wgs] [gcode=11]&quot;</span> % (sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], circular)</span><br><span class="line">        SeqIO.write([rec], fasta_fh, <span class="string">&quot;fasta&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span> &gt;&gt;feature_fh, <span class="string">&quot;&gt;Feature %s&quot;</span> % (rec.name,)</span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> rec.features:</span><br><span class="line">            <span class="keyword">if</span> f.strand == <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">print</span> &gt;&gt;feature_fh, <span class="string">&quot;%d\t%d\t%s&quot;</span> % (f.location.nofuzzy_start + <span class="number">1</span>, f.location.nofuzzy_end, f.<span class="built_in">type</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span> &gt;&gt;feature_fh, <span class="string">&quot;%d\t%d\t%s&quot;</span> % (f.location.nofuzzy_end, f.location.nofuzzy_start + <span class="number">1</span>, f.<span class="built_in">type</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> f.<span class="built_in">type</span> == <span class="string">&#x27;CDS&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;product&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> f.qualifiers:</span><br><span class="line">                f.qualifiers[<span class="string">&#x27;product&#x27;</span>] = [<span class="string">&#x27;hypothetical protein&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> f.<span class="built_in">type</span> == <span class="string">&#x27;CDS&#x27;</span>:</span><br><span class="line">                f.qualifiers[<span class="string">&#x27;protein_id&#x27;</span>] = [<span class="string">&quot;gnl|ProjectID_%s|%s&quot;</span> % (sys.argv[<span class="number">3</span>], f.qualifiers[<span class="string">&#x27;locus_tag&#x27;</span>][<span class="number">0</span>])]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> f.<span class="built_in">type</span> <span class="keyword">in</span> coding:</span><br><span class="line">                <span class="keyword">del</span> f.qualifiers[<span class="string">&#x27;locus_tag&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> key, vals <span class="keyword">in</span> f.qualifiers.iteritems():</span><br><span class="line">                my_allowed_tags = copy(allowed_tags)</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;pseudo&#x27;</span> <span class="keyword">in</span> f.qualifiers:</span><br><span class="line">                    my_allowed_tags.append(<span class="string">&#x27;note&#x27;</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_allowed_tags:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> vals:</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">len</span>(v) <span class="keyword">or</span> key == <span class="string">&#x27;pseudo&#x27;</span>:</span><br><span class="line">                        <span class="built_in">print</span> &gt;&gt;feature_fh, <span class="string">&quot;\t\t\t%s\t%s&quot;</span> % (key, v)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">go()</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-使用"><a href="#3-1-3-使用" class="headerlink" title="3.1.3. 使用"></a>3.1.3. 使用</h3><ol>
<li><p>命令<br><code>python2 genbank_to_tbl.py sample mc_01 ncbi_id &lt; sample.gb</code></p>
</li>
<li><p>参数</p>
</li>
</ol>
<ul>
<li>sample：样品名称，organism name</li>
<li>mc_01：品种编号，strain ID</li>
<li>ncbi_id：NCBI项目ID</li>
<li>&lt; sample.gb：输入genbank格式文件</li>
</ul>
<p>四个参数都是必需参数。</p>
<ol start="3">
<li>输出</li>
</ol>
<ul>
<li>seq.fsa：基因组序列</li>
<li>seq.tbl：tbl格式文件</li>
</ul>
<ol start="4">
<li>notes</li>
</ol>
<ul>
<li>seq.tbl结果中包含genbank注释的gene，CDS，exon，intron，tRNA，rRNA，pseudo genes等结果。</li>
<li>需要在输入的genbank文件中包含locus_tag的值（可以用基因名称），否则报错。</li>
</ul>
<h2 id="3-2-Genbank2Sequin-py"><a href="#3-2-Genbank2Sequin-py" class="headerlink" title="3.2. Genbank2Sequin.py"></a>3.2. Genbank2Sequin.py</h2><h3 id="3-2-1-简介"><a href="#3-2-1-简介" class="headerlink" title="3.2.1. 简介"></a>3.2.1. 简介</h3><p>Genbank2Sequin.py脚本用于批量转换genbank格式的gene和CDS注释为tbl格式。</p>
<h3 id="3-2-2-脚本"><a href="#3-2-2-脚本" class="headerlink" title="3.2.2. 脚本"></a>3.2.2. 脚本</h3><p>下载地址：<a href="https://github.com/Van-Doorslaer/Genbank2sequin/blob/master/Genbank2Sequin.py">https://github.com/Van-Doorslaer/Genbank2sequin/blob/master/Genbank2Sequin.py</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"><span class="keyword">import</span> re, glob, os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> glob.glob(<span class="string">&quot;*.gb&quot;</span>):</span><br><span class="line">    ID = f.split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> SeqIO.parse(f,<span class="string">&quot;genbank&quot;</span>):</span><br><span class="line">        <span class="comment">#print r.features</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(ID+<span class="string">&#x27;.fsa&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fasta, <span class="built_in">open</span>(ID+<span class="string">&quot;.tbl&quot;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> table:</span><br><span class="line">            <span class="built_in">print</span> &gt;&gt; fasta, <span class="string">&quot;&gt;%s [organism=Human papillomavirus %s]\n%s&quot;</span> %(ID, ID, r.seq)</span><br><span class="line">            <span class="built_in">print</span> &gt;&gt;table, <span class="string">&quot;&gt;Feature &quot;</span>+ID </span><br><span class="line">            <span class="keyword">for</span> (index, feature) <span class="keyword">in</span> <span class="built_in">enumerate</span>(r.features):</span><br><span class="line">                <span class="keyword">if</span> feature.<span class="built_in">type</span> ==  <span class="string">&#x27;CDS&#x27;</span>:</span><br><span class="line">                    m=re.search(<span class="string">&#x27;\[(\d*)\:(\d*)\]&#x27;</span>,<span class="built_in">str</span>(feature.location))</span><br><span class="line">                    <span class="keyword">if</span> m:</span><br><span class="line">                        <span class="comment">#print feature.qualifiers</span></span><br><span class="line">                        <span class="built_in">print</span> &gt;&gt;table, <span class="string">&quot;%s\t%s\tgene\n\t\t\tgene\t%s&quot;</span> %(<span class="built_in">int</span>(m.groups()[<span class="number">0</span>])+<span class="number">1</span>, m.groups()[<span class="number">1</span>],feature.qualifiers[<span class="string">&#x27;note&#x27;</span>][<span class="number">0</span>])</span><br><span class="line">                        <span class="built_in">print</span> &gt;&gt;table, <span class="string">&quot;%s\t%s\tCDS\n\t\t\tproduct\t%s\n\t\t\tgene\t%s\n\t\t\tcodon_start\t1&quot;</span> %(<span class="built_in">int</span>(m.groups()[<span class="number">0</span>])+<span class="number">1</span>, m.groups()[<span class="number">1</span>], feature.qualifiers[<span class="string">&#x27;note&#x27;</span>][<span class="number">0</span>], feature.qualifiers[<span class="string">&#x27;note&#x27;</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-使用"><a href="#3-2-3-使用" class="headerlink" title="3.2.3. 使用"></a>3.2.3. 使用</h3><ol>
<li>命令<br><code>python2 Genbank2Sequin.py</code></li>
</ol>
<ul>
<li>运行后会自动搜索当前文件夹下的所有.gb后缀文件，然后把gene和CDS的注释转换为.tbl文件。</li>
</ul>
<ol start="2">
<li>输出</li>
</ol>
<ul>
<li>*.tbl：tbl格式文件。</li>
</ul>
<ol start="3">
<li>notes</li>
</ol>
<ul>
<li>*.tbl结果中只包含genbank注释的gene，CDS结果。</li>
<li>需要在输入的genbank文件中包含note的值（可以用基因名称），否则报错。</li>
<li>可批量操作多个gb文件。</li>
</ul>
<h1 id="4-reference"><a href="#4-reference" class="headerlink" title="4. reference"></a>4. reference</h1><ol>
<li>GB2sequin paper：<a href="https://www.sciencedirect.com/science/article/pii/S0888754318301897?via=ihub">https://www.sciencedirect.com/science/article/pii/S0888754318301897?via%3Dihub</a></li>
<li>GB2sequin：<a href="https://chlorobox.mpimp-golm.mpg.de/GenBank2Sequin.html">https://chlorobox.mpimp-golm.mpg.de/GenBank2Sequin.html</a></li>
<li>genbank_to_tbl.py：<a href="https://gist.github.com/nickloman/2660685">https://gist.github.com/nickloman/2660685</a></li>
<li>Genbank2Sequin.py：<a href="https://github.com/Van-Doorslaer/Genbank2sequin/blob/master/Genbank2Sequin.py">https://github.com/Van-Doorslaer/Genbank2sequin/blob/master/Genbank2Sequin.py</a></li>
<li>genbank格式：<a href="https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html">https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html</a></li>
<li>tbl格式：<a href="https://www.ncbi.nlm.nih.gov/genbank/feature_table/">https://www.ncbi.nlm.nih.gov/genbank/feature_table/</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>fileformat</category>
      </categories>
      <tags>
        <tag>GenBank</tag>
        <tag>tbl</tag>
        <tag>organellar genome</tag>
        <tag>genome annotation</tag>
        <tag>genome submit</tag>
        <tag>Sequin</tag>
        <tag>tbl2asn</tag>
        <tag>GB2sequin</tag>
        <tag>gbf2tbl.pl</tag>
        <tag>genbank_to_tbl.py</tag>
        <tag>Genbank2Sequin.py</tag>
      </tags>
  </entry>
  <entry>
    <title>从codon比对的cds序列中提取四倍简并位点</title>
    <url>/2021/10/10/bioinfo_extract.4dtv.from.cds/</url>
    <content><![CDATA[<h1 id="1-从condon比对的cds序列中提取四倍简并位点"><a href="#1-从condon比对的cds序列中提取四倍简并位点" class="headerlink" title="1. 从condon比对的cds序列中提取四倍简并位点"></a>1. 从condon比对的cds序列中提取四倍简并位点</h1><p>输入文件是根据密码子规则（即三个三个对齐）比对好的cds序列，输出文件是以其中一个物种的4dtv为标准提取所有物种的4dtv位点，提取的也是按照比对前的顺序排列，结果保存在4dtv.aln文件中。</p>
<h2 id="1-1-输入数据和变量定义"><a href="#1-1-输入数据和变量定义" class="headerlink" title="1.1. 输入数据和变量定义"></a>1.1. 输入数据和变量定义</h2><ol>
<li><code>cds=/path/to/cds.aln</code> # 定义变量cds为codon模式比对好的cds序列</li>
<li><code>species=Athaliana</code> #以哪个物种的4dtv为标准提取，就定义变量species为那个物种的序列ID</li>
</ol>
<h2 id="1-2-三种方案【选择一种】"><a href="#1-2-三种方案【选择一种】" class="headerlink" title="1.2. 三种方案【选择一种】"></a>1.2. 三种方案【选择一种】</h2><h3 id="1-2-1-一步生成"><a href="#1-2-1-一步生成" class="headerlink" title="1.2.1. 一步生成"></a>1.2.1. 一步生成</h3><ol>
<li>一步生成运行文件，生成从cds获取4dtv的命令，很长，所以储存在文件4dtv.sh中。运行4dtv.sh就可以获取<br><code>seqkit locate -V 0 -i -d -p GCN -p CGN -p GGN -p CTN -p CCN -p TCN -p ACN -p GTN $&#123;cds&#125; |awk -v awka=&quot;$&#123;species&#125;&quot; &#39;&#123;if ($1 == awka &amp;&amp; $6%3== 0) print $6&#125;&#39;|sort -k 1n |uniq |awk -v awkb=&quot;$&#123;cds&#125;&quot; &#39;&#123;print &quot;&lt;(seqkit subseq -r &quot;$1&quot;:&quot;$1&quot; &quot;awkb&quot;)&quot;&#125;&#39; |sed -e &#39;1i\seqkit concat -w 0&#39; -e &#39;$a\&gt; 4dtv.aln&#39;|xargs echo &gt;4dtv.sh</code></li>
</ol>
<p>代码含义：用seqkit locate根据4dtv的规则提取位置，然后筛选指定物种的位置，筛选第三位位置是3的整数倍的位置，把第三位位置(即4dtv位点)提取出来，排序去重；再按照seqkit concat要求的格式规则把seqkit concat命令写入提取脚本4dtv.sh中。</p>
<p>除非位点在1000个以内，否则一步生成运行文件可能会运行失败，推荐用下一种方案。</p>
<ol start="2">
<li>运行生成的4dtv.sh，获得4dtv.aln结果<br><code>bash 4dtv.sh</code></li>
</ol>
<h3 id="1-2-2-切割分开运行【推荐】"><a href="#1-2-2-切割分开运行【推荐】" class="headerlink" title="1.2.2. 切割分开运行【推荐】"></a>1.2.2. 切割分开运行【推荐】</h3><p>如果需要合并的位点超过1000个，一步生成运行文件占用内存，运行较慢，可以分步骤进行。</p>
<p>如果因为4dtv.sh太长无法运行，可以把4dtv.temp分成1-n几部分（比如1000行作为一个子文件），然后切割各部分分别生成4dtv_n.sh，之后分别运行再合并。</p>
<ol>
<li><p>生成临时文件4dtv.temp<br><code>seqkit locate -V 0 -i -d -p GCN -p CGN -p GGN -p CTN -p CCN -p TCN -p ACN -p GTN $&#123;cds&#125; |awk -v awka=&quot;$&#123;species&#125;&quot; &#39;&#123;if ($1 == awka &amp;&amp; $6%3== 0) print $6&#125;&#39; |sort -k 1n |uniq &gt;4dtv.temp</code></p>
</li>
<li><p>分割临时文件4dtv.temp<br><code>split -l 1000 4dtv.temp -d -a 4 4dtv.temp_</code><br>命令含义：分割文件4dtv.temp成多个文件，每个子文件1000行（-l 1000），以数字（-d）而非字母命名子文件，数字长度为4（-a 4，default是2）；会生成4dtv.temp_0000-nnnn的子文件。</p>
</li>
</ol>
<p>可以先看看4dtv.temp的长度，我尝试了下按1000行切割比较合适，再多就达到能同时打开文件数量上限无法运行了。</p>
<ol start="3">
<li><p>生成4dtv.temp.n.sh<br><code>for i in $(ls 4dtv.temp_*);do cat $&#123;i&#125; |awk -v awkb=&quot;$&#123;cds&#125;&quot; &#39;&#123;print &quot;&lt;(seqkit subseq -r &quot;$1&quot;:&quot;$1&quot; &quot;awkb&quot;)&quot;&#125;&#39; |sed -e &#39;1i\seqkit concat -w 0&#39; -e &#39;$a\&gt;&#39;|sed &quot;s/^&gt;$/&gt; $&#123;i&#125;.aln/&quot; |sed &#39;s/$/ \\/g&#39; |sed &#39;$ s/.$//&#39; &gt;$&#123;i&#125;.sh; done</code></p>
</li>
<li><p>运行生成的4dtv.temp.n.sh，获得4dtv.aln_n结果【耗时步骤】<br><code>for i in $(ls 4dtv.temp_*.sh);do bash $&#123;i&#125;;done</code></p>
</li>
</ol>
<p>建议用nohup放到后台运行<br><code>nohup sh -c &#39;for i in $(ls 4dtv.temp_*.sh);do bash $&#123;i&#125;;done&#39; &amp;</code></p>
<ol start="5">
<li>合并子文件，获得最终结果<br><code>seqkit concat ./4dtv.temp_*.aln &gt;4dtv.aln</code></li>
</ol>
<p>可以<code>seqkit stats *aln</code>检查是否都是1000长度的序列；以及<code>seqkit stats 4dtv.aln</code>检查是否序列长度与4dtv.temp的行数一致。</p>
<ol start="6">
<li>删除中间文件<br><code>rm 4dtv.temp*</code></li>
</ol>
<h3 id="1-2-3-分物种运行【不推荐】"><a href="#1-2-3-分物种运行【不推荐】" class="headerlink" title="1.2.3. 分物种运行【不推荐】"></a>1.2.3. 分物种运行【不推荐】</h3><p>一开始没发现seqkit concat这个工具，然后自己写的合并，有时会有aln的问题，不建议用。</p>
<ol>
<li>定义数组sps为物种列表<br><code>sps=($(seqkit seq -n $&#123;cds&#125;|xargs))</code></li>
<li>以第六个物种${sps[5]}的4dtv为标准，为每个物种保存一份4dtv.bed文件<br><code>for i in $(echo $&#123;sps[*]&#125;); do cat $&#123;sps[5]&#125;.4dtv|sed &quot;s/$&#123;species[5]&#125;/$&#123;i&#125;/g&quot; &gt;$&#123;i&#125;.4dtv.bed; done</code></li>
<li>为每个物种提取4dtv位点，保存到4dtv.aln.temp【耗时步骤】<br><code>for i in $(echo $&#123;sps[*]&#125;); do seqkit subseq --bed $&#123;i&#125;.4dtv.bed $&#123;cds&#125; | grep -v &quot;&gt;&quot;|xargs echo |sed &quot;1i\&gt;$&#123;i&#125;&quot; &gt;$&#123;i&#125;.4dtv.aln.temp; done</code></li>
<li>合并物种的4dtv位点<br><code>cat *.4dtv.aln.temp &gt;4dtv.aln</code> #合并</li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>4dtv</category>
      </categories>
      <tags>
        <tag>4dtv</tag>
        <tag>codon</tag>
      </tags>
  </entry>
  <entry>
    <title>软件mitogenomics用于线粒体基因组相关格式转换</title>
    <url>/2022/06/30/bioinfo_fileformat_mitogenomics/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=27901965&auto=1&height=32"></iframe></div>

<h1 id="mitogenomics简介"><a href="#mitogenomics简介" class="headerlink" title="mitogenomics简介"></a>mitogenomics简介</h1><ul>
<li>无意中发现的一个软件。</li>
<li>基于已有线粒体基因组序列和基因序列，通过比对获取注释tbl格式文件，所以只适用于线粒体的基因。</li>
<li>包括两个转化格式的脚本mitos2fasta.py，aln2tbl.py（和python2版本）。</li>
</ul>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><ol>
<li><p>git下载<br><code>git clone https://github.com/IMEDEA/mitogenomics</code></p>
</li>
<li><p>脚本</p>
</li>
</ol>
<ul>
<li>因为软件是三个脚本组成，可以直接使用脚本。</li>
</ul>
<ol start="3">
<li>依赖</li>
</ol>
<ul>
<li>python3的Biopython和argparse模块。</li>
<li>可以用pip安装<code>pip install biopython argparse</code>。</li>
</ul>
<h1 id="软件mitogenomics"><a href="#软件mitogenomics" class="headerlink" title="软件mitogenomics"></a>软件mitogenomics</h1><h2 id="脚本mitos2fasta-py"><a href="#脚本mitos2fasta-py" class="headerlink" title="脚本mitos2fasta.py"></a>脚本mitos2fasta.py</h2><p>python 3 版本，用于转化基因序列为比对到线粒体基因组序列的格式。</p>
<ol>
<li><p>命令<br><code>mitos2fasta.py -m mito.fa -g genes.fa -c Y &gt; assembly.fa</code></p>
</li>
<li><p>输入输出</p>
</li>
</ol>
<ul>
<li>-m mito.fa：线粒体基因组序列，fasta格式。</li>
<li>-g genes.fa：基因序列，fasta格式。可以是软件MITOS2的输出。</li>
<li>-c Y：是否简化基因名字（genes.fa文件的序列ID）并适应aln2tbl.py，Y&#x2F;N。</li>
<li>assembly.fa：输出保存到assembly.fa，即将线粒体基因组序列和基因序列比对好的序列格式，基因没比对的位置用-代替。</li>
</ul>
<h2 id="aln2tbl-py"><a href="#aln2tbl-py" class="headerlink" title="aln2tbl.py"></a>aln2tbl.py</h2><p>python 3 版本，用于转化比对到线粒体基因组序列的基因序列（即mitos2fasta.py的输出）为tbl格式。</p>
<p>aln2tbl-legacy.py是aln2tbl.py的python2版本，功能一样。</p>
<ol>
<li><p>命令<br><code>aln2tbl.py -f assembly.fa -g genes.txt -c 1 &gt; sample.tbl</code></p>
</li>
<li><p>输入输出</p>
</li>
</ol>
<ul>
<li>-f assembly.fa：输入文件是线粒体基因组和基因序列的比对文件，mitos2fasta.py的输出。</li>
<li>-g genes.txt：保存了基因名称的文本文件，单行，多个基因名称间逗号分隔。</li>
<li>-c number_genetic_code：用数字指定线粒体编码方式，植物线粒体是一般的编码方式 (1)。此外还有脊椎动物vertebrate (2), 酵母菌yeast (3), 霉菌mold, 原生动物protozoan and 腔肠动物coelenterate (4), 无脊椎动物invertebrate (5), 棘皮动物echinoderm and 扁形虫flatworm (9), 海鞘类ascidian (13)。</li>
<li><blockquote>
<p>sample.tbl：输出到tbl格式文件。</p>
</blockquote>
</li>
</ul>
<h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ol>
<li><a href="https://github.com/IMEDEA/mitogenomics">https://github.com/IMEDEA/mitogenomics</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>fileformat</category>
        <category>mitogenome</category>
      </categories>
      <tags>
        <tag>mitogenome</tag>
        <tag>organelle</tag>
        <tag>tbl</tag>
        <tag>mitogenomics</tag>
        <tag>aln2tbl.py</tag>
        <tag>aln2tbl-legacy.py</tag>
        <tag>mitos2fasta.py</tag>
      </tags>
  </entry>
  <entry>
    <title>分析基因家族扩张和收缩 —— CAFE5</title>
    <url>/2021/10/29/bioinfo_gene.family_CAFE5/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=17059176&auto=1&height=32"></iframe></div>

<h1 id="1-CAFE"><a href="#1-CAFE" class="headerlink" title="1. CAFE"></a>1. CAFE</h1><p>CAFE(Computational Analysis of gene Family Evolution)是一款以解释系统发育历史的方式分析基因家族大小变化的软件，这种分析常被称为基因家族收缩扩张(Gene family expansions and contractions)分析。</p>
<p>CAFE使用出生和死亡过程来模拟用户指定的系统发育树中的基因获得和丢失，可计算由父节点到子节点的基因家族大小转移率，也可推断祖先物种的基因家族大小，在该模型下生成的基因家族规模分布可以为评估观察到的类群之间家族规模差异的显著性提供基础。</p>
<p>自2005年Hahn课题组提出评估基因家族进化速度和模式的算法，2006年第一个版本CAFE发表后，2020年推出了最新版本<a href="https://academic.oup.com/bioinformatics/article-abstract/36/22-23/5516/6039105?redirectedFrom=fulltext">CAFE5</a>，之前旧版本的基本模型假设所有基因家族都具有相同的进化速率。新版本支持伽马分布速率类别对家族之间的速率变化进行显式建模。</p>
<h1 id="2-CAFE5安装"><a href="#2-CAFE5安装" class="headerlink" title="2. CAFE5安装"></a>2. CAFE5安装</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/hahnlab/CAFE5.git</span><br><span class="line">cd CAFE5</span><br><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>conda可以安装CAFE4<br><code>conda install -c bioconda cafe</code>安装的是CAFE4</p>
<h1 id="3-CAFE5使用"><a href="#3-CAFE5使用" class="headerlink" title="3. CAFE5使用"></a>3. CAFE5使用</h1><h2 id="3-1-CAFE5输入文件"><a href="#3-1-CAFE5输入文件" class="headerlink" title="3.1. CAFE5输入文件"></a>3.1. CAFE5输入文件</h2><p>CAFE5需要至少两个输入文件，一个是基因家族计数文件gene_families.txt，一个是树文件tree.txt</p>
<h3 id="3-1-1-gene-families-txt"><a href="#3-1-1-gene-families-txt" class="headerlink" title="3.1.1. gene_families.txt"></a>3.1.1. gene_families.txt</h3><ol>
<li>gene_families.txt文件格式<br>制表符分隔的基因家族计数文件，通常用OrthoMCL, SwiftOrtho, FastOrtho, OrthAgogue, OrthoFinder等软件获取计数信息。</li>
</ol>
<p>第一列是功能描述Desc，可以为null，第二列是Family ID，其余列是每个物种以及包含对应的基因家族基因的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Desc	Family ID	human	chimp	orang	baboon	gibbon	macaque	marmoset rat	mouse	cat	horse	cow</span><br><span class="line">ATPase	ORTHOMCL1	 52	 55	 54	 57	 54	  56	  56	 53	 52	57	55	 54</span><br><span class="line">(null)	ORTHOMCL2	 76	 51	 41	 39	 45	  36	  37	 67	 79	37	41	 49</span><br><span class="line">HMG box	ORTHOMCL3	 50	 49	 48	 48	 46	  49	  48	 55	 52	51	47	 55</span><br><span class="line">(null)	ORTHOMCL4	 43	 43	 47	 53	 44	  47	  46	 59	 58	51	50	 55</span><br><span class="line">Dynamin	ORTHOMCL5	 43	 40	 43	 44	 31	  46	  33	 79	 70	43	49	 50</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>用orthofinder2的结果文件Orthogroups.GeneCount.tsv转换成gene_families.txt文件<br><code>awk -v OFS=&quot;\t&quot; &#39;&#123;$NF=null;print $1,$0&#125;&#39; Orthogroups.GeneCount.tsv |sed -E -e &#39;s/Orthogroup/desc/&#39; -e &#39;s/_[^\t]+//g&#39; &gt;gene_families.txt</code></p>
</li>
<li><p>如果是MCL获得的基因家族数据。cafe5的tutorials目录下有脚本mcl2rawcafe.py用于把mcl的输出转化成cafe5的输入。<br><code>python mcl2rawcafe.py -i dump.blast_output.mci.I30 -o gene_families.txt -sp &quot;ENSG00 ENSPTR ENSPPY ENSPAN ENSNLE ENSMMU ENSCJA ENSRNO ENSMUS ENSFCA ENSECA ENSBTA&quot;</code>。</p>
</li>
<li><p>剔除不同物种间的基因拷贝数变异特别大的基因家族。<br>否则可能无法估计参数，运行中断报错Failed to initialize any reasonable values</p>
</li>
</ol>
<ul>
<li>cafe5的tutorial目录下脚本clade_and_size_filter.py可以筛除一个或以上物种有超过100个基因拷贝的基因家族。<br><code>python clade_and_size_filter.py -s -i gene_families.txt -o gene_familie_filter.txt</code></li>
</ul>
<p>脚本运行失败。</p>
<ul>
<li>也可以用awk命令来筛除3-13列中基因家族数量大于等于100的行，可以根据自己的数据更改。<br><code>awk &#39;NR==1 || $3&lt;100 &amp;&amp; $4&lt;100 &amp;&amp; $5&lt;100 &amp;&amp; $6&lt;100 &amp;&amp; $7&lt;100 &amp;&amp; $8&lt;100 &amp;&amp; $9&lt;100 &amp;&amp; $10&lt;100 &amp;&amp; $11&lt;100 &amp;&amp; $12&lt;100 &amp;&amp; $13&lt;100 &#123;print $0&#125;&#39; gene_families.txt &gt;gene_families_filter.txt</code></li>
</ul>
<h3 id="3-1-2-tree-txt"><a href="#3-1-2-tree-txt" class="headerlink" title="3.1.2. tree.txt"></a>3.1.2. tree.txt</h3><ol>
<li>tree.txt文件格式<br>tree.txt是二叉的（binary），有根的（rooted），超度量(时间树，ultrametric)的newick格式树。</li>
</ol>
<p>可以用R包Ape的函数<code>is.binary</code>, <code>is.rooted</code>, <code>is.ultrametric</code>对树是否是二叉有根超度量做检验。</p>
<p>tree.txt文件内容的示例：<br>((((cat:68.710507,horse:68.710507):4.566782,cow:73.277289):20.722711,(((((chimp:4.444172,human:4.444172):6.682678,orang:11.126850):2.285855,gibbon:13.412706):7.211527,(macaque:4.567240,baboon:4.567240):16.056992):16.060702,marmoset:36.684935):57.315065):38.738021,(rat:36.302445,mouse:36.302445):96.435575);</p>
<ol start="2">
<li><p>用paml的Figtree转换成tree.txt文件（newick格式）<br><code>grep -E -v &quot;NEXUS|BEGIN|END&quot; FigTree.tre|sed -E -e &quot;s/\[[^]]*\]//g&quot; -e &quot;s/[ \t]//g&quot; -e &quot;/^$/d&quot; -e &quot;s/UTREE/tree tree/&quot; &gt;tree.txt</code></p>
</li>
<li><p>CAFE5软件下脚本prep_r8s.py用于构建r8s的批量运行脚本，可用批量运行脚本获得tree。</p>
</li>
</ol>
<h2 id="3-2-运行CAFE5"><a href="#3-2-运行CAFE5" class="headerlink" title="3.2. 运行CAFE5"></a>3.2. 运行CAFE5</h2><p><code>cafe5 -i gene_families_filter.txt -t tree.txt -p -k 2 -o k2p</code><br>参数：<br>-p代表指定root frequency distribution为泊松分布（默认是均匀分布uniform distribution）。<br>-k 3代表使用GAMMA模型（默认是base模型）并且使用3种gamma rate（代表不同基因家族有着不同的进化速率）。-k的值需要运行多次比较likelihood并确保收敛后才知道使用哪个最好，一般来说2-5之间试一试。<br>-o 指定输出目录，默认是results。</p>
<h2 id="3-3-CAFE5的结果"><a href="#3-3-CAFE5的结果" class="headerlink" title="3.3. CAFE5的结果"></a>3.3. CAFE5的结果</h2><h3 id="3-3-1-结果文件"><a href="#3-3-1-结果文件" class="headerlink" title="3.3.1. 结果文件"></a>3.3.1. 结果文件</h3><ol>
<li>model_asr.tre</li>
</ol>
<ul>
<li>每个基因家族的树的合集，nexus格式</li>
<li>树上的物种ID后的下划线隔开的数字是预期的基因家族大小</li>
<li>树上的星号代表这个物种的基因家族有显著变化</li>
</ul>
<ol start="2">
<li>model_clade_results.txt</li>
</ol>
<ul>
<li>进化树上每个节点扩张或者收缩了多少基因家族</li>
</ul>
<ol start="3">
<li>model_family_results.txt</li>
</ol>
<ul>
<li>基因家族变化的p值和是否显著的结果</li>
</ul>
<ol start="4">
<li>model_results.txt</li>
</ol>
<ul>
<li>模型，最终似然值，最终Lambda值等参数信息。</li>
</ul>
<p>还生成了一些其他文件。</p>
<h3 id="3-3-2-选择最优结果"><a href="#3-3-2-选择最优结果" class="headerlink" title="3.3.2. 选择最优结果"></a>3.3.2. 选择最优结果</h3><p>k值的结果比较：<br>查看k2p，k3p，k5p，k6p等不同的结果文件Gamma_results.txt文件中的第一行信息，Model Gamma Final Likelihood (-lnL)值，挑选最大的为最优结果。</p>
<h3 id="3-3-3-结果整理"><a href="#3-3-3-结果整理" class="headerlink" title="3.3.3. 结果整理"></a>3.3.3. 结果整理</h3><ol>
<li>对特定物种显著扩张或显著收缩基因的提取</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat Gamma_change.tab |cut -f1,15|grep &quot;+[1-9]&quot; &gt;sample.expanded #提取Gamma_change.tab第15列代表物种sample的扩张的orthogroupsID</span><br><span class="line">cat Gamma_change.tab |cut -f1,15|grep &quot;-&quot; &gt;sample.contracted  #提取Gamma_change.tab第15列代表物种sample的收缩的orthogroupsID</span><br><span class="line">grep &quot;sample&lt;13&gt;\*&quot; Gamma_asr.tre &gt; sample_significant_trees.tre # 根据sample ID和编号提取sample分支的基因家族显著扩张或收缩的基因家族树（Gamma_asr.tre文件中默认以p&lt;0.05为标准判断变化是否显著）</span><br><span class="line">grep -E -o &quot;OG[0-9]+&quot; sample_significant_trees.tre &gt; sample_significant.ogs # 提取sample分支显著变化的OG IDs （默认以p&lt;0.05为标准）</span><br><span class="line">awk &#x27;$2 &lt;0.01 &#123;print $1&#125;&#x27; Gamma_family_results.txt &gt;p0.01_significant.ogs # 以p&lt;0.01为标准提取所有显著扩张或收缩的orthogroupsID（根据情况调整，常用p&lt;0.05或p&lt;0.01）</span><br><span class="line">grep -f sample_significant.ogs p0.01_significant.ogs &gt; sample_p0.01_significant.ogs # 提取以p&lt;0.01为标准判断显著性的sample分支基因家族显著变化的OG IDs。</span><br><span class="line">grep -f sample_p0.01_significant.ogs sample.expanded |cut -f1 &gt;s ample.expanded.significant #提取显著扩张的sample物种的orthogroupsID</span><br><span class="line">grep -f sample_p0.01_significant.ogs sample.contracted |cut -f1 &gt; sample.contracted.significant #提取显著收缩的sample物种的orthogroupsID</span><br><span class="line">grep -f sample.expanded.significant ./OrthoFinder/Results_Oct14/Orthogroups/Orthogroups.txt |sed &quot;s/ /\n/g&quot;|grep &quot;bv&quot; |sort -k 1.3n |uniq &gt;sample.expanded.significant.genes #提取显著扩张的基因列表，假设基因ID是bv的前缀。</span><br><span class="line">grep -f sample.contracted.significant ./OrthoFinder/Results_Oct14/Orthogroups/Orthogroups.txt sed &quot;s/ /\n/g&quot;|grep &quot;bv&quot; |sort -k 1.3n |uniq &gt;sample.contracted.significant.genes #提取显著收缩的基因列表，假设基因ID是bv的前缀。</span><br><span class="line">seqkit grep -f sample.expanded.significant.genes sample.pep.fa &gt;sample.expanded.significant.pep.fa #提取显著扩张的基因序列</span><br><span class="line">seqkit grep -f sample.contracted.significant.genes sample.pep.fa &gt;sample.contracted.significant.pep.fa #提取显著收缩的基因序列</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>提取出指定物种的显著扩张和收缩的蛋白序列之后，就可以拿去做GO注释和基因富集分析。</li>
</ol>
<h2 id="3-4-把每个节点收缩扩张的基因数量画在树上"><a href="#3-4-把每个节点收缩扩张的基因数量画在树上" class="headerlink" title="3.4. 把每个节点收缩扩张的基因数量画在树上"></a>3.4. 把每个节点收缩扩张的基因数量画在树上</h2><p>有看到一个画图脚本，不适用于CAFE5，暂且记录在此。<br><code>python python_scripts/cafetutorial_draw_tree.py -i reports/summary_run1_node.txt -t &#39;((((cat:68.7105,horse:68.7105):4.56678,cow:73.2773):20.7227,(((((chimp:4.44417,human:4.44417):6.68268,orang:11.1268):2.28586,gibbon:13.4127):7.21153,(macaque:4.56724,baboon:4.56724):16.057):16.0607,marmoset:36.6849):57.3151):38.738,(rat:36.3024,mouse:36.3024):96.4356)&#39; -d &#39;((((cat&lt;0&gt;,horse&lt;2&gt;)&lt;1&gt;,cow&lt;4&gt;)&lt;3&gt;,(((((chimp&lt;6&gt;,human&lt;8&gt;)&lt;7&gt;,orang&lt;10&gt;)&lt;9&gt;,gibbon&lt;12&gt;)&lt;11&gt;,(macaque&lt;14&gt;,baboon&lt;16&gt;)&lt;15&gt;)&lt;13&gt;,marmoset&lt;18&gt;)&lt;17&gt;)&lt;5&gt;,(rat&lt;20&gt;,mouse&lt;22&gt;)&lt;21&gt;)&lt;19&gt;&#39; -o reports/summary_run1_tree_rapid.png -y Rapid</code></p>
<p>没有试过这个脚本，发表的图还是用R包ggtree自己画。</p>
<h1 id="correction-note"><a href="#correction-note" class="headerlink" title="correction note"></a>correction note</h1><p>3.3.3结果整理部分的“1. 对特定物种显著扩张或显著收缩基因的提取”部分的代码已更新，修改了一处错误。新代码对<strong>特定物种</strong>的显著变化的基因家族Orthogroup IDs进行提取。</p>
<p>——感谢University of Colorado Boulder的李瑞祺的提醒。</p>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li><a href="https://academic.oup.com/bioinformatics/article-abstract/36/22-23/5516/6039105?redirectedFrom=fulltext">https://academic.oup.com/bioinformatics/article-abstract/36/22-23/5516/6039105?redirectedFrom=fulltext</a></li>
<li><a href="https://github.com/hahnlab/CAFE5">https://github.com/hahnlab/CAFE5</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>gene family</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>phylogeny</tag>
        <tag>gene family</tag>
        <tag>CAFE</tag>
      </tags>
  </entry>
  <entry>
    <title>基因流推断 —— Dsuite</title>
    <url>/2022/04/10/bioinfo_geneflow_Dsuite/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=171959&auto=1&height=32"></iframe></div>

<h1 id="1-Dsuite"><a href="#1-Dsuite" class="headerlink" title="1. Dsuite"></a>1. Dsuite</h1><ol>
<li>Dsuite简介<ul>
<li>Dsuite是通过计算Patterson’s D统计量(即ABBA统计量)和f4等统计量来评估种群间或近缘种间基因流的基于C语言的软件。</li>
</ul>
</li>
<li>Dsuite 原理<ul>
<li>D值（即ABBA统计量）和f4-ratio统计可以表示为适用于四个分类群的双等位基因SNP：P1,P2,P3,O，拓扑是 (((P1,P2),P3),O)。</li>
<li>其中外类群O携带祖先等位基因A，衍生等位基因用B表示。BBAA,ABBA,BABA分别代表四个分类群携带等位的三种模式。</li>
<li>在没有基因流的零假设下，由于具有相同频率的不完全谱系分类，预计P3与P1或P2共享衍生等位基因B的两种模式ABBA和BABA的频率相等，如果ABBA和BABA的频率有显著差异则代表在P3和P1或P2间存在基因渐渗。</li>
<li>D&#x3D;(nABBA-nBABA)&#x2F;(nABBA+nBABA)；在外群对于祖先等位基因A是固定的（外群中B的频率为0）假设下，D统计量是等位基因模式计数的归一化差异。</li>
<li>如果外群中衍生等位基因B不为0，则Dsuite的D值是Patterson’s D，适用于无根的四分类群树。</li>
</ul>
</li>
<li>Dsuite输入输出<ul>
<li>输入：基因组snp的vcf格式文件，居群树文件(可选optional)</li>
<li>输出：D值统计，f4-ratio统计，f-branch统计，f-branch树矩阵热图</li>
</ul>
</li>
<li>Dsuite优势和不足<ul>
<li>Dsuite的优势是运行非常快(时间以小时计算)</li>
<li>不足是Dsuite分析结果不包含基因流的方向</li>
</ul>
</li>
<li>Dsuite适用范围<ul>
<li>Dsuite适用于基因组学大数据和多样本(超过十个)数据</li>
<li>适用于居群间或物种间的基因流推测</li>
<li>即使每个群体只有一个个体也可以推测基因流</li>
<li>还可以计算pool-seq数据的基因流</li>
<li>相较其他计算D值软件，Dsuite还同时可以计算f4-ratio和f-branch，以及滑窗统计f相关值。</li>
</ul>
</li>
</ol>
<h1 id="2-Dsuite-install"><a href="#2-Dsuite-install" class="headerlink" title="2. Dsuite install"></a>2. Dsuite install</h1><ol>
<li>安装Dsuite主程序<br>Dsuite是C编写的，需要编译；需要GCC(&gt;&#x3D;4.9.0)和zlib压缩库。<br>编译后可执行文件在Dsuite&#x2F;Build&#x2F;目录下，可以加到环境变量中或使用绝对路径。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/millanek/Dsuite.git</span><br><span class="line">cd Dsuite</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装python3 Fbranch绘图脚本【可选但推荐】<br>如果要绘制f-branch计算结果，则需要安装这个绘图脚本。注意<code>--prefix=</code>后没有任何内容。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd utils</span><br><span class="line">python3 setup.py install --user --prefix=</span><br></pre></td></tr></table></figure>

<h1 id="3-Dsuite分析"><a href="#3-Dsuite分析" class="headerlink" title="3. Dsuite分析"></a>3. Dsuite分析</h1><h2 id="3-1-输入文件"><a href="#3-1-输入文件" class="headerlink" title="3.1. 输入文件"></a>3.1. 输入文件</h2><ol>
<li>sample.snp.vcf.gz<ul>
<li>基因组尺度的snp文件，vcf格式，可用bgzip压缩</li>
</ul>
</li>
<li>sets.txt<ul>
<li>包括两列，tab分隔；第一列个体名，第二列物种名&#x2F;居群名。</li>
<li>对于Dtrios模块，至少指定一个个体为外类群，外类群个体的第二列写Outgroup，可有多个。</li>
<li>要注意第二列物种名不能包含短横杠-和句点.字符，否则Dsuite Dtrios虽然不会报错，但Dsuite Fbranch模块运行报错解析不了树文件(ERROR: The tree string could not be parsed correctly)。</li>
</ul>
</li>
<li>species.newick【optional】<ul>
<li>Newick格式的居群&#x2F;物种树文件，物种名称与sets.txt对应。</li>
<li>外类群名称替换成Outgroup，与sets.txt对应。</li>
<li>树文件必须定根在Outgroup，否则dtools.py报错树文件和franch.out的拓扑不一致。</li>
<li>去掉支持率；否则Dsuite Fbranch模块运行报错解析不了树文件，ERROR: The tree string could not be parsed correctly。</li>
<li>枝长最好也去掉，不去枝长也不会被Dsuite用到，还可能增加报错风险。</li>
<li>这个文件对于Dtrios模块是可选项，但建议加上好画fbranch的图。</li>
</ul>
</li>
</ol>
<h2 id="3-2-Dtrios模块"><a href="#3-2-Dtrios模块" class="headerlink" title="3.2. Dtrios模块"></a>3.2. Dtrios模块</h2><p><code>Dsuite Dtrios</code>用于计算所有三物种组合的D和f4-ratio统计量</p>
<ol>
<li><p>用法<br><code>Dsuite Dtrios sample.snp.vcf.gz sets.txt -t species.newick -o sample</code></p>
</li>
<li><p>输入和常用参数</p>
</li>
</ol>
<ul>
<li>sample.snp.vcf.gz：变异文件</li>
<li>sets.txt：分组文件</li>
<li>-t species.newick：指定物种树文件</li>
<li>-o sample：指定输出文件前缀，默认是sets</li>
<li>-p 5：如果样品中包含pool-seq数据，-p用于设置最小深度，设置后从等位基因深度估计群体的等位基因频率。</li>
<li>-c：不输出sample_combine_stderr.txt和sample_combine.txt；这两个文件用作DtriosCombine的输入，如果不需要可加上-c不输出这两个文件。</li>
</ul>
<ol start="3">
<li>运行耗时</li>
</ol>
<ul>
<li>7Mb的29个物种的snp数据花费大概3-4小时。</li>
</ul>
<ol start="4">
<li>结果</li>
</ol>
<ul>
<li>sample_BBAA.txt：不参考-t的拓扑，尝试推断树拓扑的统计量。对每个三重奏进行排序，假设正确的树是 BBAA 模式比不一致的 ABBA和BABA 模式更常见；ABBA和BABA 模式被认为是由不完整的谱系分类或基因渗入引起的。</li>
<li>sample_Dmin.txt：不管关于树拓扑的任何假设，不尝试推断树拓扑，而是输出每个三物种组合的最小D值统计量。三物种组合的排序是为了使nABBA和nBABA之间的差异最小。</li>
<li>sample_tree.txt：如果-t指定物种树则输出此项；与指定树一致的排序的D和f4-ratio统计量。这个文件是后续f-branch分析的输入文件。</li>
<li>sample.txt</li>
<li>sample_combine_stderr.txt和sample_combine.txt：用作DtriosCombine的输入，如果不需要可删除</li>
</ul>
<ol start="5">
<li>notes</li>
</ol>
<ul>
<li>sample_BBAA.txt，sample_Dmin.txt，sample_tree.txt三个文件结构一致，是在不同树的假设前提下（意味着三物种组合的不同排序）的统计量输出。</li>
<li>三个文件包含三物种组合的D统计量，Z-score，未调整的p-value，f4-ratio，三种模式（BBAA,ABBA,BABA）的计数。</li>
<li>三个文件的D统计量总是正值，因为软件对P1和P2进行排序，使得nABBA&gt;&#x3D;nBABA。</li>
<li>Dtrios模块使用标准block-jackknife程序获得一个近似正态分布的标准误差，在三个文件中，计算Z-scores的公式是Z&#x3D;D&#x2F;std_err(D)，并输出p-values。</li>
<li>可以用p-values&lt;0.05&#x2F;0.01来筛选D显著大于0的三联体，当D显著大于0，代表P2与P3间有基因流。</li>
</ul>
<h2 id="3-3-计算和绘制f-branch"><a href="#3-3-计算和绘制f-branch" class="headerlink" title="3.3. 计算和绘制f-branch"></a>3.3. 计算和绘制f-branch</h2><h3 id="3-3-1-计算f-branch值"><a href="#3-3-1-计算f-branch值" class="headerlink" title="3.3.1. 计算f-branch值"></a>3.3.1. 计算f-branch值</h3><p><code>Dsuite Fbranch</code>是一种启发式方法，执行f-branch计算，用于解释f4-ratio相关结果。</p>
<ol>
<li><p>用法<br><code>Dsuite Fbranch species.newick sample_tree.txt &gt;fbranch.out</code></p>
</li>
<li><p>输入</p>
</li>
</ol>
<ul>
<li>species.newick：指定物种树文件</li>
<li>sample_tree.txt：需要Dsuite Dtrios并-t指定树拓扑得到的结果文件sample_tree.txt作为输入</li>
</ul>
<ol start="3">
<li>结果</li>
</ol>
<ul>
<li>fbranch.out：f-branch统计量保存成矩阵格式</li>
</ul>
<h3 id="3-3-2-绘制f-branch图"><a href="#3-3-2-绘制f-branch图" class="headerlink" title="3.3.2. 绘制f-branch图"></a>3.3.2. 绘制f-branch图</h3><p>用dtools.py脚本绘制f-branch图</p>
<ol>
<li>用法<br><code>Dsuite/utils/dtools.py fbranch.out species.newick --outgroup Outgroup --use_distances --dpi 1200 --tree-label-size 30</code></li>
</ol>
<p>如果运行log出现Plotting fbranch… Saving plots可以看到图片文件生成，即使报错Segmentation fault (core dumped)也没关系。</p>
<ol start="2">
<li>输入和常用参数</li>
</ol>
<ul>
<li>fbranch.out：指定fbranch文件</li>
<li>species.newick：指定物种树文件</li>
<li>–outgroup：指定外类群（与fbranch.out和species.newick一致，一般是Outgroup）</li>
<li>–use_distances：画树时使用newick文件里节点距离</li>
<li>–dpi：设置png分辨率，有些期刊投稿要求1200，800，600不等；最好高点。</li>
<li>–tree-label-size：设置树节点标签大小</li>
</ul>
<ol start="3">
<li>结果<br>画Fbranch的图，得到fbranch.svg和fbranch.png；</li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/bioinfo_geneflow.Dsuite_fbranch.png?raw=true" width=90% title="f-branch示意图(A4,(A3,(A2,A1)B)C)D" align=center/>

<p><strong><p align="center">Figure 1. f-branch示意图</p></strong></p>
<h1 id="4-reference"><a href="#4-reference" class="headerlink" title="4. reference"></a>4. reference</h1><ol>
<li>Dsuite github：<a href="https://github.com/millanek/Dsuite">https://github.com/millanek/Dsuite</a></li>
<li>Dsuite paper：<a href="https://onlinelibrary.wiley.com/doi/10.1111/1755-0998.13265">https://onlinelibrary.wiley.com/doi/10.1111/1755-0998.13265</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>gene flow</category>
      </categories>
      <tags>
        <tag>gene flow</tag>
        <tag>Dsuite</tag>
        <tag>hybridization</tag>
        <tag>introgressive</tag>
      </tags>
  </entry>
  <entry>
    <title>3s软件</title>
    <url>/2022/09/22/bioinfo_geneflow_3s/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=105216&auto=1&height=32"></iframe></div>

<h1 id="1-检测基因流的软件"><a href="#1-检测基因流的软件" class="headerlink" title="1. 检测基因流的软件"></a>1. 检测基因流的软件</h1><ol>
<li>基于MCMC算法的：IM,IMA</li>
<li>基于似然法的：除了3s外的其他软件只能分析两条序列</li>
<li>Huristic method：ABBA(基于D统计量的计算，无数学模型，无法估计),Hyde</li>
</ol>
<h1 id="2-3s软件简介"><a href="#2-3s软件简介" class="headerlink" title="2. 3s软件简介"></a>2. 3s软件简介</h1><p>3s，3 species的简称。</p>
<p>软件是杨子恒和朱天琪团队开发，基于C语言的，通过计算似然率来检测两个近缘物种&#x2F;群体间基因流的软件。推荐添加一个外类群，所以称为三个物种（3 species），适用于基因组数据。</p>
<ol>
<li>3s简介</li>
</ol>
<ul>
<li>3s利用似然率来推断两个物种&#x2F;群体间的基因流方向和强度</li>
</ul>
<ol start="2">
<li>3s输入</li>
</ol>
<ul>
<li>输入：基因组或其他测序序列phylip文件</li>
<li>输出：基因流方向和强度</li>
</ul>
<ol start="3">
<li>3s优势和不足</li>
</ol>
<ul>
<li>随着数据量线性增加运算时间，运算快，适合基因组数据。</li>
<li>一次只能检测三个物种&#x2F;群体，无法建立系统发育网。</li>
</ul>
<h1 id="3-开发历史"><a href="#3-开发历史" class="headerlink" title="3. 开发历史"></a>3. 开发历史</h1><ol>
<li>3s软件主页</li>
</ol>
<ul>
<li><a href="http://abacus.gene.ucl.ac.uk/software/3s.html">http://abacus.gene.ucl.ac.uk/software/3s.html</a></li>
<li><a href="http://abacus.gene.ucl.ac.uk/software/#3s">http://abacus.gene.ucl.ac.uk/software/#3s</a></li>
</ul>
<ol start="2">
<li>2012年，朱天琪和杨子恒开发的检测基因流的模型SIM3s，发布了软件3s.v2.1版本，包含6个参数。</li>
</ol>
<ul>
<li>文章发表在MBE上：<a href="https://academic.oup.com/mbe/article/29/10/3131/1029349">https://academic.oup.com/mbe/article/29/10/3131/1029349</a></li>
</ul>
<ol start="3">
<li>2017年，提出了Introgression模型，发布了版本3s.v3.1版本，包含9个参数。</li>
</ol>
<ul>
<li>文章发表在SB上：<a href="https://academic.oup.com/sysbio/article/66/3/379/2670069?login=false">https://academic.oup.com/sysbio/article/66/3/379/2670069?login=false</a></li>
</ul>
<ol start="4">
<li>2020年，据作者朱天琪说开发了新的more general migration model模型，包含15个参数，2022.09还未发表。</li>
</ol>
<ul>
<li>假设所有物种间都可能有基因，1-2间，2-3间，1-3间，3-5之间都可能存在基因流。</li>
<li>这个模型参数太多，最好根据先验知识尽可能设置一些无基因流的群体间参数为0，再进行计算更准确。</li>
<li>如果实在没有先验知识，那先打开所有可能基因流，运行一遍，再把基因流强度很低的位置关闭，再运行一遍获取更准确结果。</li>
<li>2020年09月据说代码已有，2022.09说还未发表，可以关注着。</li>
</ul>
<h1 id="4-3s软件原理"><a href="#4-3s软件原理" class="headerlink" title="4. 3s软件原理"></a>4. 3s软件原理</h1><h2 id="4-1-模型基础"><a href="#4-1-模型基础" class="headerlink" title="4.1. 模型基础"></a>4.1. 模型基础</h2><ol>
<li>Wright-Fisher模型：溯祖模型的逆向过程</li>
<li>多物种溯祖模型</li>
</ol>
<ul>
<li>不区分物种间和群体间，这里的物种&#x3D;群体</li>
<li>无法跨物种边界溯祖</li>
</ul>
<h2 id="4-2-3s模型的参数定义"><a href="#4-2-3s模型的参数定义" class="headerlink" title="4.2. 3s模型的参数定义"></a>4.2. 3s模型的参数定义</h2><ol>
<li>三个物种：两个近缘种（1和2）和一个外类群（3）</li>
<li>序列数据由中性位点组成</li>
<li>θ<sub>1</sub>&#x3D;4N<sub>1</sub>μ，θ<sub>2</sub>&#x3D;4N<sub>2</sub>μ，θ<sub>4</sub>&#x3D;4N<sub>4</sub>μ，θ<sub>5</sub>&#x3D;4N<sub>5</sub>μ是物种1，2，4，5的群体大小参数。这里没有物种3是因为假设物种3没有基因流。</li>
<li>τ0, τ1是两个物种的分化时间</li>
<li>迁移率(migration rate)M<sub>ij</sub>&#x3D;N<sub>j</sub>m<sub>ij</sub>。定义是在真实世界，从群体i向群体j的迁移个体的数量，其中N<sub>j</sub>代表群体j的群体大小，m<sub>ij</sub>代表迁移比例。</li>
</ol>
<img src="https://academic.oup.com/view-large/figure/87817031/syw063f1.tif" title="3个物种的基因流模型参数" width="90%"/>

<p><strong><p align="center">Figure 1. 3个物种的基因流模型参数</strong><br>图源：<a href="https://academic.oup.com/sysbio/article/66/3/379/2670069?login=false">https://academic.oup.com/sysbio/article/66/3/379/2670069?login=false</a></p></p>
<h2 id="4-3-SIM3s模型"><a href="#4-3-SIM3s模型" class="headerlink" title="4.3. SIM3s模型"></a>4.3. SIM3s模型</h2><ol>
<li>通过假设两个参数相等，θ<sub>1</sub>&#x3D;θ<sub>2</sub>&#x3D;θ；M<sub>12</sub>&#x3D;M<sub>21</sub>&#x3D;M</li>
<li>结果是共有6个参数需要评估：Θ&#x3D;{τ0,τ1,θ4,θ5,θ,M}</li>
<li>这个模型是2012年发表的老版本模型SIM3s(symmetric IM model for three species)</li>
</ol>
<h2 id="4-4-3s模型背后的计算"><a href="#4-4-3s模型背后的计算" class="headerlink" title="4.4. 3s模型背后的计算"></a>4.4. 3s模型背后的计算</h2><p>基于最大似然法估计参数：先算似然函数，对参数做最优，似然值最大的对应参数即为估计结果。</p>
<ol>
<li>每个位点&#x2F;序列计算一个<strong>似然值</strong>，似然值代表的是给定参数后基因树的概率。</li>
<li>似然值的计算是通过马尔科夫链来描述和实现的，三个样本的初始状态是123。</li>
<li>在比对好的三个样本的序列上对不同模式进行碱基计数。三个样本的碱基一致为同一种模式，12一致3不一致为一种模式，等等。</li>
<li>3s软件的突变模型使用JC69模型，即各种碱基的任意方向和类型的替换速率是相等的，适合近缘物种&#x2F;群体。</li>
<li>通过似然比检验（Likelihood Ratio Test，LRT）来判断有无基因流：当按照95%显著临界值，2Δℓ&gt;5.99时，则认为检验是显著的，即存在基因流，基因流的大小即最大似然估计值。</li>
</ol>
<h1 id="5-3s的优势"><a href="#5-3s的优势" class="headerlink" title="5. 3s的优势"></a>5. 3s的优势</h1><ol>
<li>3s的计算基于极大似然法，极大似然法的优势在于计算量随着样本数是线性增加的，而比如贝叶斯,MCMC算法则是指数增加。</li>
<li>使用的segment&#x2F;locus数量越多，检验功效（指有基因流存在情况下检出率）越好，所以适合检验基因组这种大数据。</li>
<li>假阳性很低（&lt;5%可接受）</li>
<li>基因流的方向和强度都可以被估计。</li>
</ol>
<h1 id="6-3s模型假设和数据准备"><a href="#6-3s模型假设和数据准备" class="headerlink" title="6. 3s模型假设和数据准备"></a>6. 3s模型假设和数据准备</h1><h2 id="6-1-3s模型假设和数据选择"><a href="#6-1-3s模型假设和数据选择" class="headerlink" title="6.1. 3s模型假设和数据选择"></a>6.1. 3s模型假设和数据选择</h2><ol>
<li>使用中性位点避免重组的影响。</li>
<li>3s假设segment之间是自由重组的，segment内部是不存在重组的。所以建议在基因组上取样的序列不要离得太近（建议50kb，至少大于10kb），序列长度不要太长（50bp-1kb）。</li>
<li>使用的segment&#x2F;locus数量越多，检验功效（指有基因流存在情况下检出率）越好，所以适合检验基因组这种大数据。</li>
</ol>
<h2 id="6-2-常用的数据准备方式"><a href="#6-2-常用的数据准备方式" class="headerlink" title="6.2. 常用的数据准备方式"></a>6.2. 常用的数据准备方式</h2><ol>
<li>适用于组装好的基因组数据</li>
</ol>
<ul>
<li>将基因组切分为1kb的片段</li>
<li>每隔50kb取1kb的片段</li>
<li>将含有基因和基因上下游10kb的片段去除（基因通常被认为是非中性的）</li>
</ul>
<ol start="2">
<li>适用于获取的别人的partition数据</li>
</ol>
<ul>
<li>去除间隔&lt;10kb的partition</li>
<li>删除序列长度&lt;50bp或者&gt;1000bp的partition</li>
</ul>
<ol start="3">
<li>适用于微生物等基因组非常小的样品</li>
</ol>
<ul>
<li>有许多微生物样品的基因组很小，能取的片段数量有限，影响分析结果。</li>
<li>可以通过非独立重抽样增加片段数量。</li>
<li>每个物种测序多个个体，共同作为一个数据源，以增加片段数量。比如ABC三个物种都测四个个体，A1B1C1,A2B2C2,A3B3C3,A4B4C4。</li>
</ul>
<h1 id="7-3s软件使用"><a href="#7-3s软件使用" class="headerlink" title="7. 3s软件使用"></a>7. 3s软件使用</h1><h2 id="7-1-3s软件安装"><a href="#7-1-3s软件安装" class="headerlink" title="7.1. 3s软件安装"></a>7.1. 3s软件安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://abacus.gene.ucl.ac.uk/software/3s.v3.1.tgz # 下载软件，只有6.74MB</span><br><span class="line">tar -zxf 3s.v3.1.tgz #解压缩和解包</span><br><span class="line">cd 3s.v3.1 #进入文件夹</span><br><span class="line">gcc -O3 -o 3s 3s.c tools.c lfun3s.c -lm #编译</span><br></pre></td></tr></table></figure>

<h2 id="7-2-输入文件"><a href="#7-2-输入文件" class="headerlink" title="7.2. 输入文件"></a>7.2. 输入文件</h2><ol>
<li>三个样本的碱基序列文件</li>
</ol>
<ul>
<li>phylip格式</li>
<li>比对好的(aligned)</li>
</ul>
<ol start="2">
<li>3s.ctl：参数文件基本使用默认即可，不需要变动。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seed = -1 #随机数种子，-1使用时间种子</span><br><span class="line">outfile = path/to/out #存储运行结果的路径</span><br><span class="line">seqfile = sample_align.phylip #比对好的phylip格式的序列</span><br><span class="line">Imapfile = mapfile.txt #map文件，即下面准备的输入文件；如果没有map文件，默认出现的前3个物种为物种1，2，3。</span><br><span class="line">ratefile = ChenLi3s.Rate.txt # 这行作者建议删除，因为使用的JC69模型，无法改变不同碱基的替换率。</span><br><span class="line">nloci = 1000 # 基因位点的数量。如果小于实际位点数，只计算前1000个；如果大于实际位点数，则报错。</span><br><span class="line">npoints = 16 # 做数值积分的格点数，越大精度越高，但速度慢很多。用8，16，32；作者建议16，或者尝试32。</span><br><span class="line">getSE = 0 # 通常设置为0，不算方差；如果设置成1，计算方差，运算速度大幅下降，但总体上来说都很快。算不算都行。</span><br><span class="line">Small_Diff = 0.5e-9 #最大似然估计的时候，似然值到多小就停止计算，建议0.5e-9，在0.5e-8到1e-9范围内调整。</span><br><span class="line">simmodel = 0 #0代表不用对称模型（symmetric models），1代表使用对称模型。对称模型是指所有群体大小参数都一样，一般不用。</span><br><span class="line">models = 0 2 3 #计算的模型，3代表introgression模型。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>mapfile</li>
</ol>
<ul>
<li>用于指定三个物种分别是1，2，3的文本文件。</li>
<li>每行两列，空格隔开。第一列物种名，第二列1，2，3。保存mapfile.txt</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A 1</span><br><span class="line">B 2</span><br><span class="line">C 3</span><br></pre></td></tr></table></figure>

<h2 id="7-3-3s软件运行"><a href="#7-3-3s软件运行" class="headerlink" title="7.3. 3s软件运行"></a>7.3. 3s软件运行</h2><p>运行命令<code>3s 3s.ctl</code>即可</p>
<h2 id="7-4-运行结果"><a href="#7-4-运行结果" class="headerlink" title="7.4. 运行结果"></a>7.4. 运行结果</h2><ol>
<li><p>结果示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***Model 0 (M0)***</span><br><span class="line">lnL = -342929.817009</span><br><span class="line">MLEs</span><br><span class="line">    theta4 theta5 tau0 tau1 theta1 theta2 theta3</span><br><span class="line">    0.002213 0.000337 0.000866 0.000431 0.001156 0.003993 0.000502</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">***Model 2***</span><br><span class="line">lnL = -342888.249022</span><br><span class="line">2DlnL = +83.135973</span><br><span class="line">MLEs</span><br><span class="line">    theta4 theta5 tau0 tau1 theta1 theta2 theta3 M12</span><br><span class="line">    0.002248 0.000076 0.000853 0.000759 0.000987 0.001408 0.000500 0.934564</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果的解释</p>
</li>
</ol>
<ul>
<li>Model 0是没有基因流的情况下估计得到的参数，theta是θ，tau是τ。</li>
<li>Model 2是存在基因流的情况下估计得到的参数，M12代表的是从物种1到物种2的基因流，强度是0.934564，代表平均每一代有0.934564个个体从物种1迁移到物种2，是很强的基因流。</li>
</ul>
<h2 id="7-5-结果有效性"><a href="#7-5-结果有效性" class="headerlink" title="7.5. 结果有效性"></a>7.5. 结果有效性</h2><h3 id="7-5-1-如何保证收敛"><a href="#7-5-1-如何保证收敛" class="headerlink" title="7.5.1. 如何保证收敛"></a>7.5.1. 如何保证收敛</h3><ol>
<li>同一数据，运行多次保证结果一致，且2dlnL&gt;0。当多次结果不一致时，可以考虑调小small_diff，不行再调大。</li>
<li>遇到收敛困难时，可以先在M0（即无基因流的模式）下分析，把M0的MLE作为其他模型的初值。</li>
<li>如果估计值触碰到上下界且明显不合理，需多次分析；可以尝试通过修改in.3s文件将初值设置在更合理的地方。</li>
<li>将不可能出现迁移的方向迁移率设置为0，减少参数个数。</li>
</ol>
<h3 id="7-5-2-如何选择正确模型"><a href="#7-5-2-如何选择正确模型" class="headerlink" title="7.5.2. 如何选择正确模型"></a>7.5.2. 如何选择正确模型</h3><ol>
<li>如估计的树接近星状树，需调整物种树再次分析。这个调整物种树就是调整mapfile.txt文件，使得不同物种成为外类群。如果调整成任意物种树都是星状树，则可以作为辐射进化（即τ0,τ1时间很短）的证据。</li>
<li>如果迁移率M<sub>ij</sub>触碰下界可将该迁移率固定为0后重新分析，如两次分析-lnL相差在1.92内，则认为参数少的模型更加准确。</li>
<li>多次分析后找出最优模型</li>
</ol>
<h1 id="8-reference"><a href="#8-reference" class="headerlink" title="8. reference"></a>8. reference</h1><p>这篇笔记主要是参考“朱天琪老师在中国科学院微生物研究所真菌学国家重点实验室主办的2020种群遗传学与基因组学高级培训班(第二期)和2022组学驱动的进化生态高级培训班的讲座和PPT”。</p>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>gene flow</category>
      </categories>
      <tags>
        <tag>gene flow</tag>
        <tag>hybridization</tag>
        <tag>introgressive</tag>
        <tag>3s</tag>
        <tag>SIM3s</tag>
      </tags>
  </entry>
  <entry>
    <title>系统发育网络推断 —— PhyloNetworks</title>
    <url>/2022/04/14/bioinfo_geneflow_PhyloNetworks/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=108998&auto=1&height=32"></iframe></div>

<h1 id="1-PhyloNetworks"><a href="#1-PhyloNetworks" class="headerlink" title="1. PhyloNetworks"></a>1. PhyloNetworks</h1><ol>
<li>PhyloNetworks简介<ul>
<li>PhyloNetworks是通过基因树或多位点序列(SNaQ)的最大伪似然进行推断系统发育网络的一个Julia包。</li>
</ul>
</li>
<li>PhyloNetworks原理<ul>
<li>原理：通过SNaQ来实现网络推断，SNaQ通过估计4分类群子集的最大伪似然来加速运算，估计的网络不受根的影响。</li>
</ul>
</li>
<li>PhyloNetworks输入输出<ul>
<li>输入：newick格式基因树(多个基因树组成的文件)</li>
<li>输出：系统发育网络，基因流方向和杂交节点贡献比例</li>
</ul>
</li>
<li>PhyloNetworks优势和不足<ul>
<li>推断系统发育网络，包括基因流的方向和强度。</li>
<li>相较于其他推断系统发育网络的软件，PhyloNetworks集成了上游分析，网络估计，引导分析，下游特征进化分析，绘图等功能。</li>
<li>不足是运行多样本(超过十个个体)和数据量大(超过1000个)会非常耗时(常常以星期&#x2F;月计时)。</li>
</ul>
</li>
<li>PhyloNetworks适用范围<ul>
<li>PhyloNetworks适用于基因树数据</li>
<li>适用于居群间或物种间的基因流推测</li>
<li>适用于推断基因流方向和强度</li>
</ul>
</li>
</ol>
<h1 id="2-PhyloNetworks安装"><a href="#2-PhyloNetworks安装" class="headerlink" title="2. PhyloNetworks安装"></a>2. PhyloNetworks安装</h1><p>PhyloNetworks是Julia包，Julia是一个类似R的计算机语言，可以交互式或脚本式执行命令。</p>
<h2 id="2-1-Julia-安装"><a href="#2-1-Julia-安装" class="headerlink" title="2.1. Julia 安装"></a>2.1. Julia 安装</h2><p>如果想简要了解julia，可以看<a href="https://learnxinyminutes.com/docs/julia/">julia tutorials</a>。</p>
<ol>
<li><p>预编译软件安装<br>在<a href="https://julialang.org/downloads/">julia software</a>找到对应版本的预编译的软件下载解压缩即可使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://julialang-s3.julialang.org/bin/linux/x64/1.7/julia-1.7.2-linux-x86_64.tar.gz #下载linux的64位预编译的julia</span><br><span class="line">tar -xzf julia-1.7.2-linux-x86_64.tar.gz #解压缩</span><br><span class="line">julia-1.7.2/bin/julia -h #查看帮助文章</span><br></pre></td></tr></table></figure>
</li>
<li><p>源代码编译安装<br>通过<a href="https://github.com/JuliaLang/julia">julia github</a>获取源代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/JuliaLang/julia.git #克隆github上的最新版源代码</span><br><span class="line">cd julia</span><br><span class="line">git checkout v1.7.2 #运行checkout来获取julia的最新稳定版本1.7.2</span><br><span class="line">make #编译</span><br><span class="line">./julia -h #查看帮助文档</span><br></pre></td></tr></table></figure></li>
</ol>
<p>之后把julia命令的路径添加到环境变量，便可以直接使用julia了。<br>julia与R很像，进入交互界面，只需要在shell里键入<code>julia</code>回车即可，退出交互界面是ctrl+D。</p>
<h2 id="2-2-安装PhyloNetworks包"><a href="#2-2-安装PhyloNetworks包" class="headerlink" title="2.2. 安装PhyloNetworks包"></a>2.2. 安装PhyloNetworks包</h2><ul>
<li>进入julia运行<code>using Pkg</code>-<code>Pkg.add(&quot;PhyloNetworks&quot;)</code>即可安装PhyloNetworks包。</li>
<li>在julia运行<code>Pkg.update()</code>会更新所有julia包。</li>
<li>PhyloNetworks的配套包PhyloPlots是具有可视化网络和交互操作性的实用程序，例如将网络导出到 R（然后可以通过 R 绘制），建议安装：<code>using Pkg</code>-<code>Pkg.add(&quot;PhyloPlots&quot;)</code></li>
</ul>
<h1 id="3-PhyloNetworks分析"><a href="#3-PhyloNetworks分析" class="headerlink" title="3. PhyloNetworks分析"></a>3. PhyloNetworks分析</h1><h2 id="3-1-输入文件"><a href="#3-1-输入文件" class="headerlink" title="3.1. 输入文件"></a>3.1. 输入文件</h2><ol>
<li>CF表</li>
</ol>
<ul>
<li>输入文件可以有多种形式，不管哪种形式，最终PhyloNetworks的SNaQ用到的都是CF表。</li>
<li>每个4分类群子集的一致性因子(CF)表，即基因树频率表。CF表的格式是csv(逗号分隔的表格)，表头是t1,t2,t3,t4,CF12_34,CF13_24,CF14_23,ngenes。</li>
<li>可以用建树分析得到的基因树来计算CF；也可以用经过对齐的基因序列，通过TICR管道通过BUCKy估计CF获取CF表（用BUCKy需要考虑基因树估计误差）。</li>
</ul>
<ol start="2">
<li>起始树</li>
</ol>
<ul>
<li>除了CF表外，SNaQ还需要一棵起始树作为优化起点。</li>
<li>可以用基因树分析得到的物种树(比如这里用的是ASTRAL分析raxmltrees.tre的结果astraltree.tre)。</li>
</ul>
<p>下面介绍两种获取CF表的方式：</p>
<h3 id="3-1-1-从基因树到CF表"><a href="#3-1-1-从基因树到CF表" class="headerlink" title="3.1.1. 从基因树到CF表"></a>3.1.1. 从基因树到CF表</h3><ol>
<li>文件准备：基因树raxmltrees.tre</li>
</ol>
<ul>
<li>通过MrBayes或RAxML建树软件对每个基因单独建树后合并成基因树列表文件。</li>
<li>比如我用的是RAxML-NG建树后合并所有sample.raxml.support文件为一个文件raxmltrees.tre的结果。</li>
</ul>
<ol start="2">
<li>用基因树计算CF获取tableCF.csv文件</li>
</ol>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> PhyloNetworks <span class="comment">#导入PhyloNetworks包</span></span><br><span class="line">raxmltrees=joinpath(<span class="string">&quot;raxmltrees.tre&quot;</span>) <span class="comment">#读取基因树文件</span></span><br><span class="line">genetrees = readMultiTopology(raxmltrees) <span class="comment">#解析基因树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> PhyloPlots <span class="comment">#导入PhylpPlots包</span></span><br><span class="line">plot(genetrees[<span class="number">3</span>], :R) <span class="comment">#画基因树文件里第三棵树</span></span><br><span class="line"></span><br><span class="line">q,t = countquartetsintrees(genetrees) <span class="comment">#读取基因树，计算四分类群的CFs</span></span><br><span class="line">df = writeTableCF(q,t) <span class="comment">#读取计算得到的CF值到df：基因频率</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> CSV <span class="comment">#导入CSV包</span></span><br><span class="line">CSV.write(<span class="string">&quot;tableCF.csv&quot;</span>, df) <span class="comment">#保存df内容为tableCF.csv文件</span></span><br><span class="line">raxmlCF = readTableCF(<span class="string">&quot;tableCF.csv&quot;</span>) <span class="comment">#读取tableCF.csv文件到raxmlCF</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-TICR：从对齐序列-sequence-alignment-到CF表"><a href="#3-1-2-TICR：从对齐序列-sequence-alignment-到CF表" class="headerlink" title="3.1.2. TICR：从对齐序列(sequence alignment)到CF表"></a>3.1.2. TICR：从对齐序列(sequence alignment)到CF表</h3><p>waiting tag…</p>
<p>参考网址<a href="https://crsl4.github.io/PhyloNetworks.jl/latest/man/ticr_howtogetQuartetCFs/">https://crsl4.github.io/PhyloNetworks.jl/latest/man/ticr_howtogetQuartetCFs/</a></p>
<h2 id="3-2-构建系统发育网络【耗时】"><a href="#3-2-构建系统发育网络【耗时】" class="headerlink" title="3.2. 构建系统发育网络【耗时】"></a>3.2. 构建系统发育网络【耗时】</h2><p><strong>时效参考</strong>：29个物种的2700棵基因树，用hmax&#x3D;1，10个线程，约10天才跑完。</p>
<p>获取了CF表tableCF.csv文件后，可以继续在julia中用PhyloNetworks包构建系统发育网络。</p>
<h3 id="3-2-1-构建网络"><a href="#3-2-1-构建网络" class="headerlink" title="3.2.1. 构建网络"></a>3.2.1. 构建网络</h3><ol>
<li>构建网络起点<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> PhyloNetworks <span class="comment">#导入PhyloNetworks包</span></span><br><span class="line">astralfile= joinpath(<span class="string">&quot;astraltree.tre&quot;</span>) <span class="comment">#导入起始树文件astraltree.tre，这个树是个体树</span></span><br><span class="line">astraltree = readMultiTopology(astralfile) <span class="comment"># 读取树文件</span></span><br><span class="line">raxmlCF = readTableCF(<span class="string">&quot;tableCF.csv&quot;</span>) <span class="comment"># 读取tableCF.csv文件，生成&quot;DataCF&quot; 对象</span></span><br><span class="line">net0 = snaq!(astraltree,raxmlCF, hmax=<span class="number">0</span>, filename=<span class="string">&quot;net0&quot;</span>, seed=<span class="number">1234</span>) <span class="comment"># 用astraltree,raxmlCF，指定hmax=0来运行。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>部分屏幕输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MaxNet is (C,D,((B,A):1.395762055180493,(O,E):0.48453400554506426):10.0);</span><br><span class="line">with -loglik 53.53150526187732</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>把得到的net0作为起点来构建hmax&#x3D;1的网络</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">julia命令：</span><br><span class="line">julia&gt;net1 = snaq!(net0, raxmlCF, hmax=1, filename=&quot;net1&quot;, seed=2345)</span><br><span class="line"></span><br><span class="line">屏幕输出：</span><br><span class="line">best network and networks with different hybrid/gene flow directions printed to .networks file</span><br><span class="line">MaxNet is (C,D,((O,(E,#H7:::0.19558838614943078):0.31352437658618976):0.6640664399202987,(B,(A)#H7:::0.8044116138505693):10.0):10.0);</span><br><span class="line">with -loglik 28.31506721890958</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出文件<br>snaq输出文件包括：</p>
</li>
</ol>
<ul>
<li>net1.out：主输出文件，代表上面的net1；包含括号格式的网络树和参数，每一次run的输出保存在这个文件</li>
<li>net1.networks：网络树列表，包含了每一次run的网络树结果。这些网络树是对评估的最佳网络net1的修改（通过移动杂交节点来改变网络方向），对每个修改后的网络，计算了伪似然分数（pseudolikelihood score，loglik或-Ploglik）</li>
<li>net1.err： 如果有任何错误信息会生成这个文件would provide info about errors, if any</li>
</ul>
<p>可以在julia中查看文件，用<code>less(&quot;net1.out&quot;)</code>命令，下箭头向下滚动，<code>q</code>退出查看。</p>
<ol start="4">
<li>把最佳网络写入文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">julia&gt; net1 = readTopology(&quot;net1.out&quot;) # 读取net1.out文件到net1；如果接着上面运行net1已经赋值了，则不必读取</span><br><span class="line">julia&gt; net1 # 输出net1的信息到屏幕</span><br><span class="line">HybridNetwork, Rooted Network</span><br><span class="line">12 edges</span><br><span class="line">12 nodes: 6 tips, 1 hybrid nodes, 5 internal tree nodes.</span><br><span class="line">tip labels: C, D, O, E, ...</span><br><span class="line">(C,D,((O,(E,#H7:::0.196):0.314):0.664,((A)#H7:::0.804,B):10.0):10.0);</span><br><span class="line"></span><br><span class="line">julia&gt; writeTopology(net1)  # 输出net1的到屏幕, 包含完整精度的枝长和 γ</span><br><span class="line">&quot;(C,D,((O,(E,#H7:::0.19558838614943078):0.31352437658618976):0.6640664399202987,((A)#H7:::0.8044116138505693,B):10.0):10.0);&quot;</span><br><span class="line"></span><br><span class="line">julia&gt; writeTopology(net1, round=true, digits=2) # 精度digits为两位</span><br><span class="line">&quot;(C,D,((O,(E,#H7:::0.2):0.31):0.66,((A)#H7:::0.8,B):10.0):10.0);&quot;</span><br><span class="line"></span><br><span class="line">julia&gt; writeTopology(net1,di=true) # 适用于dendroscope使用的括号格式，忽略γ值</span><br><span class="line">&quot;(C,D,((O,(E,#H7):0.31352437658618976):0.6640664399202987,((A)#H7,B):10.0):10.0);&quot;</span><br><span class="line"></span><br><span class="line">julia&gt; writeTopology(net1, &quot;bestnet_h1.tre&quot;) # 把net1的最佳网络写到文件bestnet_h1.tre中</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里写入文件bestnet_h1.tre的内容和net1.networks的第一行(删除网络树分号后内容)是一样的，也可以直接在shell里用<code>head -1 net1.networks|sed &quot;s/;.*/;/g&quot; &gt;bestnet_h1.tre</code>来获取。</p>
<ol start="5">
<li><p>迭代运行<br>在得到net1后，可以基于net1来运行计算有两个杂交节点(hybrid nodes)的net2，继续迭代可以得到net3等。</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">net2 = snaq!(net1,raxmlCF, hmax=<span class="number">2</span>, filename=<span class="string">&quot;net2&quot;</span>, seed=<span class="number">3456</span>)</span><br><span class="line">net3 = snaq!(net2,raxmlCF, hmax=<span class="number">3</span>, filename=<span class="string">&quot;net3&quot;</span>, seed=<span class="number">4567</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>可视化网络<br>在julia里可以用PhyloPlots绘制得到的网络图。</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> PhyloPlots</span><br><span class="line">plot(net1, :R);</span><br></pre></td></tr></table></figure></li>
</ol>
<img src="https://crsl4.github.io/PhyloNetworks.jl/latest/assets/figures/snaqplot_net1_1.svg" title="系统发育网络图net1示例" width="60%"/>

<p><strong><p align="center">Figure 1. 系统发育网络图net1示例</strong><br>from <a href="https://crsl4.github.io/PhyloNetworks.jl/latest/man/snaq_plot/">PhyloNetworks Tutorial</a></p></p>
<p>这个网络中A作为杂交后代，80.4%是B的姐妹，19.6%是E的姐妹。</p>
<h3 id="3-2-2-并行计算"><a href="#3-2-2-并行计算" class="headerlink" title="3.2.2. 并行计算"></a>3.2.2. 并行计算</h3><ul>
<li>最好根据使用的服务器的处理器&#x2F;核心(processors&#x2F;cores)的数量来决定用多少线程，超过服务器有的核心数量不会让运行更快。</li>
<li>并行运算的线程设置其实等于计算次数，例如设定12线程，会计算12次。</li>
</ul>
<h4 id="3-2-2-1-交互式并行计算"><a href="#3-2-2-1-交互式并行计算" class="headerlink" title="3.2.2.1. 交互式并行计算"></a>3.2.2.1. 交互式并行计算</h4><p>交互式里并行计算可以用两种方法设置并行核心数量</p>
<ol>
<li>用<code>julia -p 12</code>进入julia代表使用12个核心。</li>
<li>用<code>julia</code>进入julia（默认使用1个核心），然后用<code>using Distributed</code>-<code>addprocs(11)</code>向julia添加11个核心数量（现在一共12个核心）。</li>
</ol>
<p>notes</p>
<ul>
<li>在<code>julia</code>中可以用<code>using Distributed</code>-<code>nworkers()</code>查看现在正在使用的核心总数。</li>
<li>在添加核心后导入包，比如添加后运行<code>using PhyloNetworks</code>才能让这个包的函数使用到多线程。</li>
</ul>
<h4 id="3-2-2-2-脚本式并行计算【推荐】"><a href="#3-2-2-2-脚本式并行计算【推荐】" class="headerlink" title="3.2.2.2. 脚本式并行计算【推荐】"></a>3.2.2.2. 脚本式并行计算【推荐】</h4><p>使用脚本来并行运行julia</p>
<ol>
<li><p>julia脚本runSNaQ.jl的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env julia</span><br><span class="line"></span><br><span class="line"># file &quot;runSNaQ.jl&quot;. run in the shell like this in general:</span><br><span class="line"># julia runSNaQ.jl hvalue nruns</span><br><span class="line"># example for h=2 and default 10 runs:</span><br><span class="line"># julia runSNaQ.jl 2</span><br><span class="line"># or example for h=3 and 50 runs:</span><br><span class="line"># julia runSNaQ.jl 3 50</span><br><span class="line"></span><br><span class="line">length(ARGS) &gt; 0 ||</span><br><span class="line">    error(&quot;need 1 or 2 arguments: # reticulations (h) and # runs (optional, 10 by default)&quot;)</span><br><span class="line">h = parse(Int, ARGS[1])</span><br><span class="line">nruns = 10</span><br><span class="line">if length(ARGS) &gt; 1</span><br><span class="line">    nruns = parse(Int, ARGS[2])</span><br><span class="line">end</span><br><span class="line">outputfile = string(&quot;net&quot;, h, &quot;_&quot;, nruns, &quot;runs&quot;) # example: &quot;net2_10runs&quot;</span><br><span class="line">seed = 1234 + h # change as desired! Best to have it different for different h</span><br><span class="line">@info &quot;will run SNaQ with h=$h, # of runs=$nruns, seed=$seed, output will go to: $outputfile&quot;</span><br><span class="line"></span><br><span class="line">using Distributed</span><br><span class="line">addprocs(nruns)</span><br><span class="line">@everywhere using PhyloNetworks</span><br><span class="line">net0 = readTopology(&quot;astraltree.tre&quot;);</span><br><span class="line">using DataFrames, CSV</span><br><span class="line">df_sp = DataFrame(CSV.File(&quot;tableCF.csv&quot;, pool=false); copycols=false);</span><br><span class="line">d_sp = readTableCF!(df_sp);</span><br><span class="line">net = snaq!(net0, d_sp, hmax=h, filename=outputfile, seed=seed, runs=nruns)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用julia脚本<br>举例：<code>julia runSNaQ.jl 1 12</code></p>
</li>
</ol>
<p>julia运行时间比较长，建议用nohup和&amp;来放后台：<code>nohup julia runSNaQ.jl 1 12 &gt;h1.log 2&gt;&amp;1 &amp;</code></p>
<ol start="3">
<li>运行说明</li>
</ol>
<ul>
<li>脚本接受的运行参数有两个，第一个参数设置最大杂交次数hmax，第二个参数设置并行运行的核心数（也代表重复运行次数）。</li>
<li>这里默认输入文件在当前目录下，包括CF表tableCF.csv文件和起始树astraltree.tre文件。</li>
</ul>
<ol start="4">
<li>迭代运行</li>
</ol>
<ul>
<li>如果时间充裕，可选迭代运行的方式。</li>
<li>跑完hmax&#x3D;1参数后，可以用hmax&#x3D;1的树结果作为运行hmax&#x3D;2的起点树。跑完hmax&#x3D;2参数后，可以用hmax&#x3D;2的树结果作为运行hmax&#x3D;3的起点树。直到跑到hmax&#x3D;5或者hmax&#x3D;10的，能找到最佳hmax值。这就是迭代运行的方式。</li>
<li>用<code>head -1 net1.networks|sed &quot;s/;.*/;/g&quot; &gt;bestnet_h1.tre</code>获取hmax&#x3D;1的最佳网络树。</li>
<li>然后更改脚本里指定的起始树为<code>bestnet_h1.tre</code>，开始搜索h&#x3D;2的网络树。</li>
<li>具体更改julia脚本中的两行为下面的参数。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net1 = readTopology(&quot;bestnet_h1.tre&quot;);</span><br><span class="line">net2 = snaq!(net1, d_sp, hmax=h, filename=outputfile, seed=seed, runs=nruns)</span><br></pre></td></tr></table></figure>

<ul>
<li>类似的操作，在获得hmax&#x3D;2的结果后继续获得hmax&#x3D;3的结果。依次获得hmax更高的结果。</li>
</ul>
<ol start="5">
<li>不迭代并行运行</li>
</ol>
<ul>
<li>如果时间不充裕，可选不迭代运行的方式。</li>
<li>即hmax&#x3D;1，2，3，4，5…的程序同时运行，起始树全部都选择前面获得的astral树。</li>
<li>操作上，可以准备多份runSNaQ.jl文件，分别命名为runSNaQ_h1.jl,runSNaQ_h2.jl,runSNaQ_h3.jl…同时运行<code>nohup julia runSNaQ_h1.jl 1 12 &gt;h1.log 2&gt;&amp;1 &amp;</code>,<code>nohup julia runSNaQ_h2.jl 2 12 &gt;h2.log 2&gt;&amp;1 &amp;</code>,<code>nohup julia runSNaQ_h3.jl 3 12 &gt;h3.log 2&gt;&amp;1 &amp;</code>…</li>
<li>julia脚本内需要修改变量名称，以免同时运行时相互干扰。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net0_h1 = readTopology(&quot;astraltree.tre&quot;);</span><br><span class="line">net1_h1 = snaq!(net1_h1, d_sp, hmax=h, filename=outputfile, seed=seed, runs=nruns)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net0_h2 = readTopology(&quot;astraltree.tre&quot;);</span><br><span class="line">net1_h2 = snaq!(net0_h2, d_sp, hmax=h, filename=outputfile, seed=seed, runs=nruns)</span><br></pre></td></tr></table></figure>

<h4 id="提交slurm集群"><a href="#提交slurm集群" class="headerlink" title="提交slurm集群"></a>提交slurm集群</h4><p>waiting tag…</p>
<p>PhyloNetworks教程里的建议是在上一步运行julia脚本之后用slurm提交julia作业到集群。但我没具体去研究，提交到集群后似乎可以自动化运行h&#x3D;0到h&#x3D;3。</p>
<p>设置slurm的脚本复制到下面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#SBATCH -o path/to/slurm/log/file/runsnaq_slurm%a.log</span><br><span class="line">#SBATCH -J runsnaq</span><br><span class="line">#SBATCH --array=0-3</span><br><span class="line">#SBATCH -c 30</span><br><span class="line">## --array: to run multiple instances of this script,</span><br><span class="line">##          one for each value in the array.</span><br><span class="line">##          1 instance = 1 task</span><br><span class="line">## -J job name</span><br><span class="line">## -c number of cores (CPUs) per task</span><br><span class="line"></span><br><span class="line">echo &quot;slurm task ID = $SLURM_ARRAY_TASK_ID used as hmax&quot;</span><br><span class="line">echo &quot;start of SNaQ parallel runs on $(hostname)&quot;</span><br><span class="line"># finally: launch the julia script, using Julia executable appropriate for slurm, with full paths:</span><br><span class="line">/workspace/software/bin/julia --history-file=no -- runSNaQ.jl $SLURM_ARRAY_TASK_ID 30 &gt; net$SLURM_ARRAY_TASK_ID_30runs.screenlog 2&gt;&amp;1</span><br><span class="line">echo &quot;end of SNaQ run ...&quot;</span><br></pre></td></tr></table></figure>

<p>后面有时间再仔细研究研究：<br><a href="https://crsl4.github.io/PhyloNetworks.jl/latest/man/snaq_plot/">PhyloNetworks SNaQ部分</a></p>
<h2 id="3-3-选择最佳杂交次数"><a href="#3-3-选择最佳杂交次数" class="headerlink" title="3.3. 选择最佳杂交次数"></a>3.3. 选择最佳杂交次数</h2><h3 id="3-3-1-运行不同杂交次数"><a href="#3-3-1-运行不同杂交次数" class="headerlink" title="3.3.1. 运行不同杂交次数"></a>3.3.1. 运行不同杂交次数</h3><p>一般来说需要运行多次网络构建，最后根据结果来确定最佳的杂交次数(也就是h值)。</p>
<ul>
<li>根据估计的杂交次数来运行，比如估计有4次杂交，可以计划运行从h&#x3D;0到h&#x3D;6。每个指定的h最好运行在8次以上。</li>
<li>也可以根据运行结果的loglik值来决定运行的最大h值。</li>
</ul>
<p>有两种运行策略，迭代和非迭代：</p>
<ol>
<li>迭代</li>
</ol>
<ul>
<li>迭代运行策略指先运行h&#x3D;0，待结束后用h&#x3D;0的结果作为起始树运行h&#x3D;1；待h&#x3D;1运行结束再用h&#x3D;1的结果作为起始树运行h&#x3D;2，直到h&#x3D;6。</li>
</ul>
<ol start="2">
<li>非迭代</li>
</ol>
<ul>
<li>非迭代运行策略就是把astraltree.tre作为所有h取值的起始树，这样可以同时运行h&#x3D;0到h&#x3D;6，加快获得结果的时间。</li>
</ul>
<h3 id="3-3-2-选择最佳h值"><a href="#3-3-2-选择最佳h值" class="headerlink" title="3.3.2. 选择最佳h值"></a>3.3.2. 选择最佳h值</h3><p>根据loglik值随h值的变化，当loglik降到了最低且在h继续增大时保持平稳时的h值即为最佳h值。</p>
<ol>
<li>loglik值</li>
</ol>
<ul>
<li>每个估计的网络都有一个伪偏差loglik值：负对数似然的倍数直到一个常数。</li>
<li>这个loglik值越低越好（如果网络完美地拟合数据，这个常数就为0）。</li>
<li>每个loglik值可以在结果文件net1.network中查看。</li>
</ul>
<ol start="2">
<li>绘制loglik值随h值的变化<br>得到不同h值下的最佳网络的loglik值后，就可以绘制loglik值随h值的变化。</li>
</ol>
<p>例如官方教程里给出的loglik值从h&#x3D;0-3的变化。可以用教程里建议的julia的R”plot”绘图（如下）或者julia绘图，也可以在R或者excel等软件中自行画折线图。</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">scores = [net0.loglik, net1.loglik, net2.loglik, net3.loglik]</span><br><span class="line">hmax = collect(<span class="number">0</span>:<span class="number">3</span>)</span><br><span class="line"><span class="string">R&quot;plot&quot;</span>(hmax, scores, type=<span class="string">&quot;b&quot;</span>, ylab=<span class="string">&quot;network score&quot;</span>, xlab=<span class="string">&quot;hmax&quot;</span>, col=<span class="string">&quot;blue&quot;</span>);</span><br></pre></td></tr></table></figure>

<img src="https://crsl4.github.io/PhyloNetworks.jl/latest/assets/figures/snaqplot_scores_heuristic.svg" title="loglik随h变化的示例图" width="60%"/>

<p><strong><p align="center">Figure 2. loglik随h变化的示例图</strong><br>from <a href="https://crsl4.github.io/PhyloNetworks.jl/latest/man/snaq_plot/">PhyloNetworks Tutorial</a></p></p>
<p>从图中可以看到loglik值在h&#x3D;1时降到了最低且在h继续增大时保持平稳。所以建议最佳杂交次数是h&#x3D;1。</p>
<ol start="3">
<li>用R包ggplot2绘制</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">hmax<span class="operator">&lt;-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0</span><span class="operator">:</span><span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">score<span class="operator">&lt;-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">246.5604838333106</span><span class="punctuation">,</span><span class="number">10.072487746425647</span><span class="punctuation">,</span><span class="number">10.072487747047507</span><span class="punctuation">,</span><span class="number">10.07248774671892</span><span class="punctuation">,</span><span class="number">10.072487747122702</span><span class="punctuation">,</span><span class="number">66.88016392780662</span><span class="punctuation">,</span><span class="number">10.072487746482409</span><span class="punctuation">,</span><span class="number">10.072487765482101</span><span class="punctuation">,</span><span class="number">66.88016941187634</span><span class="punctuation">,</span><span class="number">10.072487747318323</span><span class="punctuation">,</span><span class="number">10.072487746650621</span><span class="punctuation">)</span></span><br><span class="line">df <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>h <span class="operator">=</span> hmax<span class="punctuation">,</span> loglike <span class="operator">=</span> score<span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> df<span class="punctuation">,</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> ind<span class="punctuation">,</span> y <span class="operator">=</span> loglike<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> geom_line<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span> geom_point<span class="punctuation">(</span>shape<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span>size<span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span>color<span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span><span class="operator">+</span> theme_classic<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span>xlab<span class="punctuation">(</span><span class="string">&quot;the number of hybrid nodes&quot;</span><span class="punctuation">)</span><span class="operator">+</span>ylab<span class="punctuation">(</span><span class="string">&quot;pseudolikelihood scores&quot;</span><span class="punctuation">)</span><span class="operator">+</span>scale_x_continuous<span class="punctuation">(</span>breaks<span class="operator">=</span>seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span> theme_classic<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span>theme<span class="punctuation">(</span>axis.title.x <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">15</span><span class="punctuation">,</span> face <span class="operator">=</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>axis.title.y <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">15</span><span class="punctuation">,</span> face <span class="operator">=</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>axis.text.x <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">13</span><span class="punctuation">,</span> face <span class="operator">=</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>axis.text.y <span class="operator">=</span> element_text<span class="punctuation">(</span>size <span class="operator">=</span> <span class="number">13</span><span class="punctuation">,</span> face <span class="operator">=</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-系统发育网络可视化"><a href="#3-4-系统发育网络可视化" class="headerlink" title="3.4. 系统发育网络可视化"></a>3.4. 系统发育网络可视化</h2><p>找到最佳的杂交次数后，可以把对应的系统发育网络绘制出来，比如这里的h&#x3D;1。</p>
<h3 id="3-4-1-对网络重新定根"><a href="#3-4-1-对网络重新定根" class="headerlink" title="3.4.1. 对网络重新定根"></a>3.4.1. 对网络重新定根</h3><p>由于SNaQ算法不考虑root，大部分情况下bestnet_h1.tre结果都需要重新定外类群为树的根。</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> PhyloNetworks</span><br><span class="line">net = readTopology(<span class="string">&quot;net1_12runs.out&quot;</span>) <span class="comment"># 读取最佳杂交次数的结果</span></span><br><span class="line">writeTopology(net,<span class="string">&quot;bestnet_h1.tre&quot;</span>) <span class="comment"># 保存最佳杂交次数的最佳杂交树</span></span><br><span class="line">net1 = readTopology(<span class="string">&quot;bestnet_h1.tre&quot;</span>) <span class="comment">#读取bestnet_h1.tre到net1</span></span><br><span class="line">rootatnode!(net1,<span class="string">&quot;C&quot;</span>) <span class="comment">#重新定根到样本C，可直接用于之后的PhyloPlots画图</span></span><br><span class="line">net1_reroot = rootatnode!(net1,<span class="string">&quot;C&quot;</span>) <span class="comment"># 重新定根到样本C，并保存到net1root</span></span><br><span class="line">writeTopology(net1_reroot) <span class="comment"># 输入net1root的内容到屏幕，引号内的内容就是要保存的重新定根后的网络</span></span><br><span class="line">writeTopology(net1_reroot, <span class="string">&quot;net1_reroot.tre&quot;</span>) <span class="comment"># 把重新定根的网络写到文件net1root.tre中</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-2-使用配套包PhyloPlots绘制系统发育网络"><a href="#3-4-2-使用配套包PhyloPlots绘制系统发育网络" class="headerlink" title="3.4.2. 使用配套包PhyloPlots绘制系统发育网络"></a>3.4.2. 使用配套包PhyloPlots绘制系统发育网络</h3><p>可以使用配套julia包PhyloPlots绘制系统发育网络</p>
<ol>
<li><p>保存图为pdf</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> PhyloNetworks</span><br><span class="line">net1_reroot = readTopology(<span class="string">&quot;net1_reroot.tre&quot;</span>) <span class="comment"># 读取重新定根后的net1root.tre到net1root</span></span><br><span class="line"><span class="keyword">using</span> PhyloPlots <span class="comment"># 导入PhyloPlots包，用于绘图</span></span><br><span class="line"><span class="keyword">using</span> RCall      <span class="comment"># 导入RCall，用于使用R的命令</span></span><br><span class="line">imagefilename = <span class="string">&quot;net1_reroot.pdf&quot;</span> <span class="comment"># 创建pdf格式文件</span></span><br><span class="line"><span class="string">R&quot;pdf&quot;</span>(imagefilename) <span class="comment"># 开始绘图</span></span><br><span class="line">plot(net1_reroot, :R, showGamma=<span class="literal">true</span>); <span class="comment"># 绘制网络并把网络图发到文件</span></span><br><span class="line"><span class="string">R&quot;dev.off()&quot;</span>; <span class="comment"># 保存和退出</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>保存成svg格式</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> PhyloNetworks</span><br><span class="line">net1root = readTopology(<span class="string">&quot;net1_reroot.tre&quot;</span>) <span class="comment"># 读取重新定根后的net1root.tre到net1root</span></span><br><span class="line"><span class="keyword">using</span> PhyloPlots</span><br><span class="line"><span class="keyword">using</span> RCall</span><br><span class="line">imagefilename = <span class="string">&quot;net1_reroot.svg&quot;</span></span><br><span class="line"><span class="string">R&quot;svg&quot;</span>(imagefilename, width=<span class="number">4</span>, height=<span class="number">3</span>) <span class="comment"># 开始绘图，设定宽和高</span></span><br><span class="line"><span class="string">R&quot;par&quot;</span>(mar=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]) <span class="comment"># 去除图的边界</span></span><br><span class="line">plot(net1root, :R, showGamma=<span class="literal">true</span>, showEdgeNumber=<span class="literal">true</span>); <span class="comment"># 绘制网络并把网络图发到文件</span></span><br><span class="line"><span class="string">R&quot;dev.off()&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<img src="https://crsl4.github.io/PhyloNetworks.jl/latest/assets/figures/snaqplot_net1_2.svg" title="系统发育网络示例图" width="60%"/>

<p><strong><p align="center">Figure 3. 系统发育网络示例图</strong><br>from <a href="https://crsl4.github.io/PhyloNetworks.jl/latest/man/snaq_plot/">PhyloNetworks Tutorial</a></p></p>
<p>这里的图和前面的Figure 1一样。</p>
<h3 id="3-4-3-使用ggtree绘制系统发育网络"><a href="#3-4-3-使用ggtree绘制系统发育网络" class="headerlink" title="3.4.3. 使用ggtree绘制系统发育网络"></a>3.4.3. 使用ggtree绘制系统发育网络</h3><p>waiting tag…</p>
<h2 id="3-5-更多分析"><a href="#3-5-更多分析" class="headerlink" title="3.5. 更多分析"></a>3.5. 更多分析</h2><p>更多分析可参考<a href="https://crsl4.github.io/PhyloNetworks.jl/dev/">PhyloNetworks tutorials</a></p>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li>PhyloNetworks paper：<a href="https://academic.oup.com/mbe/article/34/12/3292/4103410">https://academic.oup.com/mbe/article/34/12/3292/4103410</a></li>
<li>PhyloNetworks github]：<a href="https://github.com/crsl4/PhyloNetworks.jl">https://github.com/crsl4/PhyloNetworks.jl</a></li>
<li>PhyloNetworks tutorials：<a href="https://crsl4.github.io/PhyloNetworks.jl/dev/">https://crsl4.github.io/PhyloNetworks.jl/dev/</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>gene flow</category>
      </categories>
      <tags>
        <tag>gene flow</tag>
        <tag>hybridization</tag>
        <tag>introgressive</tag>
        <tag>PhyloNetworks</tag>
        <tag>population networks</tag>
        <tag>Julia</tag>
      </tags>
  </entry>
  <entry>
    <title>系统发育网络推断 —— TreeMix</title>
    <url>/2022/03/20/bioinfo_geneflow_TreeMix/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1296539261&auto=1&height=32"></iframe></div>

<p>这篇博客记录的分析步骤是：</p>
<ol>
<li>使用基因组尺度的snp数据计算等位基因频率</li>
<li>转换成TreeMix的输入文件格式</li>
<li>用TreeMix推断基因流</li>
<li>确定最佳基因流数量</li>
<li>绘制系统发育网络图</li>
</ol>
<h1 id="1-TreeMix"><a href="#1-TreeMix" class="headerlink" title="1. TreeMix"></a>1. TreeMix</h1><p>TreeMix是一个利用全基因组尺度的等位基因频率数据推断居群的分化和和杂合（基因流动或基因渗入）的一个软件，适用于推断一个物种多个居群的系统发育网。TreeMix用多居群的等位基因频率来推测最大似然树(ML树)，并可推断指定数量基因流事件。</p>
<ol>
<li>TreeMix简介<ul>
<li>TreeMix利用等位基因频率来推断群体间分化和杂合（基因流动或基因渗入）</li>
</ul>
</li>
<li>TreeMix输入输出<ul>
<li>输入：基因组snp的vcf文件，和居群系统树(可选optional)</li>
<li>输出：最佳杂交次数和系统发育网络(包含杂交方向和强度)</li>
</ul>
</li>
<li>TreeMix优势和不足<ul>
<li>TreeMix和PhyloNetworks一样，也是推断系统发育网络。</li>
<li>我自己用时，有些PhyloNetworks报错无法定根和边缘错误的情况TreeMix可以找到最佳杂交次数。</li>
<li>不足是比PhyloNetworks更耗时，超级耗时。</li>
</ul>
</li>
</ol>
<h2 id="1-1-TreeMix-install"><a href="#1-1-TreeMix-install" class="headerlink" title="1.1. TreeMix install"></a>1.1. TreeMix install</h2><ol>
<li><p><code>conda install -c bioconda treemix</code> #现在conda可以下到最新版本treemix 1.13</p>
</li>
<li><p>在<a href="https://bitbucket.org/nygcresearch/treemix/downloads/">treemix software</a>下载压缩包再安装</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf treemix-1.0.tar.gz</span><br><span class="line">cd treemix-1.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="1-2-准备文件"><a href="#1-2-准备文件" class="headerlink" title="1.2. 准备文件"></a>1.2. 准备文件</h2><ol>
<li>sample.snp.vcf.gz：基因组尺度的snp文件，vcf格式</li>
<li>sample.tre【optional】：居群的系统发育树文件，Newick格式，把支持率等信息删除；也可以不提供，用TreeMix推断ML树。<strong>这个树文件是居群树文件，不是个体树文件</strong>。</li>
</ol>
<h2 id="1-3-分析步骤"><a href="#1-3-分析步骤" class="headerlink" title="1.3. 分析步骤"></a>1.3. 分析步骤</h2><h3 id="1-3-1-计算等位基因频率"><a href="#1-3-1-计算等位基因频率" class="headerlink" title="1.3.1. 计算等位基因频率"></a>1.3.1. 计算等位基因频率</h3><ol>
<li><p><code>vcftools --gzvcf sample.snp.vcf.gz --plink-tped --out sample</code> # 转换为tped格式，生成sample.tped和sample.tfam文件。<br>如果报错<strong>Unrecognized values used for CHROM: scaffold_1 - Replacing with 0</strong>，可以用<code>bcftools view -H sample.snp.vcf.gz | cut -f 1 | uniq | awk &#39;&#123;print $0&quot;\t&quot;$0&#125;&#39; &gt; chrom-map.txt</code>生成染色体ID的文件，然后再用–chrom-map指定文件来运行<code>vcftools --gzvcf sample.snp.vcf.gz --plink-tped --chrom-map chrom-map.txt --out sample</code>。</p>
</li>
<li><p>sample.tfam文件共6列，前两列都为样本ID，修改第一列数据为群体ID。（可以是同一物种不同种群作为单独群体，也可以是一个物种作为一个群体，这里sample的一个物种作为一个群体，群体ID为物种名）。</p>
</li>
<li><p><code>cat sample.tfam |awk &#39;&#123;print $1&quot;\t&quot;$2&quot;\t&quot;$1&#125;&#39; &gt;sample.pop.cov</code>编辑文件sample.pop.cov，格式为：共三列，前两列与修改后的sample.tfam前两列一样，为群体ID和样本ID，第三列和第一列一致，tab分隔。</p>
</li>
<li><p>计算等位基因组的频率</p>
</li>
</ol>
<ul>
<li><code>plink --threads 12 --tfile sample --freq --allow-extra-chr --within sample.pop.cov</code> # 计算等位基因组的频率，生成plink.frq.strat和plink.nosex文件，加上–allow-extra-chr是防止识别不了染色体名称。</li>
<li><code>pigz plink.frq.strat</code> #压缩等位基因频率文件</li>
</ul>
<ol start="5">
<li>转换格式【耗时小时计】</li>
</ol>
<ul>
<li><code>python2 /path/to/plink2treemix.py plink.frq.strat.gz sample.treemix.in.gz</code> #用treemix自带脚本进行格式转换，notes：输入输出都为压缩文件，plink2treemix.py使用python2并需要绝对路径（否则报错）。</li>
</ul>
<h3 id="1-3-2-treemix推断基因流"><a href="#1-3-2-treemix推断基因流" class="headerlink" title="1.3.2. treemix推断基因流"></a>1.3.2. treemix推断基因流</h3><ol>
<li><p>treemix默认功能<br><code>treemix -i sample.treemix.in.gz -o sample</code> # treemix的默认功能是在所有位点都独立的假设下建一棵种群ML树</p>
</li>
<li><p>TreeMix参数解释</p>
</li>
</ol>
<ul>
<li>-i 指定基因频率输入文件</li>
<li>-o 指定输出文件前缀</li>
<li>-tf 【可选】指定树文件，指定后就使用指定树的拓扑结构(最好把支持率和其他无关信息都删除，只留最简单的Newick格式)，否则treemix会推断拓扑</li>
<li>-root 【可选】指定外类群(指定的是居群名称)，多个用逗号分隔；最好指定，否则后面plot_tree画树没找到更换外类群的参数会很麻烦</li>
<li>-m 为the number of migration edges即基因渗入的次数</li>
<li>-k 1000 因为SNP之间不是独立位点，为了避免连锁不平衡，用k参数指定SNP数量有连锁，比如这里指定用1000个SNP组成的blocks评估协方差矩阵</li>
<li>-se 计算迁移权重的标准误差(计算成本高)，如果想省时间可以不用这个参数</li>
<li>-bootstrap 为了判断给定树拓扑的可信度，在blocks运行bootstrap重复，没太理解</li>
<li>-global 在增加所有种群后做一轮全局重组。</li>
<li>noss 关闭样本量校正。TreeMix计算协方差会考虑每个种群的样本量，有些情况(如果有种群的样本只有1个)会过度校正，可以关闭。</li>
<li>-g old.vertices.gz old.edges.gz #使用之前生成的树和图结果，用-g指定之前的两个结果文件</li>
<li>-cor_mig known_events and -climb #合并已知的迁移事件</li>
</ul>
<ol start="3">
<li><p>推荐参数<br>检测物种间基因流，每个物种一个个体或多个个体的数据，用的参数：<br><code>treemix -i sample.treemix.in.gz -o sample -tf sample.tre -root outgroup1,outgroup2 -m 3 -k 1000 -se -bootstrap -global -noss</code></p>
</li>
<li><p>多次分析以评估最佳m值<br>比如m取1-10(常用1-5,1-10)，每个m值重复5次(至少两次)。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for m in &#123;1..10&#125;</span><br><span class="line">do</span><br><span class="line">	&#123;</span><br><span class="line">	for i in &#123;1..5&#125;</span><br><span class="line">	do</span><br><span class="line">		&#123;</span><br><span class="line">			nohup time treemix -i sample.treemix.in.gz -o sample.$&#123;m&#125;.$&#123;i&#125; -tf sample.tre -root outgroup1,outgroup2 -m $&#123;m&#125; -k 1000 -se -bootstrap -global -noss&gt;$&#123;m&#125;.$&#123;i&#125;.out 2&gt;&amp;1 &amp;</span><br><span class="line">		&#125;</span><br><span class="line">	done</span><br><span class="line">	&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行结果<br>每一次运行都将生成一套后缀为llik,modelcov,treeout,vertices,cov,covse,edges的文件，这些文件都不大(KB级别)，但还会生成一个300+MB的out文件(out文件没报错就可以删除了)。</p>
</li>
</ol>
<ul>
<li>.llik：保存了从0到指定基因渗入次数m的始末似然值</li>
<li>.treeout.gz: 拟合树模型(fitted tree model)和迁移事件(migration events)。第一行是Newick格式的ML树，剩下行包含迁移边界(migration edges)</li>
<li>.cov.gz: 种群间的协方差矩阵(covariance matrix)</li>
<li>.covse.gz: 协方差矩阵的标准误差(standard errors)</li>
<li>.modelcov.gz: 模型的拟合协方差(fitted covariance)</li>
<li>.vertices.gz和.edges.gz: 包含推断图的内部结构</li>
</ul>
<h3 id="1-3-3-确认最佳m值"><a href="#1-3-3-确认最佳m值" class="headerlink" title="1.3.3. 确认最佳m值"></a>1.3.3. 确认最佳m值</h3><p>R包OptM分析treemix的结果，确认最佳m值(Deltam值最小情况下的m值)。</p>
<p>在treemix运行的结果目录下运行R，需要使用每一次运行的.llik,.cov.gz,.modelcov.gz三个配套结果文件，每个m值至少重复&#x2F;迭代两次，否则报错。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>library<span class="punctuation">(</span>OptM<span class="punctuation">)</span> <span class="comment">#载入OptM包</span></span><br><span class="line"><span class="operator">&gt;</span>evanno<span class="operator">=</span>optM<span class="punctuation">(</span><span class="string">&quot;./&quot;</span><span class="punctuation">,</span>method <span class="operator">=</span> <span class="string">&quot;Evanno&quot;</span>，tsv<span class="operator">=</span><span class="string">&quot;evanno.txt&quot;</span><span class="punctuation">)</span> <span class="comment">#用Evanno方法(默认)分析treemix结果文件，保存结果到evanno.txt文件，里面就有每个m对应的Deltam值(第15列)，Deltam值最小时对应的m即时最佳m值，这里的例子是m=3时最低。</span></span><br><span class="line">  m runs   mean<span class="punctuation">(</span>Lm<span class="punctuation">)</span>   sd<span class="punctuation">(</span>Lm<span class="punctuation">)</span>   <span class="built_in">min</span><span class="punctuation">(</span>Lm<span class="punctuation">)</span>   <span class="built_in">max</span><span class="punctuation">(</span>Lm<span class="punctuation">)</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span>   <span class="number">32</span> <span class="operator">-</span><span class="number">329764.72</span> <span class="number">4802.416</span> <span class="operator">-</span><span class="number">336972.0</span> <span class="operator">-</span><span class="number">320838.0</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span>    <span class="number">5</span> <span class="operator">-</span><span class="number">239329.60</span> <span class="number">3018.974</span> <span class="operator">-</span><span class="number">243918.0</span> <span class="operator">-</span><span class="number">236221.0</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span>    <span class="number">5</span> <span class="operator">-</span><span class="number">139018.20</span> <span class="number">5332.074</span> <span class="operator">-</span><span class="number">147433.0</span> <span class="operator">-</span><span class="number">134177.0</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span>    <span class="number">5</span> <span class="operator">-</span><span class="number">116765.80</span> <span class="number">1533.134</span> <span class="operator">-</span><span class="number">119301.0</span> <span class="operator">-</span><span class="number">115329.0</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span>    <span class="number">5</span>  <span class="operator">-</span><span class="number">94811.20</span> <span class="number">2239.830</span>  <span class="operator">-</span><span class="number">97001.2</span>  <span class="operator">-</span><span class="number">91664.1</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span>    <span class="number">2</span>  <span class="operator">-</span><span class="number">86727.45</span> <span class="number">1860.469</span>  <span class="operator">-</span><span class="number">88043.0</span>  <span class="operator">-</span><span class="number">85411.9</span></span><br><span class="line"><span class="number">7</span> <span class="number">6</span>    <span class="number">5</span>  <span class="operator">-</span><span class="number">79769.74</span> <span class="number">1545.658</span>  <span class="operator">-</span><span class="number">82041.1</span>  <span class="operator">-</span><span class="number">77782.6</span></span><br><span class="line"><span class="number">8</span> <span class="number">7</span>    <span class="number">5</span>  <span class="operator">-</span><span class="number">68844.08</span> <span class="number">2924.953</span>  <span class="operator">-</span><span class="number">73560.4</span>  <span class="operator">-</span><span class="number">66420.4</span></span><br><span class="line">      L<span class="string">&#x27;(m)   sdL&#x27;</span><span class="punctuation">(</span>m<span class="punctuation">)</span>  minL<span class="string">&#x27;(m)   maxL&#x27;</span><span class="punctuation">(</span>m<span class="punctuation">)</span>    L<span class="string">&#x27;&#x27;</span><span class="punctuation">(</span>m<span class="punctuation">)</span></span><br><span class="line"><span class="number">1</span>        <span class="literal">NA</span>        <span class="literal">NA</span>        <span class="literal">NA</span>         <span class="literal">NA</span>        <span class="literal">NA</span></span><br><span class="line"><span class="number">2</span>  <span class="number">90435.12</span> <span class="number">1783.4423</span> <span class="number">88651.676</span>  <span class="number">92218.561</span>  <span class="number">9876.281</span></span><br><span class="line"><span class="number">3</span> <span class="number">100311.40</span> <span class="number">2313.0997</span> <span class="number">97998.300</span> <span class="number">102624.500</span> <span class="number">78059.000</span></span><br><span class="line"><span class="number">4</span>  <span class="number">22252.40</span> <span class="number">3798.9398</span> <span class="number">18453.460</span>  <span class="number">26051.340</span>   <span class="number">297.800</span></span><br><span class="line"><span class="number">5</span>  <span class="number">21954.60</span>  <span class="number">706.6962</span> <span class="number">21247.904</span>  <span class="number">22661.296</span> <span class="number">13870.850</span></span><br><span class="line"><span class="number">6</span>   <span class="number">8083.75</span>  <span class="number">379.3613</span>  <span class="number">7704.389</span>   <span class="number">8463.111</span>  <span class="number">1126.040</span></span><br><span class="line"><span class="number">7</span>   <span class="number">6957.71</span>  <span class="number">314.8111</span>  <span class="number">6642.899</span>   <span class="number">7272.521</span>  <span class="number">3967.950</span></span><br><span class="line"><span class="number">8</span>  <span class="number">10925.66</span> <span class="number">1379.2958</span>  <span class="number">9546.364</span>  <span class="number">12304.956</span>        <span class="literal">NA</span></span><br><span class="line">    sdL<span class="string">&#x27;&#x27;</span><span class="punctuation">(</span>m<span class="punctuation">)</span> minL<span class="string">&#x27;&#x27;</span><span class="punctuation">(</span>m<span class="punctuation">)</span> maxL<span class="string">&#x27;&#x27;</span><span class="punctuation">(</span>m<span class="punctuation">)</span>     Deltam</span><br><span class="line"><span class="number">1</span>         <span class="literal">NA</span>        <span class="literal">NA</span>        <span class="literal">NA</span>         <span class="literal">NA</span></span><br><span class="line"><span class="number">2</span>  <span class="number">529.65744</span>  <span class="number">9346.624</span> <span class="number">10405.939</span>  <span class="number">3.2714033</span></span><br><span class="line"><span class="number">3</span> <span class="number">1485.84010</span> <span class="number">76573.160</span> <span class="number">79544.840</span> <span class="number">14.6395203</span></span><br><span class="line"><span class="number">4</span> <span class="number">3092.24366</span> <span class="operator">-</span><span class="number">2794.444</span>  <span class="number">3390.044</span>  <span class="number">0.1942427</span></span><br><span class="line"><span class="number">5</span>  <span class="number">327.33487</span> <span class="number">13543.515</span> <span class="number">14198.185</span>  <span class="number">6.1928138</span></span><br><span class="line"><span class="number">6</span>   <span class="number">64.55023</span>  <span class="number">1061.490</span>  <span class="number">1190.590</span>  <span class="number">0.6052453</span></span><br><span class="line"><span class="number">7</span> <span class="number">1064.48476</span>  <span class="number">2903.465</span>  <span class="number">5032.435</span>  <span class="number">2.5671598</span></span><br><span class="line"><span class="number">8</span>         <span class="literal">NA</span>        <span class="literal">NA</span>        <span class="literal">NA</span>         <span class="literal">NA</span></span><br><span class="line">    mean<span class="punctuation">(</span>f<span class="punctuation">)</span>        sd<span class="punctuation">(</span>f<span class="punctuation">)</span></span><br><span class="line"><span class="number">1</span>        <span class="literal">NA</span>           <span class="literal">NA</span></span><br><span class="line"><span class="number">2</span> <span class="number">0.9776741</span> <span class="number">1.214193e-04</span></span><br><span class="line"><span class="number">3</span> <span class="number">0.9837528</span> <span class="number">7.790282e-04</span></span><br><span class="line"><span class="number">4</span> <span class="number">0.9867460</span> <span class="number">2.483868e-04</span></span><br><span class="line"><span class="number">5</span> <span class="number">0.9897553</span> <span class="number">8.854187e-05</span></span><br><span class="line"><span class="number">6</span> <span class="number">0.9909923</span> <span class="number">5.825696e-05</span></span><br><span class="line"><span class="number">7</span> <span class="number">0.9915973</span> <span class="number">8.194263e-05</span></span><br><span class="line"><span class="number">8</span> <span class="number">0.9923055</span> <span class="number">2.114830e-04</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span>plot_optM<span class="punctuation">(</span>evanno<span class="punctuation">,</span>method <span class="operator">=</span> <span class="string">&quot;Evanno&quot;</span><span class="punctuation">,</span>pdf<span class="operator">=</span><span class="string">&quot;evanno.pdf&quot;</span><span class="punctuation">)</span> <span class="comment">#把结果作图，更直观判断最佳m值，保存成evanno.pdf</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span>linear<span class="operator">=</span>optM<span class="punctuation">(</span><span class="string">&quot;./&quot;</span><span class="punctuation">,</span>method <span class="operator">=</span> <span class="string">&quot;linear&quot;</span><span class="punctuation">,</span>tsv<span class="operator">=</span><span class="string">&quot;linear.txt&quot;</span><span class="punctuation">)</span> <span class="comment">#还可以换linear线性回归方法分析一下treemix结果，m作为横坐标，Log Likelihood做纵坐标，保存结果到linear.txt文件，但不知道为啥没报错但没有结果文件输出</span></span><br><span class="line"><span class="operator">&gt;</span>plot_optM<span class="punctuation">(</span>linear<span class="punctuation">,</span>method <span class="operator">=</span> <span class="string">&quot;linear&quot;</span><span class="punctuation">,</span>pdf<span class="operator">=</span><span class="string">&quot;linear.pdf&quot;</span><span class="punctuation">)</span> <span class="comment">#结果作图，这个结果我没找到怎么看最佳m值，猜测是在图中斜率变化最大的位置对应的m值，标记了黑色的change points处，这里是m在2-3的位置，接近2。</span></span><br></pre></td></tr></table></figure>

<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/bioinfo_geneflow.treemix_evanno.png?raw=true" width=80% title="linear" align=center/>

<p><strong><p align="center">Figure 1. evanno 示例</p></strong></p>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/bioinfo_geneflow.treemix_linear.png?raw=true" width=80% title="linear" align=center/>

<p><strong><p align="center">Figure 2. linear 示例</p></strong></p>
<h3 id="1-3-4-最佳m值作图"><a href="#1-3-4-最佳m值作图" class="headerlink" title="1.3.4. 最佳m值作图"></a>1.3.4. 最佳m值作图</h3><p>用最佳m值对应的结果文件作图</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span>source<span class="punctuation">(</span><span class="string">&quot;path/to/plotting_funcs.R&quot;</span><span class="punctuation">)</span> <span class="comment">#载入treemix/src文件夹中的R脚本</span></span><br><span class="line"><span class="operator">&gt;</span>plot_tree<span class="punctuation">(</span><span class="string">&quot;sample.treemix.3.1&quot;</span><span class="punctuation">)</span> <span class="comment">#用sample.treemix.3.1结果作图</span></span><br></pre></td></tr></table></figure>

<p><strong>notes</strong>：</p>
<ul>
<li>虽然TreeMix的输入是个体的snp.vcf计算的基因型频率数据，但推断的系统发育网是居群的(居群名称组成的系统结构)，不是个体的系统发育。</li>
<li>sample.tre是居群树(据群名称组成的树)，不是个体树</li>
<li>treemix的参数-root指定的也是居群名称</li>
</ul>
<h1 id="2-reference"><a href="#2-reference" class="headerlink" title="2. reference"></a>2. reference</h1><ol>
<li>TreeMix paper：<a href="https://www.nature.com/articles/npre.2012.6956.1">https://www.nature.com/articles/npre.2012.6956.1</a></li>
<li>TreeMix software：<a href="https://bitbucket.org/nygcresearch/treemix/downloads/">https://bitbucket.org/nygcresearch/treemix/downloads/</a></li>
<li>TreeMix manual：<a href="https://bitbucket.org/nygcresearch/treemix/downloads/treemix_manual_10_1_2012.pdf">https://bitbucket.org/nygcresearch/treemix/downloads/treemix_manual_10_1_2012.pdf</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>gene flow</category>
      </categories>
      <tags>
        <tag>gene flow</tag>
        <tag>hybridization</tag>
        <tag>introgressive</tag>
        <tag>population networks</tag>
        <tag>TreeMix</tag>
      </tags>
  </entry>
  <entry>
    <title>基因流及其推断</title>
    <url>/2022/04/10/bioinfo_geneflow_intro/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=210766&auto=1&height=32"></iframe></div>

<h1 id="1-基因流-gene-flow-x2F-杂交-hybridization-x2F-渐渗-introgressive"><a href="#1-基因流-gene-flow-x2F-杂交-hybridization-x2F-渐渗-introgressive" class="headerlink" title="1. 基因流(gene flow)&#x2F;杂交(hybridization)&#x2F;渐渗(introgressive)"></a>1. 基因流(gene flow)&#x2F;杂交(hybridization)&#x2F;渐渗(introgressive)</h1><p>基因流，杂交和渐渗通常一起讨论，有些情况下甚至三者在说同一件事。从定义判断，基因流通常发生在种内群体间，杂交则是发生在种间，渐渗是指杂交加回交产生的一种现象。<br>可以这样理解，杂交和渐渗都是基因流的具体结果。</p>
<ol>
<li>基因流(gene flow)</li>
</ol>
<ul>
<li>基因流是指遗传物质在不同群体间的流动。</li>
<li>造成基因流动的原因可能是个体或配子(例如花粉)在群体间的迁徙，或者不同群体间个体的交配等。</li>
<li>基因流可能发生在同一物种的不同群体间，也可能发生在不同物种间。</li>
</ul>
<ol start="2">
<li>杂交(hybridization)</li>
</ol>
<ul>
<li>杂交指不同物种间通过有性生殖实现配子融合形成下一代的过程。</li>
</ul>
<ol start="3">
<li>渐渗(introgressive)</li>
</ol>
<ul>
<li>渐渗是指通过种间杂种与亲本物种之一的反复回交，将遗传物质从一个物种转移到另一个物种的基因库中，是一个长期的过程。</li>
</ul>
<h1 id="2-推断基因流-x2F-杂交"><a href="#2-推断基因流-x2F-杂交" class="headerlink" title="2. 推断基因流&#x2F;杂交"></a>2. 推断基因流&#x2F;杂交</h1><p>通常在物种内检测不同地区的群体间是否存在基因流，也可以在物种间检测基因流来判断杂交&#x2F;渐渗，物种间的基因流会导致系统发育树的不稳定或核质冲突等问题，所以可以推断系统发育网络来检测所有物种对的基因流。</p>
<h2 id="2-1-推断基因流的软件"><a href="#2-1-推断基因流的软件" class="headerlink" title="2.1. 推断基因流的软件"></a>2.1. 推断基因流的软件</h2><ol>
<li>通过计算Patterson’s D值(ABBA-BABA值)和相关统计量来判断基因流：Dsuite(2020),ADMIXTOOLS(2012),HyDe(2018),ANGSD(2011,2018),POPGENOME(2014,2019),COMP-D(2020)。</li>
<li>推断系统发育网络：PhyloNetworks(2017),PhyloNet(2008,2018),TreeMix(2012),BEAST2(2017)。</li>
<li>基于最大似然法：3s(2017)</li>
<li>基于MCMC算法的：IM, IMA</li>
</ol>
<p>有几个软件单独写了博客：</p>
<h3 id="2-1-1-Dsuite【推荐】"><a href="#2-1-1-Dsuite【推荐】" class="headerlink" title="2.1.1. Dsuite【推荐】"></a>2.1.1. Dsuite【推荐】</h3><p><a href="https://yanzhongsino.github.io/2022/04/10/bioinfo_geneflow_Dsuite/">Dsuite blog</a></p>
<ol>
<li>Dsuite简介<ul>
<li>Dsuite是通过计算Patterson’s D统计量(即ABBA统计量)和f4等统计量来评估种群间或近缘种间基因流的基于C语言的软件。</li>
</ul>
</li>
<li>Dsuite 原理<ul>
<li>D值（即ABBA统计量）和f4-ratio统计可以表示为适用于四个分类群的双等位基因SNP：P1,P2,P3,O，拓扑是 (((P1,P2),P3),O)。</li>
<li>其中外类群O携带祖先等位基因A，衍生等位基因用B表示。BBAA,ABBA,BABA分别代表四个分类群携带等位的三种模式。</li>
<li>在没有基因流的零假设下，由于具有相同频率的不完全谱系分类，预计P3与P1或P2共享衍生等位基因B的两种模式ABBA和BABA的频率相等，如果ABBA和BABA的频率有显著差异则代表在P3和P1或P2间存在基因渐渗。</li>
<li>D&#x3D;(nABBA-nBABA)&#x2F;(nABBA+nBABA)；在外群对于祖先等位基因A是固定的（外群中B的频率为0）假设下，D统计量是等位基因模式计数的归一化差异。</li>
<li>如果外群中衍生等位基因B不为0，则Dsuite的D值是Patterson’s D，适用于无根的四分类群树。</li>
</ul>
</li>
<li>Dsuite输入输出<ul>
<li>输入：基因组snp的vcf格式文件，居群树文件(可选optional)</li>
<li>输出：D值统计，f4-ratio统计，f-branch统计，f-branch树矩阵热图</li>
</ul>
</li>
<li>Dsuite优势和不足<ul>
<li>Dsuite的优势是运行非常快(时间以小时计算)</li>
<li>不足是Dsuite分析结果不包含基因流的方向</li>
</ul>
</li>
<li>Dsuite适用范围<ul>
<li>Dsuite适用于基因组学大数据和多样本(超过十个)数据</li>
<li>适用于居群间或物种间的基因流推测</li>
<li>即使每个群体只有一个个体也可以推测基因流</li>
<li>还可以计算pool-seq数据的基因流</li>
<li>相较其他计算D值软件，Dsuite还同时可以计算f4-ratio和f-branch，以及滑窗统计f相关值。</li>
</ul>
</li>
</ol>
<h3 id="2-1-2-PhyloNetworks"><a href="#2-1-2-PhyloNetworks" class="headerlink" title="2.1.2. PhyloNetworks"></a>2.1.2. PhyloNetworks</h3><p><a href="https://yanzhongsino.github.io/2022/04/14/bioinfo_geneflow_PhyloNetworks/">PhyloNetworks blog</a></p>
<ol>
<li>PhyloNetworks简介<ul>
<li>PhyloNetworks是通过基因树或多位点序列(SNaQ)的最大伪似然进行推断系统发育网络的一个Julia包。</li>
</ul>
</li>
<li>PhyloNetworks原理<ul>
<li>原理：通过SNaQ来实现网络推断，SNaQ通过估计4分类群子集的最大伪似然来加速运算，估计的网络不受根的影响。</li>
</ul>
</li>
<li>PhyloNetworks输入输出<ul>
<li>输入：newick格式基因树(多个基因树组成的文件)</li>
<li>输出：系统发育网络，基因流方向和杂交节点贡献比例</li>
</ul>
</li>
<li>PhyloNetworks优势和不足<ul>
<li>推断系统发育网络，包括基因流的方向和强度。</li>
<li>相较于其他推断系统发育网络的软件，PhyloNetworks集成了上游分析，网络估计，引导分析，下游特征进化分析，绘图等功能。</li>
<li>不足是运行多样本(超过十个个体)和数据量大(超过1000个)会非常耗时(常常以星期&#x2F;月计时)。</li>
</ul>
</li>
<li>PhyloNetworks适用范围<ul>
<li>PhyloNetworks适用于基因树数据</li>
<li>适用于居群间或物种间的基因流推测</li>
<li>适用于推断基因流方向和强度</li>
</ul>
</li>
</ol>
<h3 id="2-1-3-TreeMix"><a href="#2-1-3-TreeMix" class="headerlink" title="2.1.3. TreeMix"></a>2.1.3. TreeMix</h3><p><a href="https://yanzhongsino.github.io/2022/03/20/bioinfo_geneflow_treemix/">TreeMix blog</a></p>
<ol>
<li>TreeMix简介<ul>
<li>TreeMix利用等位基因频率来推断群体间分化和杂合（基因流动或基因渗入）</li>
</ul>
</li>
<li>TreeMix输入输出<ul>
<li>输入：基因组snp的vcf文件，和居群系统树(可选optional)</li>
<li>输出：最佳杂交次数和系统发育网络(包含杂交方向和强度)</li>
</ul>
</li>
<li>TreeMix优势和不足<ul>
<li>TreeMix和PhyloNetworks一样，也是推断系统发育网络。</li>
<li>我自己用时，有些PhyloNetworks报错无法定根和边缘错误的情况TreeMix可以找到最佳杂交次数。</li>
<li>不足是比PhyloNetworks更耗时，超级耗时。</li>
</ul>
</li>
</ol>
<h3 id="2-1-4-3s"><a href="#2-1-4-3s" class="headerlink" title="2.1.4. 3s"></a>2.1.4. 3s</h3><p><a href="https://yanzhongsino.github.io/2022/09/22/bioinfo_geneflow_3s/">3s blog</a></p>
<ol>
<li>3s简介</li>
</ol>
<ul>
<li>3s利用似然率来推断两个物种&#x2F;群体间的基因流方向和强度</li>
</ul>
<ol start="2">
<li>3s输入</li>
</ol>
<ul>
<li>输入：基因组或其他测序序列phylip文件</li>
<li>输出：基因流方向和强度</li>
</ul>
<ol start="3">
<li>3s优势和不足</li>
</ol>
<ul>
<li>随着数据量线性增加运算时间，运算快，适合基因组数据。</li>
<li>一次只能检测三个物种&#x2F;群体，无法建立系统发育网。</li>
</ul>
<h1 id="3-reference"><a href="#3-reference" class="headerlink" title="3. reference"></a>3. reference</h1><ol>
<li>wiki: gene flow：<a href="https://en.wikipedia.org/wiki/Gene_flow">https://en.wikipedia.org/wiki/Gene_flow</a></li>
<li>wiki: introgression：<a href="https://en.wikipedia.org/wiki/Introgression">https://en.wikipedia.org/wiki/Introgression</a></li>
<li>Dsuite paper：<a href="https://onlinelibrary.wiley.com/doi/10.1111/1755-0998.13265">https://onlinelibrary.wiley.com/doi/10.1111/1755-0998.13265</a></li>
<li>PhyloNetworks paper：<a href="https://academic.oup.com/mbe/article/34/12/3292/4103410">https://academic.oup.com/mbe/article/34/12/3292/4103410</a></li>
<li>TreeMix paper：<a href="https://www.nature.com/articles/npre.2012.6956.1">https://www.nature.com/articles/npre.2012.6956.1</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>gene flow</category>
      </categories>
      <tags>
        <tag>gene flow</tag>
        <tag>Dsuite</tag>
        <tag>hybridization</tag>
        <tag>introgressive</tag>
        <tag>3s</tag>
        <tag>PhyloNetworks</tag>
        <tag>population networks</tag>
        <tag>TreeMix</tag>
      </tags>
  </entry>
  <entry>
    <title>用OrthoFinder做直系同源推断</title>
    <url>/2021/12/06/bioinfo_orthology.inference_OrthoFinder2/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=108151&auto=1&height=32"></iframe></div>

<h1 id="1-直系同源-orthology-推断"><a href="#1-直系同源-orthology-推断" class="headerlink" title="1. 直系同源(orthology)推断"></a>1. 直系同源(orthology)推断</h1><h2 id="1-1-直系同源推断"><a href="#1-1-直系同源推断" class="headerlink" title="1.1. 直系同源推断"></a>1.1. 直系同源推断</h2><p>直系同源(orthology)是指直系同源基因的直系同源这种属性，相关的概念可以参考<a href="https://yanzhongsino.github.io/2021/06/23/concept_homology/">博文-同源性相关概念</a>。</p>
<p>直系同源推断(orthology inference)常常在多个物种间进行，通常是获取多个物种的直系同源群(orthogroups)和直系同源群间的关系。</p>
<p>直系同源基因判定的方法有两种：</p>
<ul>
<li>一种是将物种的直系同源基因两两比较，不同物种的每一对都是直系同源，但存在基因重复，使得用这种方法找到的同源关系是不具有传递性的（A和B是同源的，B和C是同源的，但是A和C不是同源的）。multiparanoid和OMA方法都是这个原理。所以需要每个同源基因都在多个集合中存在才行，进行两两比较。</li>
<li>另一种是识别完整的正交群，一个同源组orthogroup包含所有物种共同祖先基因，同时包含直系／旁系同源基因，OrthoMCL是这个原理，它是通过正交组做推断，用BLAST计算多个物种序列之间的序列相似性得分，然后用MCL聚类算法，识别该数据集中高度相似的序列组。</li>
</ul>
<h2 id="1-2-直系同源基因推断常用软件：OrthoMCL和OrthoFinder"><a href="#1-2-直系同源基因推断常用软件：OrthoMCL和OrthoFinder" class="headerlink" title="1.2. 直系同源基因推断常用软件：OrthoMCL和OrthoFinder"></a>1.2. 直系同源基因推断常用软件：OrthoMCL和OrthoFinder</h2><h3 id="1-2-1-OrthoMCL"><a href="#1-2-1-OrthoMCL" class="headerlink" title="1.2.1. OrthoMCL"></a>1.2.1. OrthoMCL</h3><p>OrthoMCL是2003年发表的工具。发表以后得到广泛使用，但存在一些问题：</p>
<ul>
<li>2013年之后就没更新，安装需要使用MySQL。</li>
<li>在BLAST序列相似度时发现，长序列比短序列更准确，有时会留下较长的质量差的序列，而丢弃较短的单质量好的序列。</li>
<li>orthoBench是唯一可用的公开的正交群标准数据集，用orthoBench数据集评估orthoMCL性能，发现它对序列长度有依赖性，太长或者太短的序列都不准确。</li>
<li>recall率有待提高。</li>
</ul>
<h3 id="1-2-2-OrthoFinder"><a href="#1-2-2-OrthoFinder" class="headerlink" title="1.2.2. OrthoFinder"></a>1.2.2. OrthoFinder</h3><p>OrthoFinder是2015年才出现，2019年正式发表的工具。OrthoFinder解决了一些OrthoMCL中存在的问题，展现了优势：</p>
<ul>
<li>持续更新，安装友好，运行速度快。</li>
<li>OrthoFinder解决了这个问题，它将BLAST评分做了转换，将原来的e值准换成bit值（比特值）来减少序列长度对准确度的影响，因为e值存在阈值，e 小于10的－180次方的都被算作0，而比特值没有阈值。</li>
<li>OrthoFinder用RBNH代替了传统的RBH提高了recall。</li>
</ul>
<p>这篇博文主要介绍OrthoFinder这个工具。</p>
<h1 id="2-OrthoFinder"><a href="#2-OrthoFinder" class="headerlink" title="2. OrthoFinder"></a>2. OrthoFinder</h1><h2 id="2-1-OrthoFinder的功能"><a href="#2-1-OrthoFinder的功能" class="headerlink" title="2.1. OrthoFinder的功能"></a>2.1. OrthoFinder的功能</h2><p>OrthoFinder是用于推断系统发育直系同源关系的基于python的软件。OrthoFinder1模块推断直系同源群，OrthoFinder2模块在直系同源群的基础上构建物种系统发育树，步骤如下：</p>
<ol>
<li>推断所有物种的直系同源群和直系同源基因。</li>
</ol>
<ul>
<li>用all vs all比对所有输入的物种蛋白序列；</li>
<li>RBNHs方法确定阈值；</li>
<li>MCL聚类获得直系同源组。</li>
</ul>
<ol start="2">
<li>推断找到的所有直系同源基因的有根基因树。</li>
</ol>
<ul>
<li>为每个直系同源组构建基因系统发育树；</li>
<li>使用STAG算法从无根基因树上构建无根物种树；</li>
<li>使用STRIDE算法构建有根物种树；</li>
<li>有根物种树进一步辅助构建有根基因树。</li>
</ul>
<ol start="3">
<li>用基因树推断基因间的所有直系同源群间的关系。</li>
<li>推断基因复制事件并交叉引用到对应的基因树和物种树上的对应节点。</li>
<li>提供比较基因组学统计结果。</li>
</ol>
<img src="https://github.com/davidemms/OrthoFinder/raw/master/assets/Workflow.png" width=100% title="The OrthoFinder workflow" alt="The OrthoFinder workflow" align=center/>

<p><strong><p align="center">Figure 1. The OrthoFinder workflow</strong><br>from <a href="https://github.com/davidemms/OrthoFinder">github: orthofinder</a></p></p>
<h2 id="2-2-OrthoFinder的分步原理"><a href="#2-2-OrthoFinder的分步原理" class="headerlink" title="2.2. OrthoFinder的分步原理"></a>2.2. OrthoFinder的分步原理</h2><h3 id="2-2-1-OrthoFinder1推断直系同源群的基本原理"><a href="#2-2-1-OrthoFinder1推断直系同源群的基本原理" class="headerlink" title="2.2.1. OrthoFinder1推断直系同源群的基本原理"></a>2.2.1. OrthoFinder1推断直系同源群的基本原理</h3><ul>
<li>首先BLAST all vs all 做所有物种蛋白序列的比对。选best hits Top5%，用比特值代替e值，用最小二乘法将Top5%的分数值拟合成一个线性模型，将比特值用这个模型转换之后，较长的质量差的hit将不再优于短的质量好的序列；</li>
<li>然后将基因长度和系统发育距离标准化。用的是RBNH方法，传统的是用RBH方法，它是一种高精度鉴定直系同源基因对的方法，用BLAST best hit的倒数做的，但是RBNH是用标准话的比特值来做的。</li>
</ul>
<h3 id="2-2-2-OrthoFinder1推断直系同源群的工作流程"><a href="#2-2-2-OrthoFinder1推断直系同源群的工作流程" class="headerlink" title="2.2.2. OrthoFinder1推断直系同源群的工作流程"></a>2.2.2. OrthoFinder1推断直系同源群的工作流程</h3><p>OrthoFinder1推断直系同源群的分析过程分为如下几步:</p>
<ol>
<li>BLAST all-vs-all搜索。使用BLASTP以evalue&#x3D;10e-3进行搜索，寻找潜在的同源基因。(除了BLAST, 还可以选择DIAMOND和MMSeq2等其他搜索工具)。</li>
<li>基于基因长度和系统发育距离对BLAST bit得分进行标准化。</li>
<li>使用RBNHs方法，确定一个同源组序列性相似度的阈值，筛选出质量好的直系同源组(orthogroup graph)。</li>
<li>构建直系同源组图(orthogroup graph)，通过归一化的比特值画出正交组的边缘连接，用作MCL的输入。</li>
<li>使用MCL对基因进行聚类，划分直系同源组。</li>
</ol>
<h3 id="2-2-3-OrthoFinder2在OrthoFinder1的基础上构建物种系统发育树的流程"><a href="#2-2-3-OrthoFinder2在OrthoFinder1的基础上构建物种系统发育树的流程" class="headerlink" title="2.2.3. OrthoFinder2在OrthoFinder1的基础上构建物种系统发育树的流程"></a>2.2.3. OrthoFinder2在OrthoFinder1的基础上构建物种系统发育树的流程</h3><ol>
<li>为每个直系同源组构建基因系统发育树；</li>
<li>使用STAG算法从无根基因树上构建无根物种树；</li>
<li>使用STRIDE算法构建有根物种树；</li>
<li>有根物种树进一步辅助构建有根基因树；</li>
<li>基于DLC(Duplication-Loss-Coalescent)分析模型，有根基因树可以用来推断物种形成和基因复制事件；</li>
<li>最后把结果记录在统计信息中。</li>
</ol>
<h2 id="2-3-OrthoFinder使用"><a href="#2-3-OrthoFinder使用" class="headerlink" title="2.3. OrthoFinder使用"></a>2.3. OrthoFinder使用</h2><h3 id="2-3-1-OrthoFinder安装"><a href="#2-3-1-OrthoFinder安装" class="headerlink" title="2.3.1. OrthoFinder安装"></a>2.3.1. OrthoFinder安装</h3><ol>
<li><p>conda安装【推荐】<br>conda安装一次解决依赖问题：<code>conda install orthofinder</code></p>
</li>
<li><p>下载解压缩<br><a href="https://github.com/davidemms/OrthoFinder/releases">OrthoFinder最新版下载地址</a></p>
</li>
</ol>
<p>下载后解压缩：<code>tar xzf OrthoFinder_source.tar.gz</code> or <code>tar xzf OrthoFinder.tar.gz</code></p>
<p>即可使用：<code>python OrthoFinder_source/orthofinder.py -h</code> or <code>./OrthoFinder/orthofinder -h</code></p>
<h3 id="2-3-2-OrthoFinder运行"><a href="#2-3-2-OrthoFinder运行" class="headerlink" title="2.3.2. OrthoFinder运行"></a>2.3.2. OrthoFinder运行</h3><h4 id="2-3-2-1-输入文件"><a href="#2-3-2-1-输入文件" class="headerlink" title="2.3.2.1. 输入文件"></a>2.3.2.1. 输入文件</h4><p>把需要分析的物种的组学蛋白序列文件(.fa,.faa,.fasta,.fas,.pep后缀)放在同一个目录下(例如workdirectory目录下)，然后用OrthoFinder的-f参数指定目录做分析。</p>
<p>如果是下载的蛋白数据，使用最长转录本的蛋白序列即可。</p>
<h4 id="2-3-2-2-简单版"><a href="#2-3-2-2-简单版" class="headerlink" title="2.3.2.2. 简单版"></a>2.3.2.2. 简单版</h4><p><code>orthofinder -f ./workdirectory</code> # -f指定数据目录</p>
<h4 id="2-3-2-3-参数版"><a href="#2-3-2-3-参数版" class="headerlink" title="2.3.2.3. 参数版"></a>2.3.2.3. 参数版</h4><p><code>orthofinder -f ./workdirectory -t 24 -a 8 -M msa -S blast -A mafft -T raxml-ng</code></p>
<ul>
<li>-t指定比对线程;</li>
<li>-a指定分析线程;</li>
<li>-M指定推断基因树的方法: dendroblast(default)&#x2F;msa;</li>
<li>-S指定比对软件: diamond(default)&#x2F;blast&#x2F;blast_gz&#x2F;mmseqs&#x2F;blast_nucl</li>
<li>-A指定多序列比对(MSA)使用软件：mafft(default)&#x2F;muscle；需要指定-M msa</li>
<li>-T指定画树软件：fasttree(default)&#x2F;raxml&#x2F;raxml-ng&#x2F;iqtree</li>
</ul>
<h4 id="2-3-2-4-修改参数文件config-json"><a href="#2-3-2-4-修改参数文件config-json" class="headerlink" title="2.3.2.4. 修改参数文件config.json"></a>2.3.2.4. 修改参数文件config.json</h4><ol>
<li>如果需要做更细致的参数设定，比如对调用软件blast的参数evalue阈值的修改，可以通过修改参数文件config.json来实现。</li>
<li>config.json文件位置：下载安装的在安装目录下，conda安装的在conda的bin目录下。</li>
<li>推荐修改值：</li>
</ol>
<ul>
<li>raxml-ng参数修改为–model LG+G8+F –threads 2 –bs-trees 1000（default是–model LG+G4 –threads 1)；</li>
<li>blastp和blastn的参数修改为 -evalue 0.00001（default是0.001）</li>
</ul>
<h4 id="2-3-2-5-RESTART"><a href="#2-3-2-5-RESTART" class="headerlink" title="2.3.2.5. RESTART"></a>2.3.2.5. RESTART</h4><p>如果需要重新运行，可以使用以下参数设定从哪个步骤开始运行。</p>
<ul>
<li>-b  <dir> # Start OrthoFinder from pre-computed BLAST results in <dir></li>
<li>-fg <dir> # Start OrthoFinder from pre-computed orthogroups in <dir></li>
<li>-ft <dir> # Start OrthoFinder from pre-computed gene trees in <dir></li>
</ul>
<ol>
<li>添加新物种<br>运行之后想要添加物种可以用<code>orthofinder -b previous_orthofinder_directory -f new_fasta_directory</code>而无需重新运行先前计算的 BLAST 搜索。</li>
</ol>
<p>这会将“new_fasta_directory”中的每个物种添加到现有物种集中，重用所有以前的 BLAST 结果，仅执行新物种所需的新 BLAST 搜索并重新计算正交群。’previous_orthofinder_directory’ 是包含文件 ‘SpeciesIDs.txt’ 的 OrthoFinder ‘WorkingDirectory&#x2F;‘。</p>
<ol start="2">
<li>移除物种<br>OrthoFinder 允许您从以前的分析中删除物种。<br>在先前分析的“WorkingDirectory&#x2F;”中有一个名为“SpeciesIDs.txt”的文件。使用“#”字符注释掉要从分析中删除的任何物种，然后使用以下命令运行 OrthoFinder：<code>orthofinder -b previous_orthofinder_directory</code></li>
</ol>
<p>其中 ‘previous_orthofinder_directory’ 是包含文件 ‘SpeciesIDs.txt’ 的 OrthoFinder ‘WorkingDirectory&#x2F;‘。</p>
<ol start="3">
<li>同时添加和删除物种<br>前面两个选项可以结合起来，如上所述注释掉要删除的物种，然后使用命令：<br><code>orthofinder -b previous_orthofinder_directory -f new_fasta_directory</code></li>
</ol>
<h4 id="2-3-2-6-结果文件"><a href="#2-3-2-6-结果文件" class="headerlink" title="2.3.2.6. 结果文件"></a>2.3.2.6. 结果文件</h4><p>OrthoFinder的标准输出包括：直系同源组，直系同源基因，有根基因树，解析基因树，无根物种树、有根物种树，基因重复事件以及相关的统计数据。</p>
<ol>
<li><p><strong>Phylogenetic_Hierarchical_Orthogroups 文件夹</strong></p>
<p> 从 2.4.0 版本开始，主要文件储存在这个目录下面，orthogroups目录被弃用。</p>
<p> OrthoFinder 通过分析有根基因树来推断每个层次级别（即物种树中的每个节点）的 HOG、正交群。这是一种比所有其他方法使用的和以前由 OrthoFinder 使用的基于基因相似性&#x2F;图形的方法（已弃用的 Orthogroups&#x2F;Orthogroups.tsv 文件）更准确的正交群推断方法。</p>
<p> 根据 Orthobench 基准，这些新的正交群比 OrthoFinder 2 正交群 (Orthogroups&#x2F;Orthogroups.tsv) 准确 12%。通过包括外群物种，可以进一步提高准确度（在 Orthobench 上准确度提高 20%），这有助于解释有根基因树。</p>
</li>
</ol>
<ul>
<li>参阅“Species_Tree&#x2F;SpeciesTree_rooted_node_labels.txt”以确定哪个 N?.tsv 文件包含您需要的正交群。</li>
<li>N0.tsv是制表符分隔的文本文件。每行包含属于单个正交群的基因。来自每个正交群的基因被组织成列，每个物种一个。附加列给出了 HOG（分层正交群）ID 和基因树中确定 HOG 的节点（注意，这可能位于包含基因的进化枝的根上方）。该文件有效地替换了使用 MCL 进行马尔可夫聚类的Orthogroups&#x2F;Orthogroups.tsv 中的正交群。</li>
<li>N1.txt, N2.tsv, … : Orthogroups 从对应物种树 N1、N2 等物种进化枝的基因树推断出来。现在可以在分析中包含外群物种，然后使用 HOG 文件获取为物种树中所选进化枝定义的正交群。</li>
</ul>
<ol start="2">
<li><strong>Orthologues 文件夹</strong></li>
</ol>
<ul>
<li>Orthologues 目录包含每个物种的一个子目录，该子目录又包含每个成对物种比较的文件，列出该物种对之间的直向同源物。</li>
<li>直向同源物可以是一对一、一对多或多对多，这取决于直向同源物分化后的基因复制事件。</li>
<li>文件中的每一行都包含一个物种中的基因，这些基因是另一个物种中基因的直向同源物，并且每一行都与包含这些基因的直向群交叉引用。</li>
</ul>
<ol start="3">
<li><strong>Orthogroups 文件夹【2.4.0版本后弃用】</strong><br>从 2.4.0 版本开始，主要文件储存在Phylogenetic_Hierarchical_Orthogroups目录下面，orthogroups目录被弃用。</li>
</ol>
<ul>
<li>Orthogroups.tsv【2.4.0版本后弃用】：制表符分隔的文本文件。每行包含属于单个正交群的基因。来自每个正交群的基因被组织成列，每个物种一个。应改用 Phylogenetic_Hierarchical_Orthogroups&#x2F;N0.tsv 中的正交群。</li>
<li>Orthogroups.txt【旧格式】：包含 Orthogroups.tsv 文件内容的 OrthoMCL 输出格式文件，列间用空格分隔。第一列是OG开头的orthogroups的ID号，冒号结束；后面不同数量的列是此orthogroup包含的各物种的基因ID。</li>
<li>Orthogroups_UnassignedGenes.tsv：是制表符分隔的文本文件，其格式与 Orthogroups.csv 相同，但包含未分配给任何正交群的所有基因，即 MCL 中 未成功聚类（直系同源组中基因数 &gt;&#x3D; 1）的离散基因。</li>
<li>Orthogroups.GeneCount.tsv：是一个制表符分隔的文本文件，其格式与 Orthogroups.csv 相同，但包含每个正交群中每个物种的基因数计数，可用于基因收缩扩张分析。</li>
<li>Orthogroups_SingleCopyOrthologues.txt：是一个正交群列表，每个物种只包含一个基因，即它们包含一对一的直向同源物（单拷贝直系同源基因）。它们非常适合物种间比较和物种树推断。</li>
</ul>
<ol start="4">
<li><strong>Gene_Trees 文件夹</strong></li>
</ol>
<ul>
<li>记录了每个 orthogroup（gene_num &gt;&#x3D; 4）的有根基因树结构。</li>
</ul>
<ol start="5">
<li><strong>Resolved Gene Trees文件夹</strong></li>
</ol>
<ul>
<li>为具有 4 个或更多序列的每个正交群推断出有根的系统发育树，并使用OrthoFinder的杂种-重叠&#x2F;重复-丢失溯祖模型(hybrid species-overlap&#x2F;duplication-loss coalescent model)进行解析。</li>
</ul>
<ol start="6">
<li><strong>Species_Tree 文件夹</strong></li>
</ol>
<ul>
<li>SpeciesTree_rooted.txt：STAG物种树从所有orthogroups推断，含有内部节点STAG支持值，并使用STRIDE生根，计算出的有根物种树结构。</li>
<li>SpeciesTree_rooted_node_labels.txt：与上述相同的树，但节点被赋予标签(N0,N1, . . . , N m N_0,N_1,…,N_mN0,N1,…,Nm)（而不是支持值）以允许其他结果文件交叉引用物种树中的分支&#x2F;节点（例如基因复制事件的位置）。</li>
<li>Orthogroups_for_concatenated_alignment.txt：仅在 -M msa 模式下输出，列出了所有串联起来用于推断物种树的 orthogroup ID。</li>
</ul>
<ol start="7">
<li><strong>Comparative_Genomics_Statistics 文件夹</strong></li>
</ol>
<ul>
<li><p>Duplications_per_Orthogroup.tsv：是一个制表符分隔的文本文件，它给出了每个正交群中标识的重复数。此数据的主文件是 Gene_Duplication_Events&#x2F;Duplications.tsv。</p>
</li>
<li><p>Duplications_per_Species_Tree_Node.tsv：是一个制表符分隔的文本文件，它给出了识别为沿着物种树的每个分支发生的重复数。此数据的主文件是 Gene_Duplication_Events&#x2F;Duplications.tsv。</p>
</li>
<li><p>Orthogroups_SpeciesOverlaps.tsv：是一个制表符分隔的文本文件，其中包含作为方阵的每个物种对之间共享的正交群的数量。</p>
</li>
<li><p>OrthologuesStats_*.tsv：是制表符分隔的文本文件，包含矩阵给出每对物种之间一对一、一对多和多对多关系中的直向同源物数量。</p>
<ul>
<li>OrthologuesStats_one-to-one.tsv是每个物种对之间一对一直向同源物的数量。</li>
<li>OrthologuesStats_many-to-many.tsv包含每个物种对的多对多关系中的直向同源物的数量（由于物种形成后两个谱系中的基因重复事件）。条目 (i,j) 是物种 i 中与物种 j 中的基因存在多对多直系关系的基因数。</li>
<li>OrthologuesStats_one-to-many.tsv：条目 (i,j) 给出物种 i 中与物种 j 的基因处于一对多直系关系的基因数量。这里有一个示例结果文件的演练： https : &#x2F;&#x2F;github.com&#x2F;davidemms&#x2F;OrthoFinder&#x2F;issues&#x2F;259。</li>
<li>OrthologuesStats_many-to-one.tsv：条目 (i,j) 给出物种 i 中与物种 j 的基因处于多对一直系关系的基因数量。这里有一个示例结果文件的演练： https : &#x2F;&#x2F;github.com&#x2F;davidemms&#x2F;OrthoFinder&#x2F;issues&#x2F;259。</li>
<li>OrthologuesStats_Total.tsv包含任何多样性的每个物种的直向同源物对的总数。条目 (i,j) 是物种 i 中在物种 j 中具有直向同源物的基因总数。</li>
</ul>
</li>
<li><p>Statistics_Overall.tsv：是一个制表符分隔的文本文件，其中包含有关正交群大小和分配给正交群的基因比例的一般统计信息。</p>
</li>
<li><p>Statistics_PerSpecies.tsv：是一个制表符分隔的文本文件，包含与 Statistics_Overall.csv 文件相同的信息，但针对每个单独的物种。</p>
</li>
</ul>
<p>文件“Statistics_Overall.csv”和“Statistics_PerSpecies.csv”中的大部分术语都是不言自明的，其余的定义如下。</p>
<ul>
<li>Species-specific orthogroup：完全由来自一个物种的基因组成的正交群。</li>
<li>G50：正交群中的基因数量，使得 50% 的基因处于该大小或更大的正交群中。</li>
<li>O50：正交群的最小数量，使得 50% 的基因处于该大小或更大的正交群中。</li>
<li>单拷贝正群：每个物种只有一个基因（并且没有更多）的正群。这些正交群是推断物种树和许多其他分析的理想选择。</li>
<li>未分配基因：未与任何其他基因放在同一个群中的基因。</li>
</ul>
<ol start="8">
<li><strong>Gene_Duplication_Events 文件夹</strong></li>
</ol>
<ul>
<li>Duplications.tsv是一个制表符分隔的文本文件，它列出了通过检查每个正群基因树的每个节点识别出的所有基因复制事件，每行代表至少一次基因复制事件。</li>
<li>Duplications.tsv的列分别是1.“Orthogroup”，2.“Species Tree node”（发生复制的物种树的分支，参见Species_Tree&#x2F;SpeciesTree_rooted_node_labels.txt），3.“Gene tree node”（与基因复制事件对应的节点，参见相应的orthogroup Resolved_Gene_Trees&#x2F;) 中的树；4.”Support”（存在复制基因的两个副本的预期物种的比例）；5.“Type”（”Terminal”：物种树终端分支上的重复，”Non-Terminal”：物种树内部分支上的重复，因此被多个物种共享，”Non-Terminal”：STRIDE检查基因树的拓扑结构在复制后应该是什么）；6.“Genes 1”（基因列表来自复制基因的一个副本，逗号分隔）；7.“Genes 2”（基因列表来自复制基因的另一个副本，逗号分隔）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Orthogroup      Species Tree Node       Gene Tree Node  Support Type    Genes 1 Genes 2</span><br><span class="line">OG0000000       N5      n62     0.5     Non-Terminal    Mcandidum_pep_mc33950   Mdodecandrum_pep_DR005872, Mcandidum_pep_mc01326, Mdodecandrum_pep_DR006000, Mcandidum_pep_mc01492</span><br><span class="line">OG0000000       N5      n63     1.0     Non-Terminal    Mdodecandrum_pep_DR005872, Mcandidum_pep_mc01326        Mdodecandrum_pep_DR006000, Mcandidum_pep_mc01492</span><br><span class="line">OG0000000       N5      n177    0.5     Non-Terminal    Mdodecandrum_pep_DR002276, Mdodecandrum_pep_DR013872, Mcandidum_pep_mc36653, Mdodecandrum_pep_DR026891, Mcandidum_pep_mc22876, Mcandidum_pep_mc37513, Mdodecandrum_pep_DR026886 Mdodecandrum_pep_DR004265</span><br></pre></td></tr></table></figure>

<ul>
<li>SpeciesTree_Gene_Duplications_0.5_Support.txt：提供了物种树分支上的上述重复的总和。它是一个 newick 格式的文本文件。每个节点或物种名称后面的数字是在导致节点&#x2F;物种的分支上发生的具有至少 50% 支持度的基因复制事件的数量。分支长度是标准分支长度，如 Species_Tree&#x2F;SpeciesTree_rooted.txt 中给出的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(((((Mcandidum.pep_7199:1,Mdodecandrum.pep_3425:1)N5_9299:1,Egrandis.pep_12485:1)N3_296:1,((Ptrichocarpa.pep_13300:1,(Csinensis.pep_5628:1,(Graimondii.pep_15253:1,Athaliana.pep_8750:1)N10_30:1)N8_5:1)N6_61:1,(Ppersica.pep_5798:1,(Mtruncatula.pep_23336:1,Csativus.pep_3576:1)N9_48:1)N7_12:1)N4_19:1)N2_96:1,Vvinifera.pep_7596:1)N1_535:1,Mguttatus.pep_8911:1)N0_1806;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><strong>Orthogroup_Sequences 文件夹</strong></li>
</ol>
<ul>
<li>FASTA格式文件，每个正交群的 FASTA 文件给出了正交群中每个基因的氨基酸序列。</li>
</ul>
<ol start="10">
<li><strong>Single_Copy_Orthologue_Sequences 文件夹</strong></li>
</ol>
<ul>
<li>FASTA格式文件，包含每个单拷贝 Orthogroup 所包含的氨基酸的序列信息。</li>
</ul>
<ol start="11">
<li><strong>WorkingDirectory 文件夹</strong></li>
</ol>
<ul>
<li>OrthoFinder 运行所需的必需中间文件，如 DIAMOND 比对结果，STAG 输出的无根物种树等。</li>
</ul>
<ol start="12">
<li><strong>MultipleSequenceAlignments 文件夹</strong></li>
</ol>
<ul>
<li>此文件夹仅在 -M msa 模式下输出，均为 FASTA 格式文件。</li>
<li>记录了每个 orthogroup 中序列间的多序列比对结果。</li>
<li>记录了程序通过 CMSA 算法过滤后的 orthogroup 中各序列串联后的多序列比对结果，同时比对结果中空位数 &gt; 50% 的列已被删除。</li>
</ul>
<h1 id="3-references"><a href="#3-references" class="headerlink" title="3. references"></a>3. references</h1><ol>
<li>tutorial：<a href="https://davidemms.github.io/">https://davidemms.github.io/</a></li>
<li>github：<a href="https://github.com/davidemms/OrthoFinder">https://github.com/davidemms/OrthoFinder</a></li>
<li>paper：<a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1832-y">https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1832-y</a></li>
<li>xuzhougeng’s blog：<a href="https://xuzhougeng.top/archives/OrthoFinder2-fast-and-accurate-phylogenomic-orthology-analysis-from-gene-sequences">https://xuzhougeng.top/archives/OrthoFinder2-fast-and-accurate-phylogenomic-orthology-analysis-from-gene-sequences</a></li>
<li><a href="https://blog.csdn.net/weixin_44614936/article/details/101640473">https://blog.csdn.net/weixin_44614936/article/details/101640473</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>orthology inference</category>
      </categories>
      <tags>
        <tag>OrthoFinder2</tag>
        <tag>orthology</tag>
        <tag>OrthoMCL</tag>
      </tags>
  </entry>
  <entry>
    <title>树空间的多维缩放（multidimensional scaling，MDS）可视化物种树和基因树的RF距离</title>
    <url>/2023/03/13/bioinfo_phylogeny_MDS/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=105210&auto=1&height=32"></iframe></div>

<h1 id="1-树空间的多维缩放（multidimensional-scaling，MDS）可视化物种树和基因树的RF距离"><a href="#1-树空间的多维缩放（multidimensional-scaling，MDS）可视化物种树和基因树的RF距离" class="headerlink" title="1. 树空间的多维缩放（multidimensional scaling，MDS）可视化物种树和基因树的RF距离"></a>1. 树空间的多维缩放（multidimensional scaling，MDS）可视化物种树和基因树的RF距离</h1><ol>
<li>简介</li>
</ol>
<ul>
<li>当系统发育拓扑冲突时，需要评估基因树与物种树的不一致程度，可使用树空间的多维缩放（multidimensional scaling，MDS）来对树的RF距离进行降维，并在指定维度可视化基因树与物种树之间的RF距离。</li>
</ul>
<ol start="2">
<li>分析步骤</li>
</ol>
<ul>
<li>先使用R包ape 5.0计算树之间的成对Robinson-Foulds（RF）距离，然后对RF距离进行多维缩放（multidimensional scaling，MDS），最后绘制指定维度下的RF距离示意图。</li>
</ul>
<ol start="3">
<li>结果</li>
</ol>
<ul>
<li>MDS的二维图如下所示，图中的物种树，包括不同数据和不同软件的物种树（包括ASTRAL_tree，SCGs_ML，SNPs_ML，Plastome_ML树）用其他颜色标示，每个蓝色的点代表一棵基因树，颜色深浅代表支持率平均值的大小。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/MDS_support.png?raw=true" width=70% title="MDS图示例" align=center/>

<p><strong><p align="center">图 1. MDS二维图示例</p></strong></p>
<h1 id="2-分析过程"><a href="#2-分析过程" class="headerlink" title="2. 分析过程"></a>2. 分析过程</h1><ol>
<li>输入文件</li>
</ol>
<ul>
<li>species_genes.tre：物种树和基因树合并的树文件，可以合并多棵物种树（比如用不同算法和数据构建的树）。</li>
</ul>
<ol start="2">
<li>用R包ape计算基因树成对间的Robinson-Foulds（RF）距离</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ape<span class="punctuation">)</span> <span class="comment"># 载入ape包</span></span><br><span class="line">trees<span class="operator">&lt;-</span>read.tree<span class="punctuation">(</span><span class="string">&quot;species_genes.tre&quot;</span><span class="punctuation">)</span> <span class="comment"># 读取树</span></span><br><span class="line">trees_dist<span class="operator">&lt;-</span>dist.topo<span class="punctuation">(</span>trees<span class="punctuation">,</span> method <span class="operator">=</span> <span class="string">&quot;PH85&quot;</span><span class="punctuation">)</span> <span class="comment"># 计算RF，trees_dist的数据类别是dist</span></span><br><span class="line">trees_matric<span class="operator">&lt;-</span>as.matrix<span class="punctuation">(</span>trees_dist<span class="punctuation">)</span> <span class="comment"># 转化dist到矩阵matrix</span></span><br><span class="line">write.table <span class="punctuation">(</span>trees_matric<span class="punctuation">,</span> file <span class="operator">=</span><span class="string">&quot;RF_pairs.tsv&quot;</span><span class="punctuation">,</span> sep <span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">)</span> <span class="comment"># 保存矩阵数据到RF_pairs.tsv文件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>RF_pairs.tsv文件是行和列都是tree1,tree2,…,treen等依次命名的树之间的RF距离矩阵。</li>
</ul>
<ol start="3">
<li>MDS多维缩放</li>
</ol>
<ul>
<li>经典MDS法</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mds <span class="operator">&lt;-</span> cmdscale<span class="punctuation">(</span>trees_dist<span class="punctuation">,</span> eig<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">,</span> k<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span> <span class="comment"># k代表维度</span></span><br><span class="line">mds.var.per <span class="operator">&lt;-</span> <span class="built_in">round</span><span class="punctuation">(</span>mds<span class="operator">$</span>eig<span class="operator">/</span><span class="built_in">sum</span><span class="punctuation">(</span>mds<span class="operator">$</span>eig<span class="punctuation">)</span><span class="operator">*</span><span class="number">100</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">mds.values <span class="operator">&lt;-</span> mds<span class="operator">$</span>points</span><br><span class="line">mds.data <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>Sample<span class="operator">=</span>rownames<span class="punctuation">(</span>mds.values<span class="punctuation">)</span><span class="punctuation">,</span> X<span class="operator">=</span>mds.values<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> Y<span class="operator">=</span>mds.values<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">write.table<span class="punctuation">(</span>mds.data<span class="punctuation">,</span>file<span class="operator">=</span><span class="string">&quot;mds.tsv&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">)</span> <span class="comment"># 把MDS的二维值保存到mds.tsv</span></span><br></pre></td></tr></table></figure>

<ul>
<li>mds.tsv文件示例。每棵树都有一行数据，这里是二维的，包含MDS1和MDS2两个值。用tree1,tree2,…,treen等依次命名，与species_genes.tre树文件中树的顺序一致。如果合并了物种树和基因树，可以依据顺序在mds.tsv中找到物种树对应的行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Sample&quot;	&quot;MDS1&quot;	&quot;MDS2&quot;</span><br><span class="line">&quot;tree1&quot;	&quot;tree1&quot;	-15.2853071675022	-9.23665453167777</span><br><span class="line">&quot;tree2&quot;	&quot;tree2&quot;	-13.8416686613703	-7.78853307096205</span><br></pre></td></tr></table></figure>

<ul>
<li>nonmetric MDS法</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>MASS<span class="punctuation">)</span></span><br><span class="line">mds <span class="operator">&lt;-</span> isoMDS<span class="punctuation">(</span>trees_dist<span class="punctuation">,</span> k<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span> <span class="comment"># k代表维度</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>绘图</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">ggplot<span class="punctuation">(</span>data<span class="operator">=</span>mds.data<span class="punctuation">,</span> aes<span class="punctuation">(</span>x<span class="operator">=</span>X<span class="punctuation">,</span> y<span class="operator">=</span>Y<span class="punctuation">,</span> label<span class="operator">=</span>Sample<span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  geom_text<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  xlab<span class="punctuation">(</span>paste<span class="punctuation">(</span><span class="string">&quot;MDS1 - &quot;</span><span class="punctuation">,</span> mds.var.per<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="string">&quot;%&quot;</span><span class="punctuation">,</span> sep<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  ylab<span class="punctuation">(</span>paste<span class="punctuation">(</span><span class="string">&quot;MDS2 - &quot;</span><span class="punctuation">,</span> mds.var.per<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="string">&quot;%&quot;</span><span class="punctuation">,</span> sep<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  theme_bw<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  ggtitle<span class="punctuation">(</span><span class="string">&quot;MDS plot using Euclidean distance&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">mds <span class="operator">&lt;-</span> cmdscale<span class="punctuation">(</span>trees_dist<span class="punctuation">,</span> eig<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">,</span> k<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span> <span class="comment"># k代表维度</span></span><br><span class="line">x <span class="operator">&lt;-</span> mds<span class="operator">$</span>points<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line">y <span class="operator">&lt;-</span> mds<span class="operator">$</span>points<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">plot<span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">,</span> xlab<span class="operator">=</span><span class="string">&quot;Coordinate 1&quot;</span><span class="punctuation">,</span> ylab<span class="operator">=</span><span class="string">&quot;Coordinate 2&quot;</span><span class="punctuation">,</span> main<span class="operator">=</span><span class="string">&quot;Metric MDS&quot;</span><span class="punctuation">,</span> type<span class="operator">=</span><span class="string">&quot;n&quot;</span><span class="punctuation">)</span></span><br><span class="line">text<span class="punctuation">(</span>mds<span class="operator">$</span>points<span class="punctuation">,</span> labels <span class="operator">=</span> rownames<span class="punctuation">(</span>trees_matric<span class="punctuation">)</span><span class="punctuation">,</span> cex <span class="operator">=</span> <span class="number">0.6</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>结果图保存成pdf后可以在pdf编辑器里把物种树对应的点用更大尺寸和其他颜色标示出来。</p>
<ol start="5">
<li>建议</li>
</ol>
<ul>
<li>还可以把每个基因树和物种树的支持率的平均值计算出来之后，用支持率给每棵树的MSD点上色，从而查看是否是离物种树越近的基因树的平均支持率越高。</li>
<li>也可以用基因树的平均支持率和基因树离物种树的RF距离画散点图，并做线性回归分析判断相关性。</li>
</ul>
<h1 id="3-references"><a href="#3-references" class="headerlink" title="3. references"></a>3. references</h1><ol>
<li>MDS paper：<a href="https://academic.oup.com/sysbio/article/67/3/400/4175806">https://academic.oup.com/sysbio/article/67/3/400/4175806</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=30% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>phylogeny</category>
      </categories>
      <tags>
        <tag>phylogeny</tag>
        <tag>ggplot2</tag>
        <tag>R packages</tag>
        <tag>multidimensional scaling</tag>
        <tag>MDS</tag>
        <tag>成对Robinson-Foulds距离</tag>
        <tag>ape</tag>
        <tag>gene tree</tag>
        <tag>species tree</tag>
      </tags>
  </entry>
  <entry>
    <title>用软件Quartet Sampling来计算分支支持率，评估系统发育树不一致程度，区分强冲突和弱支持</title>
    <url>/2022/11/08/bioinfo_phylogeny_QuartetSampling/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=105143&auto=1&height=32"></iframe></div>


<h1 id="1-Quartet-Sampling（QS）method"><a href="#1-Quartet-Sampling（QS）method" class="headerlink" title="1. Quartet Sampling（QS）method"></a>1. Quartet Sampling（QS）method</h1><p>Quartet Sampling（QS）是为系统发育树量化分支的支持率的一种方法，用于区分植物系统发育树上的强烈拓扑冲突和信息不足（缺乏支持）导致的支持率低，即区分强冲突（不一致）和弱支持（不确定性）。</p>
<h2 id="1-1-原理"><a href="#1-1-原理" class="headerlink" title="1.1. 原理"></a>1.1. 原理</h2><h3 id="1-1-1-四重采样"><a href="#1-1-1-四重采样" class="headerlink" title="1.1.1. 四重采样"></a>1.1.1. 四重采样</h3><ol>
<li>对于给定的系统发育树，每个内部枝将树划分为四个不重叠的分类群子集（图A）。</li>
<li>这四组分类群（也被称为元-四重奏，meta-quartet）可以以三种拓扑关系存在：与给定拓扑一致的关系，以及两种替代的不一致关系（Replicate 1和Replicate 2）。</li>
<li>QS方法从四个子集中的每一个子集中重复随机采样一个分类单元，然后基于给定序列数据（完全比对或随机采样的基因分区），评估跨越该特定分支的随机选择的四条序列（即四重奏，quartet）的所有三个可能系统发育拓扑的似然值。</li>
<li>对于同一分支采样的所有四重奏，评估这四个采样分类群可以采用的所有三种可能拓扑的可能性。</li>
<li>然后记录所有重复中具有最佳可能性的四重拓扑并制成表格。</li>
<li>此过程生成一组计数（跨每个分支的所有复制），其中一致或两个不一致关系中的每一个都具有最佳可能性。</li>
<li>该过程可以通过评估每个四重奏的完全比对的可能性（即在单矩阵框架中）或通过从多基因或全基因组比对（即在多基因树中）的单个基因&#x2F;分区比对中随机抽样来执行聚结框架）。</li>
</ol>
<img src="https://bsapubs.onlinelibrary.wiley.com/cms/asset/e55c64b7-cc9d-49bb-92c9-6e59e0661dde/ajb21016-fig-0001-m.jpg" width=90% title="四重采样方法的描述" align=center/>

<p><strong><p align="center">图1. 四重采样方法的描述</strong><br>图源：<a href="https://bsapubs.onlinelibrary.wiley.com/doi/full/10.1002/ajb2.1016">https://bsapubs.onlinelibrary.wiley.com/doi/full/10.1002/ajb2.1016</a></p></p>
<h3 id="1-1-2-评估分数"><a href="#1-1-2-评估分数" class="headerlink" title="1.1.2. 评估分数"></a>1.1.2. 评估分数</h3><p>QS 方法使用这些重新采样的四重树计数来计算焦点树的每个内部分支的三个分数(QC,QD,QI）和评估分类单元的QF分数。</p>
<p>总的来说，这四个分数提供了区分信息一致性（Quartet Concordance，QC），次生进化历史的存在（Quartet Differential，QD），信息量（Quartet Informativeness，QI）和树中单个分类群的可靠性（Quartet Fidelity，QF）的方法。 </p>
<p>QS方法把这些影响分开，而不是像系统发育支持的标准测量那样将它们混为一个单一的汇总支持率。</p>
<ol>
<li>Quartet Concordance (QC) score - 四重奏一致性分数</li>
</ol>
<ul>
<li>QC分数是一种类似熵的度量，量化了四种分类群的三种拓扑之间的相对支持度。</li>
<li>即支持率在三种拓扑中分配越平均，QC值越接近0；越不均，约远离0。</li>
<li>当频率最高的拓扑与输入树一致时，QC 值在 (0,1] 范围内为正。</li>
<li>当所有四重树与输入树的焦点分支一致时，QC 等于 1。</li>
<li>当其中一个不一致的拓扑是最常见的采样四重奏，QC 值在 [-1,0) 范围内为负。</li>
<li>当所有四重奏树都是两个不一致的系统发育拓扑之一时接近 -1。</li>
<li>当三个拓扑中平均分配时，QC 等于 0（或者如果三个可能中只有两个被注册为在所有复制中具有最佳可能性，则在两个之间平均分配）。</li>
</ul>
<ol start="2">
<li>Quartet Differential (QD) score - 四重奏差异分数</li>
</ol>
<ul>
<li>QD分数使用基因渐渗的f和D统计量的逻辑（尽管使用四重拓扑比例，而不是位点频率），并测量两个不一致拓扑的采样比例之间的差异。</li>
<li>QD 分数没有具体量化基因渗入，也没有识别基因渗入的分类群，但确实表明一种拓扑的频率高于另一种拓扑。</li>
<li>QD 的低值表明在两个不一致的拓扑结构之间存在一个倾向性的拓扑结构，这也可能表明在给定分支上有背景谱系分选之外的有偏（biased）生物过程的，包括混杂变量，例如基因渗入、强烈的异质性、异质碱基组成等。</li>
<li>QD 表示支持率在两种替代拓扑上的差异水平，在 [0,1] 范围内变化，值为 1 表示两棵替代拓扑树的比例没有偏斜（skew），值为0 表示采样的所有不一致树仅来自两种替代关系之一。</li>
</ul>
<ol start="3">
<li>Quartet Informativeness (QI) score - 四重奏信息分数</li>
</ol>
<ul>
<li>在给定最佳和次佳的差异阈值的基础上，最佳似然四重树的似然值超过了次优似然值的四重树。这种情况下，QI分数量化了给定分支的复制比例。</li>
<li>该分数表明，当分子数据在拓扑上有效地模棱两可时（即，当三个可能的四重拓扑中的两个或所有三个具有几乎无法区分的似然分数时），重复不被视为一致或不一致。</li>
<li>QI在 [0,1] 范围内变化，表示超过阈值的采样四重奏的比例。</li>
<li>QI 值为 1 表示所有四重奏都提供信息，而值为 0 表示所有四重奏都不确定（即，对于给定分支没有重要信息）。</li>
<li>QI 代表了分支的信息量，与 QC 和 QD 结合使用，以区分具有低信息的分支与具有冲突信息（即高度不一致）的分支。</li>
</ul>
<ol start="4">
<li>Quartet Fidelity (QF) score - 四重奏保真度分数</li>
</ol>
<ul>
<li>对于每个末端分类单元，计算 QF 分数以报告总复制的比例（跨所有分支），包括导致一致四重奏拓扑的给定分类单元。</li>
<li>因此，QF 的使用与“rogue taxon”测试的方法相似。</li>
<li>然而，一个重要的区别是使用分类群完整的引导复制来计算这些分数而不是重新采样的子树，因此在系统发育分析中会遇到与引导得分本身相同的问题（即，当所有引导时，RogueNaRok 算法不会报告rogue分类分数为 100）。</li>
<li>对于给定的分类单元，QF 分数在 [0,1] 范围，作为涉及与焦点树分支一致的分类单元的四重拓扑的比例。</li>
<li>因此，QF 值为 1 表示当一个给定的分类单元在四重奏中采样时，总是在所有内部分支中产生一致的拓扑结构。</li>
<li>QF 值接近 0 表明涉及该分类单元的拓扑结构大多不一致，也可能表明序列质量或比对性（identity）较差，或者表明存在使系统无序的特定的谱系，或者分类单元在给定树中明显错位。</li>
<li>请注意，QF 与 QC、QD 和 QI 的具体不同之处在于它是跨内部分支评估的<strong>特定分类单元</strong>的评估，而不是内部分支的评估。</li>
</ul>
<h2 id="1-2-程序"><a href="#1-2-程序" class="headerlink" title="1.2. 程序"></a>1.2. 程序</h2><p>主要包含以下几个脚本：</p>
<ol>
<li>pysrc&#x2F;quartet_sampling.py：主程序，用于实现Quartet Sampling（QS）方法。</li>
<li>pysrc&#x2F;merge_output.py：合并quartet_sampling.py程序的输出文件RESULT.node.scores.csv，当使用同一拓扑树运行多次时，用这个脚本合并多次运行的结果到一套结果。</li>
<li>pysrc&#x2F;query_tree.py：树查询脚本，从运行后注释好的大型树中找到特定节点。</li>
<li>pysrc&#x2F;utils&#x2F;calc_qstats.py：用于对quartet_sampling.py程序的输出文件RESULT.node.scores.csv进行基础统计。</li>
<li>pysrc&#x2F;utils&#x2F;fasta2phy.py：用于把fasta格式序列转换成relaxed phylip格式。</li>
</ol>
<h2 id="1-3-安装"><a href="#1-3-安装" class="headerlink" title="1.3. 安装"></a>1.3. 安装</h2><p>无需安装，在已安装python3和RAxML的基础上，脚本可直接运行。</p>
<h2 id="1-4-quartet-sampling-py程序"><a href="#1-4-quartet-sampling-py程序" class="headerlink" title="1.4. quartet_sampling.py程序"></a>1.4. quartet_sampling.py程序</h2><p>quartet_sampling.py脚本用于进行Quartet Sampling（QS）计算。</p>
<h3 id="1-4-1-输入"><a href="#1-4-1-输入" class="headerlink" title="1.4.1. 输入"></a>1.4.1. 输入</h3><p>拓扑树和比对序列中的样品名称必须一致和对应。可以有多余的序列（拓扑树上没有的），程序会忽略；但不能有拓扑树上出现但缺失序列的情况。</p>
<ol>
<li>拓扑树(sample.tre)</li>
</ol>
<ul>
<li>newick格式</li>
<li>不需要枝长数据，如果有会被忽略</li>
<li>建议去除方括号和方括号内的支持率</li>
</ul>
<ol start="2">
<li>比对好的序列(sample_aligned.phy)</li>
</ol>
<ul>
<li>relaxed phylip格式</li>
<li>DNA核酸序列或者氨基酸序列，如果是氨基酸序列在参数中加上<code>--amino-acid</code></li>
<li><code>utils/fasta2phy.py</code>脚本可以把fasta格式转为relaxed phylip格式</li>
</ul>
<ol start="3">
<li>partition分区文件【可选】</li>
</ol>
<ul>
<li>是可选的输入文件</li>
<li>RAxML格式</li>
<li>用作串联比对序列的分区，或者用作单基因树的基因分区。</li>
<li>如果序列稀疏到某些分区包含空序列，建议用<code>--ignore-error</code>参数忽略空分区造成的RAxML错误。</li>
</ul>
<h3 id="1-4-2-运行"><a href="#1-4-2-运行" class="headerlink" title="1.4.2. 运行"></a>1.4.2. 运行</h3><ol>
<li>运行命令</li>
</ol>
<ul>
<li><code>python3 quartet_sampling.py --tree sample.tre --align sample_aligned.phy --reps 1000 --threads 4 --lnlike 2  --verbout</code></li>
</ul>
<ol start="2">
<li>参数</li>
</ol>
<ul>
<li>–tree：必需，指定拓扑树</li>
<li>–align：必需，指定aligned序列</li>
<li>–reps：必需，每个枝计算的重复次数，默认100，推荐1000</li>
<li>–threads：必需，每个枝的重复的平行运算的线程，默认1</li>
<li>–lnlike：log-likelihood阈值，默认2。用来指定最好似然树超过第二好似然树的最小差异（对每个枝来说）。推荐指定，如果不指定，则调用简单模式，用RAxML从比对序列推断树，不评估似然值，所有枝上的QI分数为0。</li>
<li>–data-type：指定数据类型，默认nuc，可选amino，cat</li>
<li>–engine：指定推断树和评估树模型似然值的软件，默认raxml-ng，可选raxml，paup，iqtree</li>
<li>–partitions：指定分区文件（RAxML格式）。</li>
<li>–genetrees：指定分区文件，用分区文件划分比对好的序列成分离的基因树区域。</li>
<li>–ignore-errors：忽略RAxML和PAUP运行错误。</li>
<li>–clade：执行CSV taxon list指定的特定枝的分析。</li>
<li>–calc-qdstats：实验性参数，为QD树频率做卡方检验。只有脚本可用的时候才能用。</li>
<li>–result-prefix：指定结果文件前缀</li>
<li>–verbose：指定后提供更详尽的输出，生成RESULT.verbose文件。</li>
<li>–verbout：指定后提供每个topology和QC的频率的输出，生成RESULT.verbout文件。</li>
<li>–min-overlap 20000：在四分体中所有类群被采样需要的最少位点数，默认不设置，推荐20000。</li>
</ul>
<ol start="3">
<li>速度</li>
</ol>
<ul>
<li>速度很快，6Mb多的snp序列数据40分钟跑完。</li>
</ul>
<h3 id="1-4-3-结果文件"><a href="#1-4-3-结果文件" class="headerlink" title="1.4.3. 结果文件"></a>1.4.3. 结果文件</h3><ol>
<li>RESULT.node.scores.csv</li>
</ol>
<ul>
<li>csv格式文件，包含以下信息：</li>
<li>node_label</li>
</ul>
<ol start="2">
<li>RESULT.node.counts.csv</li>
</ol>
<ul>
<li>tsv格式文件，包含以下信息：</li>
</ul>
<ol start="3">
<li>RESULT.labeled.tre</li>
</ol>
<ul>
<li>一棵newick树，每个中间枝都含有QS##标识符</li>
</ul>
<ol start="4">
<li>RESULT.labeled.tre.freq&#x2F;qc&#x2F;qd&#x2F;qi</li>
</ol>
<ul>
<li>一棵newick树，每个中间枝都含有一致性重复频率(frequency of concordant replicates)&#x2F;QC&#x2F;QD&#x2F;QI分数标识符</li>
</ul>
<ol start="5">
<li>RESULT.labeled.tre.figtree</li>
</ol>
<ul>
<li>FigTree格式的树，包含所有QS分数和中间枝的QC&#x2F;QD&#x2F;QI分数。</li>
</ul>
<ol start="6">
<li>RESULT.run.stats</li>
</ol>
<ul>
<li>记录了nonoverlapping_count</li>
</ul>
<ol start="7">
<li>RESULT.verbout</li>
</ol>
<ul>
<li>csv格式文件，每个topology和QC的频率，标题行是topo1,topo2,topo3,topou,qc,qd,qi。</li>
</ul>
<h2 id="1-5-calc-qstats-py程序"><a href="#1-5-calc-qstats-py程序" class="headerlink" title="1.5. calc_qstats.py程序"></a>1.5. calc_qstats.py程序</h2><ol>
<li>运行</li>
</ol>
<ul>
<li><code>/path/to/pysrc/utils/calc_qstats.py --data RESULT.node.scores.csv</code></li>
</ul>
<ol start="2">
<li>输出</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data read</span><br><span class="line">29 26</span><br><span class="line">QC</span><br><span class="line">Mean (IQR)</span><br><span class="line">0.54 (0.31,0.94)</span><br><span class="line">QD</span><br><span class="line">Mean (IQR)</span><br><span class="line">0.13 (0.0,0.14)</span><br><span class="line">QI</span><br><span class="line">Mean (IQR)</span><br><span class="line">1.0 (1.0,1.0)</span><br><span class="line">QF</span><br><span class="line">Mean (IQR)</span><br><span class="line">0.8 (0.78,0.84)</span><br></pre></td></tr></table></figure>

<h1 id="2-可视化脚本QS-visualization"><a href="#2-可视化脚本QS-visualization" class="headerlink" title="2. 可视化脚本QS_visualization"></a>2. 可视化脚本QS_visualization</h1><p>Quartet Sampling开发者推荐了一个可视化脚本<a href="https://github.com/ShuiyinLIU/QS_visualization%EF%BC%8C%E7%9B%B4%E6%8E%A5%E5%9C%A8quartet_sampling.py%E7%94%9F%E6%88%90%E7%9A%84%E7%BB%93%E6%9E%9C%E7%9B%AE%E5%BD%95%E4%B8%8B%E8%BF%90%E8%A1%8CR%E8%84%9A%E6%9C%ACplot_QC_ggtree.R%E5%8D%B3%E5%8F%AF%E5%BE%97%E5%88%B0%E7%94%A8%E4%BA%8E%E5%87%BA%E7%89%88%E7%9A%84%E7%BB%93%E6%9E%9C%E3%80%82">https://github.com/ShuiyinLIU/QS_visualization，直接在quartet_sampling.py生成的结果目录下运行R脚本plot_QC_ggtree.R即可得到用于出版的结果。</a></p>
<p>这个脚本调用ggtree和ggplot2来画图，可以根据需要自行修改参数画图。</p>
<ol>
<li>运行plot_QC_ggtree.R</li>
</ol>
<ul>
<li>在Linux环境中运行<code>Rscript plot_QC_ggtree.R</code></li>
<li>在Windows的Rstudio中运行<code>source(&quot;plot_QC_ggtree.R&quot;)</code></li>
</ul>
<ol start="2">
<li>结果文件</li>
</ol>
<ul>
<li>00.treeQC_rect_circ.pdf：可视化结果，一共三页，三张图。</li>
<li>tree_qc&#x2F;qd&#x2F;qi.tre：把quartet_sampling.py生成的RESULT.labeled.tre.qc&#x2F;qd&#x2F;qi结果改格式生成的newick树文件，QC&#x2F;QD&#x2F;QI值作为节点标签。</li>
</ul>
<p>00.treeQC_rect_circ.pdf示例文件：<a href="https://github.com/ShuiyinLIU/QS_visualization/blob/f2a08588d2f5cd40ce952ef4cad2f7f55144e28f/00.treeQC_rect_circ.pdf">https://github.com/ShuiyinLIU/QS_visualization/blob/f2a08588d2f5cd40ce952ef4cad2f7f55144e28f/00.treeQC_rect_circ.pdf</a></p>
<ol start="3">
<li>plot_QC_ggtree.R脚本</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">list.files<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">library<span class="punctuation">(</span>ggtree<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>treeio<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ape<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">qc <span class="operator">&lt;-</span> read.tree<span class="punctuation">(</span><span class="string">&quot;RESULT.labeled.tre.qc&quot;</span><span class="punctuation">)</span></span><br><span class="line">qd <span class="operator">&lt;-</span> read.tree<span class="punctuation">(</span><span class="string">&quot;RESULT.labeled.tre.qd&quot;</span><span class="punctuation">)</span></span><br><span class="line">qi <span class="operator">&lt;-</span> read.tree<span class="punctuation">(</span><span class="string">&quot;RESULT.labeled.tre.qi&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># process node labels of above three labeled trees</span></span><br><span class="line"><span class="comment"># qc tree</span></span><br><span class="line">tree <span class="operator">&lt;-</span> qc</span><br><span class="line">tree<span class="operator">$</span>node.label <span class="operator">&lt;-</span> gsub<span class="punctuation">(</span><span class="string">&quot;qc=&quot;</span><span class="punctuation">,</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span>tree<span class="operator">$</span>node.label<span class="punctuation">)</span></span><br><span class="line">View<span class="punctuation">(</span>tree<span class="operator">$</span>node.label<span class="punctuation">)</span></span><br><span class="line">write.tree<span class="punctuation">(</span>tree<span class="punctuation">,</span><span class="string">&quot;tree_qc.tre&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># qd tree</span></span><br><span class="line">tree <span class="operator">&lt;-</span> qd</span><br><span class="line">tree<span class="operator">$</span>node.label <span class="operator">&lt;-</span> gsub<span class="punctuation">(</span><span class="string">&quot;qd=&quot;</span><span class="punctuation">,</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span>tree<span class="operator">$</span>node.label<span class="punctuation">)</span></span><br><span class="line">View<span class="punctuation">(</span>tree<span class="operator">$</span>node.label<span class="punctuation">)</span></span><br><span class="line">write.tree<span class="punctuation">(</span>tree<span class="punctuation">,</span><span class="string">&quot;tree_qd.tre&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># qi tree</span></span><br><span class="line">tree <span class="operator">&lt;-</span> qi</span><br><span class="line">tree<span class="operator">$</span>node.label <span class="operator">&lt;-</span> gsub<span class="punctuation">(</span><span class="string">&quot;qi=&quot;</span><span class="punctuation">,</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span>tree<span class="operator">$</span>node.label<span class="punctuation">)</span></span><br><span class="line">View<span class="punctuation">(</span>tree<span class="operator">$</span>node.label<span class="punctuation">)</span></span><br><span class="line">write.tree<span class="punctuation">(</span>tree<span class="punctuation">,</span><span class="string">&quot;tree_qi.tre&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># read 3 modified tree files for QC/QD/QI</span></span><br><span class="line">tree_qc <span class="operator">&lt;-</span> read.newick<span class="punctuation">(</span><span class="string">&quot;tree_qc.tre&quot;</span><span class="punctuation">,</span> node.label<span class="operator">=</span><span class="string">&#x27;support&#x27;</span><span class="punctuation">)</span></span><br><span class="line">tree_qd <span class="operator">&lt;-</span> read.newick<span class="punctuation">(</span><span class="string">&quot;tree_qd.tre&quot;</span><span class="punctuation">,</span> node.label<span class="operator">=</span><span class="string">&#x27;support&#x27;</span><span class="punctuation">)</span></span><br><span class="line">tree_qi <span class="operator">&lt;-</span> read.newick<span class="punctuation">(</span><span class="string">&quot;tree_qi.tre&quot;</span><span class="punctuation">,</span> node.label<span class="operator">=</span><span class="string">&#x27;support&#x27;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># add a customized label for internode or inter-branch, i.e., qc/qd/qI</span></span><br><span class="line">score_raw <span class="operator">=</span> paste<span class="punctuation">(</span>tree_qc<span class="operator">@</span>data<span class="operator">$</span>support<span class="punctuation">,</span><span class="string">&quot;/&quot;</span><span class="punctuation">,</span>tree_qd<span class="operator">@</span>data<span class="operator">$</span>support<span class="punctuation">,</span><span class="string">&quot;/&quot;</span><span class="punctuation">,</span>tree_qi<span class="operator">@</span>data<span class="operator">$</span>support<span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">score <span class="operator">=</span> gsub<span class="punctuation">(</span><span class="string">&quot;NA/NA/NA&quot;</span><span class="punctuation">,</span><span class="string">&quot;&quot;</span><span class="punctuation">,</span>score_raw<span class="punctuation">)</span></span><br><span class="line">score <span class="operator">=</span> gsub<span class="punctuation">(</span><span class="string">&quot;NA&quot;</span><span class="punctuation">,</span><span class="string">&quot;-&quot;</span><span class="punctuation">,</span>score<span class="punctuation">)</span></span><br><span class="line">View<span class="punctuation">(</span>score<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set labeled QC tree as the main plot tree</span></span><br><span class="line">tree <span class="operator">&lt;-</span> tree_qc</span><br><span class="line">tree<span class="operator">@</span>data<span class="operator">$</span>score <span class="operator">&lt;-</span> score</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"><span class="comment"># Partitioning quartet concordance. QC values were divided into four categories and this</span></span><br><span class="line"><span class="comment"># information was used to color circle points. </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># drop the internodes without QC vaule</span></span><br><span class="line">root <span class="operator">&lt;-</span> tree<span class="operator">@</span>data<span class="operator">$</span>node<span class="punctuation">[</span><span class="built_in">is.na</span><span class="punctuation">(</span>tree<span class="operator">@</span>data<span class="operator">$</span>support<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">pdf<span class="punctuation">(</span>file<span class="operator">=</span><span class="string">&quot;00.treeQC_rect_circ.pdf&quot;</span><span class="punctuation">,</span> width <span class="operator">=</span> <span class="number">16</span><span class="punctuation">,</span> height <span class="operator">=</span> <span class="number">18</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (1)color circle points</span></span><br><span class="line">ggtree<span class="punctuation">(</span>tree<span class="punctuation">,</span> size<span class="operator">=</span><span class="number">0.5</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_tiplab<span class="punctuation">(</span>size<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span> <span class="operator">+</span> xlim<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0.12</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_nodepoint<span class="punctuation">(</span>aes<span class="punctuation">(</span>subset<span class="operator">=</span><span class="operator">!</span>isTip <span class="operator">&amp;</span> node <span class="operator">!=</span> root<span class="punctuation">,</span> fill<span class="operator">=</span>cut<span class="punctuation">(</span>support<span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">0.05</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                 shape<span class="operator">=</span><span class="number">21</span><span class="punctuation">,</span> size<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme_tree<span class="punctuation">(</span>legend.position<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.9</span><span class="punctuation">,</span> <span class="number">0.18</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_fill_manual<span class="punctuation">(</span>values<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;#2F4F4F&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#98F898&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#FFCC99&quot;</span><span class="punctuation">,</span><span class="string">&quot;#FF6600&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                    guide<span class="operator">=</span><span class="string">&quot;legend&quot;</span><span class="punctuation">,</span> name<span class="operator">=</span><span class="string">&quot;Quartet Concordance(QC)&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    breaks<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;(0.2,1]&quot;</span><span class="punctuation">,</span><span class="string">&quot;(0,0.2]&quot;</span><span class="punctuation">,</span><span class="string">&quot;(-0.05,0]&quot;</span><span class="punctuation">,</span><span class="string">&quot;(-1,-0.05]&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                    labels<span class="operator">=</span><span class="built_in">expression</span><span class="punctuation">(</span>QC<span class="operator">&gt;</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0</span> <span class="operator">&lt;</span> QC <span class="operator">*</span> <span class="string">&quot; &lt;= 0.2&quot;</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">0.05</span> <span class="operator">&lt;</span> QC <span class="operator">*</span> <span class="string">&quot; &lt;= 0&quot;</span><span class="punctuation">,</span> QC <span class="operator">&lt;=</span> <span class="operator">-</span><span class="number">0.05</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (2)color branch</span></span><br><span class="line">ggtree<span class="punctuation">(</span>tree<span class="punctuation">,</span> aes<span class="punctuation">(</span>color<span class="operator">=</span>cut<span class="punctuation">(</span>support<span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">0.05</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> layout<span class="operator">=</span><span class="string">&quot;circular&quot;</span><span class="punctuation">,</span> size<span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme_tree<span class="punctuation">(</span>legend.position<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.85</span><span class="punctuation">,</span> <span class="number">0.24</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_colour_manual<span class="punctuation">(</span>values<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;#2F4F4F&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#98F898&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#FFCC99&quot;</span><span class="punctuation">,</span><span class="string">&quot;#FF6600&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                      breaks<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;(0.2,1]&quot;</span><span class="punctuation">,</span><span class="string">&quot;(0,0.2]&quot;</span><span class="punctuation">,</span><span class="string">&quot;(-0.05,0]&quot;</span><span class="punctuation">,</span><span class="string">&quot;(-1,-0.05]&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                      na.translate<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">,</span> na.value<span class="operator">=</span><span class="string">&quot;gray&quot;</span><span class="punctuation">,</span></span><br><span class="line">                      guide<span class="operator">=</span><span class="string">&quot;legend&quot;</span><span class="punctuation">,</span> name<span class="operator">=</span><span class="string">&quot;Quartet Concordance(QC)&quot;</span><span class="punctuation">,</span></span><br><span class="line">                      labels<span class="operator">=</span><span class="built_in">expression</span><span class="punctuation">(</span>QC<span class="operator">&gt;</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0</span> <span class="operator">&lt;</span> QC <span class="operator">*</span> <span class="string">&quot; &lt;= 0.2&quot;</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">0.05</span> <span class="operator">&lt;</span> QC <span class="operator">*</span> <span class="string">&quot; &lt;= 0&quot;</span><span class="punctuation">,</span> QC <span class="operator">&lt;=</span> <span class="operator">-</span><span class="number">0.05</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (3)color circle points and label each internode with QC/QD/QI</span></span><br><span class="line">ggtree<span class="punctuation">(</span>tree<span class="punctuation">,</span> size<span class="operator">=</span><span class="number">0.5</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_tiplab<span class="punctuation">(</span>size<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span> <span class="operator">+</span> xlim<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">0.12</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_nodepoint<span class="punctuation">(</span>aes<span class="punctuation">(</span>subset<span class="operator">=</span><span class="operator">!</span>isTip <span class="operator">&amp;</span> node <span class="operator">!=</span> root<span class="punctuation">,</span> fill<span class="operator">=</span>cut<span class="punctuation">(</span>support<span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">0.05</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                 shape<span class="operator">=</span><span class="number">21</span><span class="punctuation">,</span> size<span class="operator">=</span><span class="number">4</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  theme_tree<span class="punctuation">(</span>legend.position<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.9</span><span class="punctuation">,</span> <span class="number">0.18</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  scale_fill_manual<span class="punctuation">(</span>values<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;#2F4F4F&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#98F898&quot;</span><span class="punctuation">,</span> <span class="string">&quot;#FFCC99&quot;</span><span class="punctuation">,</span><span class="string">&quot;#FF6600&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                    guide<span class="operator">=</span><span class="string">&quot;legend&quot;</span><span class="punctuation">,</span> name<span class="operator">=</span><span class="string">&quot;Quartet Concordance(QC)&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    breaks<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;(0.2,1]&quot;</span><span class="punctuation">,</span><span class="string">&quot;(0,0.2]&quot;</span><span class="punctuation">,</span><span class="string">&quot;(-0.05,0]&quot;</span><span class="punctuation">,</span><span class="string">&quot;(-1,-0.05]&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                    labels<span class="operator">=</span><span class="built_in">expression</span><span class="punctuation">(</span>QC<span class="operator">&gt;</span><span class="number">0.2</span><span class="punctuation">,</span> <span class="number">0</span> <span class="operator">&lt;</span> QC <span class="operator">*</span> <span class="string">&quot; &lt;= 0.2&quot;</span><span class="punctuation">,</span> <span class="operator">-</span><span class="number">0.05</span> <span class="operator">&lt;</span> QC <span class="operator">*</span> <span class="string">&quot; &lt;= 0&quot;</span><span class="punctuation">,</span> QC <span class="operator">&lt;=</span> <span class="operator">-</span><span class="number">0.05</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  geom_text<span class="punctuation">(</span>aes<span class="punctuation">(</span>label<span class="operator">=</span>score<span class="punctuation">,</span> x<span class="operator">=</span>branch<span class="punctuation">)</span><span class="punctuation">,</span> size<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span> vjust<span class="operator">=</span><span class="operator">-</span><span class="number">.5</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h1 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h1><ul>
<li>蜂斗草族的系统文章用到这个方法评估系统发育树的不一致：Out of chaos: Phylogenomics of Asian Sonerileae：<a href="https://www.sciencedirect.com/science/article/pii/S1055790322001944#b0290">https://www.sciencedirect.com/science/article/pii/S1055790322001944#b0290</a></li>
</ul>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li>Quartet Sampling软件github：<a href="https://github.com/fephyfofum/quartetsampling">https://github.com/fephyfofum/quartetsampling</a></li>
<li>paper：<a href="https://bsapubs.onlinelibrary.wiley.com/doi/full/10.1002/ajb2.1016">https://bsapubs.onlinelibrary.wiley.com/doi/full/10.1002/ajb2.1016</a></li>
<li><a href="https://github.com/ShuiyinLIU/QS_visualization">https://github.com/ShuiyinLIU/QS_visualization</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>phylogeny</category>
      </categories>
      <tags>
        <tag>phylogeny</tag>
        <tag>phylogenomics</tag>
        <tag>phylogenetic discordance</tag>
        <tag>Quartet Sampling</tag>
      </tags>
  </entry>
  <entry>
    <title>用R包MSCquartets评估不完全谱系分选的程度</title>
    <url>/2023/03/13/bioinfo_phylogeny_MSCquartets/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=105203&auto=1&height=32"></iframe></div>

<h1 id="1-R包MSCquartets"><a href="#1-R包MSCquartets" class="headerlink" title="1. R包MSCquartets"></a>1. R包MSCquartets</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1. 简介"></a>1.1. 简介</h2><p>MSCquartets(Rhodes, et al. 2020)被用来进行基于枝长的假设检验，评估在不完全谱系分选（Incomplete lineage sorting, ILS）下的多物种溯祖（multispecies coalescent, MSC）模型的物种树或物种网。它首先确定所有基因树中每组四分类群的三个可能拓扑结构的数量，这些被称为四分体计数一致性系数（quartet count concordance factor, qcCF），可以通过比较生成P值来判断基因树与物种树的拟合度。所有四分类群的四分体一致性系数可以用simplex图来表示，以全面了解整个基因树数据集的不协调情况。</p>
<h2 id="1-2-分析步骤"><a href="#1-2-分析步骤" class="headerlink" title="1.2. 分析步骤"></a>1.2. 分析步骤</h2><ol>
<li>用MSCquartets(Rhodes, et al. 2020)的quartetTable函数计算基因树的所有四分体的计数一致性系数（qcCFs），并生成四分体计数表。</li>
<li>用MSCquartets的quartetTableResolved函数生成只保留解决四分体的计数表。</li>
<li>用MSCquartets的quartetTreeTestInd函数，ASTRAL构建的物种树作为指定物种树，在”T1 model”模型下进行MSC下的树型拟合假设检验。</li>
<li>用MSCquartets的quartetTestPlot函数为每个拒绝水平的所有的四分类群子集生成一个simplex图(Allman, et al. 2021)。不同的拒绝水平包括α&#x3D; 0.01、0.001、1e-04和1e-06。</li>
</ol>
<h2 id="1-3-结果解释"><a href="#1-3-结果解释" class="headerlink" title="1.3. 结果解释"></a>1.3. 结果解释</h2><p>要么qcCFs与MSC下的ILS在指定的统计学意义水平上是一致的，要么ILS以外的一些机制（例如：杂交，或基因复制和丢失，以及大量的基因树推断错误等）更可能解释基因树的不一致。</p>
<p>在simplex图中，带颜色的符号用来显示假设检验结果。当带颜色的符号处在接近图形中心点的位置，表明有大量的ILS主导；当符号更接近顶点，表明ILS的作用很小；那些被拒绝的符号应该由ILS以外的其他过程来解释。</p>
<h1 id="2-用MSCquartets检验ILS"><a href="#2-用MSCquartets检验ILS" class="headerlink" title="2. 用MSCquartets检验ILS"></a>2. 用MSCquartets检验ILS</h1><ol>
<li>输入文件</li>
</ol>
<ul>
<li>genes.tre：基因树文件，保存多棵基因树</li>
<li>物种树：可以用文本输入R<code>stree=&quot;(((t5,t6),t4),((t1,t2),t3));&quot;</code></li>
</ul>
<ol start="2">
<li>运行</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;MSCquartets&quot;</span><span class="punctuation">)</span> <span class="comment"># 安装R包MSCquartets</span></span><br><span class="line">library<span class="punctuation">(</span><span class="string">&quot;MSCquartets&quot;</span><span class="punctuation">)</span> <span class="comment"># 载入R包MSCquartets</span></span><br><span class="line"></span><br><span class="line">gtrees<span class="operator">=</span>read.tree<span class="punctuation">(</span>file<span class="operator">=</span><span class="string">&quot;genes.tre&quot;</span><span class="punctuation">)</span> <span class="comment"># 读取树文件</span></span><br><span class="line">tnames<span class="operator">=</span>taxonNames<span class="punctuation">(</span>gtrees<span class="punctuation">)</span> <span class="comment"># 从gtrees中获取所有类群的名称</span></span><br><span class="line">tnames <span class="comment"># 查看tnames，看看类群名称，后面的quartetTable函数通过tnames选择部分感兴趣的类群进行分析。</span></span><br><span class="line">QT<span class="operator">=</span>quartetTable<span class="punctuation">(</span>gtrees<span class="punctuation">,</span>tnames<span class="punctuation">[</span><span class="number">6</span><span class="operator">:</span><span class="number">11</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="comment"># 这一步耗时较长。用tnames选择感兴趣的类群（这里选的第6到第11个共6个类群），也可以不设置，默认从gtrees里选择所有类群。这里用的例子是名称为t1-t6的6个类群。</span></span><br><span class="line">RQT<span class="operator">=</span>quartetTableResolved<span class="punctuation">(</span>QT<span class="punctuation">)</span> <span class="comment"># 生成已解决的四分体计数表</span></span><br><span class="line">stree<span class="operator">=</span><span class="string">&quot;(((t5,t6),t4),((t1,t2),t3));&quot;</span> <span class="comment"># 通过文本导入物种树</span></span><br><span class="line">pTable<span class="operator">=</span>quartetTreeTestInd<span class="punctuation">(</span>RQT<span class="punctuation">,</span><span class="string">&quot;T1&quot;</span><span class="punctuation">,</span>speciestree<span class="operator">=</span>stree<span class="punctuation">)</span> <span class="comment"># 执行多个独立的假设检验，在MSC下的四分体计数拟合到物种树的检验</span></span><br><span class="line">pTable<span class="operator">=</span>quartetStarTestInd<span class="punctuation">(</span>pTable<span class="punctuation">)</span> <span class="comment"># </span></span><br><span class="line">quartetTestPlot<span class="punctuation">(</span>pTable<span class="punctuation">,</span> <span class="string">&quot;T1&quot;</span><span class="punctuation">,</span> alpha<span class="operator">=</span><span class="number">.01</span><span class="punctuation">,</span> beta<span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span> <span class="comment"># 绘制simplex图，一般在多个alpha水平下绘制，都保存。</span></span><br><span class="line">quartetTestPlot<span class="punctuation">(</span>pTable<span class="punctuation">,</span> <span class="string">&quot;T1&quot;</span><span class="punctuation">,</span> alpha<span class="operator">=</span><span class="number">.001</span><span class="punctuation">,</span> beta<span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">quartetTestPlot<span class="punctuation">(</span>pTable<span class="punctuation">,</span> <span class="string">&quot;T1&quot;</span><span class="punctuation">,</span> alpha<span class="operator">=</span><span class="number">.0001</span><span class="punctuation">,</span> beta<span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">quartetTestPlot<span class="punctuation">(</span>pTable<span class="punctuation">,</span> <span class="string">&quot;T1&quot;</span><span class="punctuation">,</span> alpha<span class="operator">=</span><span class="number">.000001</span><span class="punctuation">,</span> beta<span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>结果</li>
</ol>
<p>在simplex图中，带颜色的符号用来显示假设检验结果。当蓝色圆形符号（fail to reject tree）处在接近图形中心点的位置，表明有大量的ILS主导；当蓝色符号更接近顶点，表明ILS的作用很小。而那些代表拒绝的红色三角形符号（reject tree）应该由ILS以外的其他过程来解释。</p>
<img src="https://oup.silverchair-cdn.com/oup/backfile/Content_public/Journal/sysbio/71/3/10.1093_sysbio_syab068/1/syab068f3.jpeg?Expires=1681716268&Signature=Et1jsJ2Y~5cswNKSeKVojLZPRna5RGqVhTVmQIBpqmTasmtVY14fXqkH4vPt2QnTsxCr5jH0ifrSPx4Qw9esHFGy1qvwDuNXRP0dRuQLwJkb6G76QReJkP-AfIz8dwcLC5pjtDf4tQ-W7ufYuIzEbZkbM0SVcajZYSGde6vDA8I9knoEsGT53fzflJ~xATaVASqnj4QSkftNjGeYIMSQY~p7aYwNDcS1DMpwQbCoxMxyqXQhdqDkjtT1yLkYtro7NRi~5pqa5KwnpIqMoIuoQvc88Kc7IDhQB~wTDbHtPmV3DvfikaGRRh4nDNA6EzJ7HyQBNOcAinizJiwaJNzmDA__&Key-Pair-Id=APKAIE5G5CRDK6RD3PGA" title="simplex图" width="100%"/>

<p><strong><p align="center">图 1. simplex图示例 图源：<a href="https://doi.org/10.1093/sysbio/syab068">https://doi.org/10.1093/sysbio/syab068</a></p></strong></p>
<h1 id="3-R包MSCquartets常用函数"><a href="#3-R包MSCquartets常用函数" class="headerlink" title="3. R包MSCquartets常用函数"></a>3. R包MSCquartets常用函数</h1><h2 id="3-1-quartetTable"><a href="#3-1-quartetTable" class="headerlink" title="3.1. quartetTable"></a>3.1. quartetTable</h2><ol>
<li>quartetTable函数用来计算基因树的四分体计数一致性系数（quartet count concordance factor, qcCF），并生成四分体计数表。</li>
<li>用法：<code>quartetTable(trees, taxonnames = NULL, epsilon = 0, random = 0)</code></li>
<li>参数</li>
</ol>
<ul>
<li>trees：包含un&#x2F;rooted metric&#x2F;topological trees的multiphylo对象，把保存了所有基因树的文件读进来就可以用在这</li>
<li>taxonnames：选取trees里的部分类群进行分析，n个名字组成的向量，默认是NULL代表trees[[1]]的类群</li>
<li>epsilon：被处理成非零的最小枝长，一般默认设置成0就ok。</li>
<li>random：4 taxa的随机子集的数量。如果设置为0，用所有子集。这个参数也是一般默认设置成0就ok。</li>
<li>最终会生成n+4列的计数表（n是选中的类群数量）</li>
<li>耗时步骤，29个类群3000棵树用时1h。</li>
</ul>
<ol start="4">
<li>结果</li>
</ol>
<ul>
<li>一个(n choose 4)×(n+4)的矩阵，或者(random)×(n+4)的矩阵。编码taxonnames的四个类群子集，以及所有树的四分体种类（种类：12|34，13|24，14|23，1234）的计数。</li>
</ul>
<h2 id="3-2-quartetTableResolved"><a href="#3-2-quartetTableResolved" class="headerlink" title="3.2. quartetTableResolved"></a>3.2. quartetTableResolved</h2><ol>
<li>quartetTableResolved函数用于把四分体计数表（常由quartetTable函数生成）的未解决四分体部分转化。转化方式是要么丢弃未解决部分，要么将未解决部分均匀分配在三个已解决的计数中。</li>
<li>用法：<code>quartetTableResolved(qt,omit=FALSE)</code></li>
<li>参数</li>
</ol>
<ul>
<li>qt：quartetTable函数的从n个选中的类群中生成n+4列的计数表</li>
<li>omit：设置为TRUE代表删除未解决的四分体列；设置为FALSE代表删除未解决的四分体列的同时重新三等分这些未解决的计数分配到解决计数里。默认是FALSE。</li>
</ul>
<ol start="4">
<li>结果</li>
</ol>
<ul>
<li>与qt类似的四分体计数表，但只包含展示被解决四分体计数的列。</li>
</ul>
<h2 id="3-3-quartetTableDominant"><a href="#3-3-quartetTableDominant" class="headerlink" title="3.3. quartetTableDominant"></a>3.3. quartetTableDominant</h2><ol>
<li>quartetTableDominant函数用于将n个分类群上已解决的四分体计数表（常由quartetTableResolved函数生成）转换为只显示占支配地位的一个四分体的计数表，并附有MSC下的内部边缘权重的最大似然估计。</li>
<li>用法：<code>quartetTableDominant(rqt,bigweights=&quot;infinite&quot;)</code></li>
<li>参数</li>
</ol>
<ul>
<li>rqt：quartetTableResolved函数生成的已解决四分体的计数表。列数为(n choose 4)x(n+3)。</li>
<li>bigweights：默认为infinite，可设置成finite。表示只有一种拓扑结构的四分体的weight（internal edge length）是无限的（infinite）的值，还是有限的（finite）但很大的数值给出。如果设置成finite，，当一组4个类群的四分体计数为(m,0,0)时，那么边缘权重（edge weight）的计算方法是：主导拓扑结构的相对频率为m&#x2F;(m+1)。</li>
</ul>
<ol start="4">
<li>结果</li>
</ol>
<ul>
<li>一个(n choose 4)×(n+1)的矩阵，包含用1,1,-1,-1为类群列编码的支配地位四分体拓扑。第(n+1)列”weight”包含MSC下的四个类群的树的四分体的中心边缘长度的最大似然估计，溯祖单位。</li>
</ul>
<h2 id="3-4-quartetTreeTest"><a href="#3-4-quartetTreeTest" class="headerlink" title="3.4. quartetTreeTest"></a>3.4. quartetTreeTest</h2><ol>
<li>quartetTreeTest函数用于测试在MSC下四分体计数拟合一棵物种树的假设检验</li>
<li>用法：<code>quartetTreeTest(obs,model=&quot;T3&quot;,lambda=0,method=&quot;MLest&quot;,smallcounts=&quot;approximate&quot;,bootstraps=10^4)</code></li>
<li>参数</li>
</ol>
<ul>
<li>obs：已解决四分体频率的3个计数向量（三个数字组成的向量）</li>
<li>model：假设检验的模型，T1用于指定的一棵物种树的四分体拓扑，T3代表任何物种树四分体拓扑。</li>
<li>lambda：power-divergence统计参数，0代表似然率统计，1代表卡方检验（Chi-squared）统计</li>
<li>method：可选MLtest，conservative或者bootstrap</li>
<li>smallcounts：当有些计数很小时，获取p值的方法，可选bootstrap或者approximate</li>
<li>bootstraps：bootstrapping采样的数量</li>
</ul>
<ol start="4">
<li>其他参数细节描述：</li>
</ol>
<ul>
<li>这个函数实现了Mitchell等人（2019）给出的两个版本的测试，以及 参数boostrapping，当一些预期计数较小时，还有其他程序。当 拓扑结构和&#x2F;或内部四分体分支长度不是由无效假设指定的，这些是 比单自由度的Chi-square测试更准确，后者在理论上是不成立的。在模型的奇异点和边界附近是不合理的。</li>
<li>如果method&#x3D;”MLtest”，则使用Mitchell等人（2019）第7节中描述的该名称的测试。对于T1和T3模型来说，该测试在四元组物种内部的一个小范围内是略微反保守的。边缘的四分体物种树的小范围内，测试略显反常。虽然该检验在实践中一般表现良好，但它缺乏对 在T1或T3的全部参数空间中缺乏统一的渐进保证。</li>
<li>如果method&#x3D;”conservative”，则使用Mitchell等人（2019）所描述的保守检验。对于模型T3，它使用1个自由度的Chi-square分布（”最不利 “的方法），而对于模型T1，它使用最小调整的Bonferroni，基于n&#x3D;1e+6的模拟中预先计算的值。拒绝无效假设，但代价是第二类错误的增加。</li>
<li>如果method&#x3D;”bootstrap”，那么将根据四元组拓扑结构和内部边缘长度的参数估计进行参数化引导。引导样本的大小是由 bootstrap参数。</li>
<li>当一些预期的拓扑结构计数较小时，”MLest “和 “conservative”方法并不合适。参数smallcounts决定了是使用bootstrapping还是更快的其他近似方法。这两种方法都涉及对四元组拓扑结构和内部边缘长度的估计。近似法返回一个预先计算好的p值，通过用1e+6替换最大的观察计数，并进行1e+8的计算，找到了p值。用1e+6代替最大的观察数，并对模型T3进行1e+8的引导。当n足够大（至少是30），一些预期计数较小，四叉树的错误概率较小，bootstrap p值大约与T3或T1的选择以及最大的观察计数无关。</li>
<li>对于T1模型，obs的第一个条目被视为与物种树一致的基因四分体的计数。种树一致的基因四分体。</li>
<li>当样本量较小时，如少于30个基因树，应谨慎对待返回的p值。返回的bl值是一个一致的估计值，但不是凝聚单位的内部边缘长度的MLE。虽然一致，但t的MLE是有偏的。我们的一致估计值仍有偏差，但比MLE的偏差小。关于在参数空间存在边界和&#x2F;或奇异性的情况下处理参数估计的偏差的更多讨论，见Mitchell等人（2019）。</li>
</ul>
<ol start="5">
<li>结果</li>
</ol>
<ul>
<li>结果是两个值：(p-value,bl)</li>
<li>p-value是假设检验结果的p值</li>
<li>bl是以溯祖为单位的内部边缘长度（internal edge length）的一致性估计，可能是Inf。</li>
</ul>
<h2 id="3-5-quartetTreeTestInd"><a href="#3-5-quartetTreeTestInd" class="headerlink" title="3.5. quartetTreeTestInd"></a>3.5. quartetTreeTestInd</h2><ol>
<li>quartetTreeTestInd函数用于执行多个独立的MSC下的四分体计数拟合到物种树的假设检验。它是quartetTreeTest函数的多线程版本，quartetTreeTest只做一个假设检验，quartetTreeTestInd则是对所有已解决的四分体都进行假设检验。</li>
<li>用法：<code>quartetTreeTestInd(rqt,model=&quot;T3&quot;,lambda=0,method=&quot;MLest&quot;,smallcounts=&quot;approximate&quot;,bootstraps=10^4,speciestree=NULL)</code></li>
<li>参数</li>
</ol>
<ul>
<li>rqt：已解决四分体频率的计数表（由quartetTableResolved函数或quartetStarTestInd函数生成）</li>
<li>model：假设检验的模型，T1用于指定的一棵物种树的四分体拓扑，T3代表任何物种树四分体拓扑。</li>
<li>lambda：power-divergence统计参数，0代表似然率统计，1代表卡方检验（Chi-squared）统计</li>
<li>method：可选MLtest，conservative或者bootstrap。与quartetTreeTest函数一致。</li>
<li>smallcounts：当有些计数很小时，获取p值的方法，可选bootstrap或者approximate</li>
<li>bootstraps：bootstrapping采样的数量</li>
<li>speciestree：物种树，Newick文本格式，用于T1 test的物种四分体。model&#x3D;”T1”的必选项，model&#x3D;”T3”则会忽略这个参数。</li>
</ul>
<ol start="4">
<li>结果</li>
</ol>
<ul>
<li>如果model&#x3D;”T3”，输出rqt相同的表，并附加一列”p_T3”。附加列代表每个四分体的p-values。</li>
<li>如果model&#x3D;”T1”，输出rqt相同的表，并附加两列”p_T1”和”qindex”。”p_T1”代表每个四分体的p-values。”qindex”代表与指定物种树一致的四分体的索引值，1代表物种树上的12|34，2代表13|24，3代表14|23。</li>
</ul>
<h2 id="3-6-quartetStarTestInd"><a href="#3-6-quartetStarTestInd" class="headerlink" title="3.6. quartetStarTestInd"></a>3.6. quartetStarTestInd</h2><ol>
<li>quartetStarTestInd函数用于多个独立的MSC下的基因四分体计数拟合一个物种四分体星形树（star tree）的假设检验。它是quartetStarTest的多线程版本。这个函数假设所有四分体都是已解决的。</li>
<li>用法：<code>quartetStarTestInd(rqt)</code></li>
<li>参数</li>
</ol>
<ul>
<li>rqt：已解决的四分体计数表（由quartetTableResolved函数或quartetTreeTestInd函数生成）</li>
</ul>
<ol start="4">
<li>结果</li>
</ol>
<ul>
<li>与输入的rqt相同的表，附加列”p_star”。附加列代表用于判断是否在一个星形树上拟合进MSC的p-values。</li>
</ul>
<h2 id="3-7-quartetTestPlot"><a href="#3-7-quartetTestPlot" class="headerlink" title="3.7. quartetTestPlot"></a>3.7. quartetTestPlot</h2><ol>
<li>quartetTestPlot函数用于用四分体假设检验的结果（常由quartetTreeTest函数生成）绘制simplex图，simplex图上的点代表所有四分体计数向量，颜色代表拒绝或失败或特定显著水平的拒绝。</li>
<li>用法：<code>quartetTestPlot(pTable,test,alpha=0.05,beta=1,cex=1)</code></li>
<li>参数</li>
</ol>
<ul>
<li>pTable：四分体和p值表（常由quartetTreeTestInd函数，quartetStarTestInd函数或NANUQ函数生成）</li>
<li>test：树的零假设使用的模型，选T1或T3</li>
<li>alpha：test给出的零假设的树测试的显著性水平</li>
<li>beta：零假设检测星形树（star tree）的显著性水平。beta&#x3D;1代表只有beta&lt;1和pTable的p_star列存在的测试结果才会绘制点。</li>
<li>cex：绘制符号尺寸的缩放比例</li>
</ul>
<ol start="4">
<li>结果</li>
</ol>
<ul>
<li>不输出值，会绘制simplex图。</li>
</ul>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li>R包MSCquartets的manual：<a href="https://cran.r-project.org/web/packages/MSCquartets/MSCquartets.pdf">https://cran.r-project.org/web/packages/MSCquartets/MSCquartets.pdf</a></li>
<li>R包MSCquartets的paper：<a href="https://doi.org/10.1093/bioinformatics/btaa868">https://doi.org/10.1093/bioinformatics/btaa868</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=30% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>phylogeny</category>
        <category>ILS</category>
      </categories>
      <tags>
        <tag>gene flow</tag>
        <tag>phylogeny</tag>
        <tag>R packages</tag>
        <tag>MSCquartets</tag>
        <tag>ILS</tag>
        <tag>MSC</tag>
        <tag>simplex</tag>
      </tags>
  </entry>
  <entry>
    <title>估算系统树分歧时间 —— paml.mcmctree,r8s</title>
    <url>/2021/03/25/bioinfo_phylogeny_caculate.divergence.time/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=27853347&auto=1&height=66"></iframe></div>

<p>估算分歧时间是在已经建好物种的系统发育树，根据系统发育树上已知类群间分化时间（一般来自化石或者其他研究的标定），或者根据权威研究中对特定类群的碱基替换速率的估计（例如蕨类4.79e-9 subst.&#x2F;syn. site&#x2F;year，水稻2.5e-8 subst.&#x2F;syn. site&#x2F;year)进行估算系统发育树上其他类群的分歧时间。</p>
<p>一般来说，我们尽量使用化石证据的时间（更可靠），可以在网站<a href="http://www.timetree.org/">timetree</a>搜索化石或者其他文章标定的类群分化时间；实在没有化石可用时，则使用碱基替换速率常数。</p>
<h1 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h1><p>尝试用数学思维讲讲估算分歧时间的原理：即路程&#x3D;速度*时间，经过多长<strong>时间</strong>（地质时间），通过多大的<strong>速度</strong>（碱基替换速率），完成从祖先物种的DNA到现在物种的DNA的变化，总体上的碱基替换积累即<strong>路程</strong>。</p>
<p>假设下面Figure 1. 系统发育树示意图(A4,(A3,(A2,A1)B)C)D;是有枝长有根树，A1-A4都是现在的物种（代表时间也已知），目的是要估算B和C节点的时间。</p>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/bioinfo_caculate.divergence.time_phylogeny.jpg?raw=true" width=100% height=80% title="phylogeny示意图(A4,(A3,(A2,A1)B)C)D" align=center/>

<p><strong><p align="center">Figure 1. 系统发育示意图</p></strong></p>
<ul>
<li>第一种情况，当已知D节点时间时，求B节点时间（C节点同理）</li>
</ul>
<p>由于A1的时间点已知（即现在），那么从D到A1的时间跨度是已知的；从D到A1的枝长是已知的，枝长代表的是这个过程的碱基替换数量，即路程；时间和路程已知，我们可以算出速度；同时，从D到B的路程也是已知的（因为枝长已知），那么在假设匀速的前提下，我们也可以算出从D到B的时间，这样即可标定B（即A1和A2分歧时间）的时间。</p>
<ul>
<li>第二种情况，当已知速度（碱基替换速率，常数）时，求B节点时间</li>
</ul>
<p>由于从B到A1的枝长是已知的，枝长代表的是这个过程的碱基替换数量，即路程；速度已知，那么我们可以算得B到A1的时间跨度，由于A1的时间即现在，时间跨度就是B节点的时间。</p>
<p>以上解释是非常简化的理解这个估算过程，实际情况复杂得多，物种不会匀速进行碱基替换，所以软件会使用算法进行精细化估算。</p>
<h1 id="2-估算分歧时间常用软件"><a href="#2-估算分歧时间常用软件" class="headerlink" title="2. 估算分歧时间常用软件"></a>2. 估算分歧时间常用软件</h1><ul>
<li>beast：Linux也调用图形界面</li>
<li>paml的mcmctree：推荐</li>
<li>r8s：非常快</li>
</ul>
<h1 id="3-paml的mcmctree估算分歧时间"><a href="#3-paml的mcmctree估算分歧时间" class="headerlink" title="3. paml的mcmctree估算分歧时间"></a>3. paml的mcmctree估算分歧时间</h1><h2 id="3-1-paml介绍"><a href="#3-1-paml介绍" class="headerlink" title="3.1. paml介绍"></a>3.1. paml介绍</h2><p>PAML (Phylogenetic Analysis by Maximum Likelihood)，是杨子恒开发的一款利用DNA或Protein数据使用最大似然法进行系统发育分析的软件。</p>
<p>注意事项：</p>
<ol>
<li>PAML要求的输入文件是多序列比对结果。PAML软件不能进行多序列比对，需要使用其他软件进行分析。</li>
<li>PAML软件进行基于密码子的分析要求输入的序列必须是去除了Introns等非编码区的DNA序列，且其长度是3的整数倍，且第一个核酸位点是密码子的第一位。PAML软件不能进行基因预测，密码子的比对结果需要自行编写程序分析得到。</li>
<li>对于较大数据（物种数&gt;&#x3D;10）量的分析，输入的树文件最好使用其他软件计算。</li>
</ol>
<h2 id="3-2-paml软件包含的程序"><a href="#3-2-paml软件包含的程序" class="headerlink" title="3.2. paml软件包含的程序"></a>3.2. paml软件包含的程序</h2><ul>
<li>baseml 用于对核酸序列进行最大似然法分析。</li>
<li>codeml 用于对密码子和蛋白序列进行最大似然法分析。该程序整合了以前的两支程- 序codonml和aaml，前者用于对密码子序列进行分析，后者对蛋白序列进行分析。在新的codeml程序的配置文件中设置seqtype&#x3D;1，表示使用codonml命令，设置- seqtype&#x3D;2，表示使用aaml命令。</li>
<li>evolver 用于模拟核酸、密码子或蛋白序列。</li>
<li>basemlg 相比于baseml，该程序应用了连续的gamma模型。当数据中的物种数多于6- 到7个时，该程序运行非常慢以至得不到结果。这时，需要使用设置离散gamma模型的- baseml命令。</li>
<li>mcmctree 该程序应用Bayesian MCMC算法计算物种分歧时间。</li>
<li>pamp  用于简约法分析。</li>
<li>yn00  用于对两条编码蛋白的DNA序列进行比较并计算dnds。</li>
<li>chi2  用于在likelihood ratio test中计算卡方临界值和p值。</li>
</ul>
<p>mcmctree通过调用baseml(核苷酸数据)、codeml（密码子或者氨基酸数据）估算模型参数，之后估算分歧时间；</p>
<p><strong>指南一和指南二只适用于核苷酸数据；氨基酸数据看指南三</strong></p>
<h2 id="3-3-指南一：paml常规方法估算分歧时间"><a href="#3-3-指南一：paml常规方法估算分歧时间" class="headerlink" title="3.3. 指南一：paml常规方法估算分歧时间"></a>3.3. 指南一：paml常规方法估算分歧时间</h2><p>paml常规方法只适用于核苷酸数据；</p>
<h3 id="3-3-1-input-files"><a href="#3-3-1-input-files" class="headerlink" title="3.3.1. input files"></a>3.3.1. input files</h3><p>准备3个输入文件</p>
<h4 id="3-3-1-1-input-tre-带有校准点的有根树文件"><a href="#3-3-1-1-input-tre-带有校准点的有根树文件" class="headerlink" title="3.3.1.1. input.tre - 带有校准点的有根树文件"></a>3.3.1.1. input.tre - 带有校准点的有根树文件</h4><p>把iqtree&#x2F;raxml-ng等建树软件中得到的树文件中的支持率和枝长信息删除，添加化石校准点时间信息（格式是时间范围’&gt;0.23&lt;0.26’或者时间点‘@0.245’)，单位时百万年前100Ma；再在首行添加两个数字（物种数量和树的数量），空格隔开，可得到input.tre文件。</p>
<figure class="highlight plaintext"><figcaption><span>#cat input.tre</span></figcaption><table><tr><td class="code"><pre><span class="line">5 1</span><br><span class="line">((((A,B),C),D)&#x27;&gt;0.23&lt;0.26&#x27;,E);</span><br></pre></td></tr></table></figure>

<ul>
<li>文件内容包含两行：第一行表述树中有n个物种，共计1个树，两个数值之间用空分割；第二行则是Newick格式树信息。</li>
<li>其中第二行包含有校准点信息。校准点信息一般指95%HPD（Highest Posterior Density）对应的置信区间；校准点单位是100MYA（软件说明文档中使用该单位，也推荐使用该单位，若使用其它单位，后续配置文件中的相关参数也需要对应修改）。</li>
<li>此外，Newick格式的树尾部一定要有分号，没有的话程序可能不能正常运行。</li>
</ul>
<h4 id="3-3-1-2-input-phy-多序列比对文件（phylip格式）"><a href="#3-3-1-2-input-phy-多序列比对文件（phylip格式）" class="headerlink" title="3.3.1.2. input.phy - 多序列比对文件（phylip格式）"></a>3.3.1.2. input.phy - 多序列比对文件（phylip格式）</h4><ul>
<li>PAML要求输入的Phylip格式，其物种名和后面的序列之间至少间隔两个空格（是为了允许物种名的属名和种名之间有一个空格）。</li>
<li>python的SeqIO的转换格式模块获得的phylip和nexus格式都不行。</li>
<li>推荐用<code>echo $(cat input.align.fa) |sed &quot;s/ &gt;/\n/g&quot; |sed &quot;s/&gt;//g&quot;|sed &quot;s/ /  /g&quot; &gt;input.phy</code>手动转化align好的fas格式文件；再在首行添加两个数值，空格隔开，物种数量和碱基数量；实现fasta2phylip。</li>
</ul>
<p>如果有<strong>多个区域的序列</strong>，比如exon和intron，LSC、SSC和IR，不同的基因，密码子的第一二三位，需要不同的模型分开估算，那可以把各自区域分别align之后制作多个phy文件，再合并到一起，用空行隔开，组成input.phy文件。（此时mcmctree.ctl的ndata值为区域的个数）。</p>
<p>写了一个脚本来制作多区域的phylip文件，其中OG.length包含两列，一列OGID，一列比对后序列长度。</p>
<figure class="highlight shell"><figcaption><span>## cat fa2phylip.sh</span></figcaption><table><tr><td class="code"><pre><span class="line">cat ./OG.length | while read line</span><br><span class="line">do</span><br><span class="line">        sample_id=$(echo $line |awk &#x27;&#123;print $1&#125;&#x27;) #获取OG.ID</span><br><span class="line">        sample_a=$(echo $line |awk &#x27;&#123;print $2&#125;&#x27;) #获取序列长度</span><br><span class="line">        sed &quot;s/_.*//g&quot; ../singlegenetree/$&#123;sample_id&#125;/$&#123;sample_id&#125;.mafft.pep|seqkit seq -w 0|sed -E &quot;:a;N;s/\n/ /g;ta&quot; |sed &quot;s/ &gt;/\n/g&quot; |sed &quot;s/&gt;//g&quot;|sed &quot;s/ /  /g&quot;|sed &quot;1i\5  $&#123;sample_a&#125;&quot; |sed &#x27;1i\ &#x27; &gt; ./phy/$&#123;sample_id&#125;.phy #把上一步获取的$&#123;sample_id&#125;.mafft.pep改为phylip格式，并在首行添加空格行（为了合并后每个OG用空行隔开）</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line">cat ./phy/*phy &gt;input.phy #合并所有phy文件为一个Ane.phy</span><br></pre></td></tr></table></figure>

<h4 id="3-3-1-3-mcmctree-ctl-mcmctree程序的配置文件"><a href="#3-3-1-3-mcmctree-ctl-mcmctree程序的配置文件" class="headerlink" title="3.3.1.3. mcmctree.ctl - mcmctree程序的配置文件"></a>3.3.1.3. mcmctree.ctl - mcmctree程序的配置文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          seed = -1 *设置随机数作为seed，-1代表使用系统当前时间作为随机数</span><br><span class="line">       seqfile = input.phy *输入多序列比对文件</span><br><span class="line">      treefile = input.tre *带校准点（化石时间）的有根树文件</span><br><span class="line">       outfile = mcmc.out *输出文件</span><br><span class="line">      mcmcfile = mcmc.txt *输出的mcmc信息文件，可用Tracer软件查看</span><br><span class="line"></span><br><span class="line">       seqtype = 0  * 设置多序列比对数据类型；0：核酸数据；1：密码子比对数据；2：氨基酸数据；</span><br><span class="line">	   usedata = 1</span><br><span class="line">     * 是否利用多序列比对数据；</span><br><span class="line">	   * 0: no data不使用，不会进行likelihood估算，会快速得到mcmc树，但分歧时间不可用; </span><br><span class="line">	   * 1:seq like，使用多序列比对数据进行likelihood估算，正常进行mcmc; usedata=1时model无法选择；</span><br><span class="line">	   * 2:normal 进行正常的approximation likelihood分析，不读取多序列比对数据，直接读取当前目录的in.BV文件，in.BV是由usedata = 3时生成的out.BV重命名得来；此外，由于程序BUG，当设置usedata = 2时，一定要在改行参数后加 *，否则程序报错 Error: file name empty..；</span><br><span class="line">	   * 3：程序利用多序列比对数据调用baseml/codeml命令对数据进行分析，生成out.BV文件。由于mcmctree调用baseml/codeml进行估算的参数设置可能不太好（特别时对蛋白序列进行估算时），推荐自己修改软件自动生成的baseml/codeml配置文件，然后再手动运行baseml/codeml命令，再整合其结果文件为out.BV文件。</span><br><span class="line"></span><br><span class="line">		 ndata = 1    * 输入的多序列比对的数据区域的数量；</span><br><span class="line">         clock = 2    * 设置分子钟算法，1: global clock，表示所有分支进化速率一致; 2: independent rates，各分支的进化速率独立且进化速率的对数log(r)符合正态分布; 3，correlated rates方法，和方法2类似，但是log(r)的方差和时间t相关。</span><br><span class="line">*       TipDate = 1 100  *当外部节点由取样时间时使用该参数进行设置，同时该参数也设置了时间单位。具体数据示例请见examples/TipData文件夹。</span><br><span class="line">        RootAge = &#x27;&lt;10&#x27;  * constraint on root age, used if no fossil for root.设置root节点的分歧时间，一般设置一个最大值。</span><br><span class="line"></span><br><span class="line">         model = 4    * models for DNA:</span><br><span class="line">                        * 0:JC69, 1:K80, 2:F81, 3:F84, 4:HKY85；*设置碱基替换模型；当设置usedata = 1时，model不能使用超过4的模型，所以usedata = 1时用model = 4；usedata不等于1时，用model = 7，即GTR模型；</span><br><span class="line">                      * models for codons:</span><br><span class="line">                        * 0:one 恒定速率模型, 1:b 中性模型, 2:2 or more dN/dS ratios for branches 选择模型。</span><br><span class="line">                      * models for AAs or codon-translated AAs:</span><br><span class="line">                        * 0:poisson, 1:proportional, 2:Empirical, 3:Empirical+F</span><br><span class="line">                        * 6:FromCodon, 7:AAClasses, 8:REVaa_0, 9:REVaa(nr=189)</span><br><span class="line">         alpha = 0.5   * alpha for gamma rates at sites；*核酸序列中不同位点，其进化速率不一致，其变异速率服从GAMMA分布。一般设置GAMMA分布的alpha值为0.5。若该参数值设置为0，则表示所有位点的进化速率一致。此外，当userdata = 2时，alpha、ncatG、alpha_gamma、kappa_gamma这4个GAMMA参数无效。因为userdata = 2时，不会利用到多序列比对的数据。</span><br><span class="line">         ncatG = 5    * No. categories in discrete gamma；设置离散型GAMMA分布的categories值。</span><br><span class="line"></span><br><span class="line">     cleandata = 0    * remove sites with ambiguity data (1:yes, 0:no)?</span><br><span class="line"></span><br><span class="line">       BDparas = 1 1 0.1   * birth, death, sampling；*设置出生率、死亡率和取样比例。若输入有根树文件中的时间单位发生改变，则需要相应修改出生率和死亡率的值。例如，时间单位由100Myr变换为1Myr，则要设置成&quot;.01 .01 0.1&quot;。</span><br><span class="line">   kappa_gamma = 6 2      * gamma prior for kappa；设置kappa（转换/颠换比率）的GAMMA分布参数。</span><br><span class="line">   alpha_gamma = 1 1      * gamma prior for alpha；设置GAMMA形状参数alpha的GAMMA分布参数。</span><br><span class="line"></span><br><span class="line">   rgene_gamma = 2 20 1   * gamma prior for rate for genes；设置序列中所所有位点平均[碱基/密码子/氨基酸]替换率的Dirichlet-GAMMA分布参数：alpha=2、beta=20、初始平均替换率为每100million年（取决于输入有根树文件中的时间单位）1个替换。若时间单位由100Myr变换为1Myr，则要设置成&quot;2 2000 1&quot;。总体上的平均进化速率为：2 / 20 = 0.1 个替换 / 每100Myr，即每个位点每年的替换数为 1e-9。</span><br><span class="line">  sigma2_gamma = 1 10 1    * gamma prior for sigma^2     (for clock=2 or 3)；设置所有位点进化速率取对数后方差（sigma的平方）的Dirichlet-GAMMA分布参数：alpha=1、beta=10、初始方差值为1。当clock参数值为1时，表示使用全局的进化速率，各分枝的进化速率没有差异，即方差为0，该参数无效；当clock参数值为2时，若修改了时间单位，该参数值不需要改变；当clock参数值为3时，若修改了时间单位，该参数值需要改变。</span><br><span class="line"></span><br><span class="line">      finetune = 1: .1 .1 .1 .1 .1 .1  * times, rates, mixing, paras, RateParas；冒号前的值设置是否自动进行finetune，一般设置成1，然程序自动进行优化分析；冒号后面设置各个参数的步进值：times, musigma2, rates, mixing, paras, FossilErr。由于有了自动设置，该参数不像以前版本那么重要了，可能以后会取消该参数。</span><br><span class="line"></span><br><span class="line">         print = 1  *设置打印mcmc的取样信息：0，不打印mcmc结果；1，打印除了分支进化速率的其它信息（各内部节点分歧时间、平均进化速率、sigma2值）；2，打印所有信息。 </span><br><span class="line">        burnin = 1000000  *将前1000000次迭代burnin后，再进行取样（即打印出该次迭代估算的结果信息，各内部节点分歧时间、平均进化速率、sigma2值和各分支进化速率等）。</span><br><span class="line">      sampfreq = 10  *每10次迭代则取样一次</span><br><span class="line">       nsample = 500000  *当取样次数达到该次数时，则取样结束，同时结束程序。</span><br><span class="line"></span><br><span class="line">*** Note: Make your window wider (100 columns) when running this program.</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-mcmctree运行"><a href="#3-3-2-mcmctree运行" class="headerlink" title="3.3.2. mcmctree运行"></a>3.3.2. mcmctree运行</h3><p>运行<code>mcmctree mcmctree.ctl</code>即可获得结果。</p>
<h2 id="3-4-指南二：用approximate-likelihood-calculation估算分歧时间【推荐】"><a href="#3-4-指南二：用approximate-likelihood-calculation估算分歧时间【推荐】" class="headerlink" title="3.4. 指南二：用approximate likelihood calculation估算分歧时间【推荐】"></a>3.4. 指南二：用approximate likelihood calculation估算分歧时间【推荐】</h2><p>approximate likelihood法比常规方法快很多，而且可以选择更复杂的GTR模型（model &#x3D; 7）；推荐使用。</p>
<h3 id="3-4-1-input-files"><a href="#3-4-1-input-files" class="headerlink" title="3.4.1. input files"></a>3.4.1. input files</h3><p>输入文件和指南一一致，只是mcmctree.ctl的usedata需要修改为，usedata &#x3D; 3【一定要改】；建议model修改为model &#x3D; 7【建议改】。</p>
<h3 id="3-4-2-运行mcmctree-mcmctree3-ctl，（mcmctree-usedata-x3D-3）"><a href="#3-4-2-运行mcmctree-mcmctree3-ctl，（mcmctree-usedata-x3D-3）" class="headerlink" title="3.4.2. 运行mcmctree mcmctree3.ctl，（mcmctree usedata &#x3D; 3）"></a>3.4.2. 运行<code>mcmctree mcmctree3.ctl</code>，（mcmctree usedata &#x3D; 3）</h3><p>运行<code>mcmctree mcmctree3.ctl</code>；用Maximum Likelihood方法估算枝长和Hessian信息；</p>
<ol>
<li>若比对数据只有一个区域，即ndata &#x3D; 1，则等待运行完成，生成out.BV；</li>
<li>若比对数据多于一个区域，即ndata &gt; 1，mcmctree会多次调用baseml依次处理每个区域，可等待运行完成，也可以做手动并行运行，以加快分析速度；</li>
<li>手动并行多个区域的操作：</li>
</ol>
<ul>
<li>mcmctree运行起来后，从第一区域开始，生成一套tmp0001文件(包括tmp0001.ctl,tmp0001.txt,tmp0001.trees），ctrl+C切断程序，会自动进入下一区域分析，生成一套tmp0002文件，继续ctrl+C切断程序，直到最后一个区域的tmp文件也生成。</li>
<li>对每个区域的tmp文件分别放置一个单独的目录，并在单独目录内运行<code>baseml tmp*.ctl</code>，从而实现多区域并行运行。</li>
<li>所有区域的baseml运行结束后，会在各自目录生成rst2文件，把所有目录的rst2文件cat合并，就是out.BV文件；</li>
<li>或者用命令<code>for i in $(ls tmp*.ctl);do baseml $&#123;i&#125; ; mv rst2 $&#123;i&#125;.rst2; done</code>调用codeml进行多次分析（每次codeml都生成rst2文件，所以每次生成后把rst2改名，否则rst2被覆盖）；然后<code>cat *rst2 &gt;out.BV</code>合并所有rst2文件到out.BV文件；</li>
</ul>
<h3 id="3-4-3-运行mcmctree-mcmctree2-ctl，（mcmctree-usedata-x3D-2）"><a href="#3-4-3-运行mcmctree-mcmctree2-ctl，（mcmctree-usedata-x3D-2）" class="headerlink" title="3.4.3. 运行mcmctree mcmctree2.ctl，（mcmctree usedata &#x3D; 2）"></a>3.4.3. 运行<code>mcmctree mcmctree2.ctl</code>，（mcmctree usedata &#x3D; 2）</h3><ul>
<li>把input.phy，input.tre，mcmctree3.ctl，out.BV四个文件复制到新建目录下，mcmctree3.ctl的usedata改为usedata &#x3D; 2并重命名为mcmctree2.ctl，out.BV重命名为in.BV；</li>
<li>运行<code>mcmctree mcmctree2.ctl</code>即可获得结果。</li>
</ul>
<h2 id="3-5-指南三：用approximate-likelihood-calculation估算氨基酸数据的分歧时间"><a href="#3-5-指南三：用approximate-likelihood-calculation估算氨基酸数据的分歧时间" class="headerlink" title="3.5. 指南三：用approximate likelihood calculation估算氨基酸数据的分歧时间"></a>3.5. 指南三：用approximate likelihood calculation估算氨基酸数据的分歧时间</h2><p>氨基酸数据不能用usedata &#x3D; 1这种模式，只能用approximate likelihood calculation估算分歧时间；方法与指南二类似。</p>
<h3 id="3-5-1-input-files"><a href="#3-5-1-input-files" class="headerlink" title="3.5.1. input files"></a>3.5.1. input files</h3><ul>
<li>输入文件和指南一一致，mcmctree.ctl的参数修改：usedata &#x3D; 3，model &#x3D; 2，seqtype &#x3D; 2；增加一行aaRatefile &#x3D; wag.dat；</li>
<li>同时把paml软件安装位置下的wag.dat复制一份到当前目录；</li>
<li>wag.dat是氨基酸替换速率的数据，与model &#x3D; 2对应，也可以选用其他的氨基酸替换率数据，就用其他的替换率文件(*.dat)；</li>
</ul>
<h3 id="3-5-2-运行mcmctree-mcmctree3-ctl，（mcmctree-usedata-x3D-3）"><a href="#3-5-2-运行mcmctree-mcmctree3-ctl，（mcmctree-usedata-x3D-3）" class="headerlink" title="3.5.2. 运行mcmctree mcmctree3.ctl，（mcmctree usedata &#x3D; 3）"></a>3.5.2. 运行<code>mcmctree mcmctree3.ctl</code>，（mcmctree usedata &#x3D; 3）</h3><p>运行<code>mcmctree mcmctree3.ctl</code>；用Maximum Likelihood方法估算枝长和Hessian信息；</p>
<ol>
<li>若比对数据只有一个区域，即ndata &#x3D; 1，则等待运行完成，生成out.BV；</li>
<li>若比对数据多于一个区域，即ndata &gt; 1，mcmctree会多次调用codeml依次处理每个区域，可等待运行完成，也可以做手动并行运行，以加快分析速度；</li>
<li>手动并行多个区域的操作：</li>
</ol>
<ul>
<li>mcmctree运行起来后，从第一区域开始，生成一套tmp0001文件(包括tmp0001.ctl,tmp0001.txt,tmp0001.trees），ctrl+C切断程序，会自动进入下一区域分析，生成一套tmp0002文件，继续ctrl+C切断程序，直到最后一个区域的tmp文件也生成。</li>
<li>对每个区域的tmp文件分别放置一个单独的目录，修改所有tmp*.ctl内的aaRatefile &#x3D; wag.dat为wag.dat的相对位置或绝对，如aaRatefile &#x3D; ..&#x2F;wag.dat，然后在每一个单独目录内运行<code>codeml tmp*.ctl</code>；</li>
<li>所有区域的codeml运行结束后，会在各自目录生成rst2文件，把所有目录的rst2文件cat合并，就是out.BV文件；</li>
<li>或者用命令<code>for i in $(ls tmp*.ctl);do codeml $&#123;i&#125; ; mv rst2 $&#123;i&#125;.rst2; done</code>调用codeml进行多次分析（每次codeml都生成rst2文件，所以每次生成后把rst2改名，否则rst2被覆盖）；然后<code>cat *rst2 &gt;out.BV</code>合并所有rst2文件到out.BV文件；</li>
</ul>
<h3 id="3-5-3-运行mcmctree-mcmctree2-ctl，（mcmctree-usedata-x3D-2）"><a href="#3-5-3-运行mcmctree-mcmctree2-ctl，（mcmctree-usedata-x3D-2）" class="headerlink" title="3.5.3. 运行mcmctree mcmctree2.ctl，（mcmctree usedata &#x3D; 2）"></a>3.5.3. 运行<code>mcmctree mcmctree2.ctl</code>，（mcmctree usedata &#x3D; 2）</h3><ul>
<li>把input.phy，input.tre，mcmctree3.ctl，out.BV四个文件复制到新建目录下，mcmctree3.ctl的usedata改为usedata &#x3D; 2并重命名为mcmctree2.ctl，out.BV重命名为in.BV；</li>
<li>运行<code>mcmctree mcmctree2.ctl</code>即可获得结果。</li>
</ul>
<h2 id="3-6-指南四：codons数据处理方式"><a href="#3-6-指南四：codons数据处理方式" class="headerlink" title="3.6. 指南四：codons数据处理方式"></a>3.6. 指南四：codons数据处理方式</h2><p>如果是密码子codons数据，实测设置文件里seqtype &#x3D; 1 会报错 “Error: dN&#x2F;dS ratios among branches not implemented for gamma.”。<br>有两个方案处理codons数据。</p>
<ol>
<li>转化codons成第一、第二、第三密码子的三组数据之后，并设置ndata&#x3D;3与seqtype &#x3D; 0结合用核苷酸模式使用codons数据。</li>
<li>把codons翻译成氨基酸数据，用氨基酸模型分析codons数据。</li>
</ol>
<h2 id="3-7-结果文件"><a href="#3-7-结果文件" class="headerlink" title="3.7. 结果文件"></a>3.7. 结果文件</h2><p>程序在运行过程中，会在屏幕生生成一些信息。比较耗时间的步骤主要在于取样的百分比进度：</p>
<ul>
<li>第一列：取样的百分比进度。</li>
<li>第2-6列：参数的接受比例。一般，其值应该在30%左右。20-40%是很好的结果，15-70%是可以接受的范围。若这些值在开始时变动较大，则表示burnin数设置太小。</li>
<li>第7-x列：各内部节点的平均分歧时间，第7列则是root节点的平均分歧时间。若有y个物种，则总共有y-1个内部节点，从第7列开始后的y-1列对应这些内部节点。</li>
<li>倒数第3-x列：r_left值。若输入3各多序列比对结果，则有3列。x列的前一列是中划线 - 。</li>
<li>倒数第1-2列：likelihood值和时间消耗。</li>
</ul>
<p>屏幕信息最后，给出各个内部节点的分歧时间(t)、平均变异速率(mu)、变异速率方差(sigma2)和r_left的Posterior信息：均值(mean)、95%双侧置信区间(95% Equal-tail CI)和95% HPD置信区间(95% HPD CI)等信息。此外，倒数第二列给出了各个内部节点的Posterior mean time信息，可以用于收敛分析。</p>
<p>在当前目录下，生成几个主要结果：</p>
<ul>
<li><p>FigTree.tre    生成含有枝长（分歧时间）的超度量树文件，分歧时间和分歧时间的95%HPD区间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#NEXUS</span><br><span class="line">BEGIN TREES;</span><br><span class="line"></span><br><span class="line">        UTREE 1 = (((B: 0.408365, (A1: 0.107333, A2: 0.107333) [&amp;95%=&#123;0.0749432, 0.126365&#125;]: 0.301032) [&amp;95%=&#123;0.285365, 0.478163&#125;]: 0.362000, C: 0.770366) [&amp;95%=&#123;0.53864, 0.90012&#125;]: 0.047786, D: 0.818151) [&amp;95%=&#123;0.572406, 0.958116&#125;];</span><br><span class="line"></span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<p>FigTree.tre文件的解释：其中A1或A2冒号:后的0.107333为A1和A2的枝长，代表A1和A2分歧时间，单位是亿年，(A1,A2)外的[&amp;95%&#x3D;{0.0749432, 0.126365}]为A1和A2分歧时间的95%置信区间；A1或A2的枝长0.107333加上(A1,A2)之后的祖先枝长0.301032之和等于B的枝长0.408363，即B与A1和A2祖先种的分歧时间为0.408363亿年，95%置信区间为[&amp;95%&#x3D;{0.285365, 0.478163}]；依此类推。</p>
</li>
<li><p>mcmc.txt       MCMC取样信息，包含各内部节点分歧时间、平均进化速率、sigma2值等信息，可以在Tracer软件中打开。通过查看各参数的ESS值，若ESS值大于200，则从一定程度上表示MCMC过程能收敛，结果可靠。</p>
</li>
<li><p>out.txt        包含由较多信息的结果文件。例如，各碱基频率、节点命名信息。</p>
</li>
</ul>
<h2 id="3-8-一些注意事项"><a href="#3-8-一些注意事项" class="headerlink" title="3.8. 一些注意事项"></a>3.8. 一些注意事项</h2><p>以下来自<a href="http://www.chenlianfu.com/?p=2974">陈连福的教程</a>。</p>
<ol>
<li>如何设置burnin、sampfreq和nsample值？</li>
</ol>
<ul>
<li>一般推荐设置nsample值不小于20k(官方示例数据中设置的值)，只有当该值较大时，求得的均值才有意义。</li>
<li>sampfreq表示取样间隔，一般设置为10，100或1000。nsample 和sampfreq 的乘积表示有效迭代的次数，这些迭代越准确，次数越大，则结果越好，越趋于收敛。当然，次数越大，越消耗时间。若数据量很小，可以考虑设置sampfreq为1000；若数据量大，每次迭代耗时多，则考虑设置sampfre为10。</li>
<li>(burnin)其结果，则设置burnin值。要设置足够大的burnin值，保证在程序运行时当迭代比例达到0% (即burnin结束) 时，其参数的接受比例值较好，在30%左右且随迭代次数增多时变动幅度不大。推荐设置burnin的迭代次数为有效次数的10~40%。PAML软件时先burnin后再记录有效迭代的参数值；其它软件如BEAST则记录所有的参数值后，最后汇总时burnin掉一定比例的数据。</li>
<li>总体上，其实就是两个参数：burnin掉的迭代次数和用于估算结果的有效迭代次数。由于需要根据有效迭代数据来进行均值估算，若记录每次迭代的参数，则生成的mcmc.txt文件行数过多，文件太大，汇总时也消耗估算。于是设置没隔一定迭代轮数取样一次，这样生成的mcmc.txt文件不会太大，对最后的均值估算影响不大。</li>
<li>个人推荐有效迭代次数 1<del>10M 次，burnin 0.2</del>4M次。按时间消耗从少到多的参数值：<br>数据简单时，进行0.5M迭代次数，burnin比例40%：{ burnin 200k; sampfreq 10; nsample 50k }<br>数据中等时，进行1M迭代次数，burnin比例40%：{ burnin 400k; sampfreq 10; nsample 100k }<br>数据复杂时，进行5M迭代次数，burnin比例20%：{ burnin 1000k; sampfreq 10; nsample 500k }<br>数据巨大时，进行10M迭代次数，burnin比例20%：{ burnin 2000k; sampfreq 100; nsample 100k }<br>使用相应参数进行分析后，若不满意其收敛程度，则选用更多迭代次数的参数。</li>
</ul>
<ol start="2">
<li>如何检测MCMC的结果是否达到收敛状态？</li>
</ol>
<p>收敛的意思，即经过很多次迭代后，得到的MCMC树的各枝长趋于一个定值，变动非常小。于是，最直接的检测方法是：分别使用不同的Seed值进行mcmctree或infinitesites进行两次或多次分析，然后比较两个结果树是否一致，实际就是比较树文件中各内部节点的Height值（分歧时间 &#x2F; Posterior time）。比较方法可以有多种: </p>
<ul>
<li>结果文件mcmc.txt中每行记录了一个取样的结果，包含各内部节点的Posterior time值，即进化树的Height值，对该mcmc.txt文件进行分析，得到每个内部节点的Posterior mean time值。然后作图 （官方说明文档第6页图示），横坐标表示第一次运行的各内部节点的分歧时间均值、纵坐标表示第二次运行的各内部节点的分歧时间均值。该散点图要表现出非常明显的对角线，才认为达到收敛。这时可以考虑估算其相关系数来判断是否符合线性。</li>
<li>我觉得第一种官方文档给的方法比较麻烦且是否符合对角线没有明确的定义，于是就直接比较两次结果树文件中的各枝长。估算各枝长总的偏差百分比，当偏差百分比低于0.1%，则认为两次结果非常吻合，差异低于0.1%，认为达到收敛。</li>
<li>此外，还可以使用Tracer分析mcmc.txt文件，检测其ESS值，一般认为该值高于200，则可能达到收敛。该方法可用于辅助检测。最后，若不收敛，则需要提高burnin、nsample值，重新运行程序。</li>
</ul>
<ol start="3">
<li>使用infinitesites输入含有枝长信息的系统进化树快速进行分歧时间估算<br>infinitesites程序进行分歧时间估算时，其假设前提为多序列比对的序列长度为无限长。相比于正常的mcmctree命令，要求额外多输入一个名为 FixedDsClock23.txt 的文件。该文件中存放了相应的带有枝长信息的系统发育树。该文件中系统发育树的拓扑结构要和input.tre一致。推荐使用baseml命令输入input.trees和多序列比对结果估算枝长。</li>
</ol>
<p>FixedDsClock23.txt 文件内容示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">((((human: 0.029043, (chimpanzee: 0.014557, bonobo: 0.010908): 0.016729): 0.015344, gorilla: 0.033888): 0.033816, (orangutan: 0.026872, sumatran: 0.022437): 0.069648): 0.073309, gibbon: 0.024637);</span><br><span class="line">((((human: 0.012463, (chimpanzee: 0.002782, bonobo: 0.003835): 0.003331): 0.004490, gorilla: 0.014278): 0.006308, (orangutan: 0.010818, sumatran: 0.008845): 0.030551): 0.004363, gibbon: 0.029246);</span><br><span class="line">((((human: 0.270862, (chimpanzee: 0.066698, bonobo: 0.056883): 0.124104): 0.139082, gorilla: 0.310797): 0.391342, (orangutan: 0.152555, sumatran: 0.114176): 0.696518): 0.017607, gibbon: 1.394718);</span><br></pre></td></tr></table></figure>
<p>运行infinitesites命令进行分歧时间估算：<code>infinitesites mcmctree.ctl</code><br>使用infinitesites进行分歧时间估算时，程序要求输入多序列比对文件。虽然程序读取了序列信息，但在估算时会忽略其序列信息。</p>
<h1 id="4-r8s估算系统分歧时间"><a href="#4-r8s估算系统分歧时间" class="headerlink" title="4. r8s估算系统分歧时间"></a>4. r8s估算系统分歧时间</h1><h2 id="4-1-r8s"><a href="#4-1-r8s" class="headerlink" title="4.1. r8s"></a>4.1. r8s</h2><p>r8s 是美国加利福尼亚大学戴维斯分校的进化生物学家 Mike Sanderson 在2003年编写的用于估算进化树分化时间的软件，在进化生物学、分子生物地理学等学科有着广泛的应用，是估算分化时间常用的软件之一。该软件中的一些方法如 NPRS 和 PL 是软件作者最先提出的，目前在同类的其他软件中还难以实现。</p>
<h2 id="4-2-r8s的安装"><a href="#4-2-r8s的安装" class="headerlink" title="4.2. r8s的安装"></a>4.2. r8s的安装</h2><p>wget <a href="http://loco.biosci.arizona.edu/r8s/r8s.dist.tgz">http://loco.biosci.arizona.edu/r8s/r8s.dist.tgz</a><br>tar zxf r8s.dist.tgz</p>
<p>或者sourceforge下载<a href="https://sourceforge.net/projects/r8s/">https://sourceforge.net/projects/r8s/</a></p>
<h2 id="4-3-r8s的输入文件"><a href="#4-3-r8s的输入文件" class="headerlink" title="4.3. r8s的输入文件"></a>4.3. r8s的输入文件</h2><h3 id="4-3-1-输入文件r8s-input"><a href="#4-3-1-输入文件r8s-input" class="headerlink" title="4.3.1. 输入文件r8s.input"></a>4.3.1. 输入文件r8s.input</h3><p>一个例子，包括两个模块，一个树模块，一个r8s参数设置模块。<br>树模块可以用raxml-ng等建树软件获得的树，包括枝长信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#nexus</span><br><span class="line">begin trees;</span><br><span class="line">tree tree_1 = (A:0.5069367934,(((((B:0.5881634293,C:0.2730677988)100:0.0325689044,D:0.2516482074)100:0.0150403964,E:0.2672133160)86:0.0239229988,((G:0.4074076834,H:0.4308871688)100:0.0260782585,I:0.2360982873)100:0.0237486276)100:0.0147845808,(J:0.5746285099,K:0.2089809581)92:0.0360035242)100:0.1832776220,L:0.2440847991);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">begin r8s;</span><br><span class="line">blformat lengths=persite nsites=300000 ulrametric=no;</span><br><span class="line">mrca pointa A B;</span><br><span class="line">mrca pointb K L;</span><br><span class="line">fixage taxon=pointa age=520;</span><br><span class="line">constrain taxon=pointb min_age=350 max_age=410;</span><br><span class="line">divtime method=PL algorithm=TN;</span><br><span class="line">set smoothing=100;</span><br><span class="line">showage;</span><br><span class="line">describe plot=chronogram;</span><br><span class="line">describe plot=chrono_description;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-r8s参数设置模块"><a href="#4-3-2-r8s参数设置模块" class="headerlink" title="4.3.2. r8s参数设置模块"></a>4.3.2. r8s参数设置模块</h3><ol>
<li>blformat命令：进化树基本信息，需要在计算divergence time&#x2F;rates analysis之前运行。</li>
</ol>
<ul>
<li>lengths选项：total|persite<br>  描述进化树长度的单位。MP简约法获得的进化树，枝长单位是碱基替换个数，lengths选项应该用total；ML极大似然法获得的进化树，枝长单位是期望的碱基替换数，lengths选项应该用persite。</li>
<li>nsites选项：number<br>  在进化分析中用到的碱基位点数量。</li>
<li>ultrametric选项：yes|no<br>  表示该进化树是否经过了校正。如果选yes，直接给出进化时间，不对内部进行任何更改。如果要校对，则应该用calibrate命令。如果不想对ultrametric的进化树的分化时间全部重新估算，应该选yes。</li>
<li>round选项：yes|no<br>  是否对枝长信息四舍五入。只针对nonultrametric树（因为ultrametric树的枝长经过四舍五入会转变成not truly ultrametric树。）。round选项将每个分枝上的替换数转换为整数。如果用户自己提供了已经校对时间的进化树，chronograms，需要设定round&#x3D;no。</li>
</ul>
<ol start="2">
<li><p>mrca命令：为节点定名。<br>mrca(most recent common ancestor)可以命名两个或多个类群的最近共同祖先。<br>例如想要给树 tree test&#x3D;(a,(b,c));中a、b的共同祖先定名为node1，可以通过命令 mrca node1 a b来实现。</p>
</li>
<li><p>fixage命令：设定节点的分化时间。<br>在mrca命令的基础上，设定已知的节点分化时间点，r8s需要至少一个内部节点进行fixage。<br>用法fixage taxon&#x3D;node1 age&#x3D;100;</p>
</li>
<li><p>constrain命令：设定节点的分化时间。<br>在mrca命令的基础上，设定已知的节点分化时间上下限。<br>用法constrain taxon&#x3D;node1 min_age&#x3D;50 max_age&#x3D;200;</p>
</li>
<li><p>divtime命令：分化时间估算<br>依据设定好的分化时间，对未知节点的分化时间进行估算。<br>用法 divtime method&#x3D;LF|NPRS|PL algorithm&#x3D;POWELL|TN|QNEWT</p>
</li>
</ol>
<ul>
<li>method选项（计算方法）：LF|NPRS|PL<br>  分化时间估算的方式。推荐PL罚分似然法：如果各枝长变化速率差异很大，则smoothing值应该取的很小；如果各枝长变化速率差异很小，则smoothing值应该取的很大。</li>
<li>algorithm选项（数学算法）：POWELL|TN|QNEWT<br>  算法，作者推荐TN算法。</li>
<li>crossv选项：基于化石的进化树校正</li>
</ul>
<p>divtime method&#x3D;PL crossv&#x3D;yes cvstart&#x3D;0 cvinc&#x3D;1 cvnum&#x3D;18;<br>上述命令，是设置 smoothing 的值从 1, 10, 100, 1000 … 1e17, 来计算，最后得到最佳的 smoothing 值。</p>
<p>若使用 fixage 对 2 个节点的分歧时间进行了固定，则可以运行命令：<br>divtime method&#x3D;PL crossv&#x3D;yes fossilfixed&#x3D;yes cvstart&#x3D;0 cvinc&#x3D;1 cvnum&#x3D;18;</p>
<p>若使用 fixage 对 1 个节点进行分歧时间固定，同时使用 constrain 对 2 个节点进行了约束，则可以运行命令：<br>divtime method&#x3D;PL crossv&#x3D;yes fossilconstrained&#x3D;yes cvstart&#x3D;0 cvinc&#x3D;1 cvnum&#x3D;18;</p>
<p>得到最优的smoothing值后，再用set设置，然后进行divtime分歧时间和替换速率的计算。</p>
<ol start="6">
<li><p>smoothing<br>divtime使用PL方法，需要设置参数smoothing的值。通过设置多个smoothing的值来进行一些计算，选择最优的值之后用set设置。</p>
</li>
<li><p>showage命令：显示分化时间和分化速率</p>
</li>
<li><p>describe命令：显示进化树及树的说明</p>
</li>
</ol>
<ul>
<li><p>cladogram<br>  得到分支树的图，图上有各个节点的编号，和showage的结果结合观察。</p>
</li>
<li><p>phylogram<br>  得到进化树的图，枝长表示替换数。</p>
</li>
<li><p>chronogram<br>  得到超度量树的图，枝长表示时间。</p>
</li>
<li><p>ratogram<br>  得到树图，枝长表示替换速率。</p>
</li>
<li><p>phylo_description<br>  得到树的ASCII文字结果，枝长表示替换数。</p>
</li>
<li><p>chrono_description<br>  得到树的ASCII文字结果，枝长表示时间。</p>
</li>
<li><p>rato_description<br>  得到树的ASCII文字结果，枝长表示替换速率。</p>
</li>
<li><p>node_info<br>  得到节点的信息表格</p>
</li>
</ul>
<p>做超度量时间树，一般选择<br>describe plot&#x3D;chronogram;<br>describe plot&#x3D;chrono_description;</p>
<h2 id="4-4-r8s运行"><a href="#4-4-r8s运行" class="headerlink" title="4.4. r8s运行"></a>4.4. r8s运行</h2><p><code>r8s -b -f r8s.in &gt; r8s.out</code></p>
<p>-b是batch process the datafile，-f用于指定输入文件</p>
<p>结果保存在r8s.out文件中</p>
<h1 id="5-references"><a href="#5-references" class="headerlink" title="5. references"></a>5. references</h1><ol>
<li>mcmctree manual：<a href="http://abacus.gene.ucl.ac.uk/software/MCMCtree.Tutorials.pdf">http://abacus.gene.ucl.ac.uk/software/MCMCtree.Tutorials.pdf</a></li>
<li>陈连福的paml mcmctree教程：<a href="http://www.chenlianfu.com/?p=2974">http://www.chenlianfu.com/?p=2974</a></li>
<li>r8s paper：<a href="https://academic.oup.com/bioinformatics/article/19/2/301/372781">https://academic.oup.com/bioinformatics/article/19/2/301/372781</a></li>
<li>r8s manual：<a href="https://naturalis.github.io/mebioda/doc/week1/w1d5/r8s1.7.manual.pdf">https://naturalis.github.io/mebioda/doc/week1/w1d5/r8s1.7.manual.pdf</a></li>
<li>r8s manual 中文：<a href="http://image.sciencenet.cn/olddata/kexue.com.cn/upload/blog/file/2010/3/201032420201531842.0.pdf">http://image.sciencenet.cn/olddata/kexue.com.cn/upload/blog/file/2010/3/201032420201531842.0.pdf</a></li>
<li>陈连福的r8s教程：<a href="http://www.chenlianfu.com/?p=2280">http://www.chenlianfu.com/?p=2280</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>phylogeny</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>phylogeny</tag>
        <tag>divergence time</tag>
        <tag>paml</tag>
        <tag>mcmctree</tag>
        <tag>r8s</tag>
      </tags>
  </entry>
  <entry>
    <title>用R包castor的get_subtree_with_tips函数提取子树</title>
    <url>/2023/03/13/bioinfo_phylogeny_castor_extract.subtrees/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=27646786&auto=1&height=32"></iframe></div>

<h1 id="1-R包castor"><a href="#1-R包castor" class="headerlink" title="1. R包castor"></a>1. R包castor</h1><p>R包castor是一个可以对包含超百万类群（tips）的系统发育树进行操作的程序，功能包括修剪、重新定根、计算最近共同祖先、计算tips与树根的距离、计算成对距离等等。</p>
<p>系统发育信号和平均性状深度（性状保守性）的计算，离散性状的祖先状态重建和隐藏性状预测，性状进化的模拟和拟合模型，拟合和模拟多样化模型，以Newick格式树的标定时间，比较树，读取和写入树。</p>
<p>安装R包castor：<code>install.packages(&quot;castor&quot;)</code></p>
<h1 id="2-R包castor的get-subtree-with-tips函数"><a href="#2-R包castor的get-subtree-with-tips函数" class="headerlink" title="2. R包castor的get_subtree_with_tips函数"></a>2. R包castor的get_subtree_with_tips函数</h1><p>R包castor的get_subtree_with_tips函数用于根据子集类群列表从一棵大树中提取子树。</p>
<h2 id="2-1-介绍get-subtree-with-tips函数"><a href="#2-1-介绍get-subtree-with-tips函数" class="headerlink" title="2.1. 介绍get_subtree_with_tips函数"></a>2.1. 介绍get_subtree_with_tips函数</h2><ol>
<li><p><code>get_subtree_with_tips(tree,only_tips=NULL,omit_tips=NULL,collapse_monofurcations = TRUE,force_keep_root = FALSE))</code></p>
</li>
<li><p>参数说明</p>
</li>
</ol>
<ul>
<li>tree : “phylo”类的有根树。假定根是唯一的节点，没有传入的边。</li>
<li>only_tips : 列出要保留的提示名称的字符向量，或列出要保留的提示索引的整数向量（介于1和Ntips之间）。也可以为空。在树中找不到的filename_edges_strength中列出的提示将被悄悄忽略。</li>
<li>omit_tips : 列出要忽略的提示名称的字符向量，或列出要忽略的提示索引的整数向量（介于1和Ntips之间）。也可以为空。在树中找不到的filename_edges_strength中列出的提示将被悄悄忽略。</li>
<li>collapse_monofurcations : 指定是否应折叠（删除）剩余单个传出边缘的节点的逻辑。此类节点的传入和传出边缘将连接到单个边缘，连接节点的父级（或更早）和子级（或更高）。在这种情况下，返回的树将具有反映连接边的边长度。</li>
<li>force_keep_root : 逻辑值，指定是否保留根，即使filename_points_covered_by_landmarks和子树的根只剩下一个子树。如果为FALSE和filename_points_covered_by_landmarks，则可以删除根，并且它的一个后代可以成为根。</li>
</ul>
<h2 id="2-2-get-subtree-with-tips函数的使用"><a href="#2-2-get-subtree-with-tips函数的使用" class="headerlink" title="2.2. get_subtree_with_tips函数的使用"></a>2.2. get_subtree_with_tips函数的使用</h2><ol>
<li>输入</li>
</ol>
<ul>
<li>species.tre：物种树</li>
<li>subtree.list：待提取的类群名称列表，每个名称一行</li>
</ul>
<ol start="2">
<li>提取子树</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>treeio<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>castor<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">tree<span class="operator">&lt;-</span>read.newick<span class="punctuation">(</span><span class="string">&quot;species.tre&quot;</span><span class="punctuation">)</span> <span class="comment"># 读取物种树</span></span><br><span class="line">sub_list<span class="operator">&lt;-</span>scan<span class="punctuation">(</span><span class="string">&quot;subtree.list&quot;</span><span class="punctuation">,</span>what<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span> <span class="comment"># 读取类群列表，保存为字符向量</span></span><br><span class="line">sub<span class="operator">&lt;-</span>get_subtree_with_tips<span class="punctuation">(</span>tree<span class="punctuation">,</span>only_tips <span class="operator">=</span> sub_list<span class="punctuation">)</span> <span class="comment"># 提取子树</span></span><br><span class="line">write.tree<span class="punctuation">(</span>sub<span class="operator">$</span>subtree<span class="punctuation">,</span>file<span class="operator">=</span><span class="string">&quot;species_subtree.tre&quot;</span><span class="punctuation">)</span> <span class="comment"># 把提取的子树写入species_subtree.tre文件，newick格式</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-批量提取子树"><a href="#2-3-批量提取子树" class="headerlink" title="2.3. 批量提取子树"></a>2.3. 批量提取子树</h2><p>由于get_subtree_with_tips函数只接受单棵树的phylo数据类群作为输入，如果需要从multiphylo的多棵树中统一提取子集则需要借助get_subtrees.R脚本。</p>
<ol>
<li>批量提取</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>treeio<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>castor<span class="punctuation">)</span></span><br><span class="line">trees<span class="operator">&lt;-</span>read.newick<span class="punctuation">(</span><span class="string">&quot;genes.trees&quot;</span><span class="punctuation">)</span> <span class="comment"># 读取多棵树的genes.trees文件，trees为multiphylo。</span></span><br><span class="line">sub_list<span class="operator">&lt;-</span>scan<span class="punctuation">(</span><span class="string">&quot;subtree.list&quot;</span><span class="punctuation">,</span>what<span class="operator">=</span><span class="string">&quot;&quot;</span><span class="punctuation">)</span> <span class="comment"># 读取类群列表，保存为字符向量</span></span><br><span class="line">source<span class="punctuation">(</span><span class="string">&quot;get_subtrees.R&quot;</span><span class="punctuation">)</span> <span class="comment"># 运行get_subtrees.R脚本，子树保存在genes_subtree.tre文件中</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>get_subtrees.R脚本，这里设定共有2700棵树</li>
</ol>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="punctuation">(</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">2700</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">   tree<span class="operator">&lt;-</span>trees<span class="punctuation">[[</span>i<span class="punctuation">]</span><span class="punctuation">]</span></span><br><span class="line">   sub<span class="operator">&lt;-</span>get_subtree_with_tips<span class="punctuation">(</span>tree<span class="punctuation">,</span>only_tips <span class="operator">=</span> sub_list<span class="punctuation">)</span></span><br><span class="line">   write.tree<span class="punctuation">(</span>sub<span class="operator">$</span>subtree<span class="punctuation">,</span>file<span class="operator">=</span><span class="string">&quot;genes_subtree.tre&quot;</span><span class="punctuation">,</span>append <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="3-提取后"><a href="#3-提取后" class="headerlink" title="3. 提取后"></a>3. 提取后</h1><p>提取子树生成的species_subtree.tre文件中的枝长有时会有<code>:NaN</code>符号，用子树跑PhyloNetworks的时候会报错<code>LoadError: Expected right parenthesis after left parenthesis 6 but readN</code>是因为识别不了NaN，需要把子树中的这个符号<code>:NaN</code>删除。</p>
<p>建议用<code>sed -i -E &quot;s/:[0-9.Na]+//g&quot; species_subtree.tre</code>命令把枝长信息都删除。</p>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li>castor包的manual：<a href="https://cran.r-project.org/web/packages/castor/castor.pdf">https://cran.r-project.org/web/packages/castor/castor.pdf</a></li>
<li>castor包的paper：<a href="https://academic.oup.com/bioinformatics/article/34/6/1053/4582279?login=true">https://academic.oup.com/bioinformatics/article/34/6/1053/4582279?login=true</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=30% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>phylogeny</category>
      </categories>
      <tags>
        <tag>R package</tag>
        <tag>phylogeny</tag>
        <tag>evolutionary tree</tag>
        <tag>castor</tag>
        <tag>get_subtree_with_tips</tag>
      </tags>
  </entry>
  <entry>
    <title>构建系统发育进化树：iqtree2构建最大似然树</title>
    <url>/2023/09/26/bioinfo_phylogeny_iqtree/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1304261116&auto=1&height=32"></iframe></div>

<h1 id="1-建树的原料——输入文件"><a href="#1-建树的原料——输入文件" class="headerlink" title="1. 建树的原料——输入文件"></a>1. 建树的原料——输入文件</h1><ol>
<li>数据类型</li>
</ol>
<ul>
<li>通常是使用分子数据的比对文件进行建树，可以是DNA序列、RNA序列、氨基酸序列；</li>
<li>也可以用二进制数据binary alignments（0和1），形态数据morphological data（0-9和A-Z表示）。</li>
</ul>
<ol start="2">
<li>使用**多序列比对(Multiple Sequence Alignment,MSA)**文件来建树</li>
</ol>
<ul>
<li>关于MSA可以参考这篇博客(<a href="https://yanzhongsino.github.io/2021/09/06/bioinfo_align_MSA/)%E3%80%82">https://yanzhongsino.github.io/2021/09/06/bioinfo_align_MSA/)。</a></li>
</ul>
<ol start="3">
<li>MSA文件（sample_aln.fas）的准备</li>
</ol>
<ul>
<li>如果是组学数据（大数据量），推荐使用MAFFT比对，再用trimAI过滤，以获取比对良好的sample_aln.fas文件。</li>
<li>如果是一个或几个基因数据，则可以使用MEGA等软件带的MUSCLE或Clustal软件进行比对，比对完成后一定要手动检查所有比对区域并调整。</li>
<li>注意如果是CDS区域，使用CODON模式进行三碱基联合的比对。</li>
</ul>
<h1 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h1><p><code>nohup iqtree -s samples_aln.fas -o OUTGROUP -T AUTO -m MFP -p partition.nex -b 1000 -alrt 1000 --prefix samples &amp;</code></p>
<h1 id="3-参数解释"><a href="#3-参数解释" class="headerlink" title="3. 参数解释"></a>3. 参数解释</h1><ol>
<li>-s samples_aln.fas：指定多序列比对文件，可以是FASTA&#x2F;PHYLIP&#x2F;NEXUS&#x2F;CLUSTAL&#x2F;MSF格式</li>
<li>-o OUTGROUP：指定外类群（只在最后生成树文件时生效），指定多个物种时用逗号隔开</li>
<li>-T AUTO：指定线程，推荐系统自动检测最佳线程数（AUTO），有时用户设定的会出现过高或过低的情况</li>
<li>-m MFP：指定模型，MFP代表调用iqtree2内置的ModelFinder Plus鉴定最佳模型，默认使用BIC分数最小的模型</li>
<li>-p partition.nex：指定分区文件，支持NEXUS格式或RAxML-style格式。如果需要对多个分区进行独立的模型指定，则使用分区文件partition.nex来指定分区。</li>
</ol>
<ul>
<li>如果partition.nex文件中指定了比对文件，则可以省略-s samples_aln.fas参数。</li>
<li>下面是分区文件partition.nex的NEXUS格式示例，可以指定多个文件和一个文件的多个区域。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">nexus</span></span><br><span class="line">begin sets;</span><br><span class="line">        charset part1 = sample1_aln.fas:1-860; # 指定part1对应sample1_aln.fas文件的第1-860个碱基</span><br><span class="line">        charset part2 = sample1_aln.fas:980-1128; # 指定part1对应sample1_aln.fas文件的第980-1128个碱基</span><br><span class="line">        charset part3 = sample2_aln.phy; # 指定part3对应sample2_aln.phy文件的所有碱基位点</span><br><span class="line">		charpartition mine = HKY:part1, GTR+I+G:part2, WAG+I+G:part3; # 这行为每个part指定不同的模型</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>-b 1000：使用bootstrap自展法计算节点支持率，最少100次，建议1000次或以上。推荐数据量少时用，更准确。</li>
<li>-B 1000 –bnni：使用超快速bootstrap自展法（ultrafast bootstrap approximation, UFBoot）计算节点支持率，最少1000次，建议5000次或以上。推荐数据量大时用，比-b快10倍左右。一般推荐加上–bnni参数，代表使用NNI优化超快速bootstrap的树。</li>
<li>-alrt 1000：使用SH近似似然比检验计算节点支持率，最小1000次，可以和-b或-B一起使用，同时计算两个支持率。</li>
<li>–prefix samples：指定生成的结果文件的前缀为samples。</li>
</ol>
<h1 id="4-其他常用参数"><a href="#4-其他常用参数" class="headerlink" title="4. 其他常用参数"></a>4. 其他常用参数</h1><ol>
<li>-m MFP+ASC：当使用的输入数据是不包含恒定位点（constant sites）的比对文件时（比如SNP数据，比如形态学数据），开发者建议使用+ASC模型（ascertainment bias correction）来矫正因缺乏恒定位点（constant sites）所导致的系统发育树分枝长度过长与祖先结构错误等问题（具体解释见后文）。</li>
</ol>
<ul>
<li>+ASC模型要求输入的数据必须是variable sites（定义看后面的解释），如果比对文件（如包含SNP位点的比对文件）出现constant sites，则报错<code>ERROR: Invalid use of +ASC because of 46145 invariant sites in the alignment</code>，并生成去除constant sites的samples_aln.fas.varsites.phy。</li>
<li>如果报错中断，可以用-s指定新生成的variable位点序列samples_aln.fas.varsites.phy，其他参数不变，继续运行建树即可。</li>
</ul>
<ol start="2">
<li>–mem 100G：最大可使用内存，单位为G、M或百分数%。</li>
<li>-st DNA：指定序列的数据类型，可选DNA&#x2F;CODON&#x2F;AA&#x2F;BIN等，默认是自动检测数据类型。</li>
<li>-redo：iqtree2会生成每一步的结果文件，如果iqtree运行命令被中断，重新运行一样命令则会默认从断点开始运行。如果想要重新运行，则需要加上-redo参数。</li>
<li>-cmax 15：如果你的序列足够长，开发者建议增加-cmax设定值，默认是10，这主要是考虑计算资源。</li>
<li>-keep-ident：默认在建树过程中会删除相同序列的样本，待建树完成后再添加，以节省分析时间。但这也会使输出文件中的样本数不足。如果群体中可能包含相同序列，使用-keep-ident参数可以保留序列相同的样本，使输出样本数与输入样本数保持一致。</li>
<li>-fast：此参数仅使用 最大简约（maximum parsimony）和 BIONJ 2 种方法构建系统发育树，仅进行 2 轮树的优化（-nstop&#x3D;2），且无 OPTIMIZING CANDIDATE TREE SET 步骤。否则（不使用 -fast 参数）使用 100 种构建方法（default -ninit&#x3D;100），并至多迭代 100 次（default -nstop&#x3D;100）进行树的优化。</li>
</ol>
<h1 id="5-结果文件"><a href="#5-结果文件" class="headerlink" title="5. 结果文件"></a>5. 结果文件</h1><ol>
<li><code>-s</code>参数指定序列后会生成几个基本的结果文件：</li>
</ol>
<ul>
<li>samples.iqtree：预测的树结果，包含最终树的文本格式，可直接查看文本看到树的拓扑结构。</li>
<li>samples.treefile：NEWICK格式的ML树，可用iTOL或FigTree等树可视化软件查看。</li>
<li>samples.log：运行log文件。</li>
</ul>
<ol start="2">
<li><code>-m</code>参数运行模型选择，生成额外的文件：</li>
</ol>
<ul>
<li>samples.best_scheme.nex：最佳模型（包含碱基替换模型）文件，默认是选择BIC最小的模型为最佳模型，也可以通过参数<code>-AIC</code>或<code>-AICc</code>选AIC或AICc最小的作为最佳模型。</li>
<li>samples.model.gz：所有测试模型的对数似然，它充当checkpoint文件来恢复中断的模型选择。</li>
<li>sample.best_model.nex：最佳模型。</li>
<li>samples.best_scheme：分区情况。</li>
</ul>
<ol start="3">
<li><code>-B</code>参数指定超快速自展法评估支持率</li>
</ol>
<ul>
<li>samples.contree：具有指定分支的一致树(consensus tree)支持在原始比对序列上优化分支长度</li>
<li>samples.splits.nex：以百分比表示的所有splits（二分区）的支持值，以引导树中的出现频率计算。该文件可以用 SplitsTree 程序查看，以探索数据中的冲突信号。因此，它比一致树的信息量更大。例如，这个文件可以看到第二好的冲突split的支持率有多高，即使第二好的拓扑没有被选入一致树。</li>
<li>samples.ufboot</li>
</ul>
<ol start="4">
<li>其他结果文件</li>
</ol>
<ul>
<li>samples.ckp.gz：iqtree自动生成的checkpoint文件，用于恢复中断的运行。使用相同的命令行再次调用iqtree，有这个文件将从上次停止点恢复分析，从而节省之前完成的所有计算时间。</li>
<li>samples.mldist：似然距离。</li>
<li>samples.boottrees</li>
<li>samples.bionj</li>
</ul>
<h1 id="6-结果解释"><a href="#6-结果解释" class="headerlink" title="6. 结果解释"></a>6. 结果解释</h1><ol>
<li>多支持率情况</li>
</ol>
<ul>
<li>如果同时使用-b或-B和-alrt两种方法计算支持率，samples.iqtree文件的支持率在括号中同时展示：（SH-aLRT支持率&#x2F;UFBoot支持率）</li>
</ul>
<ol start="2">
<li>支持率的可信度：不同算法的支持率代表的可信度不一样，一般按下面的标准认为分支具有可信度，iqtree开发者推荐同时满足 UFboot &gt;&#x3D; 95% 和 SH-aLRT &gt;&#x3D; 80% 两个标准的分支可信。</li>
</ol>
<ul>
<li>-B的支持率 UFboot &gt;&#x3D; 95%</li>
<li>-b的支持率 BS support &gt;&#x3D; 80%</li>
<li>-alrt的支持率 SH-aLRT &gt;&#x3D; 80%</li>
</ul>
<h1 id="7-iqtree使用的一些原理"><a href="#7-iqtree使用的一些原理" class="headerlink" title="7. iqtree使用的一些原理"></a>7. iqtree使用的一些原理</h1><h2 id="7-1-iqtree对碱基位点（site）类型的定义"><a href="#7-1-iqtree对碱基位点（site）类型的定义" class="headerlink" title="7.1. iqtree对碱基位点（site）类型的定义"></a>7.1. iqtree对碱基位点（site）类型的定义</h2><p>iqtree 构建系统发育树时，informative sites 用于推断树的拓扑结构与分枝长度，uninformative site 则用于矫正。</p>
<ol>
<li>iqtree 将位点（site）分为 3 类：constant（invariant）、singleton、informative（variable）。</li>
<li>constant site 指位点在所有样本中只包含 1 种碱基；singleton site 指位点包含 2 种类型碱基，但突变仅出现 1 次；informative site 指位点包含 2 种类型碱基，且每种碱基出现至少 2 次。</li>
<li>从算法角度来说，iqtree 无法利用 singleton 对样本分群，即无法提供分群信息，所以 constant 与 singleton 位点属于 uninformative site 。</li>
<li>iqtree 对歧义位点（Ambiguous site）采用交集（intersection）形式分析：如果交集非空则忽略歧义碱基，若为空则视为 variant，同列中歧义碱基不堆叠。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">site        1234567</span><br><span class="line">species_1   CCCCCCC</span><br><span class="line">species_2   RTCYRCC</span><br><span class="line">species_3   CYTYYRT</span><br><span class="line">species_4   CCCYCRT</span><br><span class="line"></span><br><span class="line">site1 is singleton, because R=&#123;A or G&#125;, which exclude C, uninformative.</span><br><span class="line">site2 is singleton, because Y=&#123;C or T&#125;, which include C, ignore Y, uninformative.</span><br><span class="line">site3 is singleton, uninformative.</span><br><span class="line">site4 is constant, because Y=&#123;C or T&#125;, which include C, ignore Y, uninformative.</span><br><span class="line">site5 is singleton, because R=&#123;A or G&#125;, which exclude C, Y=&#123;C or T&#125;, which include C, ignore Y, uninformative.</span><br><span class="line">site6 is singleton, because R=&#123;A or G&#125;, which exclude C, uninformative.</span><br><span class="line">site7 is informative.</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>由于歧义位点的交集策略，当同列中仅包含非空歧义碱基时，位点会被判定为 constant site（如上例中 site 4）。因此 SNP 数据从 vcf 转 phylip 后存在部分 site 被判定为 constant 的情况。</li>
</ol>
<h2 id="7-2-ASC模型用于SNP数据或形态学数据的原理"><a href="#7-2-ASC模型用于SNP数据或形态学数据的原理" class="headerlink" title="7.2. +ASC模型用于SNP数据或形态学数据的原理"></a>7.2. +ASC模型用于SNP数据或形态学数据的原理</h2><ol>
<li>缺乏恒定位点（constant sites）的数据（例如SNP数据&#x2F;形态学数据）带来的问题</li>
</ol>
<ul>
<li>由于个体间固定长度区间内 SNP 越多，说明个体间积累的突变越多，分离的时间越长。所以 SNP 构成的 Fasta 数据大幅增加了突变的密度，使个体间分离时间大幅提前，导致分枝过长。 </li>
<li>同时，分枝过长会压缩祖先之间的分枝长度，降低祖先之间拓扑结构推断的准确性。因为祖先与个体之间时间跨度越长，祖先的可能性就越多，如果祖先对应一个概率分布，则祖先与祖先之间的分布交集就越大。 </li>
<li>例如 A &#x2F; B 的祖先是 D，C 的祖先是 E，D &#x2F; E 的祖先是 F，如果 A &#x2F; B &#x2F; C 与 D &#x2F; E 的距离越远，D &#x2F; E 的可能序列就越多，D &#x2F; E 分布重合的区间就越大；因为 D &#x2F; E 间相似度高，所以 D &#x2F; E 与 F 的距离会缩短，即压缩 D &#x2F; E 与祖先 F 之间的分枝长度，降低树结构预测的准确性。</li>
</ul>
<ol start="2">
<li><p>为了矫正缺乏恒定位点（constant sites）的数据导致发育树分枝过长的情况，iqtree 提供 +ASC 参数（ascertainment bias correction）。   </p>
</li>
<li><p>有人分别测评了 GTR+F+G4 和 GTR+F+G4+ASC 两种替换模型下的树结构，结果参见下节（Test 2&amp;3）。+ASC 虽然对 Log-likelihood 影响较小（1.2%&#x3D;1-79848&#x2F;80786），但对树结构影响较大（23.3%&#x3D;1-5.536&#x2F;7.216），且能够大幅提高稳定性（148%-&gt;0%）。</p>
</li>
<li><p>不同参数的性能测试</p>
</li>
</ol>
<table><thead><tr><th>Test</th><th>input</th><th>model</th><th>optimize</th><th>Log-likelihood</th><th>Total tree length</th><th>Sum of internal branch lengths (ratio)</th><th>near-zero internal branches</th><th>Lmap not informative ratio</th></tr></thead><tbody><tr><td>1</td><td>min4.phy</td><td>GTR+F+G4</td><td>fast</td><td>-95636</td><td>3.751</td><td>0.799 (21%)</td><td>93</td><td>8.48%</td></tr><tr><td>2</td><td>varsites.phy</td><td>GTR+F+G4</td><td>fast</td><td>-80786</td><td>7.216</td><td>1.549 (21%)</td><td>97</td><td>14.82%</td></tr><tr><td>3</td><td>varsites.phy</td><td>GTR+F+G4+ASC</td><td>fast</td><td>-79848</td><td>5.536</td><td>1.185 (21%)</td><td>101</td><td>0%</td></tr><tr><td>4</td><td>varsites.phy</td><td>GTR+F+R6+ASC</td><td>fast</td><td>-77426</td><td>1.327</td><td>0.269 (20%)</td><td>263</td><td>0%</td></tr><tr><td>5</td><td>varsites.phy</td><td>GTR+F+R6+ASC</td><td>complete</td><td>-77239</td><td>1.079</td><td>0.210 (19%)</td><td>316</td><td>0%</td></tr></tbody></table>

<ul>
<li>Test 1&amp;2：使用 iqtree 过滤 SNP 数据集中的 constant site 后再输入 iqtree，不仅可以使用 +ASC 提高模型精度，还能减少建树时间（min4 299s，varsites 50s）。</li>
<li>Test 2&amp;3：ASC 使树的分枝长度大幅降低（23.3%&#x3D;1-5.536&#x2F;7.216），且能够大幅提高稳定性（148%-&gt;0%），但对似然值改变较小（1.2%&#x3D;1-79848&#x2F;80786）。 </li>
<li>Test 3&amp;4：更换模型使树的分枝长度大幅降低（75%&#x3D;1-1.328&#x2F;5.536），但似然值改变较小（3%&#x3D;1-77426&#x2F;79848）。</li>
<li>Test 4&amp;5：多轮迭代 使树的 分枝长度 大幅降低（20%&#x3D;1-1.079&#x2F;1.328），但似然值改变微小（3‰&#x3D;1-77239&#x2F;77426）。 </li>
<li>Test all：所有模型中中间分枝（internal branch）长度占总枝长比例基本固定（约 20%），near-zero 与 tree length 相关性较高，当发育树整体分枝长度增加时，内部分枝长度也相应增加，其中近 0 分枝数量减少。中间分枝长度占比 20 % 说明 80% 的枝长分布在 末端分枝，个体间距离较大，分离时间较早。部分祖先间的进化关系太紧密（near-zero），用多叉树描述可能更符合这些节点。</li>
</ul>
<h1 id="8-reference"><a href="#8-reference" class="headerlink" title="8. reference"></a>8. reference</h1><ol>
<li>iqtree manual：<a href="http://www.iqtree.org/doc/">http://www.iqtree.org/doc/</a></li>
<li>iqtree常见问题官方解答：<a href="http://www.iqtree.org/doc/Frequently-Asked-Questions#how-do-i-interpret-ultrafast-bootstrap-ufboot-support-values">http://www.iqtree.org/doc/Frequently-Asked-Questions#how-do-i-interpret-ultrafast-bootstrap-ufboot-support-values</a></li>
<li>ASC模型解释：<a href="https://blog.csdn.net/sinat_41621566/article/details/125427326">https://blog.csdn.net/sinat_41621566/article/details/125427326</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<div style="text-align:center">
<span style="width:30%;display:inline-block">
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" title="wechat_public_QRcode" width=90%>
</span>
<span style="width:30%;display:inline-block">
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/wechat.jpg?raw=true" title="Wechat_code" width=90%>
</span>
<span style="width:30%;display:inline-block">
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/alipay.jpg?raw=true" title="Alipay_code" width=90%>
</span>
</div>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>phylogeny</category>
        <category>phylogeny inference</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>phylogeny</tag>
        <tag>evolutionary tree</tag>
        <tag>phylogeny inference</tag>
        <tag>iqtree2</tag>
        <tag>maximum likelihood tree</tag>
        <tag>ML tree</tag>
        <tag>Bayesian information criterion</tag>
        <tag>BIC</tag>
        <tag>ultrafast bootstrap approximation</tag>
        <tag>UFBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>使用pixy计算群体的pi，dxy，fst</title>
    <url>/2023/03/13/bioinfo_population.genetics_pixy/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=105146&auto=1&height=32"></iframe></div>

<h1 id="1-用pixy计算群体的pi，dxy，fst"><a href="#1-用pixy计算群体的pi，dxy，fst" class="headerlink" title="1. 用pixy计算群体的pi，dxy，fst"></a>1. 用pixy计算群体的pi，dxy，fst</h1><p>pixy可以基于多组学的vcf格式文件来计算群体的pi，dxy，fst值。</p>
<h2 id="1-1-安装pixy"><a href="#1-1-安装pixy" class="headerlink" title="1.1. 安装pixy"></a>1.1. 安装pixy</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install --yes -c conda-forge pixy</span><br><span class="line">conda install --yes -c bioconda htslib</span><br><span class="line">pixy --help</span><br></pre></td></tr></table></figure>

<h2 id="1-2-准备vcf文件"><a href="#1-2-准备vcf文件" class="headerlink" title="1.2. 准备vcf文件"></a>1.2. 准备vcf文件</h2><p>pixy需要的vcf文件与只包含snp的vcf文件不同，是同时包含变异位点（variant sites）和非变异位点（invariant sites）的全位点（all sites）文件。</p>
<ol>
<li>获取all-sites的vcf文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gatk --java-options &quot;-Xmx32g&quot; HaplotypeCaller -R ref.fa -I input.bam -O output.g.vcf -ERC GVCF # 生成单个样本gvcf文件</span><br><span class="line">gatk --java-options &quot;-Xmx32g&quot; GenomicsDBImport -V output1.g.vcf -V output2.g.vcf ... --genomicsdb-workspace-path &lt;allsamples_genomicsdb&gt;</span><br><span class="line">for chr in $(cat chr.list);do gatk --java-options &quot;-Xmx32g&quot; GenotypeGVCFs -R ref.fa -V samples.g.vcf -L $&#123;chr&#125; -all-sites -O $&#123;chr&#125;_allsites.vcf.gz;done  # joint-calling这里一定要加参数-all-sites(把non-variant位点也保存到vcf文件中，后面才能进行pixy的分析）。必须使用-L指定染色体，否则有报错风险。耗时步骤。</span><br><span class="line">ls *_allsites.vcf.gz &gt;vcf.list # 把生成的染色体的vcf文件名保存到vcf.list</span><br><span class="line">gatk MergeVcfs -I vcf.list -O samples_allsites.vcf.gz # 合并所有染色体vcf文件到一个vcf文件，耗时步骤</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>分别获取invariant和variant位点，过滤后，再合并</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vcftools --gzvcf samples_allsites.vcf.gz --max-maf 0 --minQ 30 --max-missing 0.9 --min-meanDP 10 --max-meanDP 43 --remove filter.indv --recode --stdout | bgzip -c &gt; samples_invariant_filtered.vcf.gz &amp; # 提取invariant位点并过滤，同时生成out.log名称的log文件</span><br><span class="line">vcftools --gzvcf samples_allsites.vcf.gz --mac 1 --min-alleles 2 --max-alleles 2 --minQ 30 --max-missing 0.9 --min-meanDP 10 --max-meanDP 43 --remove filter.indv --recode --stdout | bgzip -c &gt; samples_variant_filtered.vcf.gz &amp; # 提取variant位点并过滤，同时也生成out.log名称的log文件，最好与上一步骤分开在两个文件夹运行</span><br><span class="line">tabix samples_invariant_filtered.vcf.gz</span><br><span class="line">tabix samples_variant_filtered.vcf.gz</span><br><span class="line">bcftools concat --allow-overlaps samples_variant.vcf.gz samples_invariant.vcf.gz -O z -o samples_allsites_filtered.vcf.gz # 合并invariant和variant位点到一个文件</span><br></pre></td></tr></table></figure>

<h2 id="1-3-pixy计算dxy，pi和fst"><a href="#1-3-pixy计算dxy，pi和fst" class="headerlink" title="1.3. pixy计算dxy，pi和fst"></a>1.3. pixy计算dxy，pi和fst</h2><ol>
<li>popfile.txt群体文件</li>
</ol>
<ul>
<li>popfile.txt文件包含样本个体分组信息，两列内容，tab分隔。第一列样本ID，第二列分组名称（常用物种作为分组依据）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERS223827   BFS</span><br><span class="line">ERS223759   BFS</span><br><span class="line">ERS223750   BFS</span><br><span class="line">ERS223967   AFS</span><br><span class="line">ERS223970   AFS</span><br><span class="line">ERS223924   AFS</span><br><span class="line">ERS224300   AFS</span><br><span class="line">ERS224168   KES</span><br><span class="line">ERS224314   KES</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bgzip samples_allsites_filtered.vcf</span><br><span class="line">tabix samples_allsites_filtered.vcf.gz</span><br><span class="line">nohup pixy --stats pi fst dxy --vcf sample_allsites_filtered.vcf.gz --populations popfile.txt --window_size 10000 --n_cores 16 &amp;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-pixy的结果"><a href="#1-4-pixy的结果" class="headerlink" title="1.4. pixy的结果"></a>1.4. pixy的结果</h2><p>根据–stats的设定，生成三个统计量的结果文件。</p>
<ol>
<li>pixy_pi.txt：居群内的核苷酸多样性（nucleotide diversity (pi)）</li>
</ol>
<ul>
<li>pop：popfile.txt群体文件中群体ID</li>
<li>chromosome：染色体或contig的ID</li>
<li>window_pos_1：基因组window的起始位置</li>
<li>window_pos_2：基因组window的终止位置</li>
<li>avg_pi：window的位点的平均核苷酸多样性。更具体地说，pixy 计算window中所有位点的每个位点的加权平均核苷酸多样性，其中权重由每个位点的基因分型样本数决定。</li>
<li>no_sites：window中至少具有一种有效基因型的位点总数。此统计信息被提供给用户，不会直接用于任何计算。</li>
<li>count_diffs：window中所有基因型之间成对差异的原始数量。这是计算 avg_pi 的分子。</li>
<li>count_comparisons：window中所有基因型之间非缺失成对比较的原始数量（即比较两种基因型且均有效的情况）。这是计算 avg_pi 的分母。</li>
<li>count_missing：window中所有基因型之间缺失配对比较的原始数量（即比较两种基因型且至少缺失一种的情况）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop	chromosome	window_pos_1	window_pos_2	avg_pi	no_sites	count_diffs	count_comparisons	count_missing</span><br><span class="line">BFS	HiC_scaffold_1	1	10000	0.0	6	0	6	0</span><br><span class="line">AFS	HiC_scaffold_1	1	10000	0.0	6	0	6	0</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>pixy_dxy.txt：居群间的核苷酸差异（nucleotide divergence (dxy)）</li>
</ol>
<ul>
<li>pop1：popfile.txt群体文件中群体ID，比较的第一个居群</li>
<li>pop2：popfile.txt群体文件中群体ID，比较的第二个居群</li>
<li>chromosome：染色体或contig的ID</li>
<li>window_pos_1：基因组window的起始位置</li>
<li>window_pos_2：基因组window的终止位置</li>
<li>avg_dxy：window的平均每个位点的核苷酸差异</li>
<li>no_sites：window中两个群体中至少具有一种有效基因型的位点总数。此统计信息提供给用户，不会直接用于任何计算。</li>
<li>count_diffs：所有基因型之间的成对交叉种群差异的原始数量。这是计算 avg_dxy 的分子。</li>
<li>count_comparisons：window中所有基因型之间非缺失成对交叉种群比较的原始数量（即比较两种基因型且均有效的情况）。这是计算 avg_dxy 的分母。</li>
<li>count_missing：window中所有基因型之间缺失的成对跨种群比较的原始数量（即两个基因型被比较而至少有一个缺失的情况）。这个统计数字提供给用户，不直接用于任何计算。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop1	pop2	chromosome	window_pos_1	window_pos_2	avg_dxy	no_sites    count_diffs	count_comparisons	count_missing</span><br><span class="line">BFS	AFS	HiC_scaffold_1	1	10000	0.0	6	24	0</span><br><span class="line">CFS	DES	HiC_scaffold_1	1	10000	0.0	6	24	0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>pixy_fst.txt：Weir and Cockerham’s FST</li>
</ol>
<ul>
<li>pop1：popfile.txt群体文件中群体ID，比较的第一个居群</li>
<li>pop2：popfile.txt群体文件中群体ID，比较的第二个居群</li>
<li>chromosome：染色体或contig的ID</li>
<li>window_pos_1：基因组window的起始位置</li>
<li>window_pos_2：基因组window的终止位置</li>
<li>avg_wc_fst：window的平均每个SNP（不是每个位点）的 Weir and Cockerham’s FST </li>
<li>no_snps：window内变异位点（SNPs）的总数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pop1	pop2	chromosome	window_pos_1	window_pos_2	avg_wc_fst	no_snps</span><br><span class="line">BFS	AFS	HiC_scaffold_1	30001	40000	NA	67</span><br><span class="line">CFS	DES	HiC_scaffold_1	30001	40000	0.0	67</span><br></pre></td></tr></table></figure>

<h2 id="结果的后续处理"><a href="#结果的后续处理" class="headerlink" title="结果的后续处理"></a>结果的后续处理</h2><ol>
<li>计算平均值的注意事项</li>
</ol>
<p>值得注意的是，如果想用pixy的结果继续计算更大的window或者整个基因组的平均值不能直接用window的pi&#x2F;dxy值来计算。</p>
<p>正确的计算方法是使用原始计数重新计算differences&#x2F;comparisons ratios，公式如下：</p>
<p>$$(window 1 count_diffs + window 2 count_diffs + … + window n count_diffs) &#x2F; (window 1 comparisons + window 2 comparisons + … + window n comparisons)$$</p>
<ol start="2">
<li>计算整个基因组的pi值</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat pixy_pi.txt |cut -f1,2 |sort|uniq &gt;pops.list</span><br><span class="line">cat pops.list | while read line</span><br><span class="line">do</span><br><span class="line">    a=$(echo $line | awk &#x27;&#123;print $1&#125;&#x27;);</span><br><span class="line">    b=$(echo $line | awk &#x27;&#123;print $2&#125;&#x27;);</span><br><span class="line">    cat pixy_dxy.txt |awk &#x27;$1 == &quot;&#x27;$a&#x27;&quot; &amp;&amp; $2 == &quot;&#x27;$b&#x27;&quot; &#123;suma+=$8;sumb+=$9&#125; END &#123;print &quot;&#x27;$a&#x27;&quot;, &quot;&#x27;$b&#x27;&quot;, suma, sumb, suma/sumb&#125;&#x27; &gt;&gt; dxy_average.txt</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>计算整个基因组的dxy平均值</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat pixy_dxy.txt |cut -f1 |sort|uniq &gt;pop.list</span><br><span class="line">cat pop.list | while read line</span><br><span class="line">do</span><br><span class="line">    a=$(echo $line | awk &#x27;&#123;print $1&#125;&#x27;);</span><br><span class="line">    cat pixy_pi.txt |awk &#x27;$1 == &quot;&#x27;$a&#x27;&quot; &#123;suma+=$7;sumb+=$8&#125; END &#123;print &quot;&#x27;$a&#x27;&quot;, suma, sumb, suma/sumb&#125;&#x27; &gt;&gt; pi_average.txt</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="结果可视化"><a href="#结果可视化" class="headerlink" title="结果可视化"></a>结果可视化</h2><h1 id="2-references"><a href="#2-references" class="headerlink" title="2. references"></a>2. references</h1><ol>
<li>pixy manual：<a href="https://pixy.readthedocs.io/en/latest/index.html">https://pixy.readthedocs.io/en/latest/index.html</a></li>
<li>pixy github：<a href="https://github.com/ksamuk/pixy">https://github.com/ksamuk/pixy</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=30% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>population genetics</category>
      </categories>
      <tags>
        <tag>pixy</tag>
        <tag>pi</tag>
        <tag>dxy</tag>
        <tag>fst</tag>
      </tags>
  </entry>
  <entry>
    <title>绘制进化树 —— R包treeio+ggtree</title>
    <url>/2022/01/24/bioinfo_phylogeny_ggtree/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=283100&auto=1&height=32"></iframe></div>

<h1 id="1-进化树"><a href="#1-进化树" class="headerlink" title="1. 进化树"></a>1. 进化树</h1><p>进化树的相关知识可以参考<a href="https://yanzhongsino.github.io/2021/11/20/bio_evolutionary.tree/">博文进化树相关知识</a>。</p>
<h1 id="2-进化树的绘制"><a href="#2-进化树的绘制" class="headerlink" title="2. 进化树的绘制"></a>2. 进化树的绘制</h1><p>进化树的绘制是指把newick格式的树文件转换成树图形，有许多软件可以使用，在线网页版（itol，EvolView），也有R包（ggtree），或者软件figtree。<br>如果是简单的树绘制，推荐在线网页<strong>itol</strong>；如果需要精细的注释，推荐R包<strong>ggtree</strong>。</p>
<h2 id="2-1-在线绘制进化树"><a href="#2-1-在线绘制进化树" class="headerlink" title="2.1. 在线绘制进化树"></a>2.1. 在线绘制进化树</h2><ol>
<li><a href="https://itol.embl.de/">itol</a></li>
<li><a href="https://www.evolgenius.info/evolview/#login">EvolView</a></li>
</ol>
<h2 id="2-2-R包ggtree【推荐】"><a href="#2-2-R包ggtree【推荐】" class="headerlink" title="2.2. R包ggtree【推荐】"></a>2.2. R包ggtree【推荐】</h2><p>R包treeio用于解析各种格式的进化树文件，ggtree用于绘制进化树和注释。</p>
<h3 id="2-2-1-树文件的导入"><a href="#2-2-1-树文件的导入" class="headerlink" title="2.2.1. 树文件的导入"></a>2.2.1. 树文件的导入</h3><h4 id="2-2-1-1-treeio导入树"><a href="#2-2-1-1-treeio导入树" class="headerlink" title="2.2.1.1. treeio导入树"></a>2.2.1.1. treeio导入树</h4><p>treeio支持标准格式树（包括Newick树格式，NEXUS树格式，New Hampshire eXtended(NHX)树格式，Jplace树格式）和建树软件输出树（RAxML，iqtree，BEAST，MrBayes，PAML(BASEML,CODEML)，r8s，MEGA，HyPhy，Phylip，以及生成Jplace格式树的EPA和PPLACER），可以用文本输入和文件输入两种形式导入和解析树。</p>
<p><a href="https://guangchuangyu.github.io/ggtree-book/chapter-treeio.html">treeio tutorial</a>解释了各种建树软件输出的树包含的信息。</p>
<ol>
<li>文本输入<br>当树文件的文本比较简单时，可以直接把文本读到变量中，再解析。</li>
</ol>
<ul>
<li><p>Newick格式树<br><code>read.newick()</code>：用read.newick读取Newick格式的树文本，有枝长信息，缺点是没有办法添加注释信息</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>treeio<span class="punctuation">)</span></span><br><span class="line">treetext<span class="operator">&lt;-</span><span class="string">&quot;((((Mc:0.418672,Eg:0.201388):0.148853,((Pt:0.219587,(Cs:0.209405,(Gr:0.224188,At:0.492461):0.027774):0.012564):0.019343,(Pp:0.194515,(Mt:0.354580,Cl:0.338644:0.022063):0.019111):0.011710):0.029914,Vv:0.169100):0.241611,Mg:0.241611);&quot;</span>  </span><br><span class="line">tree <span class="operator">&lt;-</span> read.newick<span class="punctuation">(</span>textConnection<span class="punctuation">(</span>treetext<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>NHX格式树<br><code>read.nhx()</code>：用read.nhx()读取NHX格式的树文本，节点后中括号内[&amp;&amp;NHX]添加值注释信息，用冒号:分隔多个注释信息，缺点是没有办法添加范围注释，比如95%置信区间注释</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">treetext<span class="operator">&lt;</span><span class="string">&quot;((((Mc:0.418672[&amp;&amp;NHX:I=5728:D=1170:G=Malvids],Eg:0.201388[&amp;&amp;NHX:I=1420:D=2519:G=Malvids])[&amp;&amp;NHX:C=1]:0.148853,((Pt:0.219587[&amp;&amp;NHX:I=5355:D=1003:G=Fabids],(Cs:0.209405[&amp;&amp;NHX:I=1026:D=3516:G=Malvids],(Gr:0.224188[&amp;&amp;NHX:I=4875:D=998:G=Malvids],At:0.492461[&amp;&amp;NHX:I=1776:D=2891:G=Malvids]):0.027774[&amp;&amp;NHX:C=2]):0.012564[&amp;&amp;NHX:C=3]):0.019343[&amp;&amp;NHX:C=4],(Pp:0.194515[&amp;&amp;NHX:I=1159:D=2949:G=Fabids],(Mt:0.354580[&amp;&amp;NHX:I=3310:D=1984:G=Fabids],Cl:0.338644[&amp;&amp;NHX:I=794:D=3735:G=Fabids]):0.022063[&amp;&amp;NHX:C=5]):0.019111[&amp;&amp;NHX:C=6]):0.011710[&amp;&amp;NHX:C=7]):0.029914[&amp;&amp;NHX:C=8],Vv:0.169100[&amp;&amp;NHX:I=1522:D=3045:G=Vitales]):0.241611[&amp;&amp;NHX:C=9],Mg:0.241611[&amp;&amp;NHX:I=2278:D=1909:G=Asterids])[&amp;&amp;NHX:C=10];&quot;</span>  </span><br><span class="line">tree <span class="operator">&lt;-</span> read.nhx<span class="punctuation">(</span>textConnection<span class="punctuation">(</span>treetext<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>treeio导入树文件<br>treeio支持解析大部分软件输出的树文件</li>
</ol>
<table>
<thead>
<tr>
<th>解析函数Parser function</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>read.newick</td>
<td>解析Newick格式文件</td>
</tr>
<tr>
<td>read.nexus</td>
<td>解析NEXUS格式文件</td>
</tr>
<tr>
<td>read.nhx</td>
<td>解析NHX格式文件</td>
</tr>
<tr>
<td>read.jplace</td>
<td>解析jplace格式文件，包括EPA和pplacer的输出文件</td>
</tr>
<tr>
<td>read.jtree</td>
<td>解析jtree格式文件</td>
</tr>
<tr>
<td>read.fasta</td>
<td>解析fasta序列</td>
</tr>
<tr>
<td>read.iqtree</td>
<td>解析IQ-Tree的Newick格式输出，支持解析SH-aLRT和UFBoot支持率</td>
</tr>
<tr>
<td>read.raxml</td>
<td>解析RAxML的输出</td>
</tr>
<tr>
<td>read.r8s</td>
<td>解析r8s的输出</td>
</tr>
<tr>
<td>read.mrbayes</td>
<td>解析MrBayes的输出</td>
</tr>
<tr>
<td>read.beast</td>
<td>解析BEAST的输出</td>
</tr>
<tr>
<td>read.astral</td>
<td>解析ASTRAL的输出</td>
</tr>
<tr>
<td>read.mega</td>
<td>解析MEGA的Nexus格式输出</td>
</tr>
<tr>
<td>read.codeml</td>
<td>解析CodeML的输出，rst和mlc文件</td>
</tr>
<tr>
<td>read.paml_rst</td>
<td>解析rst文件，BaseML或CodeML的输出</td>
</tr>
<tr>
<td>read.hyphy</td>
<td>解析HyPhy输出文件</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>用对应的解析函数读取相应格式的文件，例如读取Newick格式文件用<code>tree&lt;-read.newick(&quot;newick.tre&quot;)</code>,读取beast输出的树文件用<code>tree&lt;-read.beast(&quot;beast.tre&quot;)</code>。</p>
<ol start="3">
<li>read.mega&#x2F;read.beast读取NEXUS格式文件</li>
</ol>
<ul>
<li>NEXUS格式把Newick树和其他信息组合，每种信息单独成块(blocks)，可扩展块来实现添加新类别的信息，NEXUS格式可以看作Newick树加注释信息的组合。</li>
<li>NEXUS格式树包括TAXA块和TREE块，常常也会包括储存序列比对(Phylip格式)的DATA块，有些软件有自己特定的块。</li>
<li>每个块都是<code>Begin Blockname;</code>开头，<code>End;</code>加一个空行结尾。</li>
<li>NEXUS格式的优点是可以实现尽可能地注释树，包括值注释和区间注释(例如95%置信区间)，缺点是格式稍微复杂，必须文件读取。</li>
<li>我自己尝试用read.nexus读取NEXUS文件，读取没问题，但如果想使用注释信息(比如geom_text&#x2F;geom_label2使用注释，geom_range来显示区间注释)就会报错；但是用read.mega&#x2F;read.beast读取NEXUS文件就可以顺利使用注释信息，查看了treeio里的示例文件，read.mega和read.beast里的NEXUS文件格式是一样的，区别在于beast只能读NEXUS文件，mega还可以都Newick文件。</li>
</ul>
<p>一个NEXUS文件的例子，treeio包自带的mtCDNA_timetree.nex文件，可以参考示例文件格式自己写一个NEXUS格式的树文件用于ggtree：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#NEXUS</span><br><span class="line"></span><br><span class="line">Begin Taxa;</span><br><span class="line">	Dimensions ntax=7;</span><br><span class="line">	TaxLabels</span><br><span class="line">		homo_sapiens</span><br><span class="line">		chimpanzee</span><br><span class="line">		bonobo</span><br><span class="line">		gorilla</span><br><span class="line">		orangutan</span><br><span class="line">		sumatran</span><br><span class="line">		gibbon</span><br><span class="line">		;</span><br><span class="line">End;</span><br><span class="line"></span><br><span class="line">Begin Trees;</span><br><span class="line">	Translate</span><br><span class="line">		1 homo_sapiens,</span><br><span class="line">		2 chimpanzee,</span><br><span class="line">		3 bonobo,</span><br><span class="line">		4 gorilla,</span><br><span class="line">		5 orangutan,</span><br><span class="line">		6 sumatran,</span><br><span class="line">		7 gibbon</span><br><span class="line">		;</span><br><span class="line">tree TREE1 = [&amp;R] (((((2[&amp;rate=8.21387638458966E-001,branch_length=6.27635980985610E-002]:7.76603755686346E-002,3[&amp;rate=8.08047027678532E-001,branch_length=6.17442197999256E-002]:7.76603755686346E-002)[&amp;rate=8.14690026837604E-001,branch_length=1.06551791913040E-001,reltime=7.76603755686346E-002,reltime_stderr=1.66322225004909E-002,reltime_95%_CI=&#123;4.50612194676725E-002,1.10259531669597E-001&#125;,data_coverage=100%]:1.32925460715114E-001,1[&amp;rate=1.14839817218159E+000,branch_length=2.37947876847083E-001]:2.10585836283749E-001)[&amp;rate=9.67258258023612E-001,branch_length=6.82392048602499E-002,reltime=2.10585836283749E-001,reltime_stderr=3.66695942566917E-002,reltime_95%_CI=&#123;1.38713431540633E-001,2.82458241026865E-001&#125;,data_coverage=100%]:7.17020095880709E-002,4[&amp;rate=9.49741644253964E-001,branch_length=2.63789706511460E-001]:2.82287845871820E-001)[&amp;rate=9.58459935726878E-001,branch_length=2.94031112947650E-001,reltime=2.82287845871820E-001,reltime_stderr=4.16686354669857E-002,reltime_95%_CI=&#123;2.00617320356528E-001,3.63958371387112E-001&#125;,data_coverage=100%]:3.11787816307430E-001,(5[&amp;rate=1.34822289815278E+000,branch_length=1.52886612438902E-001]:1.15251762438322E-001,6[&amp;rate=8.34007596053647E-001,branch_length=9.45753081954446E-002]:1.15251762438322E-001)[&amp;rate=1.06039055929072E+000,branch_length=4.99576332711077E-001,reltime=1.15251762438322E-001,reltime_stderr=1.98603068330366E-002,reltime_95%_CI=&#123;7.63255610455702E-002,1.54177963831074E-001&#125;,data_coverage=100%]:4.78823899740928E-001)[&amp;rate=1.00813782158154E+000,branch_length=2.10619528131437E-001,reltime=5.94075662179250E-001,reltime_stderr=7.90987567922010E-002,reltime_95%_CI=&#123;4.39042098866536E-001,7.49109225491964E-001&#125;,data_coverage=100%]:2.12333512272958E-001,7[&amp;rate=1.00813782158154E+000,branch_length=7.99899733140789E-001]:8.06409174452208E-001);</span><br><span class="line">End;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在代表样品的序号后用中括号[&amp;]提供注释信息，多个注释用逗号分隔，如果提供的注释信息值是区间，用大括号包含区间。</p>
<h3 id="2-2-2-ggtree画树"><a href="#2-2-2-ggtree画树" class="headerlink" title="2.2.2. ggtree画树"></a>2.2.2. ggtree画树</h3><p>ggtree函数是ggplot()的扩展，ggtree()相当于<code>ggplot() + geom_tree() + xlab(NA) + ylab(NA) + theme_tree()</code>的简单组合。ggplot2可添加的图层都可以直接应用于ggtree。</p>
<h4 id="2-2-2-1-基础画树"><a href="#2-2-2-1-基础画树" class="headerlink" title="2.2.2.1. 基础画树"></a>2.2.2.1. 基础画树</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggtree<span class="punctuation">)</span></span><br><span class="line">ggtree<span class="punctuation">(</span>tree<span class="punctuation">)</span> <span class="comment">#默认参数画树</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-2-基础注释"><a href="#2-2-2-2-基础注释" class="headerlink" title="2.2.2.2. 基础注释"></a>2.2.2.2. 基础注释</h4><ol>
<li><p>基础注释函数用法<br>包含注释函数的基本参数用法</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggtree<span class="punctuation">(</span>tree<span class="punctuation">)</span> <span class="punctuation">\</span> <span class="comment">#画树 </span></span><br><span class="line"><span class="operator">+</span> geom_tiplab<span class="punctuation">(</span><span class="punctuation">)</span> <span class="punctuation">\</span> <span class="comment"># 末端节点标上物种</span></span><br><span class="line"><span class="operator">+</span> geom_rootedge<span class="punctuation">(</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#添加根节点的枝长线，如果树文件中有根节点枝长则直接可使用</span></span><br><span class="line"><span class="operator">+</span> geom_point2<span class="punctuation">(</span><span class="punctuation">)</span> <span class="punctuation">\</span> <span class="comment">#节点上标记圆点</span></span><br><span class="line"><span class="operator">+</span> geom_text2<span class="punctuation">(</span>aes<span class="punctuation">(</span>label<span class="operator">=</span>node<span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">\</span> <span class="comment">#节点上做文字标记。label指定内容，这里指定节点上标记节点号，可以用这个确定树图上对应的节点号</span></span><br><span class="line"><span class="operator">+</span> geom_label2<span class="punctuation">(</span>aes<span class="punctuation">(</span>label<span class="operator">=</span>node<span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#节点上做标签标记。label指定内容，这里指定节点上标记节点号。</span></span><br><span class="line"><span class="operator">+</span> geom_cladelabel<span class="punctuation">(</span><span class="number">20</span><span class="punctuation">,</span>label<span class="operator">=</span><span class="string">&quot;legumes&quot;</span><span class="punctuation">,</span>angle<span class="operator">=</span><span class="number">90</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#用条带和文本注释一个clade(node20)，label指定文本内容，angle指定文本角度</span></span><br><span class="line"><span class="operator">+</span> geom_strip<span class="punctuation">(</span><span class="number">9</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">,</span>label<span class="operator">=</span><span class="string">&quot;legumes&quot;</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#用条带指定node9到node10的位置，label指定文字内容</span></span><br><span class="line"><span class="operator">+</span> geom_hilight<span class="punctuation">(</span>node<span class="operator">=</span><span class="number">20</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#用矩形高亮node20号分支，用法和geom_highlight()好像是一样的</span></span><br><span class="line"><span class="operator">+</span> geom_range<span class="punctuation">(</span><span class="string">&quot;length_0.95_HPD&quot;</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#在节点上画长条形的分歧时间的95%置信范围，值来自树文件中的length_0.95_HPD注释值</span></span><br><span class="line"><span class="operator">+</span> geom_taxallink<span class="punctuation">(</span>taxa1<span class="operator">=</span><span class="number">12</span><span class="punctuation">,</span> taxa2<span class="operator">=</span><span class="number">20</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#用曲线连接node12和node20</span></span><br><span class="line"><span class="operator">+</span> geom_treescale<span class="punctuation">(</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#添加比例尺</span></span><br><span class="line"><span class="operator">+</span> xlim<span class="punctuation">(</span><span class="literal">NA</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#如果内容超出边界，就用xlim拓展显示x轴的范围</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常用注释参数<br>包含注释函数的常用参数用法</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggtree<span class="punctuation">(</span>tree<span class="punctuation">,</span> layout<span class="operator">=</span><span class="string">&quot;circular&quot;</span><span class="punctuation">,</span> size<span class="operator">=</span><span class="number">0.8</span><span class="punctuation">,</span> branch.length<span class="operator">=</span><span class="string">&#x27;none&#x27;</span><span class="punctuation">)</span> <span class="punctuation">\</span> <span class="comment">#画树，layout指定布局类型，默认是rectangular；size指定枝的粗细；branch.length指定无枝长信息  </span></span><br><span class="line"><span class="operator">+</span> geom_tiplab<span class="punctuation">(</span>color<span class="operator">=</span><span class="string">&quot;black&quot;</span><span class="punctuation">,</span> size <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span> hjust <span class="operator">=</span> <span class="operator">-</span><span class="number">0.1</span><span class="punctuation">,</span> align<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">,</span> linesize<span class="operator">=</span><span class="number">0.7</span><span class="punctuation">)</span> <span class="punctuation">\</span> <span class="comment"># 末端节点标上物种，size文字大小，hjust是离进化枝线条的距离，align=T文字间左对齐，linesize设置虚线尺寸。</span></span><br><span class="line"><span class="operator">+</span> geom_rootedge<span class="punctuation">(</span>rootedge <span class="operator">=</span> <span class="number">1</span><span class="punctuation">,</span>size<span class="operator">=</span><span class="number">1</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#添加根节点的枝长线，如果树文件中有根节点枝长则直接可使用，否则可以用rootedge设置根节点枝长(不设置为0)，size设置粗细。结合xlim来显示。</span></span><br><span class="line"><span class="operator">+</span> geom_point2<span class="punctuation">(</span>color<span class="operator">=</span><span class="string">&quot;#6FE1F8&quot;</span><span class="punctuation">,</span> size<span class="operator">=</span><span class="number">5</span><span class="punctuation">,</span> alpha<span class="operator">=</span><span class="number">0.7</span><span class="punctuation">)</span> <span class="punctuation">\</span> <span class="comment">#所有节点上标记圆点，配色和透明度</span></span><br><span class="line"><span class="operator">+</span> geom_point2<span class="punctuation">(</span>aes<span class="punctuation">(</span>subset<span class="operator">=</span><span class="punctuation">(</span>node<span class="operator">==</span><span class="number">16</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> color<span class="operator">=</span><span class="string">&#x27;darkgreen&#x27;</span><span class="punctuation">,</span> size<span class="operator">=</span><span class="number">5</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#在16号节点标记绿色圆点。其中subset是取子集，符合条件的才注释；color设置颜色，size设置大小。</span></span><br><span class="line"><span class="operator">+</span> geom_text2<span class="punctuation">(</span>aes<span class="punctuation">(</span>label<span class="operator">=</span>branch.length<span class="punctuation">,</span>hjust<span class="operator">=</span><span class="operator">-</span><span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">,</span>size<span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span> fontface <span class="operator">=</span> <span class="string">&quot;bold&quot;</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#节点上标记枝长；size设置大小，fontface设置文本加粗显示</span></span><br><span class="line"><span class="operator">+</span> geom_text2<span class="punctuation">(</span>aes<span class="punctuation">(</span>subset<span class="operator">=</span><span class="operator">!</span>isTip<span class="punctuation">,</span> label<span class="operator">=</span>node<span class="punctuation">)</span><span class="punctuation">,</span> hjust<span class="operator">=</span><span class="operator">-</span><span class="number">0.3</span><span class="punctuation">,</span> size<span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span> color<span class="operator">=</span><span class="string">&quot;deepskyblue4&quot;</span><span class="punctuation">)</span>  <span class="punctuation">\</span> <span class="comment">#非tip节点标记上node号</span></span><br><span class="line"><span class="operator">+</span> geom_label2<span class="punctuation">(</span>aes<span class="punctuation">(</span>x<span class="operator">=</span><span class="number">0.79</span><span class="punctuation">,</span>label<span class="operator">=</span>D<span class="punctuation">)</span><span class="punctuation">,</span>color<span class="operator">=</span><span class="string">&quot;black&quot;</span><span class="punctuation">,</span>vjust<span class="operator">=</span><span class="operator">-</span><span class="number">0.2</span><span class="punctuation">,</span>fill<span class="operator">=</span><span class="string">&quot;#7FFF00&quot;</span><span class="punctuation">,</span>alpha<span class="operator">=</span><span class="number">0.6</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#做标记,aes里的x指定位置，label指定内容</span></span><br><span class="line"><span class="operator">+</span> geom_strip<span class="punctuation">(</span><span class="number">9</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">,</span>label<span class="operator">=</span><span class="string">&quot;legumes&quot;</span><span class="punctuation">,</span>offset <span class="operator">=</span> <span class="number">0.06</span><span class="punctuation">,</span>offset.text <span class="operator">=</span> <span class="number">0.012</span><span class="punctuation">,</span>color <span class="operator">=</span> <span class="string">&quot;#FF6100&quot;</span><span class="punctuation">,</span>barsize <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span>fontsize <span class="operator">=</span> <span class="number">5</span><span class="punctuation">,</span>angle <span class="operator">=</span> <span class="number">90</span><span class="punctuation">,</span>hjust <span class="operator">=</span> <span class="number">0.5</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#用条带指定node9和node10之间的分支clade，label指定文字内容，offset指定条带和文字与末端节点的距离，offset.text指定文字与条带的距离，barsize指定条带尺寸，fontsize指定文字尺寸，hjust指定文字位置</span></span><br><span class="line"><span class="operator">+</span> geom_hilight<span class="punctuation">(</span>node<span class="operator">=</span><span class="number">15</span><span class="punctuation">,</span>fill<span class="operator">=</span><span class="string">&quot;firebrick&quot;</span><span class="punctuation">,</span>alpha<span class="operator">=</span><span class="number">0.6</span><span class="punctuation">)</span> <span class="punctuation">\</span><span class="comment">#用矩形高亮一个分支</span></span><br><span class="line"><span class="operator">+</span> geom_range<span class="punctuation">(</span><span class="string">&quot;length_0.95_HPD&quot;</span><span class="punctuation">,</span> color<span class="operator">=</span><span class="string">&#x27;red&#x27;</span><span class="punctuation">,</span> size<span class="operator">=</span><span class="number">2</span><span class="punctuation">,</span> alpha<span class="operator">=</span><span class="number">.5</span><span class="punctuation">,</span> center<span class="operator">=</span><span class="string">&#x27;length&#x27;</span><span class="punctuation">)</span> <span class="comment">#在节点上画长条形的分歧时间的95%置信范围，值来自树文件中的length_0.95_HPD注释值，让中心点位于length注释值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其他设置</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggtree<span class="punctuation">(</span>tree<span class="punctuation">)</span></span><br><span class="line"><span class="operator">+</span> scale_x_reverse<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment">#反转x轴</span></span><br><span class="line"><span class="operator">+</span> coord_flip<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment">#置换x轴和y轴</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-2-2-3-改变树的结构"><a href="#2-2-2-3-改变树的结构" class="headerlink" title="2.2.2.3. 改变树的结构"></a>2.2.2.3. 改变树的结构</h4><p>改变树的结构包括取子树(viewClade)，坍塌(collapse)，扩展(expand)，旋转(rotate)，分组(groupClade)等操作，下面两种函数用法是等价的：</p>
<ul>
<li>rotate(p,node&#x3D;12)</li>
<li>p %&gt;% rotate(node&#x3D;12)</li>
</ul>
<p>当需要多次改变树的结构时，推荐第二种用法，比如<code>p2 &lt;- p1 %&gt;% flip(37,48) %&gt;% flip(3,4) %&gt;% flip(13,14) %&gt;% flip(25,26) %&gt;% flip(28,29) %&gt;% flip(55,56)</code>即可依次改变。</p>
<ol>
<li><p>显示子树</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p <span class="operator">&lt;-</span> ggtree<span class="punctuation">(</span>tree<span class="punctuation">)</span><span class="operator">+</span>geom_tiplab<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">viewClade<span class="punctuation">(</span>p<span class="punctuation">,</span> MRCA<span class="punctuation">(</span>p<span class="punctuation">,</span> <span class="number">10</span>，<span class="number">15</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#显示10-15节点的子树部分</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>旋转枝</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">flip<span class="punctuation">(</span>p<span class="punctuation">,</span> <span class="number">15</span><span class="punctuation">,</span> <span class="number">17</span><span class="punctuation">)</span> <span class="comment">#交换15号节点和17号节点代表的枝的位置，15和17号共享同一个祖先节点16。</span></span><br><span class="line">rotate<span class="punctuation">(</span>p<span class="punctuation">,</span> <span class="number">16</span><span class="punctuation">)</span> <span class="comment">#在16号节点把上下两个枝镜像翻转180°，与flip的区别是rotate同时改变了15和17号节点内所有子节点的顺序</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>坍塌和扩展枝</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p2 <span class="operator">&lt;-</span> collapse<span class="punctuation">(</span>p<span class="punctuation">,</span> node<span class="operator">=</span><span class="number">16</span><span class="punctuation">)</span> <span class="operator">+</span> geom_point2<span class="punctuation">(</span>aes<span class="punctuation">(</span>subset<span class="operator">=</span><span class="punctuation">(</span>node<span class="operator">==</span><span class="number">16</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> shape<span class="operator">=</span><span class="number">21</span><span class="punctuation">,</span> size<span class="operator">=</span><span class="number">5</span><span class="punctuation">,</span> fill<span class="operator">=</span><span class="string">&#x27;green&#x27;</span><span class="punctuation">)</span> <span class="comment">#坍塌21号节点，用绿色圆点标记</span></span><br><span class="line">expand<span class="punctuation">(</span>p2<span class="punctuation">,</span> node<span class="operator">=</span><span class="number">21</span><span class="punctuation">)</span> <span class="comment">#把p2坍塌的21号节点扩展开</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>缩小和放大枝</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">scaleClade<span class="punctuation">(</span>p<span class="punctuation">,</span> node<span class="operator">=</span><span class="number">15</span><span class="punctuation">,</span> scale<span class="operator">=</span><span class="number">0.1</span><span class="punctuation">)</span> <span class="comment">#缩小15号节点及子节点的枝，压缩尺度为0.1，拓扑和枝长仍然保留，但枝间距缩小为原来的0.1倍。常用于tip比较多的系统树上缩小不重要的部分，但不坍塌。</span></span><br><span class="line">scaleClade<span class="punctuation">(</span>p<span class="punctuation">,</span> node<span class="operator">=</span><span class="number">17</span><span class="punctuation">,</span> scale<span class="operator">=</span><span class="number">1.5</span><span class="punctuation">)</span> <span class="comment">#放大17号节点及子节点的枝，放大尺度为1.5，枝间距放大为原来的1.5倍。常用于突出重要的枝。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分组<br>单系分组用groupClade，多系&#x2F;并系分组用groupOTU。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p3 <span class="operator">&lt;-</span> groupClade<span class="punctuation">(</span>p<span class="punctuation">,</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">15</span><span class="punctuation">,</span><span class="number">17</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#节点15及子节点分为一组，节点17及子节点分为一组，赋予group属性，适用单系分组。</span></span><br><span class="line">ggtree<span class="punctuation">(</span>p3<span class="punctuation">,</span> aes<span class="punctuation">(</span>color<span class="operator">=</span>group<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> scale_color_manual<span class="punctuation">(</span>values<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;black&quot;</span><span class="punctuation">,</span> <span class="string">&quot;red&quot;</span><span class="punctuation">,</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#用group属性注释枝的颜色，默认颜色为黑色，15节点代表的组为红色，17节点代表的组为蓝色</span></span><br><span class="line"></span><br><span class="line">p4 <span class="operator">&lt;-</span> groupOTU<span class="punctuation">(</span>p<span class="punctuation">,</span> focus<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;A&quot;</span><span class="punctuation">,</span><span class="string">&quot;D&quot;</span><span class="punctuation">,</span><span class="string">&quot;G&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#A,D,G分为一组，赋予group属性</span></span><br><span class="line">ggtree<span class="punctuation">(</span>p4<span class="punctuation">,</span> aes<span class="punctuation">(</span>color<span class="operator">=</span>group<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#用group属性注释枝的颜色，A,D,G所在的枝和共享的枝一种颜色，其他枝另一种颜色。A,D,G可以是多系/并系。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-2-2-4-可视化数据并与系统发育树关联-——-facet-plot"><a href="#2-2-2-4-可视化数据并与系统发育树关联-——-facet-plot" class="headerlink" title="2.2.2.4. 可视化数据并与系统发育树关联 —— facet_plot"></a>2.2.2.4. 可视化数据并与系统发育树关联 —— facet_plot</h4><p>可能有不同的数据类型，并希望将它们可视化并与树关联对齐，可用facet_plot函数来处理。</p>
<p>可视化图的类型：点图dotplot&#x2F;直方图barplot&#x2F;堆叠图stacked barplot&#x2F;热图&#x2F;箱线图boxplot。</p>
<p>ggtree中定义了操作符%&lt;+%，来添加数据。添加之后，用户的数据对ggplot是可见的。可以用于树的注释。</p>
<ol>
<li>可视化点图dotplot —— geom_point<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tr <span class="operator">&lt;-</span> rtree<span class="punctuation">(</span><span class="number">30</span><span class="punctuation">)</span> <span class="comment"># 用treeio的rtree函数生成30个tip的随机树  </span></span><br><span class="line">p <span class="operator">&lt;-</span> ggtree<span class="punctuation">(</span>tr<span class="punctuation">)</span></span><br><span class="line">d1 <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>id<span class="operator">=</span>tr<span class="operator">$</span>tip.label<span class="punctuation">,</span> location<span class="operator">=</span>sample<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;GZ&quot;</span><span class="punctuation">,</span> <span class="string">&quot;HK&quot;</span><span class="punctuation">,</span> <span class="string">&quot;CZ&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">30</span><span class="punctuation">,</span> replace<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#从(&quot;GZ&quot;, &quot;HK&quot;, &quot;CZ&quot;)中随机生成30个采样地点location数据  </span></span><br><span class="line">p1<span class="operator">&lt;-</span> p <span class="operator">%&lt;+%</span> d1 <span class="operator">+</span> geom_tippoint<span class="punctuation">(</span>aes<span class="punctuation">(</span>color<span class="operator">=</span>location<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#给树的端点根据location着色  </span></span><br><span class="line"></span><br><span class="line">d2 <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>id<span class="operator">=</span>tr<span class="operator">$</span>tip.label<span class="punctuation">,</span> val<span class="operator">=</span>rnorm<span class="punctuation">(</span><span class="number">30</span><span class="punctuation">,</span> sd<span class="operator">=</span><span class="number">3</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#生成两列数据，分别是tip.label和随机生成的30个sd为3的数据值，均值mean默认为0  </span></span><br><span class="line">p2 <span class="operator">&lt;-</span> facet_plot<span class="punctuation">(</span>p1<span class="punctuation">,</span> panel<span class="operator">=</span><span class="string">&quot;dot&quot;</span><span class="punctuation">,</span> data<span class="operator">=</span>d2<span class="punctuation">,</span> geom<span class="operator">=</span>geom_point<span class="punctuation">,</span> aes<span class="punctuation">(</span>x<span class="operator">=</span>val<span class="punctuation">)</span><span class="punctuation">,</span> color<span class="operator">=</span><span class="string">&#x27;firebrick&#x27;</span><span class="punctuation">)</span> <span class="operator">+</span> theme_tree2<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment">#用ggtree的facet_plot的geom_point函数画点图  </span></span><br></pre></td></tr></table></figure></li>
</ol>
<img src="https://guangchuangyu.github.io/blog_images/Bioconductor/ggtree/facet_plot_dot2.png" width=100% height=70% title="facet_plot_p2.png" align=center/>

<p><strong><p align="center">Figure 1. p2 dotplot</strong><br>from <a href="https://guangchuangyu.github.io/blog_images/Bioconductor/ggtree/facet_plot_dot2.png">guangchuangyu’s blog</a></p></p>
<ol start="2">
<li>可视化堆叠直方图stacked barplot —— geom_barh<br>大多ggplot2的geom绘制垂直版本的图形对象，通过ggstance包可以制作水平版本的数据图geom，方便画直方图&#x2F;堆叠直方图&#x2F;热图&#x2F;箱线图与系统发育树对应。<br>包括geom_barh()，geom_histogramh()，geom_linerangeh()，geom_pointrangeh()，geom_errorbarh()，geom_crossbarh()，geom_boxploth()，geom_violinh()。<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggstance<span class="punctuation">)</span></span><br><span class="line">d3 <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>id <span class="operator">=</span> <span class="built_in">rep</span><span class="punctuation">(</span>tr<span class="operator">$</span>tip.label<span class="punctuation">,</span> each<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span><span class="punctuation">,</span>  </span><br><span class="line">					value <span class="operator">=</span> <span class="built_in">abs</span><span class="punctuation">(</span>rnorm<span class="punctuation">(</span><span class="number">60</span><span class="punctuation">,</span> mean<span class="operator">=</span><span class="number">100</span><span class="punctuation">,</span> sd<span class="operator">=</span><span class="number">50</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>  </span><br><span class="line">					category <span class="operator">=</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="built_in">LETTERS</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="number">30</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#随机生成3列数据，分别是tip.label,随机值,代表category的A/B  </span></span><br><span class="line">p3 <span class="operator">&lt;-</span> facet_plot<span class="punctuation">(</span>p2<span class="punctuation">,</span> panel <span class="operator">=</span> <span class="string">&#x27;Stacked Barplot&#x27;</span><span class="punctuation">,</span> data <span class="operator">=</span> d3<span class="punctuation">,</span>   </span><br><span class="line">				geom <span class="operator">=</span> geom_barh<span class="punctuation">,</span> <span class="comment">#用geom_barh画水平版本的堆叠直方图  </span></span><br><span class="line">				mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> value<span class="punctuation">,</span> fill <span class="operator">=</span> as.factor<span class="punctuation">(</span>category<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>   </span><br><span class="line">				stat<span class="operator">=</span><span class="string">&#x27;identity&#x27;</span> <span class="punctuation">)</span>   </span><br></pre></td></tr></table></figure></li>
</ol>
<img src="https://guangchuangyu.github.io/blog_images/Bioconductor/ggtree/facet_plot_bar2.png" title="facet_plot_p3.png" width="100%" height="70%" />

<p><strong><p align="center">Figure 2. p3 barplot</strong><br>from <a href="https://guangchuangyu.github.io/blog_images/Bioconductor/ggtree/facet_plot_bar2.png">guangchuangyu blog</a></p></p>
<ol start="3">
<li>可视化箱线图boxplot —— geom_boxploth<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">d4 <span class="operator">=</span> data.frame<span class="punctuation">(</span>id<span class="operator">=</span><span class="built_in">rep</span><span class="punctuation">(</span>tr<span class="operator">$</span>tip.label<span class="punctuation">,</span> each<span class="operator">=</span><span class="number">20</span><span class="punctuation">)</span><span class="punctuation">,</span>   </span><br><span class="line">				val<span class="operator">=</span>as.vector<span class="punctuation">(</span>sapply<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">30</span><span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>i<span class="punctuation">)</span>   </span><br><span class="line">								rnorm<span class="punctuation">(</span><span class="number">20</span><span class="punctuation">,</span> mean<span class="operator">=</span>i<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span>  </span><br><span class="line">				<span class="punctuation">)</span>				</span><br><span class="line">p4 <span class="operator">&lt;-</span> facet_plot<span class="punctuation">(</span>p3<span class="punctuation">,</span> panel<span class="operator">=</span><span class="string">&quot;Boxplot&quot;</span><span class="punctuation">,</span> data<span class="operator">=</span>d4<span class="punctuation">,</span> geom_boxploth<span class="punctuation">,</span>   </span><br><span class="line">			mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x<span class="operator">=</span>val<span class="punctuation">,</span> group<span class="operator">=</span>label<span class="punctuation">,</span> color<span class="operator">=</span>location<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#用geom_boxploth画水平版本的箱线图</span></span><br></pre></td></tr></table></figure></li>
</ol>
<img src="https://guangchuangyu.github.io/blog_images/Bioconductor/ggtree/facet_plot_boxplot2.png" title="facet_plot_p4.png" width="100%" height="70%" />

<p><strong><p align="center">Figure 3. p4 boxplot</strong><br>from <a href="https://guangchuangyu.github.io/blog_images/Bioconductor/ggtree/facet_plot_boxplot2.png">guangchuangyu blog</a></p></p>
<h4 id="2-2-2-5-时序树-chronogram"><a href="#2-2-2-5-时序树-chronogram" class="headerlink" title="2.2.2.5. 时序树(chronogram)"></a>2.2.2.5. 时序树(chronogram)</h4><p>时序树上每个节点的数字代表的是分歧时间，端点一般对齐（因为端点的所有样本都对应当下的采样时间），画时序图需要先有时间标定的树文件，树上的枝长代表时长，一般会再添加时间尺度轴。</p>
<ol>
<li>画时序树</li>
</ol>
<ul>
<li>通过<code>ggtree(tree, mrsd=&quot;2020-01-01&quot;)</code>中的mrsd指定采样日期(即tip端点时间)，mrsd代表most recent sampling date,指定采样时间</li>
<li>通过<code>+theme_tree2()</code>来在树下添加一个时间尺度轴，默认是以年为单位</li>
<li>可用deeptime包向ggtree添加地质时间尺度</li>
</ul>
<p>实现采样时间(mrsd)和内部节点时间来缩放树</p>
<ol start="2">
<li>读取时序树<br>读取时序树与读取任何系统发育树的方法一样，读取任何时间代表枝长的树文件即可。</li>
</ol>
<ul>
<li>可以用treeio解析估计时间的软件(例如beast，r8s)输出的时序树；</li>
<li>也可以把时间写入枝长位置，以文本的形式读取时序树；</li>
</ul>
<ol start="3">
<li>时间尺度轴的变化</li>
</ol>
<ul>
<li><p>直接用<code>theme_tree2() +scale_x_continuous()</code>来设置时间尺度轴的显示</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggtree<span class="punctuation">(</span>tree<span class="punctuation">)</span> <span class="operator">+</span> theme_tree2<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span>scale_x_continuous<span class="punctuation">(</span>limits<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span>breaks <span class="operator">=</span> seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span>labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">4</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span>expand <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">0.1</span><span class="punctuation">,</span><span class="number">0.1</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> geom_treescale<span class="punctuation">(</span>x<span class="operator">=</span><span class="number">3</span><span class="punctuation">,</span>y<span class="operator">=</span><span class="number">20</span><span class="punctuation">,</span>color<span class="operator">=</span><span class="string">&quot;red&quot;</span><span class="punctuation">)</span> <span class="comment">#画树，theme_tree2()在树下方加时间尺度轴，这里假设是[0,4]，用scale_x_continuous()限制时间尺度轴的显示和刻度，limits=c(-1,4)设置尺度轴显示范围为-1到4(同样也是图的横向显示范围)，breaks设置值的显示范围为0到4，每隔1显示一个值，labels设置显示的值，可以直接设定c(4,3,2,1,0)使时间尺度轴倒序显示，expand设置绘图左右范围的空白大小；geom_treescale()在右上角添加比例尺</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用<code>revts</code>设置时间尺度轴翻转</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">p <span class="operator">&lt;-</span> ggtree<span class="punctuation">(</span>tree<span class="punctuation">)</span> <span class="operator">+</span> theme_tree2<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">p1 <span class="operator">&lt;-</span> revts<span class="punctuation">(</span>p<span class="punctuation">)</span> <span class="comment">#翻转时间尺度轴，比如[0,4]翻转成[-4,0]；注意使用revts后，xlim的范围也要相应调整。</span></span><br><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span> <span class="comment">#scale_x_continuous是ggplot2的函数</span></span><br><span class="line">p2 <span class="operator">&lt;-</span> p <span class="operator">+</span> scale_x_continuous<span class="punctuation">(</span>labels <span class="operator">=</span> <span class="built_in">abs</span><span class="punctuation">)</span> <span class="comment">#把时间尺度轴的标签显示为绝对值abs的形式，scale_x_continuous是ggplot的函数</span></span><br><span class="line">p3 <span class="operator">&lt;-</span> revts<span class="punctuation">(</span>p2<span class="punctuation">)</span> <span class="comment">#把p2时间尺度轴翻转，由于p2用了绝对值，效果是把[0,4]翻转成了[4,0]</span></span><br><span class="line">p4 <span class="operator">&lt;-</span> p1 <span class="operator">+</span> scale_x_continuous<span class="punctuation">(</span>breaks<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">4</span><span class="operator">:</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span> labels<span class="operator">=</span><span class="built_in">abs</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">4</span><span class="operator">:</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#把时间尺度轴的标签显示为绝对值abs的形式，即把[-4,0]显示成[4,0]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-2-6-系统发育网-phylogenetic-reticulum-——-geom-taxalink"><a href="#2-2-2-6-系统发育网-phylogenetic-reticulum-——-geom-taxalink" class="headerlink" title="2.2.2.6. 系统发育网(phylogenetic reticulum) —— geom_taxalink"></a>2.2.2.6. 系统发育网(phylogenetic reticulum) —— geom_taxalink</h4><p>系统发育网一般是在系统发育树绘制的基础上添加物种间的杂交和基因流关系。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">ggtree<span class="punctuation">(</span>tree<span class="punctuation">)</span> <span class="operator">+</span> geom_tiplab<span class="punctuation">(</span><span class="punctuation">)</span>  </span><br><span class="line"><span class="operator">+</span> geom_taxalink<span class="punctuation">(</span><span class="string">&#x27;A&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;E&#x27;</span><span class="punctuation">)</span> <span class="comment">#在tipA和E之间添加关联线，默认是黑色实线。  </span></span><br><span class="line"><span class="operator">+</span> geom_taxalink<span class="punctuation">(</span><span class="string">&#x27;F&#x27;</span><span class="punctuation">,</span> <span class="string">&#x27;K&#x27;</span><span class="punctuation">,</span> color<span class="operator">=</span><span class="string">&#x27;red&#x27;</span><span class="punctuation">,</span> linetype <span class="operator">=</span> <span class="string">&#x27;dashed&#x27;</span><span class="punctuation">,</span> arrow<span class="operator">=</span>grid<span class="operator">::</span>arrow<span class="punctuation">(</span><span class="built_in">length</span><span class="operator">=</span>grid<span class="operator">::</span>unit<span class="punctuation">(</span><span class="number">0.02</span><span class="punctuation">,</span> <span class="string">&quot;npc&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#在tipF和K之间添加关联线，红色虚线，并添加F到K的箭头，箭头大小为0.02npc。  </span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-7-多棵图共同展示"><a href="#2-2-2-7-多棵图共同展示" class="headerlink" title="2.2.2.7. 多棵图共同展示"></a>2.2.2.7. 多棵图共同展示</h4><ol>
<li><p>multiPhylo图<br>多棵树并列展示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">trees <span class="operator">&lt;-</span> lapply<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span> <span class="number">20</span><span class="punctuation">,</span> <span class="number">40</span><span class="punctuation">)</span><span class="punctuation">,</span> rtree<span class="punctuation">)</span> <span class="comment">#随机生成3棵树，节点分别为10，20，40  </span></span><br><span class="line"><span class="built_in">class</span><span class="punctuation">(</span>trees<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="string">&quot;multiPhylo&quot;</span>  </span><br><span class="line">ggtree<span class="punctuation">(</span>trees<span class="punctuation">)</span> <span class="operator">+</span> facet_wrap<span class="punctuation">(</span><span class="operator">~</span>.id<span class="punctuation">,</span> scale<span class="operator">=</span><span class="string">&quot;free&quot;</span><span class="punctuation">)</span> <span class="operator">+</span> geom_tiplab<span class="punctuation">(</span><span class="punctuation">)</span> <span class="comment">#分面展示3棵树  </span></span><br><span class="line"></span><br><span class="line">btrees <span class="operator">=</span> read.tree<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;extdata/RAxML&quot;</span><span class="punctuation">,</span> <span class="string">&quot;RAxML_bootstrap.H3&quot;</span><span class="punctuation">,</span> package<span class="operator">=</span><span class="string">&quot;ggtree&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#读取系统的100棵树  </span></span><br><span class="line">ggtree<span class="punctuation">(</span>btrees<span class="punctuation">)</span> <span class="operator">+</span> facet_wrap<span class="punctuation">(</span><span class="operator">~</span>.id<span class="punctuation">,</span> ncol<span class="operator">=</span><span class="number">10</span><span class="punctuation">)</span> <span class="comment">#分面展示100棵树，每行10棵。  </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DensityTree图<br>多棵树重叠展示。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">trees <span class="operator">&lt;-</span> read.tree<span class="punctuation">(</span>system.file<span class="punctuation">(</span><span class="string">&quot;extdata/RAxML&quot;</span><span class="punctuation">,</span> <span class="string">&quot;RAxML_bootstrap.H3&quot;</span><span class="punctuation">,</span> package<span class="operator">=</span><span class="string">&quot;treeio&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#读取系统自带树文件RAxML_bootstrap.H3，包含100棵树。  </span></span><br><span class="line">ggdensitree<span class="punctuation">(</span>trees<span class="punctuation">,</span> alpha<span class="operator">=</span><span class="number">.3</span><span class="punctuation">,</span> colour<span class="operator">=</span><span class="string">&#x27;steelblue&#x27;</span><span class="punctuation">)</span> <span class="operator">+</span> geom_tiplab<span class="punctuation">(</span>size<span class="operator">=</span><span class="number">3</span><span class="punctuation">)</span> <span class="operator">+</span> xlim<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">45</span><span class="punctuation">)</span> <span class="comment">#重叠多棵树。bootstrap值高的线条一致性，低的线条较乱。  </span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="2-2-2-8-一个生成树的例子"><a href="#2-2-2-8-一个生成树的例子" class="headerlink" title="2.2.2.8. 一个生成树的例子"></a>2.2.2.8. 一个生成树的例子</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>treeio<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ggtree<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">treetext<span class="operator">&lt;-</span><span class="string">&quot;((((Mc:0.418672[&amp;&amp;NHX:I=+5728:D=-1170:G=Malvids],Eg:0.201388[&amp;&amp;NHX:I=+1420:D=-2519:G=Malvids])[&amp;&amp;NHX:C=1]:0.148853,((Pt:0.219587[&amp;&amp;NHX:I=+5355:D=-1003:G=Fabids],(Cs:0.209405[&amp;&amp;NHX:I=+1026:D=-3516:G=Malvids],(Gr:0.224188[&amp;&amp;NHX:I=+4875:D=-998:G=Malvids],At:0.492461[&amp;&amp;NHX:I=+1776:D=-2891:G=Malvids]):0.027774[&amp;&amp;NHX:C=2]):0.012564[&amp;&amp;NHX:C=3]):0.019343[&amp;&amp;NHX:C=4],(Pp:0.194515[&amp;&amp;NHX:I=+1159:D=-2949:G=Fabids],(Mt:0.354580[&amp;&amp;NHX:I=+3310:D=-1984:G=Fabids],Cl:0.338644[&amp;&amp;NHX:I=+794:D=-3735:G=Fabids]):0.022063[&amp;&amp;NHX:C=5]):0.019111[&amp;&amp;NHX:C=6]):0.011710[&amp;&amp;NHX:C=7]):0.029914[&amp;&amp;NHX:C=8],Vv:0.169100[&amp;&amp;NHX:I=+1522:D=-3045:G=Vitales]):0.241611[&amp;&amp;NHX:C=9],Mg:0.241611[&amp;&amp;NHX:I=+2278:D=-1909:G=Asterids])[&amp;&amp;NHX:C=10];&quot;</span>  </span><br><span class="line">tree <span class="operator">&lt;-</span> read.nhx<span class="punctuation">(</span>textConnection<span class="punctuation">(</span>treetext<span class="punctuation">)</span><span class="punctuation">)</span>  </span><br><span class="line"></span><br><span class="line">p1 <span class="operator">&lt;-</span> ggtree<span class="punctuation">(</span>tree<span class="punctuation">,</span>size<span class="operator">=</span><span class="number">0.8</span><span class="punctuation">)</span> <span class="comment">#画树，size指定线条粗细  </span></span><br><span class="line"><span class="operator">+</span> geom_tiplab<span class="punctuation">(</span>color<span class="operator">=</span><span class="string">&quot;black&quot;</span><span class="punctuation">,</span>size <span class="operator">=</span> <span class="number">4.5</span><span class="punctuation">,</span>hjust <span class="operator">=</span> <span class="operator">-</span><span class="number">0.1</span><span class="punctuation">,</span> align<span class="operator">=</span><span class="literal">TRUE</span><span class="punctuation">,</span> linesize<span class="operator">=</span><span class="number">0.7</span><span class="punctuation">)</span> <span class="comment">#添加tiplab-物种名  </span></span><br><span class="line"><span class="operator">+</span> geom_nodepoint<span class="punctuation">(</span>color<span class="operator">=</span><span class="string">&quot;#DCDCDC&quot;</span><span class="punctuation">,</span> size<span class="operator">=</span><span class="number">6</span><span class="punctuation">,</span> alpha<span class="operator">=</span><span class="number">0.9</span><span class="punctuation">)</span> <span class="comment">#节点处添加圆点，指定颜色灰色和尺寸6  </span></span><br><span class="line"><span class="operator">+</span> geom_nodelab<span class="punctuation">(</span>aes<span class="punctuation">(</span>label<span class="operator">=</span>C<span class="punctuation">)</span><span class="punctuation">,</span> size<span class="operator">=</span><span class="number">3.5</span><span class="punctuation">,</span> hjust <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span> <span class="comment">#在注释了标签C的节点处添加C的值，这里的标签C用于注释节点序号  </span></span><br><span class="line"><span class="operator">+</span> geom_label2<span class="punctuation">(</span>aes<span class="punctuation">(</span>x<span class="operator">=</span><span class="number">0.79</span><span class="punctuation">,</span>label<span class="operator">=</span>D<span class="punctuation">)</span><span class="punctuation">,</span>color<span class="operator">=</span><span class="string">&quot;black&quot;</span><span class="punctuation">,</span>vjust<span class="operator">=</span><span class="operator">-</span><span class="number">0.2</span><span class="punctuation">,</span>fill<span class="operator">=</span><span class="string">&quot;lightgreen&quot;</span><span class="punctuation">,</span>alpha<span class="operator">=</span><span class="number">0.6</span><span class="punctuation">)</span> <span class="comment"># 在注释了D的位置添加D的值，这里的标签D用于注释收缩基因的数量，x的值用于指定添加位置。  </span></span><br><span class="line"><span class="operator">+</span> geom_label2<span class="punctuation">(</span>aes<span class="punctuation">(</span>x<span class="operator">=</span><span class="number">0.73</span><span class="punctuation">,</span>label<span class="operator">=</span>I<span class="punctuation">)</span><span class="punctuation">,</span>color<span class="operator">=</span><span class="string">&quot;black&quot;</span><span class="punctuation">,</span>vjust<span class="operator">=</span><span class="operator">-</span><span class="number">0.2</span><span class="punctuation">,</span>fill<span class="operator">=</span><span class="string">&quot;pink&quot;</span><span class="punctuation">,</span>alpha<span class="operator">=</span><span class="number">0.6</span><span class="punctuation">)</span> <span class="comment"># 在注释了I的位置添加I的值，这里的标签I用于注释扩张基因的数量，x的值用于指定添加位置。  </span></span><br><span class="line"><span class="operator">+</span> xlim<span class="punctuation">(</span><span class="literal">NA</span><span class="punctuation">,</span><span class="number">1.1</span><span class="punctuation">)</span> <span class="comment"># 如果物种名或者其他标签超出显示范围，用xlim增大x轴显示。  </span></span><br><span class="line"></span><br><span class="line">p2<span class="operator">&lt;-</span> ggtree<span class="operator">::</span>rotate<span class="punctuation">(</span>p1<span class="punctuation">,</span><span class="number">13</span><span class="punctuation">)</span> <span class="comment">#旋转节点13的上下分支clade  </span></span><br><span class="line">p2<span class="operator">&lt;-</span> p1 <span class="operator">%&gt;%</span> rotate<span class="punctuation">(</span>node<span class="operator">=</span><span class="number">14</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> rotate<span class="punctuation">(</span>node<span class="operator">=</span><span class="number">16</span><span class="punctuation">)</span> <span class="comment"># 旋转节点14和节点16  </span></span><br><span class="line"></span><br><span class="line">p2<span class="operator">+</span>geom_strip<span class="punctuation">(</span><span class="number">10</span><span class="punctuation">,</span><span class="number">10</span><span class="punctuation">,</span>label<span class="operator">=</span><span class="string">&quot;Vitales&quot;</span><span class="punctuation">,</span>offset <span class="operator">=</span> <span class="number">0.14</span><span class="punctuation">,</span> offset.text <span class="operator">=</span><span class="number">0.01</span><span class="punctuation">,</span>color <span class="operator">=</span> <span class="string">&quot;grey31&quot;</span><span class="punctuation">,</span>barsize <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span>fontsize <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span><span class="operator">+</span>geom_strip<span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span><span class="number">7</span><span class="punctuation">,</span>label<span class="operator">=</span><span class="string">&quot;Fabids&quot;</span><span class="punctuation">,</span>offset <span class="operator">=</span> <span class="number">0.14</span><span class="punctuation">,</span> offset.text <span class="operator">=</span><span class="number">0.01</span><span class="punctuation">,</span>color <span class="operator">=</span> <span class="string">&quot;grey31&quot;</span><span class="punctuation">,</span>barsize <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span>fontsize <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span><span class="operator">+</span>geom_strip<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span>label<span class="operator">=</span><span class="string">&quot;Malvids&quot;</span><span class="punctuation">,</span>offset <span class="operator">=</span> <span class="number">0.14</span><span class="punctuation">,</span> offset.text <span class="operator">=</span><span class="number">0.01</span><span class="punctuation">,</span>color <span class="operator">=</span> <span class="string">&quot;grey31&quot;</span><span class="punctuation">,</span>barsize <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span>fontsize <span class="operator">=</span> <span class="number">5</span><span class="punctuation">)</span> <span class="comment"># 给图加上分支clade的条带和文字注释</span></span><br></pre></td></tr></table></figure>

<h1 id="3-reference"><a href="#3-reference" class="headerlink" title="3. reference"></a>3. reference</h1><ol>
<li>ggtree paper：<a href="https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12628">https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12628</a></li>
<li>book_visualization of phylogenetic trees](<a href="https://yulab-smu.top/treedata-book/index.html">https://yulab-smu.top/treedata-book/index.html</a></li>
<li>ggtree tutorial：<a href="https://guangchuangyu.github.io/ggtree-book/chapter-ggtree.html">https://guangchuangyu.github.io/ggtree-book/chapter-ggtree.html</a></li>
<li>treeio tutorial：<a href="https://guangchuangyu.github.io/ggtree-book/chapter-treeio.html">https://guangchuangyu.github.io/ggtree-book/chapter-treeio.html</a></li>
<li>facet_plot：<a href="https://guangchuangyu.github.io/2016/10/facet_plot-a-general-solution-to-associate-data-with-phylogenetic-tree/">https://guangchuangyu.github.io/2016/10/facet_plot-a-general-solution-to-associate-data-with-phylogenetic-tree/</a></li>
<li>不同树的绘制：<a href="https://www.codenong.com/js9fda2b82cedb/">https://www.codenong.com/js9fda2b82cedb/</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>phylogeny</category>
      </categories>
      <tags>
        <tag>R package</tag>
        <tag>biosoft</tag>
        <tag>phylogeny</tag>
        <tag>evolutionary tree</tag>
        <tag>plot</tag>
        <tag>itol</tag>
        <tag>treeio</tag>
        <tag>ggtree</tag>
        <tag>facet_plot</tag>
        <tag>ggstance</tag>
        <tag>phylogenetic reticulum</tag>
        <tag>geom_taxalink</tag>
        <tag>multiPhylo</tag>
        <tag>ggdensitree</tag>
      </tags>
  </entry>
  <entry>
    <title>用PSMC推断有效群体大小历史</title>
    <url>/2022/10/17/bioinfo_psmc/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=2534006&auto=1&height=32"></iframe></div>

<h1 id="1-PSMC"><a href="#1-PSMC" class="headerlink" title="1. PSMC"></a>1. PSMC</h1><p>Pairwise Sequentially Markovian Coalescent (PSMC) 是李恒开发的一款软件，可以通过一个二倍体个体的基因组的分析获得这个个体代表的群体的有效群体大小的历史动态。</p>
<h1 id="2-PSMC分析原理"><a href="#2-PSMC分析原理" class="headerlink" title="2. PSMC分析原理"></a>2. PSMC分析原理</h1><p>通过一个二倍体个体的基因组的等位基因上存在的变异位点计算序列间差异，从而推断序列的分化时间；计算所有等位基因（也可以换成等位片段）的分化时间。认为某个分化时间的等位基因数量越多，代表当时的有效群体大小越大，所以可以通过整个基因组上等位基因的分化时间的分布推断有效群体大小的历史动态。</p>
<ul>
<li>这个算法让人惊叹的点在于，我们可以只从一个个体的基因组上看到群体的进化历史。</li>
<li>有意思的是，前些时候看《自私的基因》那本书的时候，书里的序也详细讲解了PSMC的算法，从等位基因回溯到基因的共同祖先，讲得很清晰，非专业人士也可以读懂，有兴趣的读者可以去看看。</li>
<li>分析人类的有效群体大小历史时，在三百万年有一次共有的高峰，有可能是人类从猩猩中分化出来时期的群体规模高峰期。不过，这么久远的分化区域意味着高度差异的等位基因片段（高度杂合）。这些高度杂合的片段也有可能来自平衡选择，或重测序比对过程中重复序列不正确比对产生的错误SNP。因此，三百万年的高峰可能并不可信。</li>
</ul>
<h1 id="3-PSMC运行"><a href="#3-PSMC运行" class="headerlink" title="3. PSMC运行"></a>3. PSMC运行</h1><h2 id="3-1-文件准备"><a href="#3-1-文件准备" class="headerlink" title="3.1. 文件准备"></a>3.1. 文件准备</h2><ol>
<li>基因组文件：genome.fa</li>
<li>二代测序数据：sample_R1.clean.u.fq和sample_R2.clean.u.fq</li>
</ol>
<h2 id="3-2-运行步骤"><a href="#3-2-运行步骤" class="headerlink" title="3.2. 运行步骤"></a>3.2. 运行步骤</h2><h3 id="3-2-1-准备全基因组二倍体一致序列"><a href="#3-2-1-准备全基因组二倍体一致序列" class="headerlink" title="3.2.1. 准备全基因组二倍体一致序列"></a>3.2.1. 准备全基因组二倍体一致序列</h3><ol>
<li>二代序列mapping</li>
</ol>
<ul>
<li><code>time bwa mem -t 12 genome.fa sample_R1.clean.u.fq sample_R2.clean.u.fq | samtools sort -@ 12 -m 12G &gt; sample_sort.bam</code> 把二代数据mapping到基因组上</li>
</ul>
<ol start="2">
<li>获取二倍体一致序列</li>
</ol>
<ul>
<li><code>samtools mpileup -C50 -uf genome.fa sample_sort.bam | bcftools view --threads 16 -c - | vcfutils.pl vcf2fq -d 10 -D 100 |pgzip -p 12 &gt;diploid.fq.gz</code> 生成全基因组二倍体一致序列diploid.fq.gz</li>
<li><code>bcftools view</code>可以换成<code>bcftools call</code></li>
<li>其中，<code>vcfutils.pl vcf2fq -d 10 -D 100</code>的<code>-d 10</code>参数是最小read depth，作者建议设置成平均depth的三分之一(1&#x2F;3)；<code>-D 100</code>参数是最大read depth，建议设置成平均depth的两倍。</li>
</ul>
<ol start="3">
<li>上一步可分解为以下几步：</li>
</ol>
<ul>
<li><code>samtools mpileup -C50 -uf genome.fa sample_sort.bam | bcftools view --threads 16 -O z -o sample.vcf.gz</code> call snp，得到的是genotype likelihoods的vcf文件</li>
<li><code>bcftools call sample.vcf.gz -c -v --threads 16 -O z -o sample.variants.vcf.gz</code> 生成只有snp和indel的vcf文件，其中-c代表SNP calling选择consensus-caller算法，另可选-m即multiallelic-caller算法（更适合多种allel和罕见变异的情况）。</li>
<li><code>bcftools view -H sample.variants.vcf.gz | wc -l</code> 统计snp数量。snp数量除以基因组大小即可得到估计的杂合度。</li>
<li><code>vcfutils.pl vcf2fq -d 8 -D 50 sample.variants.vcf.gz| pigz -p 12 &gt; diploid.fq.gz</code> 生成二倍体fq文件</li>
</ul>
<h3 id="3-2-2-运行单次PSMC"><a href="#3-2-2-运行单次PSMC" class="headerlink" title="3.2.2. 运行单次PSMC"></a>3.2.2. 运行单次PSMC</h3><ol>
<li>格式转换</li>
</ol>
<ul>
<li><code>fq2psmcfa -q20 diploid.fq.gz &gt; diploid.psmcfa</code> 格式转换</li>
</ul>
<ol start="2">
<li>PSMC运行</li>
</ol>
<ul>
<li><code>nohup psmc -p &quot;4+25*2+4+6&quot; -t15 -N30 -r4 -o diploid.psmc diploid.psmcfa &amp;</code></li>
<li>psmc计算二倍体间序列差异</li>
</ul>
<ol start="3">
<li>PSMC参数</li>
</ol>
<ul>
<li>参数-p可根据经验或者近缘类群的文献设定，或者多尝试几个参数看看结果，-t,-N,-r可用默认参数。</li>
<li>-p：代表psmc有效群体大小变化的图随时间变化划分的时间阶段单位数量，例如默认的-p “4+25*2+4+6”表示从古自今依次经历了一个4单位+25个2单位+一个4单位+一个6单位的时期。数字越大需要的计算资源越多。可根据经验调整。</li>
<li>-t：maximum 2N0 coalescent time [15]; 2N0的最大世代时间，代表the upper limit of the TMRCA。</li>
<li>-r: initial theta&#x2F;rho ratio [4]; 起始θ&#x2F;ρ率，默认4。</li>
<li>-N：maximum number of iterations [30]；迭代的最大次数，默认30。</li>
<li>-o：指定输出的diploid.psmcfa文件。</li>
</ul>
<h3 id="3-2-3-运行bootstrap的PSMC【推荐】"><a href="#3-2-3-运行bootstrap的PSMC【推荐】" class="headerlink" title="3.2.3. 运行bootstrap的PSMC【推荐】"></a>3.2.3. 运行bootstrap的PSMC【推荐】</h3><p>如果要运行多次抽样的PSMC，则在上面的格式转换后，先分割长序列，再用for循环语句运行。</p>
<ol>
<li>分割长序列</li>
</ol>
<ul>
<li><code>splitfa diploid.psmcfa &gt; split.psmcfa</code> 若需要做bootstrap需先把太长序列分割</li>
</ul>
<ol start="2">
<li>bootstrap抽样运行PSMC</li>
</ol>
<ul>
<li><code>for i in &#123;1..100&#125;;do nohup psmc -b -p &quot;6+25*2+6+8&quot; -t15 -N30 -r4 -o round$&#123;i&#125;.psmc split.psmcfa &amp;</code> #-b参数表示bootstrap抽样做psmc，重复100次。估计服务器运算能力，可以10个重复作为一批。</li>
</ul>
<ol start="3">
<li>合并结果</li>
</ol>
<ul>
<li><code>cat diploid.psmc round*.psmc &gt;combine.psmc</code> #psmc结果合并</li>
</ul>
<h2 id="3-3-画图"><a href="#3-3-画图" class="headerlink" title="3.3. 画图"></a>3.3. 画图</h2><ol>
<li>运行</li>
</ol>
<ul>
<li><code>psmc_plot.pl -p -g 1 -u 4.79e-9 combine combine.psmc</code></li>
<li>画图，生产combine.eps和combine.pdf。</li>
</ul>
<ol start="2">
<li>参数</li>
</ol>
<ul>
<li>-p：指用epstopdf把esp转化成pdf文件，相当于运行完多加一个<code>epstopdf combined.eps</code>一步。</li>
<li>-g：number of years per generation [25]，指定该物种的平均世代时间（即繁殖一代的时间），比如人的默认为25年，该处值为-g 25；许多草本植物为1年。</li>
<li>-u：absolute mutation rate per nucleotide [2.5e-08]，指定该物种碱基替换率，单位是subst.&#x2F;syn. site&#x2F;year，比如默认水稻的2.5e-08，文献里提到的蕨类4.79e-9(Barker 2009)。参考已有文献对研究类群的替换率的推断，也可由进化树的枝长除以r8s评估该物种的分歧时间得到。</li>
</ul>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li><a href="https://github.com/lh3/psmc">https://github.com/lh3/psmc</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>PSMC</tag>
      </tags>
  </entry>
  <entry>
    <title>用PseudogenePipeline鉴定假基因及后续分析</title>
    <url>/2022/09/07/bioinfo_pseudogene_PseudogenePipeline/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=95370&auto=1&height=32"></iframe></div>

<h1 id="1-假基因"><a href="#1-假基因" class="headerlink" title="1. 假基因"></a>1. 假基因</h1><p>假基因(pseudogene)是类似与功能基因的非功能性DNA片段。大多数是功能基因的多余拷贝，通常是由于移码突变或提前的终止密码子被鉴定为假基因。</p>
<p>由于可能含有启动子元件，假基因有可能产生低水平的转录生成RNA，但通常无法产生功能性的最终蛋白产物。</p>
<h1 id="2-PseudogenePipeline-简介"><a href="#2-PseudogenePipeline-简介" class="headerlink" title="2. PseudogenePipeline 简介"></a>2. PseudogenePipeline 简介</h1><p>PseudogenePipeline是Shiulab开发的一个鉴定假基因的流程包，v1.0.0版本基于python2，v2.0.0版本基于python3。</p>
<h1 id="3-PseudogenePipeline-原理"><a href="#3-PseudogenePipeline-原理" class="headerlink" title="3. PseudogenePipeline 原理"></a>3. PseudogenePipeline 原理</h1><p>在基因组未被注释到基因的区域（基因间隔区）查找与基因相似的片段，大多是没有完整ORF区域或者基因的片段。使用tblastn进行基因转录翻译生成的氨基酸序列和基因组上基因间隔区的比对。</p>
<h1 id="4-PseudogenePipeline-安装"><a href="#4-PseudogenePipeline-安装" class="headerlink" title="4. PseudogenePipeline 安装"></a>4. PseudogenePipeline 安装</h1><h2 id="4-1-依赖-requirements"><a href="#4-1-依赖-requirements" class="headerlink" title="4.1. 依赖-requirements"></a>4.1. 依赖-requirements</h2><ol>
<li>python</li>
<li>RepeatMasker</li>
<li>tfasty：是fasta36包的一部分，version 36及以上 （<a href="https://faculty.virginia.edu/wrpearson/fasta/%EF%BC%89%EF%BC%8C%E5%AE%9E%E6%B5%8B%E7%94%A8%E7%9A%84fasta-36.3.8h%E7%89%88%E6%9C%AC%E3%80%82%E4%B8%8B%E8%BD%BD%E8%A7%A3%E5%8E%8B%E5%8D%B3%E5%8F%AF%E3%80%82">https://faculty.virginia.edu/wrpearson/fasta/），实测用的fasta-36.3.8h版本。下载解压即可。</a></li>
</ol>
<h2 id="4-2-下载"><a href="#4-2-下载" class="headerlink" title="4.2. 下载"></a>4.2. 下载</h2><p>在 <a href="https://github.com/ShiuLab/PseudogenePipeline">https://github.com/ShiuLab/PseudogenePipeline</a> 直接下载PseudogenePipeline，是python脚本包，无需安装即可使用。</p>
<h1 id="5-PseudogenePipeline-使用"><a href="#5-PseudogenePipeline-使用" class="headerlink" title="5. PseudogenePipeline 使用"></a>5. PseudogenePipeline 使用</h1><h2 id="5-1-文件准备"><a href="#5-1-文件准备" class="headerlink" title="5.1. 文件准备"></a>5.1. 文件准备</h2><p>文件包括：</p>
<ol>
<li>genome.fa：基因组文件，建议用repeats.gff为基因组的重复序列做mask后使用genome.repeatmask.fa，以减少计算量</li>
<li>sample.protein.fa：注释的基因对应的蛋白组</li>
<li>tblastn.out：genome.repeatmask.fa和sample.protein.fa进行tblastn获得的输出文件</li>
<li>sample.gff3：基因组的蛋白编码基因注释文件，有具体的格式要求</li>
</ol>
<h3 id="5-1-1-genome-mask文件"><a href="#5-1-1-genome-mask文件" class="headerlink" title="5.1.1. genome mask文件"></a>5.1.1. genome mask文件</h3><p>用注释的重复序列repeats.gff为基因组做genome mask，把重复序列所在位置的序列替换成N，减少假基因注释的计算量。获得masked的基因组文件genome.repeatmask.fa。</p>
<h3 id="5-1-2-tblastn-out文件"><a href="#5-1-2-tblastn-out文件" class="headerlink" title="5.1.2. tblastn.out文件"></a>5.1.2. tblastn.out文件</h3><p>用<code>tblastn</code>为mask的基因组和注释的基因组蛋白序列做比对，比对结果用作PseudogenePipeline的输入。</p>
<ol>
<li>运行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">makeblastdb -in genome.repeatmask.fa -dbtype nucl -out sample # 建库</span><br><span class="line">tblastn -db dample -query sample.proteins.fa -num_threads 4 -out tblastn.out -outfmt 6 # tblastn比对，输出tblastn.out</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>notes</li>
</ol>
<ul>
<li>可能由于基因组大(6G)，多线程会中断，只能单线程，可以把蛋白文件sample.proteins.fa切分成多份，分别单线程tblastn，然后把结果合并。</li>
<li>注意蛋白文件和基因组文件的序列id不能有空格，否则自动去除空格和空格后内容。</li>
</ul>
<h3 id="5-1-3-sample-gff3文件"><a href="#5-1-3-sample-gff3文件" class="headerlink" title="5.1.3. sample.gff3文件"></a>5.1.3. sample.gff3文件</h3><p>gff3文件格式类似普通的gff3格式，共九列。但有很具体的要求，主要是对第九列内容的要求，可参照软件给的例子进行增添修改以符合要求。</p>
<p>具体格式要求：</p>
<ul>
<li>gene行，第九列包含<code>Name=信息</code>，值可与<code>ID=信息</code>一致</li>
<li>mRNA行，第九列包含<code>longest=1</code>或者<code>longest=0</code>信息，用于可变剪切筛选，1代表最长可变剪切，0代表非最长可变剪切。</li>
<li>mRNA,exon,CDS,UTR行，第九列都包含<code>pacid=信息</code>，值可与<code>Parent=信息</code>一致，一个gene内部的所有pacid值应相同。</li>
</ul>
<h2 id="5-2-用PseudogenePipeline鉴定假基因"><a href="#5-2-用PseudogenePipeline鉴定假基因" class="headerlink" title="5.2. 用PseudogenePipeline鉴定假基因"></a>5.2. 用PseudogenePipeline鉴定假基因</h2><ol>
<li>参数文件parameter_file示例</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b_out=/path/to/tblastn.out # 前面准备的tblastn.out文件，&lt;tblastn_output_file&gt;</span><br><span class="line">p_seq=/path/to/sample.proteins.fa # 蛋白序列，&lt;protein_sequence_FASTA_file&gt;</span><br><span class="line">g_seq=/genome.repeatmask.fa # 基因组序列（最好是mask过的） &lt;genome_sequence_FASTA_File&gt;</span><br><span class="line">b_filter=y # 是否做blastout的filter，&lt;filter blastouput? y/n&gt;</span><br><span class="line">b_data=tabular # &lt;define type of blastdata: tabular, blastall, blastplus&gt;</span><br><span class="line">p_codes=/path/to/PseudogenePipeline-master/_pipeline_scripts #&lt;path to ../_pipeline_scripts&gt;</span><br><span class="line">o_codes=/path/to/PseudogenePipeline-master/_pipeline_scripts #&lt;path to ../_pipeline_scripts&gt;</span><br><span class="line">f_dir=/path/to/fasta-36.3.8h/bin #&lt;path to FASTA package install&gt;</span><br><span class="line">f_prog=tfasty36 #&lt;tfasty program name&gt;</span><br><span class="line">blosum=/path/to/PseudogenePipeline-master/_example_files/blosum50.matrix #&lt;path to blosum matrilx file&gt;</span><br><span class="line">gff=/path/to/sample.gff3 # gff3注释文件 &lt;gff_file&gt;</span><br><span class="line">repCut=300 #&lt;RepeatMasker cutoff; integer, recommended 300&gt;</span><br><span class="line">repDiv=30 #&lt;RepeatMakser divergence; integer, recommended 30&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>运行</li>
</ol>
<ul>
<li><code>python2 PseudogenePipeline-master/_wrapper_scripts/CombinedPseudoWrapper.py parameter_file</code></li>
</ul>
<h2 id="5-3-PseudogenePipeline运行结果"><a href="#5-3-PseudogenePipeline运行结果" class="headerlink" title="5.3. PseudogenePipeline运行结果"></a>5.3. PseudogenePipeline运行结果</h2><h3 id="5-3-1-结果文件"><a href="#5-3-1-结果文件" class="headerlink" title="5.3.1. 结果文件"></a>5.3.1. 结果文件</h3><p>在生成的结果目录result下，保存了结果文件，包括三个文件夹。result&#x2F;_intermediate保存着中间文件，result&#x2F;_logs保存着log文件，result&#x2F;_results保存着高置信并通过RepeatMasker过滤的鉴定出来的假基因结果文件。</p>
<h4 id="5-3-1-1-results文件夹中的文件"><a href="#5-3-1-1-results文件夹中的文件" class="headerlink" title="5.3.1.1. _results文件夹中的文件"></a>5.3.1.1. _results文件夹中的文件</h4><p>result&#x2F;_results中的结果文件包括以下文件，每个文件第一行都是以<code>#python</code>开始的生成此文件的命令，其余行才保存了假基因的信息：</p>
<ol>
<li>sample.4col.true.RMfilt.hiConf</li>
</ol>
<ul>
<li>第一行<code>#python</code>开头的是生成此文件运行的命令。</li>
<li>其余行是假基因和位置信息，共四列。第一列是假基因对应的真基因的ID（gene38168）加上假基因位置信息（ctg947|625093-625785）加上其他比对信息，分号分隔；第二列是染色体ID；第三第四列是start和end的坐标。</li>
<li><code>gene38168;ctg947|625093-625785;336-566:693-4;4|0|0|0</code>表示在染色体<code>ctg947</code>的<code>625093-625785</code>位置有一个假基因pseudogene。</li>
<li>对应的真基因是<code>gene38168</code>；<code>336-566</code>和<code>693-4</code>分别是指真基因序列和假基因序列比对上的区域；比对的信息是从tblastn的比对结果中获取的。</li>
<li>真基因<code>gene38168</code>的<strong>氨基酸</strong>序列的<code>336-566</code>位置。</li>
<li>假基因的<code>693-4</code>位置是指在染色体<code>ctg947</code>的<code>625093-625785</code>位置的假基因核酸序列上的第4到693个碱基，由于起始位置比终止位置大，所以是4-693位置的反向互补序列。</li>
<li>下面是文件的部分内容。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gene38168;ctg947|625093-625785;336-566:693-4;4|0|0|0	ctg947	625785	625096</span><br><span class="line">gene04393;ctg8706|272998-273192;228-290:190-4;2|0|1|0	ctg8706	273187	273001</span><br><span class="line">gene10546;ctg5903|105682-105807;115-156:126-4;1|0|0|0	ctg5903	105807	105685</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>sample.4col.true.RMfilt.hiConf.cdnm</li>
</ol>
<ul>
<li>同文件sample.4col.true.RMfilt.hiConf的内容基本一致，区别在于第一列的内容，这里是假基因ID（Ps000001）和对应的真基因ID（gene38168）。</li>
<li>第一行<code>#python</code>开头的是生成此文件运行的命令。</li>
<li>其余行是假基因和位置信息，共四列。</li>
<li>下面是文件的部分内容。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ps000001_gene38168	ctg947	625785	625096</span><br><span class="line">Ps000003_gene04393	ctg8706	273187	273001</span><br><span class="line">Ps000004_gene10546	ctg5903	105807	105685</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>sample.4col.true.RMfilt.hiConf.cdnm.gff</li>
</ol>
<ul>
<li>第一行<code>#python</code>开头的是生成此文件运行的命令。</li>
<li>其余行是假基因的注释信息，gff格式，共九列。</li>
<li>下面是文件的部分内容。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctg947	ShiuLab	pseudogene	625096	625785	.	-	.	ID=Ps000001;Name=Ps000001_gene38168;Derives_from=gene38168;Note=pseudogene_evidence_code_4,0,0,0</span><br><span class="line">ctg8706	ShiuLab	pseudogene	273001	273187	.	-	.	ID=Ps000003;Name=Ps000003_gene04393;Derives_from=gene04393;Note=pseudogene_evidence_code_2,0,1,0</span><br><span class="line">ctg5903	ShiuLab	pseudogene	105685	105807	.	-	.	ID=Ps000004;Name=Ps000004_evm.model.ctg10546.26;Derives_from=gene10546;Note=pseudogene_evidence_code_1,0,0,0</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>sample.4col.true.fa.RMfilt.hiConf</li>
</ol>
<ul>
<li>第一行<code>#python</code>开头的是生成此文件运行的命令。</li>
<li>其余行是假基因的序列信息，fasta格式，序列ID是假基因对应的真基因的ID（gene38168）加上假基因位置信息（ctg947|625093-625785）加上其他比对信息，分号分隔。序列ID同文件sample.4col.true.RMfilt.hiConf的第一列内容一致。</li>
<li>下面是文件的部分内容。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;gene38168;ctg947|625093-625785;336-566:693-4;4|0|0|0</span><br><span class="line">TTGCAGGTTGCAATTTTGATGTCCAAGGACCAAGCACTATATTACGCATGGTTGTTCTCCCTAATAATTTATGAATTACTTAGAAAACCTACCTTGCGCAATGTAGAAGCGTTAGTGCAAACATGGCTCCGTGTCACACAATGCATGTCACGGTCAATTAACTTTAAGAAGGTAGCAAATCGTAAAAGGAGTTGGGAGCGTAGGAGAGCATGAGCTTATCCATGACCCCAGAGGTTTCTTGAGTGCTTTTTGTTGAGTGCATATAATGCAAACATGTTCAAATGTCGCTTGTGAGTGAGTAGAGAAACCTTCCAATACGTATGTGGCAAGGTCTCTCTTGCAATGAAGAAGGTGAGCACAAACATGCGTGTTCCACTTAGTATGGAAACAAAACTGGCAATAGCTCTCAGTAGGCTAGCTTTAGGTGCAGGGCTTGAGATGTTGGGTGGTTTGCATGGCTGTGCAAAGAGCACAAGTTGTAAAGTAGTGATTGATTTTTGTAAGGCAATTGTTACATCAGGTCTTAGGGATTTGTACATTAGGTGGCCTGCCCTCTCATGGCTAGAGACACTAGCAAGTGAGTTTCAAGCTTCAAGATGCATCCCCTTTGTTGCTAGAGCCATAGACAGTTCTCACATCCCTATCATCGCCCCAAGAGACAATCACGTAGATTATTTCAATTGAAAAGGG</span><br><span class="line">&gt;gene04393;ctg8706|272998-273192;228-290:190-4;2|0|1|0</span><br><span class="line">TATATGTCGTGATATCACAGCAATCAATCTATCATTAGAGAACTTAGATGATTTGTATAAGGTGTGTGGGTTCATACATGGCTTGGACATGAAGTACAAGCACAACATACGTACTCAAAACCCCAAAGACCCCATAGATGCTATTTAAGGTTCTCAAATCTATAATGACTCTCTTGATAAGAGGAGC</span><br><span class="line">&gt;gene10546;ctg5903|105682-105807;115-156:126-4;1|0|0|0</span><br><span class="line">GGCATGGATGATGACCAATTTCTTTCTTTCTTGGACCTCAAGCAGAGGAGGTGGTATGAGGACCGCCATTGCTCCAAAGCATAGTCACGTTGTTCCACTCCTTCAGAGTCTCCAACTGCTTTG</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>sample.4col.true.fa.RMfilt.hiConf.cdnm</li>
</ol>
<ul>
<li>第一行<code>#python</code>开头的是生成此文件运行的命令。</li>
<li>其余行是假基因的序列信息，fasta格式，序列ID是假基因ID（Ps000001）和对应的真基因ID（gene38168）。序列ID同文件sample.4col.true.RMfilt.hiConf.cdnm的第一列内容一致。</li>
<li>下面是文件的部分内容。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;Ps000001_gene38168</span><br><span class="line">TTGCAGGTTGCAATTTTGATGTCCAAGGACCAAGCACTATATTACGCATGGTTGTTCTCCCTAATAATTTATGAATTACTTAGAAAACCTACCTTGCGCAATGTAGAAGCGTTAGTGCAAACATGGCTCCGTGTCACACAATGCATGTCACGGTCAATTAACTTTAAGAAGGTAGCAAATCGTAAAAGGAGTTGGGAGCGTAGGAGAGCATGAGCTTATCCATGACCCCAGAGGTTTCTTGAGTGCTTTTTGTTGAGTGCATATAATGCAAACATGTTCAAATGTCGCTTGTGAGTGAGTAGAGAAACCTTCCAATACGTATGTGGCAAGGTCTCTCTTGCAATGAAGAAGGTGAGCACAAACATGCGTGTTCCACTTAGTATGGAAACAAAACTGGCAATAGCTCTCAGTAGGCTAGCTTTAGGTGCAGGGCTTGAGATGTTGGGTGGTTTGCATGGCTGTGCAAAGAGCACAAGTTGTAAAGTAGTGATTGATTTTTGTAAGGCAATTGTTACATCAGGTCTTAGGGATTTGTACATTAGGTGGCCTGCCCTCTCATGGCTAGAGACACTAGCAAGTGAGTTTCAAGCTTCAAGATGCATCCCCTTTGTTGCTAGAGCCATAGACAGTTCTCACATCCCTATCATCGCCCCAAGAGACAATCACGTAGATTATTTCAATTGAAAAGGG</span><br><span class="line">&gt;Ps000003_gene04393</span><br><span class="line">TATATGTCGTGATATCACAGCAATCAATCTATCATTAGAGAACTTAGATGATTTGTATAAGGTGTGTGGGTTCATACATGGCTTGGACATGAAGTACAAGCACAACATACGTACTCAAAACCCCAAAGACCCCATAGATGCTATTTAAGGTTCTCAAATCTATAATGACTCTCTTGATAAGAGGAGC</span><br><span class="line">&gt;Ps000004_gene10546</span><br><span class="line">GGCATGGATGATGACCAATTTCTTTCTTTCTTGGACCTCAAGCAGAGGAGGTGGTATGAGGACCGCCATTGCTCCAAAGCATAGTCACGTTGTTCCACTCCTTCAGAGTCTCCAACTGCTTTG</span><br></pre></td></tr></table></figure>

<h4 id="5-3-1-2-intermediate文件夹中的文件"><a href="#5-3-1-2-intermediate文件夹中的文件" class="headerlink" title="5.3.1.2. _intermediate文件夹中的文件"></a>5.3.1.2. _intermediate文件夹中的文件</h4><p><code>result/_intermediate</code>中的结果文件包括以下文件，许多文件第一行都是以<code>#python</code>开始的生成此文件的命令，其余行才保存了信息：</p>
<ol>
<li>sample.fullyFiltered.disable_count</li>
</ol>
<ul>
<li>第一行都是以<code>#python</code>开始的生成此文件的命令</li>
<li>保存着假基因和对应真基因的氨基酸的比对好的序列</li>
</ul>
<ol start="2">
<li>sample.fullyFiltered.disable_count.RMfilt</li>
</ol>
<ul>
<li>前两行都是以<code>#python</code>开始的生成此文件的命令</li>
<li>保存着假基因和对应真基因的氨基酸的比对好的序列</li>
</ul>
<h3 id="5-3-2-notes"><a href="#5-3-2-notes" class="headerlink" title="5.3.2. notes"></a>5.3.2. notes</h3><ul>
<li>注释到的假基因之间是没有重叠的，一个位置的序列只能被注释为一个假基因。</li>
<li>建议做一个长度的过滤，比如长度大于300bp的假基因才被鉴定为假基因，进入到下一步的分析流程。</li>
<li>result&#x2F;_intermediate文件夹中保存着额外的文件，比如sample.fullyFiltered.disable_count.RMfilt文件保存着假基因和对应真基因比对好的蛋白质序列。</li>
</ul>
<h2 id="5-4-PseudogenePipeline运行的一个例子"><a href="#5-4-PseudogenePipeline运行的一个例子" class="headerlink" title="5.4. PseudogenePipeline运行的一个例子"></a>5.4. PseudogenePipeline运行的一个例子</h2><p>运行相关数据：</p>
<ul>
<li>6Gb大小的蕨类基因组，跑了70h。</li>
<li>70000个注释的真基因，软件结果中有222,372个假基因，其中长度大于300bp的为93594条。</li>
</ul>
<h1 id="6-假基因后续分析"><a href="#6-假基因后续分析" class="headerlink" title="6. 假基因后续分析"></a>6. 假基因后续分析</h1><p>鉴定假基因后，可以通过进一步的分析来获取更多认识。</p>
<h2 id="6-1-批量计算pseudogene和功能性gene之间的Ks"><a href="#6-1-批量计算pseudogene和功能性gene之间的Ks" class="headerlink" title="6.1. 批量计算pseudogene和功能性gene之间的Ks"></a>6.1. 批量计算pseudogene和功能性gene之间的Ks</h2><p>通过计算pseudogene和功能性基因（真基因）间的Ks，可以判断是否与其他进化事件的Ks重合（比如WGD），也可以通过Ks计算假基因产生的时间的分布。</p>
<h3 id="6-1-1-背景"><a href="#6-1-1-背景" class="headerlink" title="6.1.1. 背景"></a>6.1.1. 背景</h3><ol>
<li>Ks只能计算ORF区域的（即完整密码子，3的倍数的碱基），并遇到stop codon停止。</li>
<li>根据假基因的注释信息，找到pseudogene和对应真基因的序列，并把pseudogene和对应真基因的ORF区域提取出来。</li>
<li>若pseudogene比对到了intron区域，删除这部分，并从真基因密码子首位开始匹配pseudogene，提取完整密码子（3的倍数个碱基）。</li>
<li>只需要比对上的密码子区域，并要求3的倍数的碱基；而假基因常常包含许多中间的终止密码子，所以这些中间终止密码子和对应位置的真基因的三个碱基也需要删除。（还有一种策略是从第一个终止密码子处截断，之后的序列全都不要，但这种策略常常会使得提取出来的序列太短，造成更大误差，所以不推荐。）</li>
</ol>
<p>准备以下三个输入文件，就可以根据 <strong>博客：批量计算Ka和Ks：<a href="https://yanzhongsino.github.io/2022/09/07/bioinfo_Ks_batch.calculation.Ks">https://yanzhongsino.github.io/2022/09/07/bioinfo_Ks_batch.calculation.Ks</a></strong> 进行Ks的批量计算。</p>
<h3 id="6-1-2-准备sample-pairs文件"><a href="#6-1-2-准备sample-pairs文件" class="headerlink" title="6.1.2. 准备sample.pairs文件"></a>6.1.2. 准备sample.pairs文件</h3><p>sample.pairs保存着两列数据，tab分隔，第一列是假基因的ID，第二列是对应的真基因的ID。</p>
<p>可以用下面的命令从结果文件中提取假基因和对应的真基因的ID，获得sample.pairs。</p>
<p><code>cat ./_results/sample.4col.true.RMfilt.hiConf.cdnm  |grep -v &quot;#&quot;|sed -e &quot;s/\t.*//g&quot; -e &quot;s/_/\t/&quot; &gt;sample.pairs </code></p>
<h3 id="6-1-3-准备用于计算Ks的CDS序列文件-all-cds-和氨基酸序列文件-all-pep"><a href="#6-1-3-准备用于计算Ks的CDS序列文件-all-cds-和氨基酸序列文件-all-pep" class="headerlink" title="6.1.3. 准备用于计算Ks的CDS序列文件(all.cds)和氨基酸序列文件(all.pep)"></a>6.1.3. 准备用于计算Ks的CDS序列文件(all.cds)和氨基酸序列文件(all.pep)</h3><p>用于计算Ks的CDS序列文件需要包括所有假基因和对应真基因的CDS序列，用于计算Ks的氨基酸序列文件需要包括所有假基因和对应真基因的氨基酸序列。</p>
<p>注意：all.cds和all.pep可以包含多余的序列但不能少。因为是根据sample.pairs文件的指定序列对计算Ks的。</p>
<ol>
<li>提取cds序列</li>
</ol>
<ul>
<li>用cufflinks的gffread工具从gff文件提取CDS序列: <code>gffread sample.4col.true.RMfilt.hiConf.cdnm.gff -g genome.fa -x pseudo.cds</code></li>
<li>另一种方法直接从结果文件中提取cds序列：<code>cat sample.4col.true.fa.RMfilt.hiConf.cdnm |grep -v &quot;#&quot; &gt;pseudo.cds</code></li>
</ul>
<ol start="2">
<li>合并假基因CDS序列和基因组所有真基因的CDS序列（sample.cds）到一个文件all.cds</li>
</ol>
<ul>
<li><code>cat pseudo.cds sample.cds &gt; all.cds</code></li>
</ul>
<ol start="3">
<li>用cufflinks的gffread工具从gff文件提取pep序列</li>
</ol>
<ul>
<li><code>gffread sample.4col.true.RMfilt.hiConf.cdnm.gff -g genome.fa -y pseudo.pep</code></li>
</ul>
<ol start="4">
<li>合并假基因氨基酸序列和基因组所有真基因的氨基酸序列（sample.pep）到一个文件all.pep</li>
</ol>
<ul>
<li><code>cat pseudo.pep sample.pep &gt; all.pep</code></li>
</ul>
<h3 id="6-1-4-计算Ks"><a href="#6-1-4-计算Ks" class="headerlink" title="6.1.4. 计算Ks"></a>6.1.4. 计算Ks</h3><p>准备好以上三个文件：sample.pair, all.cds, all.pep 即可用ParaAT.pl和KaKs_Calculator2.0两个软件，参考<strong>博客：批量计算Ka和Ks：<a href="https://yanzhongsino.github.io/2022/09/07/bioinfo_Ks_batch.calculation.Ks">https://yanzhongsino.github.io/2022/09/07/bioinfo_Ks_batch.calculation.Ks</a></strong>的步骤计算假基因和对应真基因间的Ks，从而获知遗传上的分化及分布。</p>
<h2 id="6-2-检测假基因和共线性区块的关系"><a href="#6-2-检测假基因和共线性区块的关系" class="headerlink" title="6.2. 检测假基因和共线性区块的关系"></a>6.2. 检测假基因和共线性区块的关系</h2><p>在2022年08月在GBE上发表的荷叶铁线蕨基因组的文章（<a href="https://academic.oup.com/gbe/article/14/8/evac127/6659224%EF%BC%89%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%EF%BC%8C%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AFpseudogene%E9%80%A0%E6%88%90%E5%85%B1%E7%BA%BF%E6%80%A7blocks%E5%8F%98%E7%9F%AD%EF%BC%8C%E7%94%A8%E5%88%B0%E7%9A%84%E6%96%B9%E6%B3%95%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95%E5%9C%A8%E6%AD%A4%E3%80%82">https://academic.oup.com/gbe/article/14/8/evac127/6659224）中的一个应用，判断是否是pseudogene造成共线性blocks变短，用到的方法细节记录在此。</a></p>
<ol>
<li>分析MCScanX结果中找到的共线性blocks，看blocks是否有成对出现在同一个contig上的，两对出现在同一contig上的blocks是否分别有共线性对应。</li>
</ol>
<ul>
<li>结果是不存在符合条件的两对blocks。</li>
<li>原因是contig的长度短造成的，contig长度在1-2Mbp，一个block含5个及以上基因，就占据了一条contig的全长，所以同一个contig上有多个block出现的概率变小。</li>
</ul>
<ol start="2">
<li>在最长的blocks里找pseudogene造成blocks内部gene无共线性的例子。即block内部无共线性的gene对应block上对面位置是否有这个gene的pseudogene存在。</li>
</ol>
<ul>
<li>结果是在超过7个gene的blocks里找到5个blocks存在这种情况。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alignment 288: ctg4124-ctg7158：Ane23910-Ane23911之间有Ane41918的pseudogene(ctg4124 6381349 6381618)；Ane23909-Ane23910之间有Ane41900的pseudogene（重排）；</span><br><span class="line">Alignment 102： ctg11329-ctg6741：Ane66914-Ane66915之间有Ane38759的pseudogene；Ane66920-Ane66921之间有Ane38765的pseudogene(ctg11329        2818519 2817964)；</span><br><span class="line">Alignment 139: ctg1252-ctg4677：Ane27375-Ane27376之间有Ane07597的pseudogene；</span><br><span class="line">Alignment 422: ctg7700-ctg9700：Ane46157-Ane461158之间有Ane57929的pseudogene（重排）(ctg7700 2107090 2106980)；</span><br><span class="line">Alignment 396: ctg6709-ctg8004：Ane38599-Ane38600之间有Ane47496的pseudogene（重排）(ctg6709 1117953 1117655)；</span><br></pre></td></tr></table></figure>

<h2 id="6-3-非批量计算Ks"><a href="#6-3-非批量计算Ks" class="headerlink" title="6.3. 非批量计算Ks"></a>6.3. 非批量计算Ks</h2><p>如果只有少量样本对（关注的假基因和对应真基因）需要计算Ks，可以手动进行。比如上面的共线性区块分析中找到的5个blocks中的少量样本对。</p>
<h3 id="6-3-1-提取序列"><a href="#6-3-1-提取序列" class="headerlink" title="6.3.1. 提取序列"></a>6.3.1. 提取序列</h3><p>通过PseudogenePipeline运行结果的比对信息提取假基因和对应的真基因比对上的ORF区域，并提取3的倍数的碱基，以计算Ks。</p>
<ol>
<li>拿<code>_results/sample.4col.true.fa.RMfilt.hiConf</code>中的一条pseudogene序列的ID举例说明位置的含义</li>
</ol>
<ul>
<li><code>gene38168;ctg947|625093-625785;336-566:693-4;4|0|0|0    ctg947    625785    625096</code>表示在染色体<code>ctg947</code>的<code>625093-625785</code>位置有一个假基因pseudogene。</li>
<li>对应的真基因是<code>gene38168</code>；<code>336-566</code>和<code>693-4</code>分别是指真基因序列和假基因序列比对上的区域；比对的信息是从tblastn的比对结果中获取的。</li>
<li>真基因<code>gene38168</code>的<strong>氨基酸</strong>序列的<code>336-566</code>位置。</li>
<li>假基因的<code>693-4</code>位置是指在染色体<code>ctg947</code>的<code>625093-625785</code>位置的假基因核酸序列上的第4到693个碱基，由于起始位置比终止位置大，所以是4-693位置的反向互补序列。</li>
</ul>
<ol start="2">
<li>根据pseudogene的序列位置和对应的真基因的位置信息，提取两者比对上的cds序列</li>
</ol>
<ul>
<li>先从<code>_results/sample.4col.true.fa.RMfilt.hiConf</code>中提取出<code>gene38168</code>对应的假基因pseudogene；</li>
<li>根据假基因的比对位置<code>693-4</code>提取染色体<code>ctg947</code>的<code>625093-625785</code>位置的<code>4-693</code>的核酸，由于起始位置比终止位置大，所以是<code>4-693</code>位置的反向互补序列。</li>
<li>再根据真基因的ID<code>gene38168</code>提取真基因的cds序列；</li>
<li>根据真基因的蛋白比对位<code>336-566</code>，通过计算起始位置$$336*3-2&#x3D;1008$$，和终止位置$$566*3&#x3D;1698$$，找到cds对应的<code>1008-1698</code>位置提取出来。</li>
</ul>
<ol start="3">
<li>比对和删改</li>
</ol>
<ul>
<li>把两者序列保存在一个fasta文件，并用mafft&#x2F;muscle等工具做align；</li>
<li>以真基因序列为参考，根据align结果对提取的假基因序列进行删除和修改。比如删除比对到intron的部分；若是假基因中包含indel，则在indel处找到上一个密码子的第三位，在这个位置删除对应密码子；最终使得两条序列都包含3的倍数的对应密码子的orf序列。</li>
<li>删改好后再做一次align，每个假基因和对应真基因保存成一个文件；</li>
</ul>
<h3 id="6-3-2-计算Ks"><a href="#6-3-2-计算Ks" class="headerlink" title="6.3.2. 计算Ks"></a>6.3.2. 计算Ks</h3><ol>
<li>改格式</li>
</ol>
<ul>
<li><code>AXTConvertor gene_pseudo.fa gene_pseudo.axt</code></li>
<li>KaKs_Calculator的改格式工具，改比对后的fas格式（gene_pseudo.fa）为axt（gene_pseudo.axt）。</li>
<li>axt格式包括三行，第一行两个序列ID之间用短横杠-相连，第二行第一条序列，第三行第二条序列。</li>
</ul>
<ol start="2">
<li>计算Ks</li>
</ol>
<ul>
<li><code>KaKs_Calculator -i gene_pseudo.axt -o gene_pseudo.kaks -m PN</code></li>
<li>计算KaKs，用PN模型；结果就在gene_pseudo.kaks文件中。</li>
</ul>
<ol start="3">
<li>合并所有计算的ks结果</li>
</ol>
<table>
<thead>
<tr>
<th>gene-pseudo</th>
<th>Ka</th>
<th>Ks</th>
<th>Ka&#x2F;Ks</th>
</tr>
</thead>
<tbody><tr>
<td>Ane07597-Ane07597.pseudo</td>
<td>0.166453</td>
<td>0.830702</td>
<td>0.200376</td>
</tr>
<tr>
<td>Ane38759-Ane38759.pseudo</td>
<td>0.0068327</td>
<td>0.0579878</td>
<td>0.11783</td>
</tr>
<tr>
<td>Ane38765-Ane38765.pseudo</td>
<td>0.0181923</td>
<td>0.0594878</td>
<td>0.305815</td>
</tr>
<tr>
<td>Ane41900-Ane41900.pseudo</td>
<td>0.356588</td>
<td>1.23697</td>
<td>0.288276</td>
</tr>
<tr>
<td>Ane41918-Ane41918.pseudo</td>
<td>0.0304071</td>
<td>0.033778</td>
<td>0.900203</td>
</tr>
<tr>
<td>Ane47496-Ane47496.pseudo</td>
<td>0.025231</td>
<td>0.210919</td>
<td>0.119624</td>
</tr>
<tr>
<td>Ane57929-Ane57929.pseudo</td>
<td>0.0380011</td>
<td>0.0703679</td>
<td>0.540034</td>
</tr>
</tbody></table>
<ul>
<li>从结果中看出，Ane38759，Ane38765，Ane579290三个基因和它们的假基因之间的Ks接近WGD分析中计算的WGD所在的Ks&#x3D;0.06；可以作为共线性blocks内部假基因的证据。</li>
</ul>
<h1 id="7-references"><a href="#7-references" class="headerlink" title="7. references"></a>7. references</h1><ol>
<li>wiki:pseudogene:<a href="https://en.wikipedia.org/wiki/Pseudogene">https://en.wikipedia.org/wiki/Pseudogene</a></li>
<li>PseudogenePipeline github：<a href="https://github.com/ShiuLab/PseudogenePipeline">https://github.com/ShiuLab/PseudogenePipeline</a></li>
<li>2022年08月在GBE上发表的荷叶铁线蕨基因组的文章：<a href="https://academic.oup.com/gbe/article/14/8/evac127/6659224">https://academic.oup.com/gbe/article/14/8/evac127/6659224</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>pseudogene</category>
      </categories>
      <tags>
        <tag>Ks</tag>
        <tag>pseudogene</tag>
        <tag>PseudogenePipeline</tag>
        <tag>假基因</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组WGD事件的鉴定和时间估算 —— MCScanX,KaKa_Calculator</title>
    <url>/2021/11/27/bioinfo_synteny_MCScanX/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=29808885&auto=1&height=32"></iframe></div>

<h1 id="1-MCScanX介绍"><a href="#1-MCScanX介绍" class="headerlink" title="1. MCScanX介绍"></a>1. MCScanX介绍</h1><p>MCScanX调整<a href="https://yanzhongsino.github.io/2021/11/05/bioinfo_MCscan/">MCScan算法</a>进行检测基因组间或基因组内的同线性，并附加了14个下游分析和可视化的脚本。</p>
<h1 id="2-MCScanX同线性分析"><a href="#2-MCScanX同线性分析" class="headerlink" title="2. MCScanX同线性分析"></a>2. MCScanX同线性分析</h1><h2 id="2-1-种内同线性分析MCScanX"><a href="#2-1-种内同线性分析MCScanX" class="headerlink" title="2.1. 种内同线性分析MCScanX"></a>2.1. 种内同线性分析MCScanX</h2><h3 id="2-1-1-准备输入文件"><a href="#2-1-1-准备输入文件" class="headerlink" title="2.1.1. 准备输入文件"></a>2.1.1. 准备输入文件</h3><p>MCScanX做同线性分析需要两个输入文件sample.gff(四列数据)和sample.blast。</p>
<p>如果是多个物种，则把多个物种的gff3文件和pep.fa文件合并后再准备sample.gff和sample.blast输入文件。</p>
<ol>
<li>sample.gff</li>
</ol>
<ul>
<li>与gff3文件格式不一样，这里的sample.gff包含四列数据，第一列染色体ID，第二列基因ID，第三和第四列分别是起始和终止位置。</li>
<li><code>cat sample.gene.gff3 |awk &#39;&#123;if($3==&quot;gene&quot;)&#123;print $1,$9,$4,$5&#125;&#125;&#39;|sed &quot;s/;.*;//g&quot;|sed &quot;s/ID=//g&quot;|sed &quot;s/ /\t/g&quot; &gt;sample.gff</code> 从gff3文件准备sample.gff文件</li>
</ul>
<ol start="2">
<li>sample.blast</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">makeblastdb -in sample.pep.fa -dbtype prot -out index/sample.pep #给蛋白序列建库</span><br><span class="line">blastp -query sample.pep.fa -db index/sample.pep -out sample.blast -evalue 1e-5 -num_threads 12 -outfmt 6 -num_alignments 5 &amp; #进行自我比对，生成6号格式的比对结果sample.blast</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-运行MCScanX"><a href="#2-1-2-运行MCScanX" class="headerlink" title="2.1.2. 运行MCScanX"></a>2.1.2. 运行MCScanX</h3><p>在有sample.gff和sample.blast两个文件的目录下，指定前缀sample运行<code>MCScanX sample</code>。</p>
<p>重要参数解释：</p>
<ul>
<li>-s MATCH_SIZE,default: 5。每个共线性区块包含的基因数量的下限。</li>
<li>-m MAX_GAPS，default：25。在共线性区块中允许的最大gaps数量。</li>
<li>-b patterns of collinear blocks。0:intra- and inter-species (default); 1:intra-species; 2:inter-species。</li>
</ul>
<h2 id="2-2-种间同线性分析MCScanX-h"><a href="#2-2-种间同线性分析MCScanX-h" class="headerlink" title="2.2. 种间同线性分析MCScanX_h"></a>2.2. 种间同线性分析MCScanX_h</h2><p>MCScanX_h是MCScanX软件下的一个程序，输入文件和运行方式与MCScanX很像。</p>
<ol>
<li>原理</li>
</ol>
<ul>
<li>可用MCScanX_h分析指定基因对的同线性关系，用于确认orthofinder或者OrthoMCL等软件鉴定的物种间的orthologs基因对。</li>
<li>如果要分析物种间orthologs的Ks分布来确定物种分化时间，直接用MCScanX做物种间共线性分析会同时得出orthologs和paralogs的结果，但MCScanX_h则可以指定orthofinder或者OrthoMCL鉴定的orthologs基因对。</li>
<li>可以这样理解，orthofinder鉴定出物种A和物种B的orthologs（物种A和B各只有一个基因的那些行），然后用MCScanX_h确认鉴定的orthologs的同线性关系，从而更加确认orthologs的可靠性。</li>
</ul>
<ol start="2">
<li>运行的区别</li>
</ol>
<ul>
<li>区别是输入文件用sample.homology代替sample.blast。</li>
<li>sample.homology是tab分隔的成对基因ID的list。</li>
</ul>
<h3 id="2-2-1-输入文件"><a href="#2-2-1-输入文件" class="headerlink" title="2.2.1. 输入文件"></a>2.2.1. 输入文件</h3><ol>
<li>sample.gff：格式同上面MCScanX的说明。</li>
<li>sample.homology</li>
</ol>
<ul>
<li>包含两列数据，是两个物种的基因对，代表一一对应的同源关系。这里用来计算物种间分化，所以指定的是两个物种间一一对应的直系同源关系。</li>
<li>可从orthofinder或者OrthoMCL等软件鉴定的物种间提取。</li>
<li>从orthofinder的<code>./Results_Apr01/Orthogroups/Orthogroups.txt</code>文件提取只包含物种A和物种B各有一个基因的行。如果是多物种做的orthofinder，则提取只包含物种A和物种B各有一个基因的行后把其他物种删除。提取后把列间分隔符改成tab。（ps：用不同物种跑的orthofinder提取结果会有一点差异）</li>
</ul>
<h3 id="2-2-2-运行MCScanX-h"><a href="#2-2-2-运行MCScanX-h" class="headerlink" title="2.2.2. 运行MCScanX_h"></a>2.2.2. 运行MCScanX_h</h3><p>与运行MCScanX一样:</p>
<ul>
<li>在有sample.gff和sample.homology两个文件的目录下，指定前缀sample运行<code>MCScanX_h sample</code>。</li>
<li>参数也一致。</li>
</ul>
<h2 id="2-3-结果文件"><a href="#2-3-结果文件" class="headerlink" title="2.3. 结果文件"></a>2.3. 结果文件</h2><ol>
<li>sample.collinearity</li>
</ol>
<p>共线性结果文件，包括三部分内容：</p>
<ul>
<li>参数(parameters)</li>
<li>基本统计信息(statistics)：共线性基因的总数，总基因数，共线性基因占比。</li>
<li>共线性区块(block)信息：一个Alignment代表一个共线性区块（0起始编号）。后面跟着这个共线性区块的基因对的信息。第一列：block编号；第二列：基因对编号；第三列和第四列：基因对名称；第五列：blast比对的e_value值。</li>
</ul>
<p>sample.collinearity示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">############### Parameters ###############</span><br><span class="line"># MATCH_SCORE: 50</span><br><span class="line"># MATCH_SIZE: 5</span><br><span class="line"># GAP_PENALTY: -1</span><br><span class="line"># OVERLAP_WINDOW: 5</span><br><span class="line"># E_VALUE: 1e-05</span><br><span class="line"># MAX GAPS: 25</span><br><span class="line">############### Statistics ###############</span><br><span class="line"># Number of collinear genes: 21371, Percentage: 56.25</span><br><span class="line"># Number of all genes: 37996</span><br><span class="line">##########################################</span><br><span class="line">## Alignment 0: score=352.0 e_value=1.2e-17 N=8 scaf014&amp;scaf014 plus</span><br><span class="line">477-  0:	bv37796	bv37889	  3e-06</span><br><span class="line">477-  1:	bv37820	bv37905	  6e-24</span><br><span class="line">477-  2:	bv37822	bv37926	  9e-29</span><br><span class="line">477-  3:	bv37826	bv37930	  4e-62</span><br><span class="line">477-  4:	bv37828	bv37931	  1e-74</span><br><span class="line">477-  5:	bv37829	bv37932	 3e-142</span><br><span class="line">477-  6:	bv37830	bv37933	  6e-78</span><br><span class="line">477-  7:	bv37832	bv37934	  3e-76</span><br><span class="line">## Alignment 1: score=300.0 e_value=6.1e-08 N=6 scaf014&amp;scaf014 minus</span><br><span class="line">478-  0:	bv35514	bv35525	      0</span><br><span class="line">478-  1:	bv35515	bv35524	      0</span><br><span class="line">478-  2:	bv35516	bv35523	  1e-81</span><br><span class="line">478-  3:	bv35517	bv35522	      0</span><br><span class="line">478-  4:	bv35518	bv35521	 1e-115</span><br><span class="line">478-  5:	bv35519	bv35520	      0</span><br><span class="line">... ...</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>sample.html</li>
</ol>
<p>网页文件所在的文件夹，里面有每条染色体一个html文件。html文件用浏览器打开，包含三列信息。</p>
<ul>
<li>第一列是复制深度。</li>
<li>第二列是这条染色体上所有基因的排列顺序，串联重复基因的背景为红色。</li>
<li>第三列和之后列是对应的比对上的基因名称。</li>
</ul>
<ol start="3">
<li>sample.tandem</li>
</ol>
<p>包含基因组内<strong>串联重复</strong>的基因ID的list。</p>
<p>notes：MCScanX 会根据 gff 文件中染色体号的前缀（前2个字符）将染色体划分为不同的物种，若 MCScanX 识别到输入数据中包含多个物种，则不会生成 tandem 文件。</p>
<h1 id="3-MCScanX下游分析"><a href="#3-MCScanX下游分析" class="headerlink" title="3. MCScanX下游分析"></a>3. MCScanX下游分析</h1><h2 id="3-1-提取block位置"><a href="#3-1-提取block位置" class="headerlink" title="3.1. 提取block位置"></a>3.1. 提取block位置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat sample.collinearity|grep -C 1 &quot;Alignment&quot;|sed &#x27;/^--$/d&#x27; &gt;block.tem #提取block首尾基因对</span><br><span class="line">tail -1 sample.collinearity &gt;&gt;block.tem #提取block首尾基因对</span><br><span class="line">cat block.tem |sed -e &quot;s/## //g&quot; -e &quot;s/.*gene/gene/g&quot;|tr &#x27;\n&#x27; &#x27; &#x27;|sed &quot;s/Alignment /\nAlignment/g&quot; |sed -e &quot;/^$/d&quot; -e &quot;s/ /\t/g&quot;|sed -e &quot;s/\t\+/\t/g&quot; -e &quot;s/\://g&quot;|awk -v FS=&quot;\t&quot; -v OFS=&quot;\t&quot; &#x27;&#123;print $1,$2,$3,$4,$5,$6,$7,$10,$8,$11&#125;&#x27; &gt;block.txt #整理成一个block一行信息的格式，其中&quot;s/.*gene/gene/g&quot;部分的gene修改成geneID的前缀用来去除多余信息。</span><br></pre></td></tr></table></figure>

<h2 id="3-2-绘图脚本"><a href="#3-2-绘图脚本" class="headerlink" title="3.2. 绘图脚本"></a>3.2. 绘图脚本</h2><p>MCScanX的downstream_analyses目录包含一些下游脚本。</p>
<p>许多java脚本可以实现绘图功能，包括：</p>
<ul>
<li>共线性点图：dot_plotter</li>
<li>双染色体共线性图：dual_synteny_plotter</li>
<li>共线性圈图：circle_plotter</li>
<li>染色体块图：bar_plotter</li>
<li>…</li>
</ul>
<h2 id="3-3-复制事件分类"><a href="#3-3-复制事件分类" class="headerlink" title="3.3. 复制事件分类"></a>3.3. 复制事件分类</h2><h3 id="3-3-1-duplicate-gene-classifier"><a href="#3-3-1-duplicate-gene-classifier" class="headerlink" title="3.3.1. duplicate_gene_classifier"></a>3.3.1. duplicate_gene_classifier</h3><ol>
<li>duplicate_gene_classifier</li>
</ol>
<p>MCScanX的<code>duplicate_gene_classifier</code>脚本用来分析与各种复制类别相关的基因数量</p>
<ol start="2">
<li>输入</li>
</ol>
<p><code>duplicate_gene_classifier sample</code> # 输入与MCScanX一致，读取当前目录下的sample.gff和sample.blast作为输入</p>
<ol start="3">
<li>输出示例</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Type of dup	Code	Number</span><br><span class="line">Singleton	0	88907</span><br><span class="line">Dispersed	1	13573</span><br><span class="line">Proximal	2	463</span><br><span class="line">Tandem	3	847</span><br><span class="line">WGD or segmental	4	1055</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>结果解释</li>
</ol>
<p>其中 Singleton 表示单拷贝重复，Proximal 表示在相同染色体上相近但不相连的重复，Dispersed 表示除 Tandem、WGD、Proximal 以外的重复。Number代表相应复制类别相关的基因数量。</p>
<h2 id="3-4-解析结果文件sample-collinearity的脚本"><a href="#3-4-解析结果文件sample-collinearity的脚本" class="headerlink" title="3.4. 解析结果文件sample.collinearity的脚本"></a>3.4. 解析结果文件sample.collinearity的脚本</h2><p>推荐这里<a href="https://github.com/reubwn/collinearity%E6%9C%89%E8%AE%B8%E5%A4%9A%E5%8F%AF%E4%BB%A5%E8%A7%A3%E6%9E%90%E6%9E%9C%E6%96%87%E4%BB%B6sample.collinearity%E7%9A%84%E8%84%9A%E6%9C%AC">https://github.com/reubwn/collinearity有许多可以解析果文件sample.collinearity的脚本</a></p>
<h2 id="3-5-计算共线性区块Ks"><a href="#3-5-计算共线性区块Ks" class="headerlink" title="3.5. 计算共线性区块Ks"></a>3.5. 计算共线性区块Ks</h2><p>tips:需要检查得到的结果中Ks值是否有负值或NA等无效数据，并过滤无效数据。</p>
<h3 id="3-5-1-方案一：add-ka-and-ks-to-collinearity-pl（MCScanX的downstream-analyses目录下自带脚本）"><a href="#3-5-1-方案一：add-ka-and-ks-to-collinearity-pl（MCScanX的downstream-analyses目录下自带脚本）" class="headerlink" title="3.5.1. 方案一：add_ka_and_ks_to_collinearity.pl（MCScanX的downstream_analyses目录下自带脚本）"></a>3.5.1. 方案一：add_ka_and_ks_to_collinearity.pl（MCScanX的downstream_analyses目录下自带脚本）</h3><p><code>add_ka_and_ks_to_collinearity.pl -i sample.collinearity -d sample.cds.fa -o sample.kaks &gt; out.log 2&gt;&amp;1</code> #注意算出的部分kaks值为-2的问题，未找到解决方案</p>
<h3 id="3-5-2-方案二：ParaAT-pl-KaKs-Calculator2-0"><a href="#3-5-2-方案二：ParaAT-pl-KaKs-Calculator2-0" class="headerlink" title="3.5.2. 方案二：ParaAT.pl+KaKs_Calculator2.0"></a>3.5.2. 方案二：ParaAT.pl+KaKs_Calculator2.0</h3><ul>
<li>ParaAT.pl用于根据同源基因对list生成比对的gene对cds序列，并可以指定输出格式，如axt格式；</li>
<li>KaKs_Calculator用于计算基因对的kaks。</li>
</ul>
<p>用还会用到两个脚本:</p>
<ul>
<li><a href="https://github.com/scbgfengchao/4DTv/blob/master/axt2one-line.py">axt2one-line.py</a>转换axt格式为单行</li>
<li><a href="https://github.com/JinfengChen/Scripts/blob/master/FFgenome/03.evolution/distance_kaks_4dtv/bin/calculate_4DTV_correction.pl">calculate_4DTV_correction.pl</a>计算4dtv。</li>
</ul>
<ol>
<li>安装ParaAT.pl<br>参考<a href="https://yanzhongsino.github.io/2021/10/29/bioinfo_align.pep2cds/">blog.ParaAT</a></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget ftp://download.big.ac.cn/bigd/tools/ParaAT2.0.tar.gz</span><br><span class="line">tar -zxf ParaAT2.0.tar.gz</span><br><span class="line">cd ParaAT2.0</span><br><span class="line">ParaAT.pl -h</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装KaKs_Calculator2.0<br><a href="https://sourceforge.net/projects/kakscalculator2/?source=typ_redirect">KaKs_Calculator2.0下载地址</a></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://altushost-swe.dl.sourceforge.net/project/kakscalculator2/KaKs_Calculator2.0.tar.gz</span><br><span class="line">tar -zxf KaKs_Calculator2.0.tar.gz</span><br><span class="line">chmod 777 ./KaKs_Calculator2.0/bin/Linux/KaKs_Calculator</span><br><span class="line">chmod 777 ./KaKs_Calculator2.0/src/AXTConvertor</span><br></pre></td></tr></table></figure>

<p>然后把.&#x2F;KaKs_Calculator2.0&#x2F;bin&#x2F;Linux&#x2F;和.&#x2F;KaKs_Calculator2.0&#x2F;src&#x2F;添加到环境变量即可使用KaKs_Calculator和AXTConvertor命令。</p>
<ol start="3">
<li>用ParaAT.pl获取共线性基因对比对序列<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat sample.collinearity |grep -v &quot;^#&quot;|cut -f2,3 &gt;sample.homolog #提取blocks的同源gene对</span><br><span class="line">echo &quot;24&quot; &gt;proc #指定ParaAT.pl使用线程</span><br><span class="line">ParaAT.pl -g -t -h sample.homolog -n sample.cds.fa -a sample.pep.fa -m mafft -p proc -f axt -o sample.paraat 2&gt; paraat.log &amp; #用ParaAT.pl调用mafft做每对共线性基因的蛋白比对和蛋白转cds比对，输出axt格式。-g移除比对有gap的密码子，-t移除mismatched codons；；-o指定生成目录；</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加上-k参数可以在获得axt文件后自动调用KaKs_Calculator计算kaks值，使用MA模型，比YN模型慢很多，推荐手动用KaKs_Calculator的YN模型，生成sample.axt_yn.kaks文件。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>建议加上-g和-t，免得后面计算Ks时报错Error. The size of two sequences in ‘ctg00816-ctg08844’ is not equal。</li>
<li>axt格式包括三行，第一行两个序列ID之间用短横杠-相连，第二行第一条序列，第三行第二条序列。</li>
</ul>
<ol start="4">
<li>用KaKs_Calculator手动计算共线性基因对的KaKs和4dtv值<br>ParaAT.pl的-k参数只能指定KaKs_Calculator的MA模型计算kaks值，如果需要指定其他的模型，则可以手动运行计算。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd sample.paraat</span><br><span class="line">for i in `ls *axt`;do KaKs_Calculator -i $i -o $&#123;i&#125;_yn.kaks -m YN;done #用YN模型计算每个gene对的KaKs，生成四列数据，gene对，Ka，Ks，Ka/Ks</span><br><span class="line">for i in `ls |grep &quot;_yn.kaks&quot;`;do awk &#x27;NR&gt;1&#123;print $1&quot;\t&quot;$3&quot;\t&quot;$4&quot;\t&quot;$5&#125;&#x27; $i &gt;&gt;../all.kaks;done #合并kaks到all.kaks文件</span><br><span class="line">- 计算4dtv</span><br><span class="line">for i in `ls *axt`;do axt2one-line.py $i $&#123;i&#125;.one-line;done #多行axt文件转换成单行</span><br><span class="line">ls |grep &quot;axt.one-line&quot;|while read id;do calculate_4DTV_correction.pl $id &gt; $&#123;id%%one-line&#125;4dtv;done #计算4dtv值，生成两列数据，gene对，4dtv</span><br><span class="line">for i in `ls |grep &quot;4dtv&quot;`;do awk &#x27;NR&gt;1&#123;print $1&quot;\t&quot;$3&#125;&#x27; $i &gt;&gt;../all.4dtv;done #合并4dtv值到all.4dtv</span><br><span class="line">cd ..</span><br><span class="line">join all.kaks all.4dtv |sed &quot;s/ /\t/g&quot; |awk &#x27;$3 != &quot;NA&quot; &#123;print $0&#125;&#x27; |sed &#x27;1i\genepair\tKa\tKs\tKa/Ks\t4dtv_corrected&#x27; &gt;all.results #以gene对为基准，join合并kaks和4dtv值到一个文件，然后过滤Ks值为NA的无效数据，添加标题行。</span><br><span class="line"></span><br><span class="line">rm all.kaks* all.4dtv* #删除中间文件</span><br></pre></td></tr></table></figure>

<h2 id="3-6-ggplot2画密度分布图和峰值"><a href="#3-6-ggplot2画密度分布图和峰值" class="headerlink" title="3.6. ggplot2画密度分布图和峰值"></a>3.6. ggplot2画密度分布图和峰值</h2><h3 id="3-6-1-ggplot2画密度分布图"><a href="#3-6-1-ggplot2画密度分布图" class="headerlink" title="3.6.1. ggplot2画密度分布图"></a>3.6.1. ggplot2画密度分布图</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>ggplot2<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>ggpmisc<span class="punctuation">)</span></span><br><span class="line">data <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;all.results&quot;</span><span class="punctuation">,</span>header<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span></span><br><span class="line">p <span class="operator">&lt;-</span> ggplot<span class="punctuation">(</span>data<span class="punctuation">,</span> aes<span class="punctuation">(</span>Ks<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span> geom_density<span class="punctuation">(</span>size<span class="operator">=</span><span class="number">1</span><span class="punctuation">,</span>color<span class="operator">=</span><span class="string">&quot;black&quot;</span><span class="punctuation">)</span><span class="operator">+</span>xlab<span class="punctuation">(</span><span class="string">&quot;Synonymous substitution rate(Ks)&quot;</span><span class="punctuation">)</span><span class="operator">+</span>ylab<span class="punctuation">(</span><span class="string">&quot;Percent of Total Paralogs&quot;</span><span class="punctuation">)</span><span class="operator">+</span>theme_classic<span class="punctuation">(</span><span class="punctuation">)</span><span class="operator">+</span>scale_y_continuous<span class="punctuation">(</span>breaks<span class="operator">=</span>seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> <span class="number">2.5</span><span class="punctuation">,</span> <span class="number">0.2</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="operator">+</span>xlim<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span></span><br><span class="line">ggsave<span class="punctuation">(</span>file<span class="operator">=</span><span class="string">&quot;Ks.pdf&quot;</span><span class="punctuation">,</span>plot<span class="operator">=</span>p<span class="punctuation">,</span>width<span class="operator">=</span><span class="number">10</span><span class="punctuation">,</span>height<span class="operator">=</span><span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-ggplot2峰值标定"><a href="#3-6-2-ggplot2峰值标定" class="headerlink" title="3.6.2. ggplot2峰值标定"></a>3.6.2. ggplot2峰值标定</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">pb <span class="operator">&lt;-</span> ggplot_build<span class="punctuation">(</span>p<span class="punctuation">)</span></span><br><span class="line">pic <span class="operator">&lt;-</span> p <span class="operator">+</span> stat_peaks<span class="punctuation">(</span>data <span class="operator">=</span> pb<span class="punctuation">[[</span><span class="string">&#x27;data&#x27;</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">[[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">,</span> aes<span class="punctuation">(</span>x<span class="operator">=</span>x<span class="punctuation">,</span> y<span class="operator">=</span>density<span class="punctuation">)</span><span class="punctuation">,</span> geom<span class="operator">=</span> <span class="string">&#x27;text&#x27;</span><span class="punctuation">,</span> color<span class="operator">=</span><span class="string">&quot;red&quot;</span><span class="punctuation">,</span> <span class="punctuation">,</span>vjust<span class="operator">=</span><span class="operator">-</span><span class="number">0.5</span><span class="punctuation">)</span></span><br><span class="line">ggsave<span class="punctuation">(</span>file<span class="operator">=</span><span class="string">&quot;Ks_peaks.pdf&quot;</span><span class="punctuation">,</span>plot<span class="operator">=</span>pic<span class="punctuation">,</span>width<span class="operator">=</span><span class="number">10</span><span class="punctuation">,</span>height<span class="operator">=</span><span class="number">5</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>在密度分布图里得到红色标记的峰值。</p>
<h3 id="3-6-3-多个密度图"><a href="#3-6-3-多个密度图" class="headerlink" title="3.6.3. 多个密度图"></a>3.6.3. 多个密度图</h3><p>同时展示多组Ks数据分布，可以把数据合并，添加一列作为分类标签，通过colour颜色参数指定这个分类标签列，则可以实现一张图上展示多个密度图。</p>
<p><code>ggplot(data)+geom_density(aes(x=V3,colour=V5),adjust=2)+xlim(0,0.5)+theme_classic()</code> #指定第三列V3为数据，第五列V5为分类依据并赋予不同颜色。</p>
<h3 id="3-6-4-通过密度分布图判断WGD"><a href="#3-6-4-通过密度分布图判断WGD" class="headerlink" title="3.6.4. 通过密度分布图判断WGD"></a>3.6.4. 通过密度分布图判断WGD</h3><p>一般认为，Ks密度分布图如果有明显的峰，一个峰代表对应一次WGD事件。<br>通过峰的数量和对应的Ks大小可以判断WGD事件的次数和发生时间。</p>
<h2 id="3-7-WGD发生的时间"><a href="#3-7-WGD发生的时间" class="headerlink" title="3.7. WGD发生的时间"></a>3.7. WGD发生的时间</h2><p>通过Ks的密度分布图鉴定得到WGD事件发生的证据之后，有多种方法可以估算WGD发生的时间。</p>
<h3 id="3-7-1-通过Ks-x3D-2μT计算时间"><a href="#3-7-1-通过Ks-x3D-2μT计算时间" class="headerlink" title="3.7.1. 通过Ks&#x3D;2μT计算时间"></a>3.7.1. 通过Ks&#x3D;2μT计算时间</h3><p>依据公式Ks&#x3D;2μT来计算时间T，依赖准确的进化速率μ，μ通常引用近缘类群的已有权威研究。</p>
<p>进化速率μ：</p>
<ul>
<li>蕨类植物的同义突变率：4.79e-9 subst.&#x2F;syn. site&#x2F;year :the first estimate of fern nuclear genome evolutionary rates with polypodiaceous nuclear genomes (Barker 2009)</li>
<li>水稻：2.5e-8 subst.&#x2F;syn. site&#x2F;year</li>
</ul>
<h3 id="3-7-2-通过进化树估算时间"><a href="#3-7-2-通过进化树估算时间" class="headerlink" title="3.7.2. 通过进化树估算时间"></a>3.7.2. 通过进化树估算时间</h3><ul>
<li>用代表WGD的Ks值附近的同线性基因对制作两套样品的单倍型数据，然后选取一到多个近缘种的蛋白序列与其中一套单倍型做直系同源基因分析，用找到的直系同源单拷贝基因建树（把两套单倍型数据当作两个物种来建树），通过化石或者二次标定的方法用paml的mcmctree模块计算两套单倍型的分化时间，即为WGD发生的时间。</li>
<li>如果物种分化时间的尺度太大而不能准确估算WGD时间，可以先用大尺度的系统发育树做近缘种和目标物种的分化时间的估算，然后在做WGD时间估算时只用一个近缘种加上近缘种与目标物种的分化时间标定来获得更准确的WGD时间估计结果。</li>
</ul>
<h4 id="3-7-2-1-获取sample发生WGD的两套基因"><a href="#3-7-2-1-获取sample发生WGD的两套基因" class="headerlink" title="3.7.2.1. 获取sample发生WGD的两套基因"></a>3.7.2.1. 获取sample发生WGD的两套基因</h4><ol>
<li>前面分析中计算Ks的分布峰值假设在<strong>0.05</strong>，取Ks值在0.05正负25%的范围，即[0.0375-0.0625]之间的基因对。<br><code>cat all.results |awk &#39;$3&gt;0.0375 &amp;&amp; $3&gt;0.0625 &#123;print $1&#125; |sed &quot;s/-/\t/g&quot; &gt;wgd.homologs</code></li>
<li>基因对中若有一个基因对多个基因的情况，则选取Ks最接近0.05的那对。</li>
<li>获取两套基因list。<br><code>cut -f1 wgd.homologs &gt;wgd_H1.homologs</code>;<br><code>cut -f2 wgd.homologs &gt;wgd_H2.homologs</code></li>
</ol>
<h4 id="3-7-2-2-选近缘种和分化时间"><a href="#3-7-2-2-选近缘种和分化时间" class="headerlink" title="3.7.2.2. 选近缘种和分化时间"></a>3.7.2.2. 选近缘种和分化时间</h4><ol>
<li>参考近年发表的权威组学系统发育文章选取近缘种和物种分化时间数据。</li>
<li>这里假设选取了两个近缘物种sampleA和sampleB。sample发生WGD形成的两套单倍型H1和H2，目标物种sample与近缘种sampleA的分化时间已知为88Ma。</li>
<li>确定物种树拓扑结构：<code>(((sampleH1,sampleH2),sampleA)&#39;&lt;0.88&gt;0.88),sampleB;</code>，以sampleB为外类群。</li>
</ol>
<h4 id="3-7-2-3-orthofinder找直系同源基因"><a href="#3-7-2-3-orthofinder找直系同源基因" class="headerlink" title="3.7.2.3. orthofinder找直系同源基因"></a>3.7.2.3. orthofinder找直系同源基因</h4><ol>
<li>根据基因对提取蛋白序列，任意用一个（这里用wgd_H1.homologs)提取蛋白序列：<code>seqkit grep -n -f wgd_H1.homologs sample.pep &gt; wgd_H1.pep</code></li>
<li>与其他两个近缘种的蛋白序列一起，用orthofinder找直系同源基因。</li>
</ol>
<ul>
<li>orthofinder使用方法：把所有物种的pep蛋白序列（两个近缘物种加上wgd_H1.pep）放进一个文件夹(directory)，注意蛋白序列中不能有.&#x2F;*等符号（常用来代表终止密码子）。</li>
<li>运行<code>orthofinder -f directory -t 24</code> # -t指定线程</li>
<li>结果文件的Orthogroups目录下，Orthogroups.txt包含所有直系同源基因，Orthogroups_SingleCopyOrthologues.txt包含单拷贝的直系同源基因。</li>
<li>根据Orthogroups_SingleCopyOrthologues.txt把Orthogroups.txt里基因信息提取出来,<code>grep -f Orthogroups_SingleCopyOrthologues.txt Orthogroups.tsv &gt;OG.txt</code>。OG.txt文件内容是singlecopyorthologues列表，第一列orthogroupID，后面3列每套蛋白序列ID，共4列，这个文件的每行数据为一个homologs对应的每套数据的蛋白ID。</li>
<li>合并wgd.homologs和OG.txt文件为OG.list：<code>join -1 1 -2 2 wgd.homologs OG.txt &gt; OG.list</code>。OG.list文件是在OG.txt基础上增加了wgd_H2.homologs的一套蛋白ID数据，共有四套蛋白ID数据。</li>
</ul>
<h4 id="3-7-2-4-建单基因树"><a href="#3-7-2-4-建单基因树" class="headerlink" title="3.7.2.4. 建单基因树"></a>3.7.2.4. 建单基因树</h4><ol>
<li>建树脚本<br>用下面的脚本singlegenetree.sh，提取每个homologs序列，并通过raxml-ng（raxmlHPC建氨基酸树只有bootstrap结果，没有bestTree）为每个homologs基因比对（mafft）和建树。<br>OG.list文件包含第一列ogID和后4列4套样本ID。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">singlegenetree.sh</span></span><br><span class="line">cat ./OG.list | while read line</span><br><span class="line">do</span><br><span class="line">        sample_id=$(echo $line |awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">        sample_a=$(echo $line |awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">        sample_b=$(echo $line |awk &#x27;&#123;print $3&#125;&#x27;)</span><br><span class="line">        sample_c=$(echo $line |awk &#x27;&#123;print $4&#125;&#x27;)        </span><br><span class="line">        sample_d=$(echo $line |awk &#x27;&#123;print $5&#125;&#x27;)</span><br><span class="line">        mkdir ./singlegenetree/$&#123;sample_id&#125;</span><br><span class="line">        seqkit grep -n $&#123;sample_a&#125; sample.pep &gt;./singlegenetree/$&#123;sample_id&#125;/H1_$&#123;sample_a&#125;.pep</span><br><span class="line">        seqkit grep -n $&#123;sample_b&#125; sample.pep &gt;./singlegenetree/$&#123;sample_id&#125;/H2_$&#123;sample_b&#125;.pep</span><br><span class="line">        seqkit grep -n $&#123;sample_c&#125; sampleA.pep &gt;./singlegenetree/$&#123;sample_id&#125;/$&#123;sample_c&#125;.pep</span><br><span class="line">        seqkit grep -n $&#123;sample_d&#125; sampleB.pep &gt;./singlegenetree/$&#123;sample_id&#125;/$&#123;sample_d&#125;.pep</span><br><span class="line">        cd ./singlegenetree/$&#123;sample_id&#125;/</span><br><span class="line">        cat H1_$&#123;sample_a&#125;.pep H2_$&#123;sample_b&#125;.pep $&#123;sample_c&#125;.pep $&#123;sample_d&#125;.pep &gt; $&#123;sample_id&#125;.pep</span><br><span class="line">        mafft $&#123;sample_id&#125;.pep &gt;$&#123;sample_id&#125;.mafft.pep</span><br><span class="line">        raxml-ng --all --msa $&#123;sample_id&#125;.mafft.pep --data-type AA --threads 8 --bs-trees 100 --model LG+G8+F --tree pars&#123;10&#125; --outgroup $&#123;sample_d&#125; --redo</span><br><span class="line">        sed -E &quot;s/:[0-9]\.[0-9]*//g&quot; $&#123;sample_id&#125;.mafft.pep.raxml.bestTree  &gt;besttree.$&#123;sample_id&#125; #删除不必要的枝长等信息</span><br><span class="line">        cd ../../</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>筛选homologs<br>判断生成的每个OG的树文件besttree.${sample_id}，只保留符合物种树拓扑结构<code>(((sampleH1,sampleH2),sampleA)),sampleB;</code>的基因，保存成OG.filtered。</li>
</ol>
<h4 id="3-7-2-5-paml估计分化时间"><a href="#3-7-2-5-paml估计分化时间" class="headerlink" title="3.7.2.5. paml估计分化时间"></a>3.7.2.5. paml估计分化时间</h4><p>此节参考博客<a href="https://yanzhongsino.github.io/2021/03/25/bioinfo_caculate.divergence.time/">估算系统树分歧时间</a>的paml部分。</p>
<ol>
<li>在OG.filtered最后一列添加每个OG的序列长度信息，保存成OG.filtered.list。</li>
<li>准备输入文件sample.phy<br>上一步脚本提取的每个homologs的比对后的四套数据蛋白序列${sample_id}.mafft.pep，用脚本fa2phylip.sh换成phylip格式（用python的SeqIO库换的格式mcmctree识别不了）。<br>并合并提取的所有homologs序列。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fa2phylip.sh</span></span><br><span class="line">cat ./OG.filtered.list | while read line</span><br><span class="line">do</span><br><span class="line">        sample_id=$(echo $line |awk &#x27;&#123;print $1&#125;&#x27;) #获取OG.ID</span><br><span class="line">        sample_a=$(echo $line |awk &#x27;&#123;print $6&#125;&#x27;) #获取序列长度</span><br><span class="line">        sed &quot;s/_.*//g&quot; ../singlegenetree/$&#123;sample_id&#125;/$&#123;sample_id&#125;.mafft.pep|seqkit seq -w 0|sed -E &quot;:a;N;s/\n/ /g;ta&quot; |sed &quot;s/ &gt;/\n/g&quot; |sed &quot;s/&gt;//g&quot;|sed &quot;s/ /  /g&quot;|sed &quot;1i\5  $&#123;sample_a&#125;&quot; |sed &#x27;1i\ &#x27; &gt; ./phy/$&#123;sample_id&#125;.phy #把上一步获取的$&#123;sample_id&#125;.mafft.pep改为phylip格式，并在首行添加空格行（为了合并后每个OG用空行隔开）</span><br><span class="line"></span><br><span class="line">done</span><br><span class="line">cat ./phy/*phy &gt;sample.phy #合并所有phy文件为一个sample.phy文件，假设共有261个子phy文件被合并</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>准备输入文件sample.tre</li>
</ol>
<ul>
<li>sample.tre包含两行，第一行表述树中有5个样本，共计1个树，两个数值之间用空格分割；<br>第二行则是Newick格式树信息。</li>
<li>其中第二行Newick格式树包含有校准点信息，校准点信息一般指95%HPD（Highest Posterior Density）对应的置信区间，这里用的校准点时间只有一个点，所以写成’&lt;0.88&gt;0.88’形式；校准点单位是100MYA（软件说明文档中使用该单位，也推荐使用该单位，若使用其它单位，后续配置文件中的相关参数也需要对应修改）。</li>
<li>此外，Newick格式的树尾部一定要有分号，没有的话程序可能不能正常运行。</li>
<li>sample.tre内容为：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">(((sampleH1,sampleH2),sampleA)&#x27;&lt;0.88&gt;0.88),sampleB;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>准备配置文件mcmctree3.ctl<br>ndata &#x3D; 261表示有261个数据，与sample.phy包含的子phy数量对应；seqtype &#x3D; 2表示这里用的氨基酸序列；model &#x3D; 0暂时选用0，后面要改；</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">          seed = -1</span><br><span class="line">       seqfile = sample.phy</span><br><span class="line">      treefile = sample.tre</span><br><span class="line">       outfile = mcmc.out</span><br><span class="line">      mcmcfile = mcmc.txt</span><br><span class="line"></span><br><span class="line">       seqtype = 2    *0: DNA data; 1: codon data; 2: AAs data</span><br><span class="line">        ndata = 261</span><br><span class="line">       usedata = 3    * 0: no data; 1:seq like; 2:normal approximation</span><br><span class="line">         clock = 3    * 1: global clock; 2: independent rates; 3: correlated rates</span><br><span class="line">*      TipDate = 1 100</span><br><span class="line">        RootAge = &#x27;&lt;10&#x27;  * constraint on root age, used if no fossil for root.</span><br><span class="line"></span><br><span class="line">         model = 0    * 0:JC69, 1:K80, 2:F81, 3:F84, 4:HKY85</span><br><span class="line">         alpha = 0.5   * alpha for gamma rates at sites</span><br><span class="line">         ncatG = 4    * No. categories in discrete gamma</span><br><span class="line"></span><br><span class="line">     cleandata = 0    * remove sites with ambiguity data (1:yes, 0:no)?</span><br><span class="line"></span><br><span class="line">       BDparas = 1 1 0.1   * birth, death, sampling</span><br><span class="line">   kappa_gamma = 6 2      * gamma prior for kappa</span><br><span class="line">   alpha_gamma = 1 1      * gamma prior for alpha</span><br><span class="line"></span><br><span class="line">   rgene_gamma = 2 20 1   * gamma prior for rate for genes</span><br><span class="line">  sigma2_gamma = 1 10 1    * gamma prior for sigma^2     (for clock=2 or 3)</span><br><span class="line"></span><br><span class="line">      finetune = 1: .1 .1 .1 .1 .1 .1  * times, rates, mixing, paras, RateParas</span><br><span class="line"></span><br><span class="line">         print = 1</span><br><span class="line">        burnin = 1000000</span><br><span class="line">      sampfreq = 10</span><br><span class="line">       nsample = 500000</span><br><span class="line"></span><br><span class="line">*** Note: Make your window wider (100 columns) when running this program.</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>运行<code>mcmctree mcmctree3.ctl</code></li>
</ol>
<ul>
<li>此步骤的目的是为了获取in.BV文件；</li>
<li>用命令<code>mcmctree mcmctree3.ctl</code>运行起来后，ctrl+C多次中断运行（共261个序列，会依次调用261次codeml，中断后会自动进入下一次调用，目的是完成261次调用生成261个序列的临时文件）；由于单个序列短，很快会完成分析，也可以不ctrl+C中断，等待完成，只要生成261套tmp*文件即可。</li>
<li>删除rst2文件和mcmc.out,mcmc.txt,out.BV文件；把paml软件下的wag.dat文件复制到当前目录下<code>cp ~/software/anaconda3/dat/wag.dat ./</code>；</li>
<li>用命令<code>sed -i -e &quot;s/model = 0/model =2\naaRatefile = wag.dat/&quot; -e &quot;s/method = 0/method = 1/&quot; tmp*.ctl</code>把所有tmp*.ctl文件的model修改成model &#x3D; 2，method修改成method &#x3D; 1,并添加一行aaRatefile &#x3D; wag.dat；</li>
<li>用命令<code>for i in $(ls tmp*.ctl);do codeml $&#123;i&#125; ; mv rst2 $&#123;i&#125;.rst2; done</code>调用codeml进行261次分析（每次codeml都生成rst2文件，所以每次生成后把rst2改名，否则rst2被覆盖）；</li>
<li>然后<code>cat *rst2 &gt;in.BV</code>合并所有rst2文件到in.BV文件；</li>
</ul>
<ol start="6">
<li>运行<code>mcmctree mcmctree2.ctl</code></li>
</ol>
<ul>
<li>新建目录并复制四个文件sample.phy,sample.tre,mcmctree3.ctl,in.BV到新目录<code>mkdir mcmctree2 &amp;&amp; cd mcmctree2 &amp;&amp; cp ../Ane.* ./ &amp;&amp; cp ../mcmctree3.ctl ./ &amp;&amp; cp ../in.BV ./</code>;</li>
<li>把mcmctree3.ctl文件内的usedata &#x3D; 3改为usedata &#x3D; 2，并重命名成mcmctree2.ctl；</li>
<li>然后运行<code>mcmctree mcmctree2.ctl</code>；</li>
<li>等待两三天获取结果，FigTree.tre文件包含了所有节点的95%HPD的时间，是nexus格式。</li>
<li>根据FigTree.tre结果：<code>((sampleA: 0.408365, (sampleH1: 0.107333, sampleH2: 0.107333) [&amp;95%=&#123;0.0749432, 0.126365&#125;]: 0.301032) [&amp;95%=&#123;0.285365, 0.478163&#125;]: 0.362000, sampleB: 0.770366) [&amp;95%=&#123;0.53864, 0.90012&#125;];</code>的sampleH1和sampleH2分化的时间，可以看出WGD发生的时间在**10.7Ma[7.5-12.6]**之间。</li>
</ul>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3326336/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3326336/</a></li>
<li><a href="https://github.com/wyp1125/MCScanX">https://github.com/wyp1125/MCScanX</a></li>
<li><a href="https://its201.com/article/sinat_41621566/113359074">https://its201.com/article/sinat_41621566/113359074</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>synteny</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>ggplot2</tag>
        <tag>WGD</tag>
        <tag>Ks</tag>
        <tag>ParaAT</tag>
        <tag>KaKs_Calculator</tag>
        <tag>divergence time</tag>
        <tag>paml</tag>
        <tag>synteny</tag>
        <tag>colinearity</tag>
        <tag>MCScanX</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组间的同线性分析 —— MCscan</title>
    <url>/2021/11/05/bioinfo_synteny_MCscan/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=5250805&auto=1&height=32"></iframe></div>

<h1 id="1-MCscan背景"><a href="#1-MCscan背景" class="headerlink" title="1. MCscan背景"></a>1. MCscan背景</h1><h2 id="1-1-jcvi介绍"><a href="#1-1-jcvi介绍" class="headerlink" title="1.1. jcvi介绍"></a>1.1. jcvi介绍</h2><p><a href="https://github.com/tanghaibao/jcvi">jcvi</a>是美国佐治亚大学唐海宝开发的一个生物信息学python库。主要有几个常见pipeline用到了jcvi库，一个是做基因组scaffoldding的<a href="https://github.com/tanghaibao/jcvi/wiki/ALLMAPS">ALLMAPS</a>，另一个是做基因组同线性分析的<a href="https://github.com/tanghaibao/jcvi/wiki/MCscan-%28Python-version%29">MCscan</a>，以及提取植物表型数据的<a href="https://github.com/tanghaibao/jcvi/wiki/GRABSEEDS">GRABSEEDS</a>。</p>
<h2 id="1-2-MCscan介绍"><a href="#1-2-MCscan介绍" class="headerlink" title="1.2. MCscan介绍"></a>1.2. MCscan介绍</h2><p>用MCscan pipeline做两个基因组间的同线性分析，包括成对同线性(pairwise synteny)分析，宏观同线性(macrosynteny)分析，微观同线性(microsynteny)分析和结果的可视化(visualization)。</p>
<p>成对同线性分析主要是制作同线性点图(dotplot),同线性深度直方图；宏观同线性分析主要是制作同线性染色体图。其中同线性深度直方图，同线性染色体图需要用到同线性点图的结果文件作为输入。</p>
<p>微观同线性分析等后面用到再补坑。</p>
<h1 id="2-MCscan使用"><a href="#2-MCscan使用" class="headerlink" title="2. MCscan使用"></a>2. MCscan使用</h1><h2 id="2-1-安装jcvi"><a href="#2-1-安装jcvi" class="headerlink" title="2.1. 安装jcvi"></a>2.1. 安装jcvi</h2><h3 id="2-1-1-依赖"><a href="#2-1-1-依赖" class="headerlink" title="2.1.1. 依赖"></a>2.1.1. 依赖</h3><p>jcvi依赖包括biopython,numpy,matplotlib。</p>
<p>MCscan依赖包括LASTAL。</p>
<p>LASTAL可以用<code>conda install -c bioconda last</code>安装，但我用conda安装的lastal和lastdb不能多线程运行，所以在运行<code>python -m jcvi.compara.catalog ortholog --cpu=1</code>时用参数<code>--cpu=1</code>来限制单线程运行。</p>
<h3 id="2-1-2-安装jcvi"><a href="#2-1-2-安装jcvi" class="headerlink" title="2.1.2. 安装jcvi"></a>2.1.2. 安装jcvi</h3><p>任意选一种安装方式</p>
<ol>
<li><code>pip install jcvi</code></li>
<li><code>pip install git+git://github.com/tanghaibao/jcvi.git</code></li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd jcvi</span><br><span class="line">git clone git://github.com/tanghaibao/jcvi.git</span><br><span class="line">pip install -e .</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-2-准备输入文件"><a href="#2-2-准备输入文件" class="headerlink" title="2.2. 准备输入文件"></a>2.2. 准备输入文件</h2><p>输入文件包括两个基因组的CDS&#x2F;氨基酸序列文件（fa格式），两个基因组的注释坐标文件（bed格式）。</p>
<h3 id="2-2-1-jcvi支持直接从phytozome下载数据"><a href="#2-2-1-jcvi支持直接从phytozome下载数据" class="headerlink" title="2.2.1. jcvi支持直接从phytozome下载数据"></a>2.2.1. jcvi支持直接从phytozome下载数据</h3><ol>
<li><p>连接phytozome（需要登录，提前注册账号）<br><code>python -m jcvi.apps.fetch phytozome</code> 输入账户登录信息后，出现可以下载的基因组list。</p>
</li>
<li><p>下载CDS序列和注释文件(gff格式)，例如下载这两个物种:grape and peach<br><code>python -m jcvi.apps.fetch phytozome Vvinifera,Ppersica</code></p>
</li>
<li><p>转换GFF为BED格式<br><code>python -m jcvi.formats.gff bed --type=mRNA --key=Name  --primary_only Vvinifera_145_gene.gff3.gz -o grape.bed</code></p>
</li>
</ol>
<p><code>python -m jcvi.formats.gff bed --type=mRNA --key=Name  --primary_only Ppersica_139_gene.gff3.gz -o peach.bed</code></p>
<p>其中<code>--primary_only</code>是用于去除多个转录本的，只保留一个。（原文是多个isoforms）一般不去也不影响后续步骤，加上更好吧。</p>
<ol start="4">
<li>整理一下，获得CDS文件<br><code>python -m jcvi.formats.fasta format Vvinifera_145_Genoscope.12X.cds.fa.gz grape.cds</code></li>
</ol>
<p><code>python -m jcvi.formats.fasta format Ppersica_298_v2.1.cds.fa.gz peach.cds</code></p>
<h3 id="2-2-2-自己的数据"><a href="#2-2-2-自己的数据" class="headerlink" title="2.2.2. 自己的数据"></a>2.2.2. 自己的数据</h3><ol>
<li>gff2bed<br><code>python -m jcvi.formats.gff bed --type=mRNA --key=ID --primary_only sampleA.gff3.gz &gt; sampleA.bed</code></li>
</ol>
<p><code>python -m jcvi.formats.gff bed --type=mRNA --key=ID --primary_only sampleB.gff3.gz &gt; sampleB.bed</code></p>
<p>其中<code>--primary_only</code>是用于去除多个转录本的，只保留一个。（原文是多个isoforms）一般不去也不影响后续步骤，加上更好吧。</p>
<ol start="2">
<li><p>去重，会生成sampleA.uniq.bed和sampleB.uniq.bed，然后重命名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m jcvi.formats.bed uniq sampleA.bed</span><br><span class="line">mv sampleA.uniq.bed sampleA.bed</span><br><span class="line">python -m jcvi.formats.bed uniq sampleB.bed</span><br><span class="line">mv sampleB.uniq.bed sampleB.bed</span><br></pre></td></tr></table></figure>
</li>
<li><p>提取cds和pep</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">seqkit grep -f &lt;(cut -f 4 sampleA.uniq.bed ) sampleA.cdna.all.fa.gz | seqkit seq -i &gt; sampleA.cds</span><br><span class="line">seqkit grep -f &lt;(cut -f 4 sampleA.uniq.bed ) sampleB.pep.all.fa.gz | seqkit seq -i &gt; sampleA.pep </span><br><span class="line"></span><br><span class="line">seqkit grep -f &lt;(cut -f 4 sampleB.uniq.bed )  sampeB.cdna.fa.gz | seqkit seq -i  &gt; sampleB.cds</span><br><span class="line">seqkit grep -f &lt;(cut -f 4 sampleB.uniq.bed ) sampleB.pep.fa.gz | seqkit seq -i  &gt; sampleB.pep</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-3-同线性点图"><a href="#2-3-同线性点图" class="headerlink" title="2.3. 同线性点图"></a>2.3. 同线性点图</h2><h3 id="2-3-1-CDS的同线性点图dotplot"><a href="#2-3-1-CDS的同线性点图dotplot" class="headerlink" title="2.3.1. CDS的同线性点图dotplot"></a>2.3.1. CDS的同线性点图dotplot</h3><ol>
<li>确保<code>sampleA.cds</code>,<code>sampleA.bed</code>,<code>sampleB.cds</code>,<code>sampleB.bed</code>四个文件在同一目录下。</li>
<li>运行<code>python -m jcvi.compara.catalog ortholog --no_strip_names --cpu=1 sampleA sampleB</code>制作同线性点图。</li>
</ol>
<p><code>--cpu=1</code>是因为conda安装的lastal不支持多线程，所以用单线程。</p>
<ol start="3">
<li>运行时如果报错<code>ERROR savefig failed. Reset usetex to False</code>是缺少dvipng包没能生成png格式图，但看看结果文件sampleA.sampleB.anchors还是完整生成了就可以进行下一步。</li>
</ol>
<h3 id="2-3-2-蛋白的同线性点图"><a href="#2-3-2-蛋白的同线性点图" class="headerlink" title="2.3.2. 蛋白的同线性点图"></a>2.3.2. 蛋白的同线性点图</h3><p>与CDS一样，cds数据换成pep数据，在运行参数里加上数据类型<code>--dbtype prot</code>即可。</p>
<p><code>python -m jcvi.compara.catalog ortholog --dbtype prot --no_strip_names --cpu=1 sampleA sampleB</code></p>
<p><code>--cpu=1</code>是因为conda安装的lastal不支持多线程，所以用单线程。</p>
<h3 id="2-3-3-结果"><a href="#2-3-3-结果" class="headerlink" title="2.3.3. 结果"></a>2.3.3. 结果</h3><p>会生成五个结果文件。</p>
<ul>
<li>sampleA.sampleB.last: 基于LAST的比对结果</li>
<li>sampleA.sampleB.last.filtered: LAST的比对结果过滤串联重复和低分比对</li>
<li>sampleA.sampleB.anchors: 高质量的同线性区块</li>
<li>sampleA.sampleB.lifted.anchors:增加了额外的锚点，形成最终的同线性区块</li>
<li>sampleA.sampleB.pdf:同线性点图</li>
</ul>
<p>同线性点图一般可以看点连成的比较长的线，在同一横坐标范围有几根线，或者在同一纵坐标范围有几根线，从而判断两个基因组的倍数关系。</p>
<img src="https://www.dropbox.com/s/32mmo0kfhtx5b8g/grape.peach.cscore.99.png?raw=1" width=100% title="同线性点图" alt="同线性点图" align=center/>

<p><strong><p align="center">Figure 1. 同线性点图结果示例</strong><br>from <a href="https://github-wiki-see.page/m/tanghaibao/jcvi/wiki/MCscan-%28Python-version%29">MCscan jcvi viki</a></p></p>
<h2 id="2-4-同线性深度直方图"><a href="#2-4-同线性深度直方图" class="headerlink" title="2.4. 同线性深度直方图"></a>2.4. 同线性深度直方图</h2><ol>
<li>在同线性点图运行成功获得sampleA.sampleB.anchors结果文件的前提下</li>
<li>运行<code>python -m jcvi.compara.synteny depth --histogram sampleA.sampleB.anchors</code></li>
<li>生成sampleA.sampleB.depth.pdf，显示了同线性深度比例。</li>
</ol>
<img src="https://www.dropbox.com/s/hhx2dtryrum2gyo/grape.peach.depth.png?raw=1" width=100% title="同线性深度直方图" alt="同线性深度直方图" align=center/>

<p><strong><p align="center">Figure 2. 同线性深度直方图结果示例</strong><br>from <a href="https://github-wiki-see.page/m/tanghaibao/jcvi/wiki/MCscan-%28Python-version%29">MCscan jcvi viki</a></p></p>
<h2 id="2-5-同线性染色体图"><a href="#2-5-同线性染色体图" class="headerlink" title="2.5. 同线性染色体图"></a>2.5. 同线性染色体图</h2><h3 id="2-5-1-输入文件"><a href="#2-5-1-输入文件" class="headerlink" title="2.5.1. 输入文件"></a>2.5.1. 输入文件</h3><ol>
<li>seqids文件</li>
</ol>
<ul>
<li>指定展示的染色体ID，两行对应两个物种，每行的染色体之间逗号隔开，不能有空行。</li>
<li>seqids文件染色体的顺序对应同线性染色体图的顺序，可以根据前面得到的同线性点图来调整顺序使两个基因组的同线性对应，使图更清晰。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scaf001,scaf002,scaf003,scaf004,scaf005,scaf006,scaf007,scaf008,scaf009,scaf010,scaf011,scaf012,scaf013,scaf014</span><br><span class="line">scaffold1,scaffold2,scaffold3,scaffold4,scaffold5,scaffold6,scaffold7</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>.simple文件</li>
</ol>
<ul>
<li>每行代表一个同线性区块</li>
<li>一共六列，前四列是两个物种的同线性区块的上下限基因，第五列是评分，第六列是方向。</li>
<li>用前面分析同线性点图的结果文件.anchors创建。</li>
<li>运行<code>python -m jcvi.compara.synteny screen --minspan=30 --simple sampleA.sampleB.anchors sampleA.sampleB.anchors.new</code>会生成sampleA.sampleB.anchors.simple文件。</li>
</ul>
<ol start="3">
<li>layout文件</li>
</ol>
<ul>
<li>设置绘制参数。前三列是设置图的位置坐标信息，整个图的x和y轴都是[0-1]范围。第四列是设置旋转角度，第五列是设置染色体颜色，第六列是展示的标签，第七列是对齐方式，第八列指定bed文件。</li>
<li>注意, #edges下的每一行开头都不能有空格。用于指定simple文件。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># y, xstart, xend, rotation, color, label, va,  bed</span><br><span class="line"> .6,     .2,    .8,       0,      lightblue, sample_A, top, sampleA.bed</span><br><span class="line"> .4,     .2,    .8,       0,      lightpink, sample_B, top, sampleB.bed</span><br><span class="line"># edges</span><br><span class="line">e, 0, 1, sampleA.sampleB.anchors.simple</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-5-2-运行"><a href="#2-5-2-运行" class="headerlink" title="2.5.2. 运行"></a>2.5.2. 运行</h3><p><code>python -m jcvi.graphics.karyotype seqids layout</code></p>
<p>生成karyotype.pdf文件，为同线性双染色体图</p>
<img src="https://www.dropbox.com/s/51k8jujyzage3oa/grape.peach.karyotype.png?raw=1" width=100% title="同线性双染色体图" alt="同线性双染色体图" align=center/>

<p><strong><p align="center">Figure 3. 同线性双染色体图结果示例</strong><br>from <a href="https://github-wiki-see.page/m/tanghaibao/jcvi/wiki/MCscan-%28Python-version%29">MCscan jcvi wiki</a></p></p>
<h3 id="2-5-3-tips"><a href="#2-5-3-tips" class="headerlink" title="2.5.3. tips"></a>2.5.3. tips</h3><ul>
<li>运行虽然报错<code>ERROR    savefig failed. Reset usetex to False.</code>，应该是没能生成png图，但还是生成了pdf图文件。</li>
<li>当label用的名称过长时，label和图容易重叠，没有好的办法解决，最好用短一点的label。</li>
</ul>
<h3 id="2-5-4-个性化"><a href="#2-5-4-个性化" class="headerlink" title="2.5.4. 个性化"></a>2.5.4. 个性化</h3><h4 id="2-5-4-1-highlight指定同线性区块"><a href="#2-5-4-1-highlight指定同线性区块" class="headerlink" title="2.5.4.1. highlight指定同线性区块"></a>2.5.4.1. highlight指定同线性区块</h4><p>如果要突出显示指定的同线性区块（一般用于展示染色体倍数关系），则在sampleA.sampleB.anchors.sample文件中的对应同线性区域行的前面加上<code>yellowgreen*</code>,表示这行的颜色用yellowgreen展示。</p>
<p>然后再运行<code>python -m jcvi.graphics.karyotype seqids layout</code>就会生成突出显示的图。</p>
<h1 id="3-references"><a href="#3-references" class="headerlink" title="3. references"></a>3. references</h1><ol>
<li><a href="https://github.com/tanghaibao/jcvi/wiki/MCscan-(Python-version)">https://github.com/tanghaibao/jcvi/wiki/MCscan-(Python-version)</a></li>
<li><a href="https://xuzhougeng.top/archives/Comparative-genomics-using-JCVI-part-one">https://xuzhougeng.top/archives/Comparative-genomics-using-JCVI-part-one</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>synteny</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>synteny</tag>
        <tag>colinearity</tag>
        <tag>MCscan</tag>
        <tag>jcvi</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Rldeogram的ideogram函数画两物种的同线性图</title>
    <url>/2022/08/03/bioinfo_synteny_plot_Rldeogram/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=20707476&auto=1&height=32"></iframe><music URL></div>

<h1 id="1-使用Rldeogram的ideogram函数画两物种的共线性图"><a href="#1-使用Rldeogram的ideogram函数画两物种的共线性图" class="headerlink" title="1. 使用Rldeogram的ideogram函数画两物种的共线性图"></a>1. 使用Rldeogram的ideogram函数画两物种的共线性图</h1><h2 id="1-1-输入文件"><a href="#1-1-输入文件" class="headerlink" title="1.1. 输入文件"></a>1.1. 输入文件</h2><ol>
<li>karyotype.txt</li>
</ol>
<ul>
<li>Chr: 染色体号</li>
<li>Start: 起始</li>
<li>End: 终止</li>
<li>fill: 染色体填充色</li>
<li>species：物种名</li>
<li>size: 物种名字体大小</li>
<li>color: 物种名字体颜色</li>
</ul>
<p>文件示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Chr Start      End   fill species size  color</span><br><span class="line">1   1 23037639  FF8C00   Grape   12 252525</span><br><span class="line">2   1 18779884  FF8C00   Grape   12 252525</span><br><span class="line">3   1 17934068  FF8C00   Grape   12 252525</span><br><span class="line">4   1 17349521  FF8C00   Grape   12 252525</span><br><span class="line">1   1 22042719  4682B4   Populus   12 252525</span><br><span class="line">2   1 19858802  4682B4   Populus   12 252525</span><br><span class="line">3   1 19278319  4682B4   Populus   12 252525</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>synteny.txt</li>
</ol>
<ul>
<li>Species_1：物种1染色体号</li>
<li>Start_1，End_1：物种1染色体区域位置</li>
<li>Species_2：物种2染色体号</li>
<li>Start_2，End_2：物种2染色体区域位置</li>
</ul>
<p>文件示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Species_1  Start_1    End_1 Species_2 Start_2   End_2   fill</span><br><span class="line">1   12226377    12267836    1   5900307 5827251 cccccc</span><br><span class="line">1  5635667 5667377 2 4459512  4393226 cccccc</span><br><span class="line">1   7916366 7945659 3 8618518   8486865 cccccc</span><br><span class="line">2   8214553 8242202 1 5964233  6027199 cccccc</span><br><span class="line">3  2330522 2356593 1 6224069  6138821 cccccc</span><br><span class="line">3  10861038    10886821    2  8099058 8011502 cccccc</span><br><span class="line">4  9487312    9540261    3  7657579 7701112 cccccc</span><br></pre></td></tr></table></figure>

<h2 id="1-2-运行"><a href="#1-2-运行" class="headerlink" title="1.2. 运行"></a>1.2. 运行</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&#x27;RIdeogram&#x27;</span><span class="punctuation">)</span> <span class="comment">#安装RIdeogram</span></span><br><span class="line">library<span class="punctuation">(</span><span class="string">&#x27;RIdeogram&#x27;</span><span class="punctuation">)</span> <span class="comment">#载入RIdeogram</span></span><br><span class="line">ka <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;karyotype.txt&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span>header <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>stringsAsFactors <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#读取karyotype.txt文件</span></span><br><span class="line">sy <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;synteny.txt&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span>header <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span>stringsAsFactors <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#读取synteny.txt文件</span></span><br><span class="line">ideogram<span class="punctuation">(</span>karyotype <span class="operator">=</span> ka<span class="punctuation">,</span> synteny <span class="operator">=</span> sy<span class="punctuation">)</span> <span class="comment">#使用ideogram函数，生成chromosome.svg文件用于绘图</span></span><br><span class="line">convertSVG<span class="punctuation">(</span><span class="string">&quot;chromosome.svg&quot;</span><span class="punctuation">,</span> device <span class="operator">=</span> <span class="string">&quot;pdf&quot;</span><span class="punctuation">,</span>dpi<span class="operator">=</span><span class="number">1600</span><span class="punctuation">)</span> <span class="comment">#转化成chromosome.pdf文件，还可选择转化的格式：tiff，png，jpg，分辨率1600。</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-结果"><a href="#1-3-结果" class="headerlink" title="1.3. 结果"></a>1.3. 结果</h2><p>结果如下图：</p>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/ideogram.png?raw=true" title="Rldeogram绘制的同线性图" width="80%" />

<p><strong><p align="center">Figure 1. Rldeogram绘制的同线性图</p></strong></p>
<h1 id="2-references"><a href="#2-references" class="headerlink" title="2. references"></a>2. references</h1><ol>
<li><a href="https://www.jianshu.com/p/07ae1fe18071">https://www.jianshu.com/p/07ae1fe18071</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>synteny</category>
        <category>plot</category>
      </categories>
      <tags>
        <tag>R package</tag>
        <tag>R</tag>
        <tag>plot</tag>
        <tag>synteny</tag>
        <tag>Rldeogram</tag>
        <tag>ideogram</tag>
      </tags>
  </entry>
  <entry>
    <title>分析基因组共线性、计算Ks和鉴定WGD —— WGDI</title>
    <url>/2021/09/11/bioinfo_synteny_WGDI/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1697043&auto=1&height=32"></iframe></div>

<h1 id="1-WGDI介绍"><a href="#1-WGDI介绍" class="headerlink" title="1. WGDI介绍"></a>1. WGDI介绍</h1><p>WGDI (Whole-Genome Duplication Integrated analysis)是python写的命令行工具，用于多倍化和跨物种基因组比对的综合分析，包括鉴定基因组内共线性区块，Ks计算，全基因组复制事件(WGD, whole genome duplication)的数量和时间的鉴定。</p>
<p>WGDI主要的三个功能是：</p>
<ul>
<li>多倍体推断</li>
<li>基因组同源性的层次推断</li>
<li>祖先染色体核型分析</li>
</ul>
<h1 id="2-WGDI安装"><a href="#2-WGDI安装" class="headerlink" title="2. WGDI安装"></a>2. WGDI安装</h1><p>WGDI的依赖：PAML,MAFFT,MUSCLE,PAL2NAL,IQTREE。</p>
<p>安装有三种方法:</p>
<ol>
<li>conda<br><code>conda create -c bioconda -c conda-forge -n wgdi wgdi</code> 建议新建一个环境</li>
<li>pip<br><code>pip install wgdi</code></li>
<li>github<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/SunPengChuan/wgdi.git</span><br><span class="line">cd wgdi</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="3-WGDI进行共线性分析"><a href="#3-WGDI进行共线性分析" class="headerlink" title="3. WGDI进行共线性分析"></a>3. WGDI进行共线性分析</h1><h2 id="3-1-初始输入文件"><a href="#3-1-初始输入文件" class="headerlink" title="3.1. 初始输入文件"></a>3.1. 初始输入文件</h2><h3 id="3-1-1-输入文件"><a href="#3-1-1-输入文件" class="headerlink" title="3.1.1. 输入文件"></a>3.1.1. 输入文件</h3><p>WGDI需要三个输入文件，分别是基因的位置信息文件sample.gff，染色体长度信息文件sample.len和BLAST的输出文件sample.blast.txt，要求格式如下：</p>
<ol>
<li>input.gff</li>
</ol>
<ul>
<li>一共七列，以tab分隔，分别为chr(chromosome number)，geneid(gene name)，start，end，direction(strand+&#x2F;-)，order(order of each chromosome,starting from 1, 每个chr内部从1开始的顺序），original(original id and not read,旧的id，不会读入)。</li>
<li>和典型的GFF格式不一样</li>
</ul>
<ol start="2">
<li>input.len</li>
</ol>
<ul>
<li>一共三列，以tab分隔，染色体长度信息和染色体上的基因个数，chr(chromosome number), chr_length(染色体长度bp), chr_gene_number(注释到单个染色体的基因数量)。</li>
<li>后面分析作图，比如点图，图中显示的染色体顺序是依据这个文件的顺序来决定的。所以可以通过修改这个文件的染色体顺序来修改图的显示。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LG01	35874591	5368</span><br><span class="line">LG02	29224816	3939</span><br><span class="line">LG03	27760256	3620</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>sample.blast.txt</li>
</ol>
<ul>
<li>蛋白质序列的自我比对，BLAST的-outfmt 6输出格式的文件sample.blast.txt</li>
</ul>
<h3 id="3-1-2-用开发者脚本准备input-gff和input-len"><a href="#3-1-2-用开发者脚本准备input-gff和input-len" class="headerlink" title="3.1.2. 用开发者脚本准备input.gff和input.len"></a>3.1.2. 用开发者脚本准备input.gff和input.len</h3><p>开发者准备的三个脚本来对原始的sample.gff进行处理，对基因名称进行排序和重命名，生成新基因名称，以及输入文件input.gff,input.len，和用来准备sample.blast.txt的input.pep.fa。</p>
<p>脚本地址：<a href="https://github.com/SunPengChuan/wgdi-example/tree/main/genome/Aquilegia_coerulea/Aquilegia_coerulea">https://github.com/SunPengChuan/wgdi-example/tree/main/genome/Aquilegia_coerulea/Aquilegia_coerulea</a></p>
<ol>
<li>01.getgff.py</li>
</ol>
<ul>
<li>功能：从传统的gff3格式的注释文件sample.gff中提取中间文件temp.gff</li>
<li>用法：<code>python 01.getgff.py sample.gff temp.gff</code></li>
<li>temp.gff格式如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LG01	DR000002	884947	886421	+</span><br><span class="line">LG01	DR000003	886634	890799	-</span><br></pre></td></tr></table></figure>

<ul>
<li>01.getgff.py脚本：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(sys.argv[<span class="number">1</span>], sep=<span class="string">&quot;\t&quot;</span>, header=<span class="literal">None</span>,skiprows=<span class="number">3</span>)</span><br><span class="line">data = data[data[<span class="number">2</span>] == <span class="string">&#x27;mRNA&#x27;</span>]</span><br><span class="line">data = data.loc[:, [<span class="number">0</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>]]</span><br><span class="line">data[<span class="number">8</span>] = data[<span class="number">8</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;:|=|;&#x27;</span>,expand=<span class="literal">True</span>)[<span class="number">1</span>]</span><br><span class="line">data[<span class="number">0</span>] = data[<span class="number">0</span>].<span class="built_in">str</span>.replace(<span class="string">&#x27;Chr_0?&#x27;</span>,<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">data.to_csv(sys.argv[<span class="number">2</span>], sep=<span class="string">&quot;\t&quot;</span>, header=<span class="literal">None</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>02.gff_lens.py</li>
</ol>
<ul>
<li>功能：从temp.gff中生成两个输入文件：input.gff和input.len</li>
<li>用法：<code>python 02.gff_lens.py temp.gff input.gff input.len</code></li>
<li>这个脚本还对基因名称做了整理和重命名。先对temp.gff进行排序，再按照物种标识符(md)+染色体名称(LG01)+基因名称(g00001)进行重命名，input.gff的第二列是新名称，第七列是旧名称。</li>
<li>修改物种标识符(md)可以通过修改脚本的md来实现。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LG01	mdLG01g00001	23987	27163	+	1	DR032173</span><br><span class="line">LG01	mdLG01g00002	30894	32329	-	2	DR032172</span><br></pre></td></tr></table></figure>

<ul>
<li>02.gff_lens.py脚本：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/env python</span></span><br><span class="line"><span class="comment"># conding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(sys.argv[<span class="number">1</span>], sep=<span class="string">&quot;\t&quot;</span>, header=<span class="literal">None</span>)</span><br><span class="line">new = data[<span class="number">1</span>].<span class="built_in">str</span>.split(<span class="string">&#x27;.&#x27;</span>).<span class="built_in">str</span></span><br><span class="line">data[<span class="string">&#x27;id&#x27;</span>] = new[<span class="number">0</span>].values</span><br><span class="line">data[<span class="string">&#x27;cha&#x27;</span>] = data[<span class="number">3</span>]-data[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># print(data[&#x27;id&#x27;])</span></span><br><span class="line"><span class="comment"># data[&#x27;a&#x27;] = new[2].values</span></span><br><span class="line"><span class="comment"># # data[&#x27;b&#x27;] = new[3].values</span></span><br><span class="line"><span class="comment"># print(data.head())</span></span><br><span class="line"><span class="keyword">for</span> name, group <span class="keyword">in</span> data.groupby([<span class="string">&#x27;id&#x27;</span>]):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(group) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    ind = group.sort_values(by=<span class="string">&#x27;cha&#x27;</span>, ascending=<span class="literal">False</span>).index[<span class="number">1</span>:].values</span><br><span class="line">    <span class="comment">#print(name)</span></span><br><span class="line">    <span class="comment"># print(group.sort_values(by=&#x27;cha&#x27;,ascending=False))</span></span><br><span class="line"></span><br><span class="line">    data.drop(index=ind, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># data = data[data[1].str.contains(&#x27;\.mRNA1$&#x27;)]</span></span><br><span class="line">data[<span class="string">&#x27;order&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;newname&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">data[<span class="number">2</span>] = data[<span class="number">2</span>].astype(<span class="string">&#x27;int&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data.head())</span><br><span class="line"><span class="keyword">for</span> name, group <span class="keyword">in</span> data.groupby([<span class="number">0</span>]):</span><br><span class="line">    number = <span class="built_in">len</span>(group)</span><br><span class="line">    group = group.sort_values(by=[<span class="number">2</span>])</span><br><span class="line">    data.loc[group.index, <span class="string">&#x27;order&#x27;</span>] = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(group)+<span class="number">1</span>))</span><br><span class="line">    data.loc[group.index, <span class="string">&#x27;newname&#x27;</span>] = <span class="built_in">list</span>(</span><br><span class="line">        [<span class="string">&#x27;md&#x27;</span>+<span class="built_in">str</span>(name)+<span class="string">&#x27;g&#x27;</span>+<span class="built_in">str</span>(i).zfill(<span class="number">5</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(group)+<span class="number">1</span>)])</span><br><span class="line">data[<span class="string">&#x27;order&#x27;</span>] = data[<span class="string">&#x27;order&#x27;</span>].astype(<span class="string">&#x27;int&#x27;</span>)</span><br><span class="line">data = data[[<span class="number">0</span>, <span class="string">&#x27;newname&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;order&#x27;</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="built_in">print</span>(data.head())</span><br><span class="line">data = data.sort_values(by=[<span class="number">0</span>, <span class="string">&#x27;order&#x27;</span>])</span><br><span class="line">data.to_csv(sys.argv[<span class="number">2</span>], sep=<span class="string">&quot;\t&quot;</span>, index=<span class="literal">False</span>, header=<span class="literal">None</span>)</span><br><span class="line">lens = data.groupby(<span class="number">0</span>).<span class="built_in">max</span>()[[<span class="number">3</span>, <span class="string">&#x27;order&#x27;</span>]]</span><br><span class="line">lens.to_csv(sys.argv[<span class="number">3</span>], sep=<span class="string">&quot;\t&quot;</span>, header=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>03.seq_newname.py</li>
</ol>
<ul>
<li>功能：根据input.gff的第二列新名称和第七列旧名称，来把旧名称的sample.pep.fa改成新名称input.pep.fa</li>
<li>用法：<code>python 03.seq_newname.py input.gff sample.pep.fa input.pep.fa</code>，cds序列也一样修改 <code>python 03.seq_newname.py input.gff sample.cds.fa input.cds.fa</code></li>
<li>脚本最后一行<code>print(n)</code>打印一共修改了多少次，可以用来判断是否修改完全。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(sys.argv[<span class="number">1</span>], sep=<span class="string">&quot;\t&quot;</span>, header=<span class="literal">None</span>, index_col=<span class="number">6</span>)</span><br><span class="line">id_dict = data[<span class="number">1</span>].to_dict()</span><br><span class="line"><span class="built_in">print</span>(data.head())</span><br><span class="line">seqs = []</span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> seq_record <span class="keyword">in</span> SeqIO.parse(sys.argv[<span class="number">2</span>], <span class="string">&quot;fasta&quot;</span>):</span><br><span class="line">	<span class="keyword">if</span> seq_record.<span class="built_in">id</span> <span class="keyword">in</span> id_dict:</span><br><span class="line">		seq_record.<span class="built_in">id</span> = id_dict[seq_record.<span class="built_in">id</span>]</span><br><span class="line">		n += <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	seqs.append(seq_record)</span><br><span class="line">SeqIO.write(seqs, sys.argv[<span class="number">3</span>], <span class="string">&quot;fasta&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>

<h3 id="generate-conf-py脚本准备input-gff和input-len"><a href="#generate-conf-py脚本准备input-gff和input-len" class="headerlink" title="generate_conf.py脚本准备input.gff和input.len"></a>generate_conf.py脚本准备input.gff和input.len</h3><ol>
<li>脚本generate_conf.py</li>
</ol>
<ul>
<li><p>使用脚本generate_conf.py：<a href="https://github.com/xuzhougeng/myscripts/blob/master/comparative/generate_conf.py">https://github.com/xuzhougeng/myscripts/blob/master/comparative/generate_conf.py</a> 从基因组genome.fa和注释文件sample.gff3中获取input.gff和input.len文件。</p>
</li>
<li><p>命令是<code>python generate_conf.py -p input genome.fa sample.gff3</code>。</p>
</li>
</ul>
<ol start="2">
<li>可能的错误</li>
</ol>
<ul>
<li>如果存在contig没被注释到基因，generate_conf.py会报错:</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;generate_conf.py&quot;, line 117, in &lt;module&gt;</span><br><span class="line">    chrom=chrom,lens=lens,count=gene_count[chrom]), file=len_file)</span><br><span class="line">KeyError: &#x27;contig030&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>并在contig030的地方停止继续写入input.len，input.gff不受影响。</li>
</ul>
<ol start="3">
<li>可以用下面的脚本get_len.sh获取input.len</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 获取contig的长度</span></span></span><br><span class="line">samtools faidx genome.fa</span><br><span class="line">cat genome.fa.fai |cut -f1,2 &gt;chrom.len</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 获取contig的基因计数</span></span></span><br><span class="line">cat sample.gff3 |awk &#x27;$3 == &quot;gene&quot; &#123;print $1&#125;&#x27; &gt;chrom.tem</span><br><span class="line">contig=$(head -1 chrom.tem |sed &quot;s/[0-9]//g&quot;)</span><br><span class="line">c_number=$(tail -1 chrom.tem|sed &quot;s/[A-Za-z]//g&quot;)</span><br><span class="line">for i in $(seq -w 1 $c_number); do echo -e $contig$i&quot;\t&quot;$(grep &quot;$contig$i&quot; chrom.tem |wc -l);done &gt;chrom.count</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 合并生成input.len</span></span></span><br><span class="line">join chrom.len chrom.count|sed &quot;s/ /\t/g&quot; &gt;input.len</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 删除中间文件</span></span></span><br><span class="line">rm chrom.tem chrom.len chrom.count</span><br></pre></td></tr></table></figure>

<h3 id="准备sample-blastp-txt"><a href="#准备sample-blastp-txt" class="headerlink" title="准备sample.blastp.txt"></a>准备sample.blastp.txt</h3><p>用蛋白序列建库，blastp进行蛋白序列的自我比对，获取-outfmt 6格式的输出文件sample.blastp.txt。<br>如果用开发者脚本准备的输入文件，则这里需要用重命名的input.pep.fa代替sample.pep.fa。<br>命令如下：</p>
<ul>
<li><code>makeblastdb -in sample.pep.fa -dbtype prot</code></li>
<li><code>blastp -num_threads 32 -db sample.pep.fasta -query sample.pep.fa -outfmt 6 -evalue 1e-5 -num_alignments 20 -out sample.blastp.txt &amp;</code></li>
</ul>
<h2 id="3-2-共线性分析"><a href="#3-2-共线性分析" class="headerlink" title="3.2. 共线性分析"></a>3.2. 共线性分析</h2><p>WGDI的分析的参数都是在配置文件中进行设置，所以分析都需要先创建配置文件，然后修改配置文件，最后运行程序。<br>每个配置项中都有gff1，gff2；lens1，lens2；blast这五个参数，是相同的。</p>
<h3 id="3-2-1-绘制共线性点阵图"><a href="#3-2-1-绘制共线性点阵图" class="headerlink" title="3.2.1. 绘制共线性点阵图"></a>3.2.1. 绘制共线性点阵图</h3><p>WGDI的d模块绘制基因组内的共线性点阵图，初略估计是否有基因复制区域。<br>共线性点阵图是把两个基因组（做WGD分析则是把一个基因组的两份复制）分别作为横纵坐标，把检测到的同源匹配基因在相应位置做点标记；点数量多且相邻时，会有点组成的线出现，线代表比较长的共线性区块，代表着历史上的复制事件。</p>
<ol>
<li>创建配置文件input.conf<br><code>wgdi -d ? &gt;input.conf</code></li>
</ol>
<p>创建input.conf配置文件，里面包含[dotplot]配置参数。</p>
<ol start="2">
<li>修改配置文件</li>
</ol>
<ul>
<li><p>input.conf配置文件的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[dotplot]</span><br><span class="line">blast = blast file # sample.blastp.txt文件</span><br><span class="line">gff1 =  gff1 file # 比对项1的input.gff文件</span><br><span class="line">gff2 =  gff2 file # 比对项2的input.gff文件，如果是自我比对，则gff1和gff2一样</span><br><span class="line">lens1 = lens1 file # 比对项1的input.len文件</span><br><span class="line">lens2 = lens2 file # 比对项2的input.len文件，如果是自我比对，则lens1和lens2一样</span><br><span class="line">genome1_name =  Genome1 name # 比对项1的基因组名称</span><br><span class="line">genome2_name =  Genome2 name # 比对项2的基因组名称，如果是自我比对，与genome1_name一致</span><br><span class="line">multiple  = 1 # 最好的同源基因对数量，输出结果图中会用红点表示。可以先画图，再来修改这个值。</span><br><span class="line">score = 100 # blast输出的score过滤</span><br><span class="line">evalue = 1e-5 # blast输出的evalue过滤</span><br><span class="line">repeat_number = 10 # 显示的一个基因对应的同源基因的数量</span><br><span class="line">position = order # 从order,start,end中选</span><br><span class="line">blast_reverse = false</span><br><span class="line">ancestor_left = ancestor file or none # 点阵图左侧物种的祖先染色体区域，一般设置成none就好</span><br><span class="line">ancestor_top = ancestor file or none # 点阵图顶侧物种的祖先染色体区域，一般设置成none就好</span><br><span class="line">markersize = 0.5 # 点的尺寸</span><br><span class="line">figsize = 10,10 # 图的尺寸</span><br><span class="line">savefig = savefile(.png, .pdf, .svg) # 保存的图片结果名称和格式</span><br></pre></td></tr></table></figure>
</li>
<li><p>input.conf配置文件示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[dotplot]</span><br><span class="line">blast = sample.blastp.txt</span><br><span class="line">gff1 =  input.gff</span><br><span class="line">gff2 =  input.gff</span><br><span class="line">lens1 = input.len</span><br><span class="line">lens2 = input.len</span><br><span class="line">genome1_name =  sample</span><br><span class="line">genome2_name =  sample</span><br><span class="line">multiple  = 1</span><br><span class="line">score = 100</span><br><span class="line">evalue = 1e-5</span><br><span class="line">repeat_number = 10</span><br><span class="line">position = order</span><br><span class="line">blast_reverse = false</span><br><span class="line">ancestor_left = none</span><br><span class="line">ancestor_top = none</span><br><span class="line">markersize = 0.5</span><br><span class="line">figsize = 10,10</span><br><span class="line">savefig = out_dotplot.png</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p>运行<br><code>wgdi -d input.conf</code></p>
</li>
<li><p>结果<br>结果保存在out_dotplot.pdf的图中。</p>
</li>
</ol>
<p>结果解释：</p>
<ul>
<li>图中有三种颜色，红色表示genome2的基因在genome1中的最优同源匹配，次优的四个基因是蓝色，其余的是灰色。</li>
<li>WGDI会过滤掉自身与自身的比对结果，所以图中对角线出现的片段不是自身比对结果，而是串联基因（tandem）形成的共线性区块。</li>
<li>如果基因组存在加倍事件，则基因组不同区域的同源基因的排布顺序会比较一致，在图上就能观察到多个点排列组成的“线”。</li>
</ul>
<h3 id="3-2-2-获取共线性区块"><a href="#3-2-2-获取共线性区块" class="headerlink" title="3.2.2. 获取共线性区块"></a>3.2.2. 获取共线性区块</h3><p>WGDI的icl(Improved version of ColinearScan)模块用于获取共线性区块的具体位置信息。与MCScanX软件功能一致。</p>
<ol>
<li>建立配置文件<br><code>wgdi -icl ? &gt;&gt;input.conf</code></li>
</ol>
<p>在已有配置文件input.conf的基础上添加[collinearity]配置参数。</p>
<ol start="2">
<li><p>修改配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[collinearity]</span><br><span class="line">gff1 =  gff1 file # 比对项1的input.gff文件</span><br><span class="line">gff2 =  gff2 file # 比对项2的input.gff文件，如果是自我比对，则gff1和gff2一样</span><br><span class="line">lens1 = lens1 file # 比对项1的input.len文件</span><br><span class="line">lens2 = lens2 file # 比对项2的input.len文件，如果是自我比对，则lens1和lens2一样</span><br><span class="line">blast = blast file # sample.blastp.txt文件</span><br><span class="line">blast_reverse = false</span><br><span class="line">multiple  = 1 # 最好的同源基因对数量，输出结果图中会用红点表示</span><br><span class="line">process = 8 # 线程</span><br><span class="line">evalue = 1e-5 # blast输出的evalue过滤</span><br><span class="line">score = 100 # blast输出的score过滤</span><br><span class="line">grading = 50,25,10 # 为red,blue,gray三种颜色的点指定不同的分数</span><br><span class="line">mg = 25,25 # 检测共线性区域的最大gap值，即共线性区块内含的最大空缺基因数量。</span><br><span class="line">pvalue = 1 # 显著性，评估共线性blocks的紧密程度和独特程度的参数，取值范围是0-1，更好的共线性范围是0-0.2。</span><br><span class="line">repeat_number = 10 # 允许去除超过部分种群的同源基因数量</span><br><span class="line">positon = order</span><br><span class="line">savefile = out.collinearity # 保存共线性结果的文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<br><code>wgdi -icl input.conf</code></p>
</li>
</ol>
<p>4万基因的数据量，这一步耗时20分钟。</p>
<ol start="4">
<li>结果<br>结果out.collinearity中记录着共线性区域。</li>
</ol>
<p># Alignment起始的行记录着共线性区块的信息，包括得分(score),显著性(pvalue),基因对数(N)，strand(plus&#x2F;minus)。</p>
<h3 id="3-2-3-计算KaKs"><a href="#3-2-3-计算KaKs" class="headerlink" title="3.2.3. 计算KaKs"></a>3.2.3. 计算KaKs</h3><p>WGDI的ks模块计算共线性区块的基因对间的ka和ks。</p>
<ol>
<li>建立配置文件<br><code>wgdi -ks ? &gt;&gt;input.conf</code></li>
</ol>
<p>在已有配置文件input.conf的基础上添加[ks]配置参数。</p>
<ol start="2">
<li><p>修改配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ks]</span><br><span class="line">cds_file =  input.cds.fa # 基因组(一个或多个)的cds序列</span><br><span class="line">pep_file =  input.pep.fa # 基因组(一个或多个)的氨基酸序列；可选参数，如果不设置，将用biopython模块翻译cds文件获得。</span><br><span class="line">align_software = muscle # 选择多序列比对软件:&#123;muscle,mafft&#125;</span><br><span class="line">pairs_file = out.collinearity # tab分隔的共线性基因对。上一步共线性分析的结果文件，也支持MCScanX的共线性分析结果文件。</span><br><span class="line">ks_file = out.ks # 保存ks结果的文件名</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<br><code>wgdi -ks input.conf</code></p>
</li>
</ol>
<ul>
<li>WGDI会用muscle根据氨基酸序列进行联配，然后用pal2pal.pl基于cds序列将氨基酸联配转为密码子联配，最后用paml中的yn00和ng86两种方法计算ka和ks。</li>
<li>4万基因的数据量，这一步耗时40分钟。</li>
</ul>
<ol start="4">
<li>结果</li>
</ol>
<ul>
<li>out.ks结果有6列，对应的是每个基因的ka和ks。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ head -2 out.ks</span><br><span class="line">id1  id2  ka_NG86  ks_NG86  ka_YN00  ks_YN00</span><br><span class="line">vvi161s1g00311	vvi161s1g00312	0.2986	1.2027	0.3047	1.3864</span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-整合共线性区块信息"><a href="#3-2-4-整合共线性区块信息" class="headerlink" title="3.2.4. 整合共线性区块信息"></a>3.2.4. 整合共线性区块信息</h3><p>WGDI的bi模块可以整合共线性区块和ks信息成一个可读性更强的csv文件。</p>
<ol>
<li>建立配置文件<br><code>wgdi -bi ? &gt;&gt;input.conf</code></li>
</ol>
<p>在已有配置文件input.conf的基础上添加[blockinfo]配置参数。</p>
<ol start="2">
<li>修改配置参数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[blockinfo]</span><br><span class="line">blast = input.blastp.txt</span><br><span class="line">gff1 =  input.gff</span><br><span class="line">gff2 =  input.gff</span><br><span class="line">lens1 = input.len</span><br><span class="line">lens2 = input.len</span><br><span class="line">collinearity = out.collinearity # 共线性区域结果文件</span><br><span class="line">score = 100</span><br><span class="line">evalue = 1e-5</span><br><span class="line">repeat_number = 20</span><br><span class="line">position = order</span><br><span class="line">ks = out.ks # ks结果文件</span><br><span class="line">ks_col = ks_NG86 # 声明使用ks结果文件的列名</span><br><span class="line">savefile = block_info.csv</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>运行<br><code>wgdi -bi input.conf</code></p>
</li>
<li><p>结果</p>
</li>
</ol>
<p>结果文件block_info.csv共11列：</p>
<ul>
<li>id：共线性结果的id</li>
<li>chr1,start1,end1：点图左边的基因组共线性区块的位置范围</li>
<li>chr2,start2,end2：点图上边的基因组共线性区块的位置范围</li>
<li>pvalue：共线性结果评估，一般认为&lt;0.01更合理</li>
<li>length：共线性区块长度</li>
<li>ks_median：共线性区块上所有基因对ks的中位数，用于评估ks分布</li>
<li>ks_average：共线性区块上所有基因对ks的平均值</li>
<li>homo1-n：multiple参数为n，则有n列，表示一个基因有n个最佳匹配时的取值，对应点阵图中的红点</li>
<li>block1,block2：共线性区块上基因order的位置</li>
<li>ks：共线性区块上基因对的ks值</li>
<li>density1,density2：共线性区块的基因分布密集程度，值越大越密集</li>
<li>class1,class2：在alignment模块中用到，对应两个block分组。默认值是0，表示两个block是同一组。这两列需要根据覆盖率、染色体核型等多个方面进行确定。</li>
</ul>
<h2 id="3-3-根据ks分布拟合单次WGD事件"><a href="#3-3-根据ks分布拟合单次WGD事件" class="headerlink" title="3.3. 根据ks分布拟合单次WGD事件"></a>3.3. 根据ks分布拟合单次WGD事件</h2><ol>
<li>背景知识<br>在Lynch和Conery在2000年发表在Science的论文中，他们证明了小规模基因复制的Ks分布是L型，而在L型分布背景上叠加的峰则是来自于演化历史中某个突然的大规模复制事件。<br>L型分布（呈指数分布, exponential distribution)的峰可能是近期的串联复制引起，随着时间推移基因丢失，形成一个向下的坡。正态分布(normal distribution)的峰则是由全基因组复制引起。</li>
</ol>
<p>这就意味着我们可以根据ks频率分布图的正态分布峰来判断物种历史上发生过的全基因组复制事件，并通过ks值拟合峰值获得WGD事件发生的时间。</p>
<ol start="2">
<li>根据ks分布拟合单次WGD事件的峰</li>
</ol>
<ul>
<li>通过kspeaks(-kp)模块过滤blockinfo文件，根据ks峰值分布设置ks_area过滤参数，同时可以调整homo参数看看效果，得到单独一个WGD事件形成的共线性区块和相应的ks值。</li>
<li>接着用PeaksFit(-pf)模块对值的峰进行拟合得到模型参数。</li>
<li>最后用KsFigures(-kf)将拟合结果绘制到一张图上。</li>
<li>想看单个WGD事件的ks点阵图还可以把blockks的blockinfo参数换成kspeaks(-kp)模块过滤后得到的ks_median.distri.csv，跑一遍绘制ks点阵图(-bk)模块获取过滤后的ks点阵图。</li>
</ul>
<p>因为用WGDI对ks频率分布图的峰进行拟合时，一次只能拟合一个峰。当发现两次或多次WGD事件后，需要两次或多次重复以上分析过程，分别获取WGD的ks拟合图。</p>
<h2 id="3-4-ks拟合和可视化"><a href="#3-4-ks拟合和可视化" class="headerlink" title="3.4. ks拟合和可视化"></a>3.4. ks拟合和可视化</h2><h3 id="3-4-1-ks可视化——过滤并绘制ks点阵图"><a href="#3-4-1-ks可视化——过滤并绘制ks点阵图" class="headerlink" title="3.4.1. ks可视化——过滤并绘制ks点阵图"></a>3.4.1. ks可视化——过滤并绘制ks点阵图</h3><p>第一步绘制的点阵图里包含基因组上检测到的所有同源基因对（所以点特别多），bk模块绘制的ks点阵图的点只包含确认了共线性的基因对，用ks值作为点的颜色信息，可以根据ks点阵图的共线性区域的颜色来区分不同时期的多倍化事件。</p>
<ol>
<li>建立配置文件<br><code>wgdi -bk ? &gt;&gt;input.conf</code></li>
</ol>
<p>在已有配置文件input.conf的基础上添加[blockks]配置参数。</p>
<ol start="2">
<li><p>修改配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[blockks]</span><br><span class="line">lens1 = input.len</span><br><span class="line">lens2 = input.len</span><br><span class="line">genome1_name =  sample</span><br><span class="line">genome2_name =  sample</span><br><span class="line">blockinfo =  block_info.csv # bi模块整合结果</span><br><span class="line">pvalue = 0.2 # 共线性区块的显著性，对应blockinfo的pvalue列</span><br><span class="line">tandem = true # 是否过滤串联基因形成的共线性区（在点阵图上对角线附近）</span><br><span class="line">tandem_length = 200 # 如果tandem=true，那么评估tandem的标准为两个区块的物理距离</span><br><span class="line">markersize = 1</span><br><span class="line">area = 0,2 # 输出结果中ks的取值范围</span><br><span class="line">block_length =  5 # 一个共线性区块的最小基因对数量，对应blockinfo的length列</span><br><span class="line">figsize = 8,8</span><br><span class="line">savefig = ks.dotplot.pdf</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<br><code>wgdi -bk input.conf</code></p>
</li>
<li><p>结果<br>结果保存在ks.dotplot.pdf文件中。</p>
</li>
</ol>
<p>结果解释：</p>
<ul>
<li>图中每个点都是共线性区块的基因对，点的颜色是ks值。</li>
<li>可以用共线性区块的ks中位数来初步判断复制发生的时间，所以图中颜色相近的共线性区块看作同时发生的复制，当图中大致观察到两种颜色的点和线时，表示对应的两次全基因组复制事件。</li>
</ul>
<h3 id="3-4-2-ks可视化——过滤并绘制ks频率分布图"><a href="#3-4-2-ks可视化——过滤并绘制ks频率分布图" class="headerlink" title="3.4.2. ks可视化——过滤并绘制ks频率分布图"></a>3.4.2. ks可视化——过滤并绘制ks频率分布图</h3><p>通过计算共线性区块的基因对ks值，可以获得基因对复制发生的时间，如果有全基因组复制（WGD）发生，那么现有物种的基因组会留下许多ks相近的基因对，通过ks频率分布图可以看到峰，由此判断WGD的发生次数和发生时间。</p>
<ol>
<li>建立配置文件<br><code>wgdi -kp ? &gt;&gt;input.conf</code></li>
</ol>
<p>在已有配置文件input.conf的基础上添加[kspeaks]配置参数。</p>
<ol start="2">
<li><p>修改配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kspeaks]</span><br><span class="line">blockinfo = block_info.csv</span><br><span class="line">pvalue = 0.2 # 共线性区块的显著性，对应blockinfo的pvalue列</span><br><span class="line">tandem = true # 是否过滤串联重复基因形成的共线性区（在点阵图上对角线附近）</span><br><span class="line">block_length = 5 # 共线性区块的基因对的数目</span><br><span class="line">ks_area = 0,10 # 对应blockinfo的ks列，0-10表示只保留ks在0-10的基因对。</span><br><span class="line">multiple  = 1 # 选择homo中的哪列用于后续过滤，一般选homo1</span><br><span class="line">homo = -1,1 # 根据homo的共线性区块中基因对的总体得分（取值范围-1，1，值越大表示最佳匹配的基因对越多，也就是越近期的WGD事件得到的基因对）对共线性区块进行过滤，只取得分在-1-1之间的共线性区块，即不根据homo过滤。</span><br><span class="line">fontsize = 9</span><br><span class="line">area = 0,3</span><br><span class="line">figsize = 10,6.18</span><br><span class="line">savefig = ks_median.distri.pdf # ks频率分布图结果</span><br><span class="line">savefile = ks_median.distri.csv # 对block_info.csv的过滤后结果，与block_info.csv格式一致</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<br><code>wgdi -kp input.conf</code></p>
</li>
</ol>
<p>根据配置参数过滤blockinfo文件的低质量数据，再绘制频率分布图。</p>
<ol start="4">
<li>结果<br>结果保存在ks_median.distri.pdf（ks峰图）和ks_median.distri.csv（输入文件block_info.csv过滤后结果，与block_info.csv格式一致）。</li>
</ol>
<p>从峰图的峰的数量可以估计WGD的数量。</p>
<ol start="5">
<li>说明<br>因为用WGDI对ks频率分布图的峰进行拟合时，一次只能拟合一个峰。当发现两次或多次WGD事件后，需要两次或多次重复以上分析过程，分别获取WGD的ks拟合图。</li>
</ol>
<p>所以也可以先不过滤绘制ks频率分布图，初步查看ks的分布情况；再根据每次WGD事件的分布设置ks_area,multiple,homo三个参数来分离单次WGD事件的数据，再进行过滤-拟合-作图。</p>
<p>三个参数的设置：</p>
<ul>
<li>ks_area：根据单次WGD的ks分布范围设置，过滤出单次WGD的数据。</li>
<li>multiple：选择不同的homo，一般没有特殊需求，选择最优的，即1。</li>
<li>homo：设置不同的homo范围，观察做出的图中峰的变化来确定homo范围是否合理。</li>
</ul>
<h3 id="3-4-3-高斯拟合ks频率分布图的峰——pf模块"><a href="#3-4-3-高斯拟合ks频率分布图的峰——pf模块" class="headerlink" title="3.4.3. 高斯拟合ks频率分布图的峰——pf模块"></a>3.4.3. 高斯拟合ks频率分布图的峰——pf模块</h3><ol>
<li>建立配置文件<br><code>wgdi -pf ? &gt;&gt;peak.conf</code></li>
</ol>
<p>在已有配置文件input.conf的基础上添加[kspeaks]配置参数。</p>
<ol start="2">
<li><p>修改配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[peaksfit]</span><br><span class="line">blockinfo  =  ks.distri.csv</span><br><span class="line">mode  =  median</span><br><span class="line">bins_number  =  200</span><br><span class="line">ks_area  =  0,10</span><br><span class="line">fontsize  =  9</span><br><span class="line">area  =  0,3</span><br><span class="line">figsize  =  10,6.18</span><br><span class="line">savefig  =  ks.peaksfit.pdf </span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<br><code>wgdi -pf peak.conf</code></p>
</li>
<li><p>结果</p>
</li>
</ol>
<ul>
<li>拟合图ks.peaksfit.pdf</li>
<li>参数：包括一个R-square和3个拟合参数the gaussian fitting curve parameters</li>
<li>拟合参数用于后续ksfigure模块作图。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R-square: 0.9804748699350867</span><br><span class="line">The gaussian fitting curve parameters are :</span><br><span class="line">5.02360835744403  |  0.8319599832352784  |  0.10382203381206191</span><br></pre></td></tr></table></figure>

<p>其中0.83是峰值，5.02是幅值，0.10是标准差。</p>
<h3 id="3-4-4-拟合结果作图——kf模块"><a href="#3-4-4-拟合结果作图——kf模块" class="headerlink" title="3.4.4. 拟合结果作图——kf模块"></a>3.4.4. 拟合结果作图——kf模块</h3><ol>
<li><p>建立配置文件<br>在已有配置文件input.conf的基础上添加[ksfigure]配置参数。<br><code>wgdi -kf ? &gt;&gt;input.conf</code></p>
</li>
<li><p>创建all_ks.csv文件</p>
</li>
</ol>
<ul>
<li><p>all_ks.csv文件内容<br>第一行为标题行，之后行为数据行。<br>共有4+3n列(n是peak数量，即WGD的次数），逗号分隔，第一列是样本信息，第2-3列对应线条属性(color,linewidth,linestyle)，后面列都是拟合参数（the gaussian fitting curve parameters拟合参数，每个peak有3个拟合参数，n个peaks有3n个，依次列出。<br>标题行要包含所有列（可为空）；数据行根据各自的峰数量可能有不同列数（比如一个峰的7列，两个峰的10列）。</p>
</li>
<li><p>all_ks.csv文件示例<br>两个样本，三次比对(sample1_sample1,sample2_sample2,sample1_sample2)，两个峰的all_ks.csv文件示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">,color,linewidth,linestyle,,,,,,</span><br><span class="line">sample1_sample1,green,1,--,5.02360835744403,0.8319599832352784,0.10382203381206191,2.084853812322066,1.8332872127128195,0.2506813629824027</span><br><span class="line">sample2_sample2,red,1,--,5.02360835744403,0.8319599832352784,0.10382203381206191,2.084853812322066,1.8332872127128195,0.2506813629824027</span><br><span class="line">sample1_sample2,yellow,1,-,3.00367275,1.288717936,0.177816426</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p>修改配置参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ksfigure]</span><br><span class="line">ksfit = all_ks.csv # 拟合参数文件</span><br><span class="line">labelfontsize = 15</span><br><span class="line">legendfontsize = 15</span><br><span class="line">xlabel = Synonymous nucleotide substitution (Ks)</span><br><span class="line">ylabel = Density</span><br><span class="line">title = none</span><br><span class="line">area = 0,4</span><br><span class="line">figsize = 10,6.18</span><br><span class="line">savefig =  all_ks.pdf #保存的拟合图</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<br><code>wgdi -kf input.conf</code></p>
</li>
</ol>
<p>得到all_ks.pdf拟合图</p>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li>WGDI’s documentation：<a href="https://wgdi.readthedocs.io/en/latest/">https://WGDI.readthedocs.io/en/latest/</a></li>
<li>WGDI’s github：<a href="https://github.com/SunPengChuan/wgdi">https://github.com/SunPengChuan/wgdi</a></li>
<li>xuzhougeng’s WGDI上：<a href="https://www.jianshu.com/p/a50548e81ac0">https://www.jianshu.com/p/a50548e81ac0</a></li>
<li>xuzhougeng’s WGDI中：<a href="https://www.jianshu.com/p/0e4a2807468d">https://www.jianshu.com/p/0e4a2807468d</a></li>
<li>xuzhougeng’s WGDI下：<a href="https://www.jianshu.com/p/28a4c3045919">https://www.jianshu.com/p/28a4c3045919</a></li>
<li>xuzhougeng’s WGDI blockinfo blog：<a href="https://www.jianshu.com/p/e97fdcf5d06f">https://www.jianshu.com/p/e97fdcf5d06f</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>synteny</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>WGD</tag>
        <tag>Ks</tag>
        <tag>synteny</tag>
        <tag>colinearity</tag>
        <tag>WGDI</tag>
      </tags>
  </entry>
  <entry>
    <title>转录因子（transcription factor，TF）基础及WGD后保留的TF分析</title>
    <url>/2022/10/18/bioinfo_transcriptionFactor/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=105140&auto=1&height=32"></iframe></div>


<h1 id="1-转录因子（transcription-factor）"><a href="#1-转录因子（transcription-factor）" class="headerlink" title="1. 转录因子（transcription factor）"></a>1. 转录因子（transcription factor）</h1><p>转录因子（transcription factor，TF）是一种蛋白质，它通过与特定DNA序列结合来控制遗传信息从DNA到信使RNA的转录速率。</p>
<p>TFs 的功能是调节——打开和关闭——基因，以确保它们在所需的细胞中在正确的时间和正确的数量表达。TF 组以协调的方式发挥作用，在整个生命过程中指导细胞分裂、细胞生长和细胞死亡；胚胎发育过程中的细胞迁移和组织；并且间歇性地响应来自细胞外的信号，例如激素。人类基因组中有多达 1600 个 TF 。转录因子是蛋白质组和调节组的成员。</p>
<h1 id="2-植物转录因子数据库PlantTFDB"><a href="#2-植物转录因子数据库PlantTFDB" class="headerlink" title="2. 植物转录因子数据库PlantTFDB"></a>2. 植物转录因子数据库PlantTFDB</h1><p>植物转录因子数据库PlantTFDB是北京大学生物信息学中心研发的数据库和网站，目前包括165个植物物种的转录因子。</p>
<p>目前数据库已更新到v5.0，在网站<a href="http://planttfdb.gao-lab.org/index.php%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E3%80%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E4%BD%BF%E7%94%A8%E6%A4%8D%E7%89%A9%E8%BD%AC%E5%BD%95%E5%9B%A0%E5%AD%90%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%82">http://planttfdb.gao-lab.org/index.php可以查看、下载和使用植物转录因子数据库。</a></p>
<p>网站的功能包括：</p>
<ol>
<li>上传核酸或蛋白质的fasta序列，在线做转录因子的注释。</li>
<li>上传核酸或蛋白质的fasta序列，在线与数据库做blastx或blastp比对。</li>
<li>下载特定植物的TF列表，CDS或蛋白质序列。</li>
<li>查询特定TF和TF家族的功能描述。</li>
</ol>
<h1 id="3-转录因子相关分析"><a href="#3-转录因子相关分析" class="headerlink" title="3. 转录因子相关分析"></a>3. 转录因子相关分析</h1><p>转录因子分析可以应用的场景很多，这里介绍全基因组复制事件（WGD）后转录因子保留的分析。</p>
<h2 id="3-1-WGD后保留TF的分析"><a href="#3-1-WGD后保留TF的分析" class="headerlink" title="3.1. WGD后保留TF的分析"></a>3.1. WGD后保留TF的分析</h2><h3 id="3-1-1-思路"><a href="#3-1-1-思路" class="headerlink" title="3.1.1. 思路"></a>3.1.1. 思路</h3><p>除了直接看WGD后保留的基因中包含了什么种类和多少数量的TF外，还可以通过利用转录因子数据库PlantTFDB来做WGD后保留的每种TF的保留模式的进一步分析。</p>
<ol>
<li>参考</li>
</ol>
<ul>
<li>paper: <a href="https://www.sciencedirect.com/science/article/pii/S1674205219303594">https://www.sciencedirect.com/science/article/pii/S1674205219303594</a> 的 Retention Analysis of Transcription Factors部分。</li>
<li>在博客<strong>鉴定全基因复制事件(WGD)后保留的复制基因</strong> <a href="https://yanzhongsino.github.io/2022/10/18/bioinfo_WGD_geneRetention/">https://yanzhongsino.github.io/2022/10/18/bioinfo_WGD_geneRetention/</a> 的基础上完成WGD后保留TF的分析</li>
</ul>
<ol start="2">
<li>基本思路</li>
</ol>
<ul>
<li>从PlantTFDB数据库下载已有物种（比如拟南芥）的TF家族，用下载的TF家族注释orthogroups。对每个WGD事件，确认每个TF家族的保留的orthogroups的数量。</li>
<li>有些TF家族可能会被分到几个orthogroups，为了消除一个TF家族的orthogroups的大小不均的影响，文章通过标准化计算一个保留参数R值（retention value），R值用来反映WGD事件后每个TF的保留模式。</li>
</ul>
<ol start="3">
<li>R值的计算公式：$$Rvalue&#x3D;(Rs⁄Ts)&#x2F;(Ra⁄Ta)&#x3D;Rs<em>Ta&#x2F;Ts</em>Ra$$，其中：</li>
</ol>
<ul>
<li>Rs: Number of orthogroups with retention in specific TF</li>
<li>Ts: Total number of orthogroups in specific TF</li>
<li>Ra: Number of all TF orthogroups with retention</li>
<li>Ta: Total number of TF orthogroups</li>
<li>Rs&#x2F;Ts: 代表在WGD后特定TF家族保留的可能性</li>
<li>Ra&#x2F;Ta: 代表在WGD后所有TF家族保留的可能性</li>
<li>Rvalue: 用Rs&#x2F;Ts比上Ra&#x2F;Ta，代表相较TF家族平均水平，特定TF家族保留的可能性的高低。Rvalue越大，特定TF家族的保留率越高。</li>
</ul>
<h3 id="3-1-2-准备文件"><a href="#3-1-2-准备文件" class="headerlink" title="3.1.2. 准备文件"></a>3.1.2. 准备文件</h3><ol>
<li>Orthogroups.txt</li>
</ol>
<ul>
<li>Orthofinder的结果文件&#x2F;path&#x2F;to&#x2F;OrthoFinder&#x2F;Results_xx&#x2F;Orthogroups&#x2F;Orthogroups.txt</li>
<li>Orthofinder运行时需要包含了下载TF的物种</li>
</ul>
<ol start="2">
<li>dup_wgd.og</li>
</ol>
<ul>
<li>dup_wgd.og包含了前期分析的基因复制的、涉及特定WGD保留的那些orthogroups的ID列表。</li>
<li>可以从WGD后保留基因的分析的结果文件<code>N5_filter_OG_dup.tsv</code>中提取第二列来获取：<code>cat N5_filter_OG_dup.tsv|cut -f2 &gt;dup_wgd.og</code>。</li>
</ul>
<ol start="3">
<li>下载Ath_TF_list.txt并转化成Ath_TF_list.og</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat Ath_TF_list.txt|sed &#x27;1d&#x27;|cut -f2 &gt;ath_2.tem # 提取第二列geneID</span><br><span class="line">cat Ath_TF_list.txt |sed &#x27;1d&#x27;|cut -f3|sort|uniq &gt;ath.tf # 提取第三列Family</span><br><span class="line">for i in $(cat ath_2.tem); do echo $i &gt;&gt;ath.og &amp;&amp; grep $i /path/to/OrthoFinder/Results_xx/Orthogroups/Orthogroups.txt|cut -d &quot;:&quot; -f1 &gt;&gt;ath.og ; done # 根据geneID提取orthogroups</span><br><span class="line">sed -i -e &#x27;1i\Gene_ID\torthogroups_ID&#x27; -e &quot;s/ /\t/g&quot; ath.og # 在ath.og文件首行前插入标题行，并把列间分隔的空格改成tab分隔。</span><br><span class="line">paste Ath_TF_list.txt ath.og &gt;Ath_TF_list.og # 横向拼接Ath_TF_list.txt和ath.og两个文件</span><br><span class="line">head Ath_TF_list.og &amp;&amp; tail Ath_TF_list.og # 检查一下首尾的第二列和第四列是不是一样，看有没有拼接错误</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-统计R相关参数"><a href="#3-1-3-统计R相关参数" class="headerlink" title="3.1.3. 统计R相关参数"></a>3.1.3. 统计R相关参数</h3><ol>
<li>这里的Ta、Ra、Ts、Rs可以用两种数量来代表，一种是统计TF_ID的数量，另一种是统计Orthogroups的数量。</li>
</ol>
<ul>
<li>下面的是统计TF_ID的数量，如果想要统计Orthogroups的数量，则需要在每一个值统计命令<code>wc -l</code>前面加上<code>cut -f5|sort|uniq|</code>来提取Orthogroups并去重。</li>
</ul>
<ol start="2">
<li>对每一个ath.tf里的Family，统计Ta,Ra,Rs和Ts值</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in $(cat ath.tf);</span><br><span class="line">do</span><br><span class="line">    ta = $(($(cat Ath_TF_list.ogs|wc -l)-1)) # 统计Ta值（有标题行，结果需要减1）</span><br><span class="line">    ra = $(grep -f dup_wgd.og Ath_TF_list.ogs|wc -l) # 统计Ra值</span><br><span class="line">	rs=$(grep -f dup_wgd.og Ath_TF_list.ogs |awk -v awka=&quot;$i&quot; &#x27;$3 == awka &#123;print$0&#125;&#x27;|wc -l);</span><br><span class="line">	ts=$(awk -v awka=&quot;$i&quot; &#x27;$3 == awka &#123;print $0&#125;&#x27; Ath_TF_list.ogs |wc -l);</span><br><span class="line">	echo &quot;$&#123;i&#125; $&#123;rs&#125; $&#123;ts&#125; $&#123;ra&#125; $&#123;ta&#125;&quot; &gt;&gt; ath_r.tem</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>有了Ta,Ra,Rs和Ts值，接下来就可以计算Rvalue&#x3D;(Rs⁄Ts)&#x2F;(Ra⁄Ta)了。</li>
</ol>
<ul>
<li><code>cat ath_r.tem|sed &quot;s/ /\t/g&quot;|awk -F&quot;\t&quot; &#39;&#123;print $0,($1*$4)/($2*$3)&#125;&#39;|sed &#39;1i\TF\tRs\tTs\tRa\tTa\tRvalue&#39; &gt;ath_r.txt</code> 待检查是否有效</li>
</ul>
<h3 id="3-1-4-绘制热图"><a href="#3-1-4-绘制热图" class="headerlink" title="3.1.4. 绘制热图"></a>3.1.4. 绘制热图</h3><p>热图绘制可以参考博客<a href="https://yanzhongsino.github.io/2022/11/06/R_plot_heatmap">https://yanzhongsino.github.io/2022/11/06/R_plot_heatmap</a></p>
<ul>
<li>如果只有一次WGD的TF保留结果，可以直接根据Rvalue判断哪些TF家族保留率高。</li>
<li>如果有多次WGD的TF保留结果，或者做了多个物种的TF数据库保留结果，可以绘制热图相互比较。</li>
</ul>
<p>用R包pheatmap绘制热图，简单快捷。(notes: 画热图这里的代码还需根据数据格式调整)</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df<span class="operator">&lt;-</span>read.table<span class="punctuation">(</span><span class="string">&quot;tf_rvalue.txt&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span> <span class="string">&quot; &quot;</span><span class="punctuation">,</span> header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span>row.names <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">df_row <span class="operator">&lt;-</span> hclust<span class="punctuation">(</span>dist<span class="punctuation">(</span>df<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#对行聚类</span></span><br><span class="line">df <span class="operator">&lt;-</span> df<span class="punctuation">[</span>df_row<span class="operator">$</span>order<span class="punctuation">,</span><span class="punctuation">]</span> <span class="comment">#按行聚类结果排序</span></span><br><span class="line">df_column <span class="operator">&lt;-</span> hclust<span class="punctuation">(</span>dist<span class="punctuation">(</span>t<span class="punctuation">(</span>df<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#对列聚类</span></span><br><span class="line">df <span class="operator">&lt;-</span> df<span class="punctuation">[</span><span class="punctuation">,</span>df_column<span class="operator">$</span>order<span class="punctuation">]</span> <span class="comment">#按列聚类结果排序</span></span><br><span class="line"></span><br><span class="line">BiocManager<span class="operator">::</span>install<span class="punctuation">(</span><span class="string">&quot;pheatmap&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>pheatmap<span class="punctuation">)</span></span><br><span class="line">pheatmap<span class="punctuation">(</span>df<span class="punctuation">,</span>color <span class="operator">=</span> colorRampPalette<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;lightgreen&quot;</span><span class="punctuation">,</span> <span class="string">&quot;yellow&quot;</span><span class="punctuation">,</span><span class="string">&quot;orange&quot;</span><span class="punctuation">,</span><span class="string">&quot;red&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">(</span><span class="number">20</span><span class="punctuation">)</span><span class="punctuation">,</span>legend_breaks <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> legend_labels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;1.0&quot;</span><span class="punctuation">,</span><span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span><span class="string">&quot;3.0&quot;</span><span class="punctuation">,</span><span class="string">&quot;4.0&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> border_color<span class="operator">=</span><span class="string">&quot;white&quot;</span><span class="punctuation">,</span>treeheight_row <span class="operator">=</span> <span class="number">50</span><span class="punctuation">,</span> treeheight_col <span class="operator">=</span> <span class="number">8</span><span class="punctuation">,</span> display_numbers <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> number_color <span class="operator">=</span> <span class="string">&quot;black&quot;</span><span class="punctuation">,</span>main <span class="operator">=</span> <span class="string">&quot;TF heatmap&quot;</span><span class="punctuation">,</span>cellwidth <span class="operator">=</span> <span class="number">50</span><span class="punctuation">,</span> cellheight <span class="operator">=</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 其中color = colorRampPalette(c(&quot;lightgreen&quot;, &quot;yellow&quot;,&quot;orange&quot;,&quot;red&quot;))(20) #设置颜色渐变，值从低到高依次是浅绿色-黄色-橙色-红色，共20个颜色。</span></span><br></pre></td></tr></table></figure>

<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li>wiki:transcription factor: <a href="https://en.wikipedia.org/wiki/Transcription_factor">https://en.wikipedia.org/wiki/Transcription_factor</a></li>
<li>PlantTFDB: <a href="http://planttfdb.gao-lab.org/index.php">http://planttfdb.gao-lab.org/index.php</a></li>
<li>paper: <a href="https://www.sciencedirect.com/science/article/pii/S1674205219303594">https://www.sciencedirect.com/science/article/pii/S1674205219303594</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>transcription factor</category>
      </categories>
      <tags>
        <tag>WGD</tag>
        <tag>transcription factor</tag>
        <tag>PlantTFDB</tag>
      </tags>
  </entry>
  <entry>
    <title>结构变异分析软件：Assemblytics</title>
    <url>/2022/08/02/bioinfo_variation_SV_Assemblytics/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=20707476&auto=1&height=32"></iframe></div>

<h1 id="1-Assemblytics简介"><a href="#1-Assemblytics简介" class="headerlink" title="1. Assemblytics简介"></a>1. Assemblytics简介</h1><ol>
<li>Assemblytics在2016年发表在Bioinformatics上，用于检测检测基因组间的结构变异（Structural Variation，SV）。</li>
<li>Assemblytics检测的结构变异主要包括：INDELs，tandem和repeat的expansion和contraction；不包含倒位inversion和易位translocation的检测。</li>
<li>Assemblytics建议使用基因组组装的contigs而非scaffolds，避免Ns对统计结构变异产生影响（假阳性）。</li>
</ol>
<img src="https://oup.silverchair-cdn.com/oup/backfile/Content_public/Journal/bioinformatics/32/19/10.1093_bioinformatics_btw369/5/btw369f1p.gif?Expires=1662466735&Signature=XxOCD8I9su8WHNrORriUZmNxiCU219tKxNJr~iM-QEGM1pWydiON3YFnn~znOY~ibASOkh6T8rTksGBcPKFI-3ymeYLx2FDqR29phWp90a4of40ouDPqKsK5Crw5PVK5qNbbbV67n5hKpsaxUOtim-jDp5kyM8lZmPzQGm6qTRE5nclS6Lis-mQw96ZQFeguCbTS1k4Re7ULtzaMO1uLOEWG-401s~2JbBG07HI7cmt2UAP3zLV~n8CV8ISpi~W8SqvBaF7EjEqpPITGxSQQJCTP8EOg1erhp7Knf6jgTuwvnGShz4-cNNH2oRN3~2kw6aug3~B0qqPmhgFkW4JYGQ__&Key-Pair-Id=APKAIE5G5CRDK6RD3PGA" width=100% title="Assemblytics" alt="Assemblytics" align=center/>

<p><strong><p align="center">Figure 1. variant class and web results interface Assemblytics</strong><br>图片来源： <a href="https://academic.oup.com/bioinformatics/article/32/19/3021/2196631">Assemblytics paper</a></p></p>
<h1 id="2-Assemblytics使用"><a href="#2-Assemblytics使用" class="headerlink" title="2. Assemblytics使用"></a>2. Assemblytics使用</h1><p>Assemblytics的使用很简单，网站也说得清楚明了。</p>
<ol>
<li>先用MUMmer把reference genome和query genome比对，得到共线性结果。</li>
</ol>
<p><code>nucmer -maxmatch -l 100 -c 500 REFERENCE.fa ASSEMBLY.fa -prefix OUT</code></p>
<ul>
<li>-l 100：最小匹配长度设置成100</li>
<li>-c 500：最小匹配序列簇的匹配长度为500</li>
<li>-prefix OUT：输出结果文件前缀为OUT</li>
</ul>
<ol start="2">
<li>把delta结果文件压缩，压缩后的结果OUT.delta.gz上传到Assemblytics网站。</li>
</ol>
<p><code>gzip OUT.delta</code></p>
<ol start="3">
<li>填写参数，提交即可在线运行和得到结果。参数包括：</li>
</ol>
<ul>
<li>Description：物种名或样品名</li>
<li>Unique Sequence length required：需要的独特序列长度，代表一个决定用于call variants的序列是否独特的一个锚定（anchor），用于代替读取比对（read alignment）的映射质量的过滤，默认是10000。</li>
<li>Maximum variant size：最大变异的大小，默认是10000。</li>
<li>Minimum variant size：最小变异的大小，默认是50。</li>
</ul>
<h1 id="3-结果"><a href="#3-结果" class="headerlink" title="3. 结果"></a>3. 结果</h1><p>运行结果包括可交互的可视化图的界面和可下载的压缩包。</p>
<p>主要结果在文件<strong>Assemblytics_structural_variants.summary</strong>中，文件内容示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Insertion</span><br><span class="line">                         Count       Total bp</span><br><span class="line">         50-500 bp:        835          91429</span><br><span class="line">     500-10,000 bp:        158         468629</span><br><span class="line">             Total:        993         560058</span><br><span class="line"></span><br><span class="line">Deletion</span><br><span class="line">                         Count       Total bp</span><br><span class="line">         50-500 bp:        779          85083</span><br><span class="line">     500-10,000 bp:        140         289652</span><br><span class="line">             Total:        919         374735</span><br><span class="line"></span><br><span class="line">Tandem_expansion</span><br><span class="line">                         Count       Total bp</span><br><span class="line">         50-500 bp:         46           8957</span><br><span class="line">     500-10,000 bp:        117         444964</span><br><span class="line">             Total:        163         453921</span><br><span class="line"></span><br><span class="line">Tandem_contraction</span><br><span class="line">                         Count       Total bp</span><br><span class="line">         50-500 bp:          2            379</span><br><span class="line">     500-10,000 bp:          0              0</span><br><span class="line">             Total:          2            379</span><br><span class="line"></span><br><span class="line">Repeat_expansion</span><br><span class="line">                         Count       Total bp</span><br><span class="line">         50-500 bp:        373          80936</span><br><span class="line">     500-10,000 bp:        968        3666087</span><br><span class="line">             Total:       1341        3747023</span><br><span class="line"></span><br><span class="line">Repeat_contraction</span><br><span class="line">                         Count       Total bp</span><br><span class="line">         50-500 bp:        411          92021</span><br><span class="line">     500-10,000 bp:        893        3378919</span><br><span class="line">             Total:       1304        3470940</span><br><span class="line"></span><br><span class="line">Total number of all variants: 4,722</span><br><span class="line">Total bases affected by all variants: 8.61 Mbp</span><br><span class="line">Total number of structural variants: 4,722</span><br><span class="line">Total bases affected by structural variants: 8.61 Mbp</span><br></pre></td></tr></table></figure>

<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li><a href="http://assemblytics.com/">http://assemblytics.com/</a></li>
<li><a href="https://github.com/marianattestad/assemblytics">https://github.com/marianattestad/assemblytics</a></li>
<li>paper: <a href="https://academic.oup.com/bioinformatics/article/32/19/3021/2196631">https://academic.oup.com/bioinformatics/article/32/19/3021/2196631</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>variation</category>
        <category>structural variation</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>structural variation</tag>
        <tag>SV</tag>
        <tag>insertion</tag>
        <tag>deletion</tag>
        <tag>Indel</tag>
        <tag>tandem expansion</tag>
        <tag>tandem contraction</tag>
        <tag>repeat expansion</tag>
        <tag>repeat contraction</tag>
        <tag>Assemblytics</tag>
      </tags>
  </entry>
  <entry>
    <title>结构变异分析软件：MUM&amp;Co</title>
    <url>/2022/07/17/bioinfo_variation_SV_MUMandCo/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=18031133&auto=1&height=32"></iframe></div>

<h1 id="1-MUM-amp-Co简介"><a href="#1-MUM-amp-Co简介" class="headerlink" title="1. MUM&amp;Co简介"></a>1. MUM&amp;Co简介</h1><p>MUM&amp;Co是用于<strong>两个基因组间</strong>的<strong>结构变异（structural variant，SV）</strong>检测分析的软件，基于MUMmer(v4)的nucmer比对结果检测全基因组范围内的插入，缺失，串联重复，倒位和易位等结构变异。</p>
<p>2020年发表在Bioinformatics。</p>
<h1 id="2-MUM-amp-Co原理"><a href="#2-MUM-amp-Co原理" class="headerlink" title="2. MUM&amp;Co原理"></a>2. MUM&amp;Co原理</h1><p>MUMandCo调用MUMmer的nucmer模块做互换的全基因组比对（whole-genome alignmetn，WGA），delta-filter模块做全局（g-）和多对多（m-）的过滤，show-coords模块解析坐标。</p>
<ol>
<li>选出与参考基因组有最精确、非重叠的alignments的query contigs。其余的alignment都不考虑。</li>
<li>利用这些alignments统计超过50bp的SV的类型和特征。</li>
<li>全局（g-）比对 基于多个contig-chromosome pairings来检测易位（translocation）片段，基于alignment orientation检测大的倒位（inversions），基于alignment gaps检测可能的插入缺失（insertion and deletion），利用互换的比对，gaps会在reference和query基因组间同时被考虑。</li>
<li>多对多（m-）比对用于检测潜在的倒位（inversions）和重复（duplications）。</li>
<li>用全局（g-）和多对多（m-）比对的过滤去除假阳性。</li>
<li>参数<code>-b</code>可以调用BLAST来检测插入和缺失是重复的（mobile）还是新的（novel）。</li>
<li>生成保存了reference和query基因组的SV的类型、坐标等细节的tsv文件。</li>
</ol>
<h1 id="3-MUM-amp-Co可以检测的内容"><a href="#3-MUM-amp-Co可以检测的内容" class="headerlink" title="3. MUM&amp;Co可以检测的内容"></a>3. MUM&amp;Co可以检测的内容</h1><ul>
<li>插入（insertion）：&gt;&#x3D;50bp &amp; &lt;&#x3D;150kb</li>
<li>缺失（deletion）：&gt;&#x3D;50bp &amp; &lt;&#x3D;150kb</li>
<li>串联重复复制（tandem duplication）：&gt;&#x3D;50bp &amp; &lt;&#x3D;150kb</li>
<li>串联重复收缩（tandem contraction）：&gt;&#x3D;50bp &amp; &lt;&#x3D;150kb</li>
<li>倒位（inversion）：&gt;&#x3D;1kb</li>
<li>易位（translocation）：&gt;&#x3D;10kb</li>
</ul>
<h1 id="4-MUM-amp-Co安装"><a href="#4-MUM-amp-Co安装" class="headerlink" title="4. MUM&amp;Co安装"></a>4. MUM&amp;Co安装</h1><ul>
<li>MUMandCo是个bash脚本，下载后赋予执行权限即可使用。</li>
<li>依赖的软件包括MUMmer(v4)和samtools，如果使用<code>-b</code>参数则还需要blast。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/SAMtoBAM/MUMandCo.git</span><br><span class="line">chmod 711 ./MUMandCo/mumandco_v3.8.sh</span><br></pre></td></tr></table></figure>

<h1 id="5-MUM-amp-Co使用"><a href="#5-MUM-amp-Co使用" class="headerlink" title="5. MUM&amp;Co使用"></a>5. MUM&amp;Co使用</h1><ol>
<li>运行</li>
</ol>
<p><code>bash mumandco_v3.8.sh -r genome.fa -q query.fa -g 125500000 -t 24 -b -o out</code></p>
<ol start="2">
<li>参数</li>
</ol>
<ul>
<li>-r genome.fa：参考基因组。注意参考基因组和检测基因组的选择不同，结果会有一些差异。</li>
<li>-q query.fa：被检测的基因组</li>
<li>-g 125500000：参考基因组大小，单位是bp</li>
<li>-t 24：线程24，默认1</li>
<li>-b：添加blast选项用来确认插入&#x2F;缺失是mobile&#x2F;repetitive还是novel。我的理解是mobile&#x2F;repetitive代表别的地方有这个插入&#x2F;缺失，novel代表是一个新产生的插入&#x2F;缺失。</li>
<li>-ml：alignments的最小长度；默认50bp</li>
<li>-o out：输出文件的前缀；默认是mumandco</li>
</ul>
<ol start="3">
<li>时间</li>
</ol>
<ul>
<li>两个都是约300Mbp的基因组的SV分析，用了24线程，运行总耗时5小时。</li>
</ul>
<h1 id="6-MUM-amp-Co结果"><a href="#6-MUM-amp-Co结果" class="headerlink" title="6. MUM&amp;Co结果"></a>6. MUM&amp;Co结果</h1><ol>
<li>out.summary.txt</li>
</ol>
<ul>
<li>总结SV的类型和数量的文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mumandco</span><br><span class="line">Total_SVs	8252</span><br><span class="line">Deletions	3337</span><br><span class="line">Insertions	4363</span><br><span class="line">Duplications	44</span><br><span class="line">Contractions	8</span><br><span class="line">Inversions	144</span><br><span class="line">Translocations	356</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>out.SVs_all.tsv</li>
</ol>
<ul>
<li>保存了所有检测到的SVs的每一个SV的类型、坐标、长度等详细信息。</li>
<li>共有9列，包括ref_chr    query_chr    ref_start    ref_stop    size    SV_type    query_start  query_stop    info。</li>
<li>第六列SV_type包括contraction，deletion_mobile，deletion_novel，duplication，insertion_mobile，insertion_novel，inversion，transloc。</li>
<li>第九列info包含以下三种情况：<ul>
<li>‘complicated’: 在一个区域（region）有多个calls，一般是插入和缺失的重叠造成。</li>
<li>‘double’: 在相同的坐标位置（coordinates）有几个calls; 一般是串联重复复制或者串联重复收缩有多个拷贝的改变造成。</li>
<li>‘]chrX:xxxxxx]’ : 标记<strong>易位</strong>片段与其他片段的关联的VCF指示符。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ref_chr	query_chr	ref_start	ref_stop	size	SV_type	query_start  query_stop	info</span><br><span class="line">MCscaf001	LG12	674171	698315	10734	insertion_mobile	12964720     12975454</span><br><span class="line">MCscaf007	LG03	17862	8197142	8179280	transloc	27635100	19266429	[MCscaf007:8384299[</span><br><span class="line">MCscaf007	LG03	17862	8197142	8179280	transloc	27635100	19266429	]MCscaf004:7287153]</span><br><span class="line">... ...</span><br><span class="line">MCscaf254	LG05	13407	16116	2709	deletion_mobile	10455842	10467408	complicated</span><br></pre></td></tr></table></figure>

<ul>
<li>每个易位片段保留一行记录，如果易位片段的两端都涉及到易位，则有两行信息记录一次易位事件的两端。</li>
<li>所以其他事件是每行一次，在out.SVs_all.tsv文件中的行数即为事件次数；易位事件是一次事件有1-2行。</li>
</ul>
<ol start="3">
<li>out.SVs_all.withfragment.tsv</li>
</ol>
<ul>
<li>与out.SVs_all.tsv格式和内容类似，多一列fragment信息，保存了对应的参考基因组的碱基序列（插入的序列来自query基因组）。</li>
</ul>
<ol start="4">
<li>out.SVs_all.vcf</li>
<li>out_alignments文件夹</li>
</ol>
<ul>
<li>保存了alignments文件，包括ref和query各自的的delta，delta_filter，delta_filter.coords，delta_filter.coordsg文件</li>
</ul>
<h1 id="7-结果整理和统计"><a href="#7-结果整理和统计" class="headerlink" title="7. 结果整理和统计"></a>7. 结果整理和统计</h1><ol>
<li>通过out.SVs_all.tsv文件的第六列SV_type值把不同的SV类型分开，例如单独获取translocations的信息：<code>cat out.SVs_all.tsv| awk &#39;$6==&quot;transloc&quot; &#123;print $0&#125;&#39; &gt;transloc.tsv</code></li>
</ol>
<ul>
<li>大部分类型都是每个一行记录，所以行数就是总数，总数与out.summary.txt文件是一致的。</li>
<li>translocations这种类型大部分有两行记录，所以行数不是总数，如果想要计算总数可以这样：<code>cat transloc.tsv |cut -f1-8|uniq |wc -l</code>。</li>
</ul>
<ol start="2">
<li>可以用<code>datamash</code>软件来快速统计常见的值</li>
</ol>
<ul>
<li><code>cat out.SVs_all.tsv |datamash --header-in --header-out --sort groupby 6 min 5 max 5 mean 5</code>通过对第6列（SV_type）分组，进行组内的第五列(Size)值的统计量（包括最小值，最大值，平均值）进行统计。其中<code>--header-in</code>代表输入有标题行，<code>--header-out</code>代表输出包含标题行。</li>
</ul>
<p>我整理了一个这样的表格，用来一览SV的概况，供参考。</p>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/structural_variants_sum.png?raw=true" title="结构变异概况" width="90%" align=center/>

<p><strong><p align="center">结构变异概况</p></strong></p>
<p>感慨一句，选择什么计算机语言来写代码真没那么重要，人家bash脚本也可以发Bioinformatics。</p>
<h1 id="8-references"><a href="#8-references" class="headerlink" title="8. references"></a>8. references</h1><ol>
<li><a href="https://github.com/SAMtoBAM/MUMandCo">https://github.com/SAMtoBAM/MUMandCo</a></li>
<li>paper: <a href="https://academic.oup.com/bioinformatics/article/36/10/3242/5756209">https://academic.oup.com/bioinformatics/article/36/10/3242/5756209</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>variation</category>
        <category>structural variation</category>
      </categories>
      <tags>
        <tag>structural variation</tag>
        <tag>SV</tag>
        <tag>insertion</tag>
        <tag>deletion</tag>
        <tag>Indel</tag>
        <tag>MUMandCo</tag>
        <tag>duplication</tag>
        <tag>contraction</tag>
        <tag>inversion</tag>
        <tag>translocation</tag>
      </tags>
  </entry>
  <entry>
    <title>结构变异分析</title>
    <url>/2022/10/09/bioinfo_variation_SV_intro/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=105207&auto=1&height=32"></iframe></div>

<h1 id="1-变异（variation）"><a href="#1-变异（variation）" class="headerlink" title="1. 变异（variation）"></a>1. 变异（variation）</h1><p>不同生物间或者同一种生物不同个体间，染色体上同一位置对应的序列的碱基或者结构不同，或者同一序列在染色体上的位置不同，这种生物间遗传物质的不同被称为变异（variation）。变异是至少两个个体的遗传物质比较的结果。</p>
<h2 id="1-1-变异的类型"><a href="#1-1-变异的类型" class="headerlink" title="1.1. 变异的类型"></a>1.1. 变异的类型</h2><p>基因组上的变异有不同的类型，包括单核苷酸多态性（Single Nucleotide Polymorphisms，SNP），插入缺失（Insertion and Deletion, Indel），和结构变异（structural variation，SV）。</p>
<ol>
<li>单核苷酸多态性（SNP）</li>
</ol>
<ul>
<li>指单个核苷酸的碱基的变化，比如A变成了G，或者C变成了T。</li>
</ul>
<ol start="2">
<li>插入删除（Indel）</li>
</ol>
<ul>
<li>指基因组上某个位置发生的较短的线性序列的插入（Insertion）或者删除（Deletion）。插入缺失是两者比较的结果，对一方是插入的，对另一方来说就是删除，所以通常合称为Indel。</li>
<li>通常约定插入或缺失长度在50bp以下的被称为Indel，大部分情况下不超过10bp。</li>
</ul>
<ol start="3">
<li>结构变异（SV）</li>
</ol>
<ul>
<li>指长片段的序列变化或位置变化，包括长片段的插入删除（Big Indel），染色体倒位（Inversion），易位（Translocation），串联重复（Tandem repeat），拷贝数变异（copy number variation, CNV）等。</li>
</ul>
<h2 id="1-2-结构变异（structural-variation，SV）"><a href="#1-2-结构变异（structural-variation，SV）" class="headerlink" title="1.2. 结构变异（structural variation，SV）"></a>1.2. 结构变异（structural variation，SV）</h2><h3 id="1-2-1-结构变异的定义"><a href="#1-2-1-结构变异的定义" class="headerlink" title="1.2.1. 结构变异的定义"></a>1.2.1. 结构变异的定义</h3><p>结构变异（structural variation，SV）是指基因组上长片段的序列变化和位置关系变化。<br>过去通常定义为长度大于1000bp的插入删除和倒位，但随着测序的发展，现在的定义更广泛。</p>
<h3 id="1-2-2-结构变异的类型"><a href="#1-2-2-结构变异的类型" class="headerlink" title="1.2.2. 结构变异的类型"></a>1.2.2. 结构变异的类型</h3><p>目前的结构变异通常包括长度大于50bp的长片段序列插入删除（Big Indel），长度大于1000bp的染色体倒位（Inversion），长度大于1000bp的染色体内部或染色体间的序列易位（Translocation），拷贝数变异（copy number variation, CNV），串联重复（Tandem repeat）以及形式更为复杂的嵌合性变异等。</p>
<p>有些标准还包括简单重复序列（SSR），散在的重复（Interspersed duplications）和其他重复序列。</p>
<img src="https://media.springernature.com/full/springer-static/image/art%3A10.1038%2Fnrg2958/MediaObjects/41576_2011_Article_BFnrg2958_Fig1_HTML.jpg?as=webp" width=90% title="结构变异的类型" alt="结构变异的类型" align=center/>

<p><strong><p align="center">图1. 结构变异的类型</strong><br>图片来源： <a href="https://www.nature.com/articles/nrg2958">paper：Genome structural variation discovery and genotyping</a></p></p>
<h1 id="2-检测结构变异的方法"><a href="#2-检测结构变异的方法" class="headerlink" title="2. 检测结构变异的方法"></a>2. 检测结构变异的方法</h1><p>检测结构变异的方法主要有四种，包括：</p>
<ol>
<li>Read-pair (RP)：通过对双端测序reads的距离（即插入序列长度的分布）或位置关系（即双端reads的正反链情况）的异常值分析来检测结构变异。</li>
<li>Split-read (SR)：通过对双端测序reads中一条reads能比对上，另一条不能比对上的情况进行分析来检测结构变异。</li>
<li>Read-depth (RD)：利用read的mapping深度来检测基因组拷贝数变异（Copy number variantion，简称CNV）的方法。</li>
<li>Assembly (AS)：通过三代测序和de novo assembly来检测大长度和复杂结构的变异。</li>
</ol>
<p>下图总结了四种方法可以检测的结构变异的类型。</p>
<img src="https://media.springernature.com/full/springer-static/image/art%3A10.1038%2Fnrg2958/MediaObjects/41576_2011_Article_BFnrg2958_Fig2_HTML.jpg?as=webp" width=90% title="结构变异的检测方法" alt="结构变异的检测方法" align=center/>

<p><strong><p align="center">图2. 结构变异的检测方法</strong><br>图片来源： <a href="https://www.nature.com/articles/nrg2958">paper：Genome structural variation discovery and genotyping</a></p></p>
<h1 id="3-检测结构变异的软件"><a href="#3-检测结构变异的软件" class="headerlink" title="3. 检测结构变异的软件"></a>3. 检测结构变异的软件</h1><p>检测结构变异的软件有很多，个人用过的两个贴在下面：</p>
<ul>
<li>MUMandCo：<a href="https://yanzhongsino.github.io/2022/07/17/bioinfo_variation_SV_MUMandCo/">https://yanzhongsino.github.io/2022/07/17/bioinfo_variation_SV_MUMandCo/</a></li>
<li>Assemblytics：<a href="https://yanzhongsino.github.io/2022/08/02/bioinfo_variation_SV_Assemblytics/">https://yanzhongsino.github.io/2022/08/02/bioinfo_variation_SV_Assemblytics/</a></li>
</ul>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li><a href="https://en.wikipedia.org/wiki/Structural_variation">https://en.wikipedia.org/wiki/Structural_variation</a></li>
<li><a href="https://www.ncbi.nlm.nih.gov/dbvar/content/overview/#:~:text=Structural%20variation%20(SV)%20is%20generally,copy%20number%20variants%20(CNVs)">https://www.ncbi.nlm.nih.gov/dbvar/content/overview/#:~:text=Structural%20variation%20(SV)%20is%20generally,copy%20number%20variants%20(CNVs)</a>.</li>
<li>SV的检测算法和原理-知乎：<a href="https://zhuanlan.zhihu.com/p/40290546">https://zhuanlan.zhihu.com/p/40290546</a></li>
<li>SV的检测算法和原理-文章：<a href="https://www.nature.com/articles/nrg2958">https://www.nature.com/articles/nrg2958</a></li>
<li>SV的检测算法和原理-文章：<a href="https://academic.oup.com/bib/article/16/5/852/217239?login=false">https://academic.oup.com/bib/article/16/5/852/217239?login=false</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bioinfo</category>
        <category>variation</category>
        <category>structural variation</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>structural variation</tag>
        <tag>SV</tag>
        <tag>insertion</tag>
        <tag>deletion</tag>
        <tag>Indel</tag>
        <tag>tandem expansion</tag>
        <tag>tandem contraction</tag>
        <tag>repeat expansion</tag>
        <tag>repeat contraction</tag>
        <tag>Assemblytics</tag>
        <tag>MUMandCo</tag>
        <tag>variation</tag>
        <tag>SNP</tag>
      </tags>
  </entry>
  <entry>
    <title>把简历部署到网站上</title>
    <url>/2022/07/31/blog_hexo+github_setting/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=5284273&auto=1&height=32"></iframe><music URL></div>

<p>在根据博客<a href="https://yanzhongsino.github.io/2018/06/05/blog_hexo.github/">hexo建站，github.io发布，多终端同步</a>配置了hexo网站（使用next主题）的基础上，记录了添加自定义网页（包括简历、about me、404等页面）的设置技巧。</p>
<h1 id="1-添加自定义网页"><a href="#1-添加自定义网页" class="headerlink" title="1. 添加自定义网页"></a>1. 添加自定义网页</h1><p>添加自定义网页，自定义网页包括简历、404、About页面等，这里以添加<strong>简历</strong>为例。</p>
<h2 id="1-1-制作简历"><a href="#1-1-制作简历" class="headerlink" title="1.1. 制作简历"></a>1.1. 制作简历</h2><ol>
<li>现状</li>
</ol>
<ul>
<li>网上的博客在线简历相关教程大多是开发了一个专门用于简历展示的博客主题，需要博客使用这个主题以实现制作简历和在线显示的目的。</li>
<li>但我的博客用的是hexo的next主题，不想换。</li>
<li>所以最后决定用模板的html文件自己修改制作简历html。</li>
</ul>
<ol start="2">
<li>操作</li>
</ol>
<ul>
<li>在网上找喜欢的简历模板，提取html文件。</li>
<li>比如我的简历参考的是这个模板：<a href="https://github.com/mtics/hexo-mtics-resume">https://github.com/mtics/hexo-mtics-resume</a></li>
<li>在模板的demo：<a href="https://mtics.netlify.app/%EF%BC%8C%E5%8F%B3%E9%94%AE**%E6%9F%A5%E7%9C%8B%E7%BD%91%E9%A1%B5%E6%BA%90%E4%BB%A3%E7%A0%81**%EF%BC%8C%E7%84%B6%E5%90%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E4%BF%9D%E5%AD%98html%E4%BB%A3%E7%A0%81%E5%88%B0index.html%E3%80%82">https://mtics.netlify.app/，右键**查看网页源代码**，然后复制和保存html代码到index.html。</a></li>
<li>修改index.html的信息为自己的简历内容，即可使用。</li>
<li>同时为了达到同样的渲染效果，把模板<a href="https://github.com/mtics/hexo-mtics-resume/tree/master/source%E9%87%8C%E7%9A%84%E4%B8%89%E4%B8%AAcss%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%EF%BC%8Cimg/avatar.jpg%E6%96%87%E4%BB%B6%E6%94%B9%E6%88%90%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%B4%E5%83%8F%E7%85%A7%E7%89%87%E3%80%82">https://github.com/mtics/hexo-mtics-resume/tree/master/source里的三个css文件下载下来，img/avatar.jpg文件改成自己的头像照片。</a></li>
</ul>
<h2 id="1-2-添加简历"><a href="#1-2-添加简历" class="headerlink" title="1.2. 添加简历"></a>1.2. 添加简历</h2><ol>
<li>在hexo&#x2F;source目录下创建文件夹，例如resume。（如果添加about页面就创建about文件夹）</li>
<li>然后把制作好的简历网页文件index.html放在resume文件夹下。</li>
<li>简历引用了的css或js文件和图片文件，也放在resume文件夹下。</li>
</ol>
<h2 id="1-3-跳过渲染"><a href="#1-3-跳过渲染" class="headerlink" title="1.3. 跳过渲染"></a>1.3. 跳过渲染</h2><p>因为hexo应用的主题给每个网页都进行相同的渲染，所以需要对自定义网页设置跳过默认的渲染，有以下两种方法。</p>
<ol>
<li>在index.html设置</li>
</ol>
<ul>
<li>在网页文件index.html的开头添加下面代码设置跳过渲染的指令，这样通过<code>hexo g</code>生成网页时会跳过index.html文件，不受hexo主题渲染，而完全是一个独立的网页。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在_config.yml文件中设置</li>
</ol>
<p>在hexo目录的_config.yml文件设置skip_render参数来设置不渲染的文件&#x2F;文件夹。</p>
<ul>
<li>屏蔽指定文件：<code>skip_render：./resume/index.html</code></li>
<li>屏蔽指定文件夹的所有文件：<code>skip_render: ./resume/*</code></li>
<li>屏蔽指定文件夹所有文件包括子文件夹和子文件夹下的文件：<code>skip_render: ./resume/**</code></li>
<li>屏蔽多个路径：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">    - ./resume/index.html</span><br><span class="line">    - ./resume/image.png</span><br></pre></td></tr></table></figure>

<h2 id="1-4-设置主页显示"><a href="#1-4-设置主页显示" class="headerlink" title="1.4. 设置主页显示"></a>1.4. 设置主页显示</h2><p>在博客首页的菜单栏中增加简历项的设置。</p>
<ol>
<li>在主题下的设置文件中<code>./themes/next/_config.yml</code>文件中的menu项中添加简历行<code>resume: /resume/index.html || fa fa-file-user</code>，这样可以在博客首页的菜单栏中增加简历项。</li>
<li>其中<code>resume</code>会显示在博客主页</li>
<li><code>/resume/index.html</code>指定自定义网页文件</li>
<li><code>fa fa-file-user</code>定义图标，可以在<a href="https://fontawesome.com/icons?from=io%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%9B%BE%E6%A0%87%E4%BD%BF%E7%94%A8%E3%80%82">https://fontawesome.com/icons?from=io选择合适的图标使用。</a></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br><span class="line">  resume: /resume/index.html || fa fa-file-user</span><br></pre></td></tr></table></figure>

<h2 id="1-5-简历成品"><a href="#1-5-简历成品" class="headerlink" title="1.5. 简历成品"></a>1.5. 简历成品</h2><p>最后的效果可以参考我的简历：<a href="https://yanzhongsino.github.io/resume/index.html">https://yanzhongsino.github.io/resume/index.html</a></p>
<h1 id="2-添加about页面"><a href="#2-添加about页面" class="headerlink" title="2. 添加about页面"></a>2. 添加about页面</h1><p>与上面的添加简历页面类似：</p>
<ol>
<li>在hexo&#x2F;source目录下创建文件夹about</li>
<li>在about文件夹下创建index.md文件写入about显示内容</li>
<li>如果使用hexo的主题显示，则无需跳过渲染</li>
<li>把主题下的设置文件中<code>./themes/next/_config.yml</code>文件中的menu项中的about信息行的注释符#删除，表示在博客主页显示about项进入页面</li>
</ol>
<h1 id="3-添加404页面"><a href="#3-添加404页面" class="headerlink" title="3. 添加404页面"></a>3. 添加404页面</h1><p>404页面是在域名下访问不存在的地址时出现的页面。</p>
<ol>
<li>在博客主题的source下（比如我的.&#x2F;themes&#x2F;next&#x2F;source&#x2F;）创建404.html文件</li>
<li>在404.html文件中写入想要在404页面展示的内容</li>
<li>推荐把腾讯公益404页面的代码写入404页面，为传播失踪儿童信息贡献一点微薄之力。</li>
</ol>
<ul>
<li>下面的**homePageUrl&#x3D;”<a href="https://yanzhongsino.github.io&quot;**用于设置网站首页地址,需要改成自己的网站首页网址./">https://yanzhongsino.github.io&quot;**用于设置网站首页地址，需要改成自己的网站首页网址。</a></li>
<li>**homePageName&#x3D;”返回主页（您可以进入首页继续搜索）”**设置引导词，可以替换成引导用户回到网站首页的引导语。</li>
<li>腾讯公益404页面的js地址可能会更新，可以以腾讯官方代码：<a href="https://news.qq.com/404/%EF%BC%8C%E5%8F%91%E5%B8%83%E7%9A%84%E4%B8%BA%E5%87%86%E3%80%82">https://news.qq.com/404/，发布的为准。</a></li>
<li>404.html示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt;</span><br><span class="line">  &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot;</span><br><span class="line">          charset=&quot;utf-8&quot; homePageUrl=&quot;https://yanzhongsino.github.io&quot;</span><br><span class="line">          homePageName=&quot;返回主页（您可以进入首页继续搜索）&quot;&gt;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>接着正常部署博客即可。</li>
<li>测试404页面。在网页域名下输入一个不存在的地址（比如<a href="https://yanzhongsino.github.io/111%EF%BC%89%EF%BC%8C%E7%9C%8B404%E9%A1%B5%E9%9D%A2%E6%98%AF%E5%90%A6%E6%9B%B4%E6%96%B0%E6%88%90%E5%8A%9F%E3%80%82">https://yanzhongsino.github.io/111），看404页面是否更新成功。</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>markdown</tag>
        <tag>resume</tag>
        <tag>readme</tag>
        <tag>404 page</tag>
      </tags>
  </entry>
  <entry>
    <title>博客日常撰写和备份</title>
    <url>/2021/04/20/blog_maintenance/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=20707476&auto=1&height=32"></iframe><music URL></div>

<p>在根据博客<a href="https://yanzhongsino.github.io/2018/06/05/blog_hexo.github/">hexo建站，github.io发布，多终端同步</a>配置了hexo网站（使用next主题）的基础上，记录了博客日常撰写、备份。</p>
<h1 id="1-blog的categories和tags"><a href="#1-blog的categories和tags" class="headerlink" title="1. blog的categories和tags"></a>1. blog的categories和tags</h1><p>categories和tags的记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: blog</span><br><span class="line">date: 2021-04-20 16:50:00</span><br><span class="line">categories: </span><br><span class="line"></span><br><span class="line">- bio</span><br><span class="line">	- concept</span><br><span class="line">	- taxon</span><br><span class="line">	- bioinfo</span><br><span class="line">	- experiment</span><br><span class="line">	- theory</span><br><span class="line">	- knowledge</span><br><span class="line"></span><br><span class="line">- biosoft</span><br><span class="line"></span><br><span class="line">- omics</span><br><span class="line">	- genome</span><br><span class="line">	- transcriptome</span><br><span class="line">	- plastome</span><br><span class="line">	- mitochondrion</span><br><span class="line"></span><br><span class="line">- plot</span><br><span class="line">	- R</span><br><span class="line"></span><br><span class="line">- computer</span><br><span class="line">	- system</span><br><span class="line">		- windows</span><br><span class="line">		- linux</span><br><span class="line">	- program language</span><br><span class="line">		- python</span><br><span class="line">		- R</span><br><span class="line">		- perl</span><br><span class="line">		- java</span><br><span class="line">		- C</span><br><span class="line">	- IDE</span><br><span class="line">		- vim</span><br><span class="line">		- VScode</span><br><span class="line">		- git</span><br><span class="line">	- script</span><br><span class="line">	- web</span><br><span class="line"></span><br><span class="line">- linux</span><br><span class="line">	- basics</span><br><span class="line">	- shell</span><br><span class="line">	- text processing</span><br><span class="line">	- operation and maintenance</span><br><span class="line"></span><br><span class="line">- blog</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tags: </span><br><span class="line">- genome assemble</span><br><span class="line">- genome annotation</span><br><span class="line">- phylogeny</span><br><span class="line">- divergence time</span><br><span class="line">- WGD</span><br><span class="line">- HGT</span><br><span class="line">- molecular experiment</span><br><span class="line">- homolog</span><br><span class="line">- ortholog</span><br><span class="line">- paralog</span><br><span class="line">- xenolog</span><br><span class="line">- analog</span><br><span class="line">- orthology</span><br><span class="line">- orthogroup</span><br><span class="line">- gene family</span><br><span class="line">---  </span><br></pre></td></tr></table></figure>

<h1 id="2-日常blog撰写和备份操作"><a href="#2-日常blog撰写和备份操作" class="headerlink" title="2. 日常blog撰写和备份操作"></a>2. 日常blog撰写和备份操作</h1><p>在做好blog搭建后，blog撰写和日常管理可参考这部分内容。</p>
<h2 id="2-1-blog同步"><a href="#2-1-blog同步" class="headerlink" title="2.1. blog同步"></a>2.1. blog同步</h2><p>养成习惯，每次开始撰写blog前都通过git bash进入工作区，进行<code>git pull</code>命令把github端的hexo分支的更新（更新可能是其他终端上提交的）同步到本地，实现多终端的内容完全同步。<br>但如果本地有未提交的更新，则千万不要用<code>git pull</code>，否则会覆盖本地更新；直接进入下一步；直到使用<code>git add .</code>，<code>git commit -m &quot;submit&quot;</code>，<code>git push origin hexo</code>提交备份本地更新到github端的hexo分支后才可以使用<code>git pull</code>(一般是在其他终端，把github的hexo分支更新拉到其他终端设备使用)。</p>
<h2 id="2-2-blog撰写"><a href="#2-2-blog撰写" class="headerlink" title="2.2. blog撰写"></a>2.2. blog撰写</h2><p>在本地source&#x2F;_posts下添加和修改md文档实现blog的日常撰写和修改。</p>
<p>使用命令<code>hexo new &quot;newpostname&quot;</code>可以在hexo&#x2F;source&#x2F;_posts下新建一个newpostname.md的文件，这个文件以scaffolds&#x2F;post.md为模板，修改scaffolds&#x2F;post.md文件可以修改hexo new命令生成的新blog文件样式。</p>
<h2 id="2-3-blog备份"><a href="#2-3-blog备份" class="headerlink" title="2.3. blog备份"></a>2.3. blog备份</h2><p>只要blog有更改或者新增，或者配置文件有修改，即工作区（即本地的hexo目录或github.io目录）有文件修改，则建议对文件进行备份到GitHub端的hexo分支。<br>用三条命令<code>git add .</code>，<code>git commit -m &quot;submit&quot;</code>，<code>git push origin hexo</code>备份工作区，包括md博客源文件和hexo部署到github端的hexo分支。三条命令执行前建议通过<code>hexo clean</code>清除缓存和public目录，以免备份不需要的文件。</p>
<h2 id="2-4-blog发布"><a href="#2-4-blog发布" class="headerlink" title="2.4. blog发布"></a>2.4. blog发布</h2><p>可根据自身需求决定是否发布blog到github.io网站，一般写的blog完整程度比较高时可以发布。使用<code>hexo clean &amp; hexo g -d</code>命令，根据source&#x2F;_posts下的博客源文件生成public目录（网站html并同步到github端的master分支，即发布blog到github.io网站。</p>
<p>总结一下，在配置好写作环境后的任意一台终端的日常工作流应该是：</p>
<ol>
<li><code>git pull</code>同步远程github库的hexo更新到本地</li>
<li><code>hexo new &quot;newblog&quot;</code>在source&#x2F;_posts&#x2F;下添加md格式的blog，或者修改已有的blog</li>
<li><code>git add .</code>,<code>git commit -m &quot;commit notes&quot;</code>,<code>git push</code>把修改备份到github端</li>
<li>下次写作重复以上三个步骤</li>
<li>直至blog完善成熟后，用命令<code>hexo clean &amp; hexo g -d</code>生成网站并部署到github.io</li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>markdown</tag>
        <tag>sync</tag>
        <tag>website maintenance</tag>
      </tags>
  </entry>
  <entry>
    <title>博客撰写的语法和技巧</title>
    <url>/2022/04/15/blog_markdown_grammer/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=5284273&auto=1&height=32"></iframe><music URL></div>

<p>在根据博客<a href="https://yanzhongsino.github.io/2018/06/05/blog_hexo.github/">hexo建站，github.io发布，多终端同步</a>配置了hexo网站（使用next主题）的基础上，记录了部分撰写博客使用的技巧。</p>
<h1 id="1-撰写博客"><a href="#1-撰写博客" class="headerlink" title="1. 撰写博客"></a>1. 撰写博客</h1><h2 id="1-1-插入图片"><a href="#1-1-插入图片" class="headerlink" title="1.1. 插入图片"></a>1.1. 插入图片</h2><p>若是本地图片，就放在特定位置，然后在blog中引用；若是网络图片，就直接复制图片的url地址引用；</p>
<h3 id="1-1-1-推荐用法"><a href="#1-1-1-推荐用法" class="headerlink" title="1.1.1. 推荐用法"></a>1.1.1. 推荐用法</h3><p>若是自己的图片，可以统一保存在sources&#x2F;images&#x2F;目录下，在github上同步后，复制github上图片地址，就可以像引用网络图片一样引用图片url地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/R_plot_venn_2.png?raw=true&quot; width=50% title=&quot;venn_2&quot; align=&quot;center&quot; /&gt;</span><br><span class="line"></span><br><span class="line">**&lt;p align=&quot;center&quot;&gt;Figure 1. Venn diagram with 2 groups**</span><br><span class="line">from [github: yanzhongsino](https://github.com/yanzhongsino/yanzhongsino.github.io)&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;img /&gt;</code>用于图片显示，src填写图片网址，width指图片占屏幕的比例（同时还有类似的height参数，但建议不设置height以保持图片长宽比例），title是图片名称(如果网址失效会显示title值的文字)，align设置对齐方式。<br><code>&lt;p align=&quot;center&quot;&gt;Figure 1. text&lt;/p&gt;</code>用于图的标题居中显示，from指示图源(引用其他来源的图时)，**用于加粗显示。</p>
<p>效果如下：<br><img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/R_plot_venn_2.png?raw=true" width=50% title="venn_2" align="center" /></p>
<p><strong><p align="center">Figure 1. Venn diagram with 2 groups</strong><br>from <a href="https://github.com/yanzhongsino/yanzhongsino.github.io">github: yanzhongsino</a></p></p>
<h3 id="1-1-2-markdown语法"><a href="#1-1-2-markdown语法" class="headerlink" title="1.1.2. markdown语法"></a>1.1.2. markdown语法</h3><ol>
<li>统一放在images目录下<br>当Hexo项目中只用到少量图片时，可以将图片统一放在source&#x2F;images文件夹中，在blog中通过markdown语法访问它们，即<code>![图片注释](/images/image.jpg &quot;图片标题&quot;)</code>。</li>
</ol>
<p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p>
<ol start="2">
<li>放在文章各自目录下<br>图片除了可以放在统一的images文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置_config.yml来生成。</li>
</ol>
<ul>
<li>将_config.yml文件中的配置项post_asset_folder设为true<code>post_asset_folder: true</code>;</li>
<li>执行命令<code>hexo new postname</code>，在source&#x2F;_posts中会生成文章postname.md和同名文件夹postname;</li>
<li>将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。</li>
<li>在文章中添加markdown语法代码<code>![图片注释](image.jpg &quot;图片标题&quot;)</code>即可。</li>
</ul>
<p>图片只能在文章中显示，但无法在首页中正常显示。</p>
<h3 id="1-1-3-HTML语法【推荐】"><a href="#1-1-3-HTML语法【推荐】" class="headerlink" title="1.1.3. HTML语法【推荐】"></a>1.1.3. HTML语法【推荐】</h3><p>用markdown语法无法指定图片的尺寸和对齐方式，建议用HTML语法插入图片，以实现更好的控制。<br><code>&lt;img src=&quot;/images/image.png&quot; width=80% height=80% title=&quot;picture&quot; alt=&quot;picture&quot; align=center/&gt;</code></p>
<p><code>&lt;img src=&quot;url&quot; title=&quot;title&quot; width=&quot;80%&quot; height=&quot;80%&quot; /&gt;</code></p>
<h3 id="1-1-4-标签插件语法引用"><a href="#1-1-4-标签插件语法引用" class="headerlink" title="1.1.4. 标签插件语法引用"></a>1.1.4. 标签插件语法引用</h3><p>如果希望图片在文章和首页中同时显示，可以使用标签插件语法，本地和网络图片都适用。</p>
<ul>
<li>本地图片资源，不限制图片尺寸，使用 <code>&#123;% asset_img image.jpg This is an image %&#125;</code>；</li>
<li>网络图片资源，限制图片显示尺寸，<code>&#123;% img http://www.something.gif 200 400 vi-vim-cheat-sheet %&#125;</code></li>
</ul>
<h3 id="1-1-5-CDN引用"><a href="#1-1-5-CDN引用" class="headerlink" title="1.1.5. CDN引用"></a>1.1.5. CDN引用</h3><ol>
<li>除了在本地存储图片，还可以将图片上传到一些免费的CDN服务中。比如Cloudinary提供的图片CDN服务，在Cloudinary中上传图片后，会生成对应的url地址，将地址直接拿来引用即可。</li>
<li>【实测这种方法不生效】把代码<code>&lt;div align=&quot;middle&quot; style=&quot;width:200px; margin:auto&quot;&gt;这里粘贴生成的url地址&lt;/div&gt;</code>粘贴到文章中即可；align为了美观设置成居中。</li>
</ol>
<h3 id="1-1-6-fancybox"><a href="#1-1-6-fancybox" class="headerlink" title="1.1.6. fancybox"></a>1.1.6. fancybox</h3><ol>
<li>启用fancybox<br>启用fancybox：点击查看图片大图。</li>
</ol>
<p>Hexo的NexT主题中提供了fancybox的方便接口。</p>
<p>Usage：<a href="https://github.com/theme-next/theme-next-fancybox3">https://github.com/theme-next/theme-next-fancybox3</a><br>markdown用法：<code>&#123;% img http://www.viemu.com/vi-vim-cheat-sheet.gif 600 600 "点击查看大图:vi/vim-cheat-sheet" %&#125;</code></p>
<ol start="2">
<li>Hexo部分图片禁用fancybox</li>
</ol>
<p>hexo在使用fancybox插件时，图片的效果还是很可观的，但是我们往往是不需要所有的图片都用fancybox；<br>例如：hexo next主题下，添加某些图片的时候，有些事不需要可点击的<br>修改theme\next\source\js\src\utils.js 红色字体部分；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff --git a/source/js/src/utils.js b/source/js/src/utils.js</span><br><span class="line">index 0f3704e..8516665 100644</span><br><span class="line">--- a/source/js/src/utils.js</span><br><span class="line">+++ b/source/js/src/utils.js</span><br><span class="line">@@ -11,6 +11,7 @@ NexT.utils = NexT.$u = &#123;</span><br><span class="line">       .not(&#x27;.group-picture img, .post-gallery img&#x27;)</span><br><span class="line">       .each(function() &#123;</span><br><span class="line">         var $image = $(this);</span><br><span class="line">+        if ($(this).hasClass(&#x27;nofancybox&#x27;)) return;</span><br><span class="line">         var imageTitle = $image.attr(&#x27;title&#x27;);</span><br><span class="line">         var $imageWrapLink = $image.parent(&#x27;a&#x27;);</span><br></pre></td></tr></table></figure>

<p>在img标签使用的时候加上class&#x3D;”nofancybox”即可。<code>&lt;img src=&quot;http://www.viemu.com/vi-vim-cheat-sheet.gif&quot; class=&quot;nofancybox&quot; /&gt;</code></p>
<h2 id="1-2-插入背景音乐"><a href="#1-2-插入背景音乐" class="headerlink" title="1.2. 插入背景音乐"></a>1.2. 插入背景音乐</h2><ol>
<li>打开网易云网页版，找到想听的歌曲，然后点击<strong>生成外链播放器</strong>，然后复制网易云音乐的插件页面的HTML代码；</li>
<li>把代码<code>&lt;div align=&quot;middle&quot;&gt;这里粘贴刚刚复制的代码&lt;/div&gt;</code>粘贴到文章中即可；align为了美观设置成居中；</li>
</ol>
<h2 id="1-3-插入引用"><a href="#1-3-插入引用" class="headerlink" title="1.3. 插入引用"></a>1.3. 插入引用</h2><p>插入引用有多种方式</p>
<h3 id="1-3-1-markdown方式【简单】"><a href="#1-3-1-markdown方式【简单】" class="headerlink" title="1.3.1. markdown方式【简单】"></a>1.3.1. markdown方式【简单】</h3><p>如果只是简单的标记引用，就选择行首添加<code>&gt;</code>的方式，简单快捷。</p>
<ol>
<li>单行引用</li>
</ol>
<ul>
<li>在markdown中的行首添加<code>&gt;</code>符号，就会把这段内容(和接下来无空格&#x2F;空行分隔的段落)标记为引用内容(效果等于加上<blockquuote>标签)。</li>
<li>例子：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test 引用</span><br><span class="line">&gt;cite quote</span><br><span class="line">test &gt; cite content</span><br></pre></td></tr></table></figure></li>
<li>效果：</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/blog_grammer_quote.png?raw=true" width=50% title=">引用效果" align="center" />

<p><strong><p align="center">Figure 2. &gt;引用效果</strong></p>
<ol start="2">
<li>多行引用</li>
</ol>
<ul>
<li>在每一行的行首都添加<code>&gt;</code>符号。</li>
</ul>
<ol start="3">
<li>嵌套引用</li>
</ol>
<ul>
<li><p>第一行行首添加<code>&gt;</code>符号，第二行行首添加<code>&gt;&gt;</code>符号，这样就会有第二行嵌套在第一行的效果。</p>
</li>
<li><p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test 嵌套引用</span><br><span class="line">&gt;cite quote 1</span><br><span class="line">&gt;&gt;cite content 2</span><br><span class="line">&gt;&gt;&gt;cite content 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果：</p>
</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/blog_grammer_multiquote.png?raw=true" width=50% title=">嵌套引用效果" align="center" />

<p><strong><p align="center">Figure 3. &gt;嵌套引用效果</strong></p>
<h3 id="1-3-2-HTML方式【居中】"><a href="#1-3-2-HTML方式【居中】" class="headerlink" title="1.3.2. HTML方式【居中】"></a>1.3.2. HTML方式【居中】</h3><p>如果需要居中显示引用内容，可以选择HTML的blockquote来实现。</p>
<ul>
<li>直接在markdown中写HTML格式来调用引用块blockquote</li>
<li>使用例子：<code>&lt;blockquote class=&quot;blockquote-center&quot;&gt;blockquote cite test&lt;/br&gt;test2&lt;/br&gt;test1 引用test test2 引用test test3 引用test test4 引用test test5 引用test test6 引用test test7 引用test test8 引用test test9 引用test test10 引用test test11 引用test test12 引用test test13 引用test test14 引用test test15 引用test test16 引用test test17 引用test test18 引用test test19 引用test test20&lt;/blockquote&gt;</code>。其中<code>class=&quot;blockquote-center&quot;</code>是为了使引用内容居中显示。</li>
<li>效果：</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/blog_grammer_blockquote.png?raw=true" width=80% title="blockquote HTML引用效果" align="center" />

<p><strong><p align="center">Figure 4. blockquote HTML引用效果</strong></p>
<h3 id="1-3-3-标签方式【全面】"><a href="#1-3-3-标签方式【全面】" class="headerlink" title="1.3.3. 标签方式【全面】"></a>1.3.3. 标签方式【全面】</h3><p>hexo内置许多标签使得引用的功能更全面。</p>
<ol>
<li>blockquote标签（hexo标签）<br>blockquote标签可插入包含作者、来源和标题的引用。</li>
</ol>
<ul>
<li><p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>例子1：引用书中内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote David Levithan, Wide Awake %&#125;</span><br><span class="line">Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>效果如下：</p>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/blog_grammer_blockquote1.png?raw=true" width=80% title="blockquote标签引用效果" align="center" />

<p><strong><p align="center">Figure 5. blockquote标签引用效果1</strong></p>
<ul>
<li>例子2：引用Twitter<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;</span><br><span class="line">NEW: DevDocs now comes with syntax highlighting. http://devdocs.io</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>效果如下：</p>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/blog_grammer_blockquote2.png?raw=true" width=80% title="blockquote标签引用效果" align="center" />

<p><strong><p align="center">Figure 6. blockquote标签引用效果2</strong></p>
<ul>
<li>例子3：引用网页文章<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</span><br><span class="line">Every interaction is both precious and an opportunity to delight.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>效果如下：</p>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/blog_grammer_blockquote3.png?raw=true" width=80% title="blockquote标签引用效果" align="center" />

<p><strong><p align="center">Figure 7. blockquote标签引用效果3</strong></p>
<ol start="2">
<li>centerquote标签（next（版本&gt;&#x3D;0.4.5）主题内置标签）<br>这个标签生成一个带上下分割线的引用，同时引用文本自动居中。</li>
</ol>
<ul>
<li>使用格式：<code>&#123;%centerquote&#125;引用内容&#123;%endcenterquote%&#125;</code>，其中centerquote可以简写成<code>cq</code>。</li>
<li>例子：<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;%cq%&#125;</span><br><span class="line">test cq cite format</span><br><span class="line">test1</span><br><span class="line">test1 引用test test2 引用test test3 引用test test4 引用test test5 引用test test6 引用test test7 引用test test8 引用test test9 引用test test10 引用test test11 引用test test12 引用test test13 引用test test14 引用test test15 引用test test16 引用test test17 引用test test18 引用test test19 引用test test20</span><br><span class="line"></span><br><span class="line">引用</span><br><span class="line">&#123;%endcq%&#125;</span><br></pre></td></tr></table></figure></li>
<li>效果如下：</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/blog_grammer_centerquote.png?raw=true" width=80% title="centerquote标签引用效果" align="center" />

<p><strong><p align="center">Figure 8. centerquote标签引用效果</strong></p>
<h2 id="1-4-插入网页"><a href="#1-4-插入网页" class="headerlink" title="1.4. 插入网页"></a>1.4. 插入网页</h2><ol>
<li>使用iframe嵌套网页</li>
</ol>
<iframe height=450 width=90% src="https://academic.oup.com/view-large/126092648" frameborder=0 allowfullscreen></iframe>

<h1 id="2-references"><a href="#2-references" class="headerlink" title="2. references"></a>2. references</h1><ol>
<li>hexo 标签插件:blockquote：<a href="https://hexo.io/docs/tag-plugins.html">https://hexo.io/docs/tag-plugins.html</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>markdown</tag>
        <tag>next</tag>
        <tag>image</tag>
        <tag>music</tag>
        <tag>quote</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo建站，github.io发布，多终端同步</title>
    <url>/2018/06/05/blog_hexo.github/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=418550511&auto=1&height=66"></iframe></div>

<ul>
<li><strong>markdown</strong>是一种适用撰写文本的语法和文件格式，后缀是.md</li>
<li><strong>hexo</strong>是把写的markdown文件生成blog网站的工具，hexo是不仅是博客引擎驱动，还是一个快速、简洁高效的博客框架，可生成静态网页。</li>
<li><strong>git</strong>是目前世界上最先进的分布式版本控制系统，用于对开发程序或者其他需要长期追踪版本变更的项目&#x2F;文件的版本控制。</li>
<li><strong>github</strong>提供网络站点进行blog的展示和备份</li>
</ul>
<p>github pages是github网站的一个功能，专门用于管理用户自行编写的静态网页，提供静态网页存储空间，许多人把它用于搭建独立博客。</p>
<p>github pages需要相应的博客引擎驱动，主流的是<a href="https://jekyllrb.com/">jekyllrb</a>和<a href="https://hexo.io/">hexo</a>。</p>
<p><strong>部署和发布blog有很多方法。这里介绍的是markdown撰写博客，hexo建立博客网站，通过git管理博客网站，发布博客网站到github平台和多终端同步的操作。</strong></p>
<p>部署本地blog的写作环境（git+hexo），并用github.io网站发布blog</p>
<ol>
<li>git和github的配置<br>新终端搭建博客撰写环境都需要配置</li>
<li>hexo的安装和配置<br>多终端同步和单终端有一点差别，建议一开始就配置多终端同步并备份到githbu网站，一步到位，避免博客在单终端丢失。</li>
<li>撰写与发布blog</li>
<li>github两个分支实现多终端同步</li>
<li>日常blog撰写和备份操作</li>
</ol>
<h1 id="1-git和github的配置"><a href="#1-git和github的配置" class="headerlink" title="1. git和github的配置"></a>1. git和github的配置</h1><p><em>notes：username和useremail替换成自己的github用户名和邮箱。</em></p>
<ol>
<li><p>下载安装<a href="https://git-scm.com/">git</a></p>
</li>
<li><p>注册github网站</p>
<p>  注册github网站，并创建一个名为username.github.io的仓库</p>
<p>  这个特殊的名称直接关联了gitpages，gitpages服务器会自动把上传到这个仓库的文档进行部署发布，并可以通过分配的域名<a href="https://username.github.io/%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BF%E9%97%AE%E3%80%82">https://username.github.io/实现博客的访问。</a></p>
</li>
<li><p>git配置和生成SSH key密钥对</p>
<p>  git配置：打开git bash（任意位置右键选择git bash here)</p>
<p>  运行<code>git config --global user.name username</code>和<code>git config --global user.email useremail</code></p>
<p>  cd ~进入用户主目录，运行<code>ssh-keygen -t rsa -C useremail@example.com</code>，一路回车，完成后会在用户主目录（C&#x2F;Users&#x2F;you&#x2F;)下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，即SSH key密钥对，id_rsa是私钥，需要保密，id_rsa.pub是公钥，可分享。</p>
</li>
<li><p>github添加终端的公钥</p>
<p>  打开网页，登录github，打开settings-&gt;SSH and GPG keys，点击new SSH key，填上任意title，在key文本框粘贴公钥，即id_rsa.pub文件的内容，添加。</p>
</li>
<li><p>验证与github的添加</p>
<p>  在git bash下运行<code>ssh -T git@github.com</code>。<br>  输出You’ve successfully suthenicated.则代表github账户成功授权你当前使用的终端，本机可连接上github了。</p>
</li>
</ol>
<h1 id="2-hexo的安装和配置"><a href="#2-hexo的安装和配置" class="headerlink" title="2. hexo的安装和配置"></a>2. hexo的安装和配置</h1><ol>
<li><p>下载安装<a href="https://nodejs.org/zh-cn/">node.js</a></p>
<p> 使用git bash或者cmd终端检查node的安装，<code>node -v</code>和<code>npm -v</code>出现版本号即node和npm 安装成功</p>
</li>
<li><p>安装hexo</p>
<p><code>npm install hexo-cli -g</code>命令安装hexo-cli（hexo的cli命令行模块）</p>
</li>
<li><p>初始化目录<code>hexo init</code><br> 选定位置通过git bash进入，创建hexo文件夹并进入hexo，hexo init命令初始化hexo文件夹。<br> 即生成一系列建站需要的文件：</p>
<ul>
<li>_config.yml：站点配置文件</li>
<li>package.json：说明使用哪些包，npm install参考这个文件安装</li>
<li>node_modules目录:安装的模块，用npm install会重新生成</li>
<li>package-lock.json：用npm install会重新生成</li>
<li>scaffolds目录：文章模板</li>
<li>source目录：blogmarkdown源文件</li>
<li>theme目录：网站主题</li>
<li>.gitignore：记录提交时忽略的文件，即以下文件</li>
<li>.deploy_git目录：hexo d命令时会重新生成</li>
<li>db.json</li>
</ul>
</li>
<li><p>安装组件<code>npm install</code>，<code>npm install hexo-server --save</code>,<code>npm install hexo-deployer-git</code></p>
<p> <code>npm install</code>安装依赖的组件，会更新node_modules目录</p>
<p> <code>npm install hexo-server --save</code>安装hexo-server以使用服务器</p>
<p> <code>npm install hexo-deployer-git</code>安装hexo-deployer-git，实现通过<code>hexo -g</code>部署hexo网站到github端</p>
</li>
<li><p>配置博客布署deploy参数</p>
<p>修改hexo下的站点配置文件_config.yml中deploy参数。<br>repository修改成github.io库的网址，branch填master分支。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: git@github.com:username/username.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>hexo其他配置</p>
<p> 在创建的博客网站文件夹下的<code>_config.yml</code>文件中进行网站的大部分配置。参考<a href="https://hexo.io/zh-cn/docs/configuration.html">hexo配置</a></p>
<ul>
<li><p>更换主题【optional】</p>
<p>   hexo网站<a href="https://hexo.io/themes/%E6%9C%89%E8%AE%B8%E5%A4%9A%E4%B8%BB%E9%A2%98%E5%8F%AF%E9%80%89%EF%BC%8C%E6%AF%94%E5%A6%82%E5%B8%B8%E8%A2%AB%E4%BD%BF%E7%94%A8%E7%9A%84NexT%E4%B8%BB%E9%A2%98">https://hexo.io/themes/有许多主题可选，比如常被使用的NexT主题</a><br>   在Hexo主题页面ctrl+F并输入next查找到NexT主题，然后点击进入到NexT主题的github页面，该页面存储了NexT主题的源码,复制next主题的github仓库位置，并在hexo&#x2F;themes位置下运行命令<code>git clone https://github.com/theme-next/hexo-theme-next.git next</code>克隆next主题</p>
<p>   然后修改hexo下的站点配置文件_config.yml中的主题行为theme: next</p>
</li>
<li><p>网站其他配置【optional】</p>
<p>   更改站点配置文件_config.yml中其他参数，例如</p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: username&#x27;s blog #网站标题</span><br><span class="line">subtitle: &#x27;&#x27; #网站副标题</span><br><span class="line">description: &#x27;&#x27; #网站描述（主要用于SEO）</span><br><span class="line">keywords: </span><br><span class="line">author: username #作者</span><br><span class="line">language: en #网站使用语言</span><br><span class="line">timezone: Asia/Shanghai #网站时区，要在时区列表中选取，Hexo默认使用您电脑的时区</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="3-撰写与发布blog"><a href="#3-撰写与发布blog" class="headerlink" title="3. 撰写与发布blog"></a>3. 撰写与发布blog</h1><ol>
<li><p>撰写blog</p>
<p>blog文件存放在hexo&#x2F;source&#x2F;_posts下，markdown（.md)格式文件，在这个位置新建和编辑markdown文档，这就是写文章的地方。</p>
<p>使用命令<code>hexo new &quot;newpostname&quot;</code>可以在hexo&#x2F;source&#x2F;_posts下新建一个newpostname.md的文件，打开这个文件即可写作。</p>
</li>
<li><p>发布blog</p>
<p> 使用git bash进入博客建站所在位置hexo目录下，使用<code>hexo clean &amp; hexo g -d</code> 合并三条命令实现发布blog，或者一步一步实现</p>
<ul>
<li><p><code>hexo clean</code> 【optional】<br>  INFO  Validating config<br>  INFO  Deleted database.<br>  INFO  Deleted public folder.<br>  清除缓存文件（db.json)和已生成的静态文件（public目录）</p>
</li>
<li><p><code>hexo generate</code>&#x3D;<code>hexo g</code><br>  生成静态页面，静态网页会根据source&gt;_posts目录下所有markdown文件编译成静态网页（html），并生成public目录存储生成的静态文件。</p>
</li>
<li><p><code>hexo serve</code>&#x3D;<code>hexo s</code><br>  生成静态文件后，可以使用<code>hexo serve</code>命令启动本地服务器来预览博客网站。</p>
</li>
<li><p><code>hexo deploy</code>&#x3D;<code>hexo d</code><br>  部署public到github的master分支（部署位置：站点配置文件_config.yml的deploy参数设置的github账号和分支名），即部署到gitpages。</p>
<p>  部署之后，可以在githube的page项目中查看到变化。我的是<a href="https://github.com/yanzhongsino/yanzhongsino.github.io">https://github.com/yanzhongsino/yanzhongsino.github.io</a>。很快也可以在<a href="https://yanzhongsino.github.io/">https://yanzhongsino.github.io/</a>线上看到生成的博客。</p>
</li>
</ul>
</li>
</ol>
<p>每次修改blog或新增blog内容后，可用hexo clean &amp; g -d快速部署到github端master分支，从而实现github.io网站博客的更新。</p>
<h1 id="4-github两个分支实现多终端同步【推荐配置】"><a href="#4-github两个分支实现多终端同步【推荐配置】" class="headerlink" title="4. github两个分支实现多终端同步【推荐配置】"></a>4. github两个分支实现多终端同步【推荐配置】</h1><p>在进行hexo的安装和配置后，可以通过命令<code>hexo clean &amp; hexo g -d</code>发布博客网站到github.io网站，但需要备份博客源文件和多终端协作时，便有一些问题。</p>
<ul>
<li><p>单终端配置hexo的问题：</p>
<p>  hexo建站部署文件框架为：blog原始md文件存放在hexo建站位置的&#x2F;source&#x2F;_posts下，发布blog的命令<code>hexo clean &amp; hexo g -d</code>会生成&#x2F;public并把它部署到github端的master分支，但在source&#x2F;_posts下的原始md文件和hexo建站部署文件只在当前电脑存放。</p>
</li>
<li><p>多终端同步的意义：</p>
<p>  把博客md源文件和hexo部署文件备份到github，实现多端共享，共享md源文件可以避免单终端md博客文件丢失，共享hexo部署文件可以在不同电脑上写blog，并部署到github终端，保持一致。</p>
</li>
<li><p>多终端同步实现原理：</p>
<p>  在github上新建hexo分支，hexo分支用于同步博客md源文件和hexo配置文件（即同步整个hexo目录），master分支用于发布博客到github.io网站（即同步public目录）。两个分支相互独立，永远不要合并。</p>
</li>
<li><p>多终端同步实现具体操作:</p>
<p>  github网站新建hexo分支，并把hexo分支设为默认分支，<code>git clone</code>克隆hexo分支到本地终端，把克隆的目录下的.git文件夹移动到hexo配置好的建站目录hexo下。<br>  用三条命令<code>git add .</code>，<code>git commit -m &quot;submit&quot;</code>，<code>git push origin hexo</code>同步.git文件夹所在目录到github端hexo分支，这样操作之后克隆github端hexo分支便包含了hexo部署文件和md源文件，从而实现多端共享，github端的master分支只用于发布blog（同步生成的public目录）。</p>
</li>
</ul>
<h2 id="4-1-多终端同步配置"><a href="#4-1-多终端同步配置" class="headerlink" title="4.1. 多终端同步配置"></a>4.1. 多终端同步配置</h2><p>多终端同步配置具体步骤如下：</p>
<ol>
<li><p>安装node.js</p>
</li>
<li><p>在github网页新建hexo分支并设为default默认分支</p>
</li>
<li><p>克隆hexo分支到本地</p>
<p> 在git bash下进入想创建存储blog文件的位置，运行<code>git clone git@github.com:username/username.github.io.git</code>，在当前目录克隆github的github.io仓库的默认分支（应为hexo）。</p>
<p> 克隆的目录中的.git文件夹是github端hexo分支的版本库Repositor，.git文件夹所在目录（目前是username.github.io）对应github的hexo分支（把.git移动到哪hexo分支就定位到哪）。</p>
</li>
<li><p>移动.git目录</p>
<p> .git目录是通过git命令与github端hexo分支同步的关键文件。</p>
<ul>
<li>git bash下进入github.io后缀文件夹</li>
<li>进入git clone生成的github.io后缀目录，除.git目录外的文件可以不用保留，.git目录移动到hexo安装和建站的目录下。</li>
</ul>
</li>
<li><p>同步本地hexo部署文件和blog源文件到github端的hexo分支</p>
<p>在hexo部署目录下通过git三步命令同步hexo部署目录到github端的hexo分支。</p>
<p>以后有修改新增blog或更改配置都用这三步同步hexo分支。三条命令执行前建议通过<code>hexo clean</code>清除缓存和public目录，以免备份不需要的文件。</p>
<ul>
<li><p>git add .        </p>
<p>  添加所有工作区（即本地github.io文件夹）的修改到暂存区(即.git里的stage&#x2F;index文件)</p>
</li>
<li><p>git commit -m “commit notes”</p>
<p>  提交暂存区的所有更改到本地的默认分支（此时为hexo）。</p>
</li>
<li><p>git push&#x2F;git push origin hexo</p>
<p>  提交本地分支到github端的hexo分支，origin指本地默认分支（即.git文件夹所在目录），github端hexo是默认分支，所以可以省略origin hexo，直接用git push便会同步本地github.io仓库到github端的默认分支（即hexo）。</p>
<p>  从而实现github端hexo分支备份了本地hexo部署目录，包括目录下的source文件夹的blog源文件。</p>
</li>
</ul>
</li>
<li><p>blog撰写与发布</p>
<p>blog撰写与发布单终端和多终端是一样的操作。<br>撰写在source&#x2F;_posts下进行，推荐使用markdown语法撰写博客；发布使用<code>hexo clean &amp; hexo g -d</code>命令。</p>
</li>
</ol>
<h2 id="4-2-配置后新终端使用同步功能"><a href="#4-2-配置后新终端使用同步功能" class="headerlink" title="4.2. 配置后新终端使用同步功能"></a>4.2. 配置后新终端使用同步功能</h2><p>按照以上进行多终端同步配置后，在新的终端或者本地文件丢失后，可以通过以下步骤快速搭建博客撰写环境并同步博客数据。</p>
<ol>
<li><p>git和github的安装配置同上</p>
</li>
<li><p>安装node.js</p>
</li>
<li><p>克隆hexo分支到本地</p>
<p> 在git bash下进入想创建存储blog文件的位置，运行<code>git clone git@github.com:username/username.github.io.git</code>，在当前目录克隆github的github.io仓库的默认分支（应为hexo）。</p>
</li>
<li><p>安装组件</p>
<p>通过git bash进入本地github.io文件夹下依次执行 <code>npm install hexo-cli -g</code>命令安装hexo-cli（hexo的cli命令行模块）,<code>npm install</code>命令安装依赖的模块,<code>npm install hexo-server --save</code>安装hexo-server以使用服务器，<code>npm install hexo-deployer-git</code>命令安装部署模块hexo-deployer-git（注意不要 hexo init）。</p>
</li>
<li><p>进行日常blog撰写和备份</p>
</li>
</ol>
<h1 id="5-日常blog撰写和备份操作"><a href="#5-日常blog撰写和备份操作" class="headerlink" title="5. 日常blog撰写和备份操作"></a>5. 日常blog撰写和备份操作</h1><ol>
<li><p>blog同步<br>养成习惯，每次开始撰写blog前都通过git bash进入工作区，进行<code>git pull</code>命令把github端的hexo分支的更新（更新可能是其他终端上提交的）同步到本地，实现多终端的内容完全同步。</p>
<p>但如果本地有未提交的更新，则千万不要用<code>git pull</code>，否则会覆盖本地更新；直接进入下一步；直到使用<code>git add .</code>，<code>git commit -m &quot;submit&quot;</code>，<code>git push origin hexo</code>提交备份本地更新到github端的hexo分支后才可以使用<code>git pull</code>(一般是在其他终端，把github的hexo分支更新拉到其他终端设备使用)。</p>
</li>
<li><p>blog撰写<br> 使用命令<code>hexo new &quot;newpostname&quot;</code>可以在hexo&#x2F;source&#x2F;_posts下新建一个newpostname.md的文件，打开这个文件即可写作。</p>
<p> 在本地source&#x2F;_posts下添加和修改md文档实现blog的日常撰写和修改。</p>
</li>
<li><p>blog备份<br>只要blog有更改或者新增，或者配置文件有修改，即工作区（即本地的hexo目录或github.io目录）有文件修改，则建议对文件进行备份到GitHub端的hexo分支。</p>
<p>用三条命令<code>git add .</code>，<code>git commit -m &quot;submit&quot;</code>，<code>git push origin hexo</code>备份工作区，包括md博客源文件和hexo部署到github端的hexo分支。三条命令执行前建议通过<code>hexo clean</code>清除缓存和public目录，以免备份不需要的文件。</p>
</li>
<li><p>blog生成和预览<br> 通过<code>hexo g</code>生成博客网站静态文件后，可以用<code>hexo serve</code>&#x3D;<code>hexo s</code>命令启动本地服务器来在网址<code>http://localhost:4000</code>预览博客网站。没问题再进行博客发布。</p>
</li>
<li><p>blog发布<br> 可根据自身需求决定是否发布blog到github.io网站，一般写的blog完整程度比较高时可以发布。使用<code>hexo clean &amp; hexo g -d</code>命令，根据source&#x2F;_posts下的博客源文件生成public目录（网站html并同步到github端的master分支，即发布blog到github.io网站。</p>
</li>
</ol>
<p>总结一下，在配置好写作环境后的任意一台终端的日常工作流应该是：</p>
<ol>
<li><code>git pull</code>同步远程github库的更新</li>
<li><code>hexo new &quot;newblog&quot;</code>在source&#x2F;_posts&#x2F;下添加md格式的blog，或者修改已有的blog</li>
<li><code>git add .</code>,<code>git commit -m &quot;commit notes&quot;</code>,<code>git push</code>把修改备份到github端</li>
<li>下次写作重复以上三个步骤</li>
<li>用<code>hexo g</code>-<code>hexo s</code>来预览博客</li>
<li>直至blog完善成熟后，用命令<code>hexo clean &amp; hexo g -d</code>生成网站并部署到github.io</li>
</ol>
<h1 id="6-next主题同步和更新"><a href="#6-next主题同步和更新" class="headerlink" title="6. next主题同步和更新"></a>6. next主题同步和更新</h1><h1 id="7-Issue-amp-Solution"><a href="#7-Issue-amp-Solution" class="headerlink" title="7. Issue&amp;Solution"></a>7. Issue&amp;Solution</h1><h3 id="7-0-1-Issue-1：建站日记写好后，在另一个终端通过git-clone，修改后部署发现githubio没有显示，检查后发现由于next主题也是通过git-clone获取的，git不能直接管理两个git项目（有-git文件夹的被识别为一个git项目）中嵌套的其他git项目，即git-add-git-commit-m-quot-commit-notes-quot-git-push命令对hexo项目下的next项目无效，themes-x2F-next主题没有被同步到github端hexo分支。"><a href="#7-0-1-Issue-1：建站日记写好后，在另一个终端通过git-clone，修改后部署发现githubio没有显示，检查后发现由于next主题也是通过git-clone获取的，git不能直接管理两个git项目（有-git文件夹的被识别为一个git项目）中嵌套的其他git项目，即git-add-git-commit-m-quot-commit-notes-quot-git-push命令对hexo项目下的next项目无效，themes-x2F-next主题没有被同步到github端hexo分支。" class="headerlink" title="7.0.1. Issue 1：建站日记写好后，在另一个终端通过git clone，修改后部署发现githubio没有显示，检查后发现由于next主题也是通过git clone获取的，git不能直接管理两个git项目（有.git文件夹的被识别为一个git项目）中嵌套的其他git项目，即git add .,git commit -m &quot;commit notes&quot;,git push命令对hexo项目下的next项目无效，themes&#x2F;next主题没有被同步到github端hexo分支。"></a>7.0.1. Issue 1：建站日记写好后，在另一个终端通过git clone，修改后部署发现githubio没有显示，检查后发现由于next主题也是通过git clone获取的，git不能直接管理两个git项目（有.git文件夹的被识别为一个git项目）中嵌套的其他git项目，即<code>git add .</code>,<code>git commit -m &quot;commit notes&quot;</code>,<code>git push</code>命令对hexo项目下的next项目无效，themes&#x2F;next主题没有被同步到github端hexo分支。</h3><ul>
<li><p>Solution A 把next主题的git项目改为普通文件进行同步<br>  删除themes&#x2F;next目录（删除前备份next目录到其他位置），然后<code>git add .</code>,<code>git commit -m &quot;delete theme next&quot;</code>,<code>git push</code>命令同步到github端的hexo分支。<br>  把备份的next目录移回themes下，并把next目录下的.git目录删除，然后后<code>git add .</code>,<code>git commit -m &quot;commit notes&quot;</code>,<code>git push</code>命令同步到github端的hexo分支。此时next目录不作为git项目被同步到github的hexo端，而是普通文件。<br>  优点是操作简单，缺点是next主题的更新较为麻烦。</p>
</li>
<li><p>Solution B fork+subtree同步next主题<br>  删除themes&#x2F;next目录（删除前备份next目录下修改过的文件，比如主题配置文件_config.yml），然后<code>git add .</code>,<code>git commit -m &quot;delete theme next&quot;</code>,<code>git push</code>命令同步到github端的hexo分支。</p>
<p>  fork主题项目，访问<a href="https://github.com/theme-next/hexo-theme-next">next</a>主题，点击右上角fork，表示把next这个git项目完整的复制一份到自己的github下，你的github账号下会有一个hexo-theme-next的新仓库。</p>
<p>  <em>notes：注意fork的next版本与hexo版本相匹配，next V8与hexo v5，否则githubpages为空白（过来人踩过的坑~~）</em></p>
<p>  <code>git remote add -f next git@github.com:yanzhongsino/hexo-theme-next.git</code> #添加远程仓库hexo-theme-next到本地，仓库名设置为next，远程仓库网址粘贴你的github账号下fork的hexo-theme-next的网址。<code>git remote</code>显示所有添加的远程仓库，此时便能看见next。</p>
<p>  <code>git subtree add --prefix=themes/next next master --squash</code> #添加subtree，把本地next仓库作为子仓库添加到本地themes&#x2F;next目录下，分支为master，–squash的意思是把subtree的改动合并成一次commit提交。</p>
<p>  在本地替换themes&#x2F;next目录下的主题配置文件_config.yml，把删除前修改好的放进themes&#x2F;next目录，用<code>git add .</code>,<code>git commit -m &quot;add theme next&quot;</code>,<code>git push</code>命令同步本地的next目录到github端的hexo分支，实现next主题目录与githubio项目一起同步。此时，github端fork的hexo-theme-next项目也成为github端github.io项目的子项目。</p>
</li>
</ul>
<h3 id="7-0-2-Isssue-2：当next主题发生更新时，由于next主题的配置文件-config-yml不一致，使用git-pull拉取需要解决冲突问题，或者手动替换配置文件。"><a href="#7-0-2-Isssue-2：当next主题发生更新时，由于next主题的配置文件-config-yml不一致，使用git-pull拉取需要解决冲突问题，或者手动替换配置文件。" class="headerlink" title="7.0.2. Isssue 2：当next主题发生更新时，由于next主题的配置文件_config.yml不一致，使用git pull拉取需要解决冲突问题，或者手动替换配置文件。"></a>7.0.2. Isssue 2：当next主题发生更新时，由于next主题的配置文件_config.yml不一致，使用git pull拉取需要解决冲突问题，或者手动替换配置文件。</h3><ul>
<li><p>Solution A 把next主题的配置文件_config.yml合并到站点配置文件_config.yml<br>  把next主题的配置文件_config.yml的内容复制到站点配置文件_config.yml，每行都缩进两个空格(在VScode里选中内容，ctrl+]即可缩进)，然后在内容前一行添加<code>theme_config:</code>标题行。有任何主题配置都在博客配置文件中进行。</p>
</li>
<li><p>Solution B 使用_config.next.yml进行主题配置和同步【需要&gt;hexo5.0】<br>  <a href="https://theme-next.js.org/docs/getting-started/configuration.html">next官方指导doc</a></p>
<p>  在本地的github.io的工作目录下，创建一个_config.next.yml的文件，把需要更改的主题设置从next&#x2F;_config.yml复制到_config.next.yml并进行更改，用_config.next.yml进行主题配置和同步。</p>
<p>  当next主题在配置文件&#x2F;themes&#x2F;next&#x2F;_config.yml增加新的特性时，可随时复制新特性的内容到这个文件_config.next.yml中，实现主题的配置和同步。</p>
<p>  将本地的修改推送给子项目（github端fork的hexo-theme-next项目）<code>git subtree push --prefix=themes/next next master</code>，对github端fork的hexo-theme-next项目进行pull、push操作需要使用<code>git subtree</code>命令。</p>
<p>  平常使用同步同前面介绍的一致。<code>git add .</code>,<code>git commit -m &quot;commit notes&quot;</code>,<code>git push</code>命令同步hexo项目和blog源文件到github端的hexo分支，<code>hexo clean &amp; hexo g -d</code>命令部署网站（生成public）并发布到githubio网站（同步到github端的master分支）。<br>  当next主题项目下文件更改时，增加了<code>git subtree push --prefix=themes/next next master</code>推送本地更改到子项目（github端fork的hexo-theme-next项目）的操作。</p>
</li>
<li><p>Solution C 使用source&#x2F;_data&#x2F;next.yml进行主题配置和同步<br>  使用source&#x2F;_data&#x2F;next.yml进行主题配置和同步的方案在next v8版本被告知不支持【20201122】</p>
<p>  为了避免这种不便，next开发者提供了两种<a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md">解决方案</a>。</p>
<p>  把主题配置修改的任务转移到新建的位置：复制一份主题配置文件&#x2F;themes&#x2F;next&#x2F;_config.yml到新建的位置&#x2F;source&#x2F;_data&#x2F;next.yml，并且维持&#x2F;themes&#x2F;next&#x2F;_config.yml的默认值，在&#x2F;source&#x2F;_data&#x2F;next.yml中修改主题配置。当next主题在配置文件&#x2F;themes&#x2F;next&#x2F;_config.yml增加新的特性时，可随时复制新特性的内容到这个新的文件&#x2F;source&#x2F;_data&#x2F;next.yml，这样更新主题时便不需额外处理冲突或者手动替换配置文件了。</p>
</li>
<li><p>next主题更新【还未验证】<br>  当next的源项目更新后，希望自己的网站和hexo部署同步更新的操作。<br>  通过git bash进入本地next主题子项目，更新子项目：<code>git fetch next master</code>,<code>git pull https://github.com/example/hexo-theme-next.git</code>命令拉取next项目源更新的仓库到本地。<br>  然后<code>git add .</code>,<code>git commit -m &quot;commit notes&quot;</code>,<code>git push</code>命令推送本地更改到主项目，<code>git subtree push --prefix=themes/next next master</code>推送本地更改到子项目。</p>
</li>
</ul>
<h3 id="7-0-3-Issue-3-hexo-deploy时报错Authentication-failed"><a href="#7-0-3-Issue-3-hexo-deploy时报错Authentication-failed" class="headerlink" title="7.0.3. Issue 3:hexo deploy时报错Authentication failed"></a>7.0.3. Issue 3:hexo deploy时报错Authentication failed</h3><p>报错信息如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fatal: 发送请求时出错。</span><br><span class="line">fatal: 基础连接已经关闭: 连接被意外关闭。</span><br><span class="line">yLogon failed, use ctrl+c to cancel basic credential prompt.</span><br><span class="line">remote: Invalid username or password.</span><br><span class="line">fatal: Authentication failed for &#x27;https://github.com/yanzhongsino/yanzhongsino.github.io.git/&#x27;</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (D:\yanzhongsino.github.io\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:315:20)</span><br><span class="line">      at ChildProcess.cp.emit (D:\yanzhongsino.github.io\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure>

<p>是因为github的认证信息过期了，用以下两条命令可以解决这个问题。<br>git config –global –unset credential.helper<br>git config credential.helper store</p>
<h3 id="7-0-4-Issue-4-hexo-deploy报错unable-to-access-20210518"><a href="#7-0-4-Issue-4-hexo-deploy报错unable-to-access-20210518" class="headerlink" title="7.0.4. Issue 4:hexo deploy报错unable to access 20210518"></a>7.0.4. Issue 4:hexo deploy报错unable to access 20210518</h3><p>报错信息如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">fatal: unable to access &#x27;https://github.com/yanzhongsino/yanzhongsino.github.io.git/&#x27;: OpenSSL SSL_read: Connection was reset, errno 10054</span><br><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (D:\yanzhongsino.github.io\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:315:20)</span><br><span class="line">      at ChildProcess.cp.emit (D:\yanzhongsino.github.io\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure>

<ul>
<li>Solution<br>可能是git的协议问题，修改hexo下的站点配置文件_config.yml中deploy参数，地址如果是http协议的修改成ssh协议的。<br>把deploy的type修改成git，repository若是<code>https://github.com/yanzhongsino/yanzhongsino.github.io.git</code>格式修改成<code>git@github.com:yanzhongsino/yanzhongsino.github.io.git</code>格式，如下。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repository: git@github.com:yanzhongsino/yanzhongsino.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>

<p>也可能是网络之类的问题，就隔一段时间试试<code>hexo deploy</code>。</p>
<h3 id="报错kex-exchange-identification-Connection-closed-by-remote-host"><a href="#报错kex-exchange-identification-Connection-closed-by-remote-host" class="headerlink" title="报错kex_exchange_identification: Connection closed by remote host"></a>报错kex_exchange_identification: Connection closed by remote host</h3><ol>
<li>问题<br>运行git的博客同步命令，报错kex_exchange_identification: Connection closed by remote host。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">kex_exchange_identification: Connection closed by remote host</span><br><span class="line">Connection closed by 20.205.243.166 port 22</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方案<br>运行VPN的全局模式会导致这个报错，取消全局模式即可。</li>
</ol>
<p><strong>小记</strong></p>
<p>学习hexo+githubpages建站已是两年前（2018.06）的事，那时初学前端，好多新知识需要记录，就先建好站用来发布。结果转行前端从入门到放弃只不过两三月，便把博客搁置了。</p>
<p>前几天拾起来，建站知识已忘得精光，原来应该是配置好了hexo的多端同步，但由于两年的荒废，遗忘导致我把hexo和master分支合并了，博客的原始文件有没备份，所以一切从头开始。</p>
<p>学了几天，博客搭建初步捡回来了。可不能再忘，这次笔记记得很精细，下次如果需要看看笔记应该可以捡回来。</p>
<p>——2020.11.18 Yan Zhong in Guangzhou</p>
<p>next主题的同步稍微有点麻烦，在理解git的各种命令的含义的基础上理解各种操作实现了什么目的会更有帮助。<br>目前版本号 hexo 5.2.0, next 8.0.2。</p>
<p>——2020.11.22 Yan Zhong in Guangzhou</p>
<p>添加了攥写blog时插入图片或背景音乐教程的小节，并添加了BGM</p>
<p>——2021.03.25 Yan Zhong in Guangzhou</p>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>tutorial</tag>
        <tag>sync</tag>
        <tag>build website</tag>
        <tag>deploy website</tag>
      </tags>
  </entry>
  <entry>
    <title>冠群(crown groups)和干群(stem groups)及相关定义</title>
    <url>/2021/07/16/concept_crown.and.stem/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1842025914&auto=1&height=32"></iframe></div>

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/1a/Crown_n_Stem_Groups.svg/330px-Crown_n_Stem_Groups.svg.png" title="冠群干群示意图" width="100%" />

<p><strong><p align="center">Figure 1. 冠群干群示意图</strong><br>from <a href="https://en.wikipedia.org/wiki/Crown_group">wikipedia: crown group</a></p></p>
<p>C1&#x2F;C2是冠群，S1是干群；C1和S1组成了泛群&#x2F;总群T1</p>
<p><strong>泛群(pan-group)&#x3D;冠群(crown groups)+干群(stem groups)</strong></p>
<h1 id="1-冠群-crown-groups"><a href="#1-冠群-crown-groups" class="headerlink" title="1. 冠群(crown groups)"></a>1. 冠群(crown groups)</h1><p>在种系遗传学(phylogenetics)中，冠群(crown groups)指的是指定的现存生物群体，和它们的最近共同祖先(the most recent common ancestor,最近共祖)，和最近共祖的所有灭绝后代的物种集合。</p>
<p>同时，这也是进化枝(clade)的其中一种定义方式，即某个最近共祖和它的所有后代（包括现存的和灭绝的）的物种集。<br>如图中红色部分则是两个典型的冠群。</p>
<h1 id="2-泛群-Pan-group"><a href="#2-泛群-Pan-group" class="headerlink" title="2. 泛群(Pan-group)"></a>2. 泛群(Pan-group)</h1><p>泛群(pan-group)或者总群(total group)是指冠群和比起其他现存生物与冠群更近缘的所有生物的总称。在系统树上，是指冠群和所有回退到与含有现存成员的最近分支分叉的位置(但不包含这个分叉点)的分支。</p>
<h1 id="3-干群-stem-groups"><a href="#3-干群-stem-groups" class="headerlink" title="3. 干群(stem groups)"></a>3. 干群(stem groups)</h1><p>干群(stem groups)是并系类群，由一个泛群中不包括冠群的成员组成。所有干群成员都是灭绝的，多用于古生物学的化石集合。</p>
<h1 id="4-邻群-Plesion-group"><a href="#4-邻群-Plesion-group" class="headerlink" title="4. 邻群(Plesion-group)"></a>4. 邻群(Plesion-group)</h1><p>邻群(plesion-group)有几种含义，其中一种是”nearby group”，例如指定类群(可以是冠群，也可以不是)的姐妹群；另一种含义是一个可能是并系的群体，由原始特征(symplesiomorphies，我也不是太明白)定义，通常是指系统发育树的基部类群。<br>就我们的进化学研究我好像没见过这个词，用的不多。</p>
<h1 id="5-词缀"><a href="#5-词缀" class="headerlink" title="5. 词缀"></a>5. 词缀</h1><p>通常要作区分时，把crown-,stem-,pan-,plesion-作为前缀，比如Crown-Aves指现存所有鸟类，以及它们的最近共祖和最近共祖的所有灭绝后代。</p>
<h1 id="6-冠-crown-和干-stem-的在系统发育树上的应用"><a href="#6-冠-crown-和干-stem-的在系统发育树上的应用" class="headerlink" title="6. 冠(crown)和干(stem)的在系统发育树上的应用"></a>6. 冠(crown)和干(stem)的在系统发育树上的应用</h1><p>系统发育树在描述分支节点时，有冠节点和干节点的区别，在标定物种的分化时间时，有冠时间点和干时间点的区别，这个其实是对应冠节点和干节点的，冠节点的时间就是冠时间点。</p>
<p>用例子说明系统发育树上的冠节点和干节点：</p>
<p>在下面系统发育树示意图(A4,(A3,(A2,A1)B)C)D中，假设A1和A2都属于As类群，A3和A4不属于As类群，那么在这个系统发育树上，As类群的冠节点是B，干节点是C。当描述As与其他物种分化时间时，冠时间指B点的时间，干时间指C点的时间。</p>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/bioinfo_caculate.divergence.time_phylogeny.jpg?raw=true" title="系统发育树示意图(A4,(A3,(A2,A1)B)C)D" width="100%" />

<p><strong><p align="center">Figure 2. 系统发育树示意图</p></strong></p>
<p>notes：</p>
<p>每篇博客的周期都有点超出预期吖~</p>
<p>2021.08.05写完</p>
<p><strong>ref：</strong></p>
<ol>
<li>wiki: crown group：<a href="https://en.wikipedia.org/wiki/Crown_group">https://en.wikipedia.org/wiki/Crown_group</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>
]]></content>
      <categories>
        <category>bio</category>
        <category>concept</category>
      </categories>
      <tags>
        <tag>concept</tag>
        <tag>crown groups</tag>
        <tag>stem groups</tag>
        <tag>fossil time</tag>
      </tags>
  </entry>
  <entry>
    <title>同源性(homology)相关概念</title>
    <url>/2021/06/23/concept_homology/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=3986241&auto=1&height=32"></iframe></div>

<img src="https://bitesizebio.com/wp-content/uploads/2015/11/Homology.png" width=60% title="homologs示意图" alt="homologs示意图" align=center/>

<p><strong><p align="center">Figure 1. homologs示意图</strong><br>from <a href="https://bitesizebio.com/26762/homology-terminology-never-say-wrong-word/">bitesizebio website</a></p></p>
<h2 id="1-同源性-homology-定义"><a href="#1-同源性-homology-定义" class="headerlink" title="1. 同源性(homology)定义"></a>1. 同源性(homology)定义</h2><p><strong>homology</strong>在生物学上被翻译成“同源性”，是指在不同生物类群中，由于共同的祖先，在一对结构或基因间表现出来的相似性。在基因序列(DNA,RNA or Protein)上体现出的相似性被称作序列同源性(sequence homology)，具有序列同源性的基因被称做同源基因(homolog&#x3D;homologous gene)，常用于进化生物学的研究。</p>
<h2 id="2-同源基因-homolog-分类"><a href="#2-同源基因-homolog-分类" class="headerlink" title="2. 同源基因(homolog)分类"></a>2. 同源基因(homolog)分类</h2><p>按不同成因分为两类（也有把homolog分为ortholog，paralog和xenolog三类的）：</p>
<ul>
<li>直系同源基因（ortholog）：物种形成(speciation)导致，一个共同祖先的基因由于物种形成分离到不同物种间；orthologs通常（不是绝对）保留相同的功能。</li>
<li>旁系同源基因(paralog)：重复(duplication)导致，一个物种的基因组内由于基因复制产生的同源性；paralogs通常具有不同的功能，或者成为假基因(pseudogene)；不同物种间不是由于物种形成导致的同源基因也被称为paralogs。在旁系同源基因中，起源于一次全基因组重复(whole-genome duplication, WGD)的那些被称为ohnolog，由Ken Wolfe在2000年第一次给出定义。</li>
</ul>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ee/Ohnology.svg/290px-Ohnology.svg.png" width=50% title="ohnologs示意图" alt="ohnologs示意图" align=center/>

<p><strong><p align="center">Figure 2. ohnologs示意图</strong><br>from <a href="https://en.wikipedia.org/wiki/Sequence_homology">wikipedia: sequence homology</a></p></p>
<h2 id="3-扩展概念"><a href="#3-扩展概念" class="headerlink" title="3. 扩展概念"></a>3. 扩展概念</h2><ul>
<li>直系同源基因：单数形式ortholog&#x3D;orthologous gene；复数形式orthologs&#x3D;orthologous genes。</li>
<li>直系同源(orthology)：一个名词，代表直系同源基因的直系同源属性；相应地，有旁系同源(paralogy)。</li>
<li>直系同源群(orthogroup)：在一群物种中，起源于这群物种的最近共同祖先(last common ancestor, LCA)的一个基因的一组基因，是这群物种中具有直系同源性的基因家族(gene family)的合集。</li>
</ul>
<p>按照逻辑，应该有一套完整的单词：</p>
<table>
<thead>
<tr>
<th>*log 特指基因</th>
<th>*logy 属性</th>
<th>*logous 形容词</th>
<th>*group</th>
</tr>
</thead>
<tbody><tr>
<td>ortholog</td>
<td>orthology</td>
<td>orthologous</td>
<td>orthogroup</td>
</tr>
<tr>
<td>paralog</td>
<td>paralogy</td>
<td>paralogous</td>
<td>paragroup</td>
</tr>
<tr>
<td>homolog</td>
<td>homology</td>
<td>homologous</td>
<td>homogroup</td>
</tr>
</tbody></table>
<p>但我查了下，paragroup,homogroup这两个词是不存在的。<br>按照orthogrop的定义，个人觉得用homogroup代替orthogroup好像更好，因为直系同源群内包括orthologs和paralogs，即包括所有homologs。</p>
<h2 id="4-相关概念"><a href="#4-相关概念" class="headerlink" title="4. 相关概念"></a>4. 相关概念</h2><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Ortholog_paralog_analog_examples.svg/400px-Ortholog_paralog_analog_examples.svg.png" width=50% title="analog示意图" alt="analog示意图" align=center/>

<p><strong><p align="center">Figure 3. analog示意图</strong><br>from <a href="https://en.wikipedia.org/wiki/Sequence_homology">wikipedia: sequence homology</a></p></p>
<ul>
<li><p>异同源基因(xenolog)：水平基因转移(horizontal&#x2F;lateral gene transfer)导致，来源于寄生，腐生，共生或病毒侵染等途径转移产生的异同源基因；一般具有相似功能，但如果新环境差异巨大，功能可能出现分化。xenolog一词最早在1970年由Walter Fitch创造。由于异同源基因不是来自共同祖先，而是拥有独立起源。</p>
</li>
<li><p>analog（不知道咋翻译，同功基因？）：在不同物种中，不相关的基因有着相似的功能，但是独立的进化起源。<br>按照定义，xenolog应该是一种analog。</p>
</li>
<li><p>基因家族(gene family)：是指在一个物种中，起源于一个基因的复制，通常具有相似生化功能的一套基因。</p>
</li>
</ul>
<p><strong>reference</strong></p>
<ol>
<li>wiki：homology：<a href="https://en.wikipedia.org/wiki/Homology_(biology)">https://en.wikipedia.org/wiki/Homology_(biology)</a></li>
<li>wiki：sequence homology：<a href="https://en.wikipedia.org/wiki/Sequence_homology#Homoeology">https://en.wikipedia.org/wiki/Sequence_homology#Homoeology</a></li>
<li>Paper：Orthologs, Paralogs, and Evolutionary Genomics：<a href="https://www.annualreviews.org/doi/abs/10.1146/annurev.genet.39.073003.114725">https://www.annualreviews.org/doi/abs/10.1146/annurev.genet.39.073003.114725</a></li>
<li>Paper：analog和xenolog的由来和定义：<a href="https://academic.oup.com/sysbio/article-abstract/19/2/99/1655771?redirectedFrom=fulltext">https://academic.oup.com/sysbio/article-abstract/19/2/99/1655771?redirectedFrom=fulltext</a></li>
<li>Paper：ohnolog的由来和定义：<a href="https://www.nature.com/articles/ng0500_3">https://www.nature.com/articles/ng0500_3</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bio</category>
        <category>concept</category>
      </categories>
      <tags>
        <tag>gene family</tag>
        <tag>orthology</tag>
        <tag>concept</tag>
        <tag>homolog</tag>
        <tag>ortholog</tag>
        <tag>paralog</tag>
        <tag>xenolog</tag>
        <tag>analog</tag>
        <tag>orthogroup</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux系统中设置环境变量PATH</title>
    <url>/2021/04/20/linux_basics_PATH/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=5264843&auto=1&height=32"></iframe><music URL></div>



<h1 id="1-环境变量PATH设置"><a href="#1-环境变量PATH设置" class="headerlink" title="1. 环境变量PATH设置"></a>1. 环境变量PATH设置</h1><h2 id="1-1-PATH的解释"><a href="#1-1-PATH的解释" class="headerlink" title="1.1. PATH的解释"></a>1.1. PATH的解释</h2><p>PATH是环境变量，一个存放有（可执行）命令和程序的目录集合，目录间以冒号:分隔。</p>
<p>操作系统接到用户输入命令时，会<strong>从前到后依次</strong>查看PATH存储的目录，查找与输入命令同名的可执行文件，<strong>一旦查找到就停止查找</strong>，全部目录都查不到就报错。</p>
<p><code>echo $PATH</code>可以查看当前存放了哪些目录。</p>
<h2 id="1-2-设置环境变量"><a href="#1-2-设置环境变量" class="headerlink" title="1.2. 设置环境变量"></a>1.2. 设置环境变量</h2><h3 id="1-2-1-临时设置，当前终端有效"><a href="#1-2-1-临时设置，当前终端有效" class="headerlink" title="1.2.1. 临时设置，当前终端有效"></a>1.2.1. 临时设置，当前终端有效</h3><ol>
<li>添加目录到环境变量<br><code>PATH=$PATH:/home/usrname/opt/software/</code>命令把目录<code>/home/software/</code>添加到PATH后，并用冒号:分隔，即重新给PATH赋值。</li>
</ol>
<p><code>PATH=$PATH:/home/software/</code>和<code>PATH=/home/software/:$PATH</code>区别在于把目录<code>/home/software/</code>置于PATH的最前面还是最后面，最前面代表最优先使用这个目录下的命令。</p>
<ol start="2">
<li>声明环境变量<br><code>export PATH</code>命令声明变量，使其对系统shell可识别</li>
</ol>
<p>以上两条命令可以合并成<code>export PATH=$PATH:/home/software/</code>或者<code>export PATH=/home/software/:$PATH</code>，此时目录<code>/home/software/</code>下的命令可以被当前shell直接调用。</p>
<p>但这种设置方式只在当前shell有效，关掉shell就失效。</p>
<h3 id="1-2-2-当前用户永久设置"><a href="#1-2-2-当前用户永久设置" class="headerlink" title="1.2.2. 当前用户永久设置"></a>1.2.2. 当前用户永久设置</h3><p>登录服务器时，会自动运行当前用户下<code>~/.bashrc</code>和<code>~/.bash_profile</code>文件内的命令。</p>
<p>所以把<code>export PATH=$PATH:/home/software/</code>写入<code>~/.bashrc</code>或者<code>~/.bash_profile</code>文件就可以使目录<code>/home/software/</code>对于当前用户永久生效。</p>
<p>第一次写入后需要用命令<code>source ~/.bashrc</code>运行~&#x2F;.bashrc文件来刷新环境变量，之后就不再需要。</p>
<h3 id="1-2-3-所有用户永久设置"><a href="#1-2-3-所有用户永久设置" class="headerlink" title="1.2.3. 所有用户永久设置"></a>1.2.3. 所有用户永久设置</h3><p>与前一步同理，不过写入的文件是&#x2F;etc&#x2F;profile或者&#x2F;etc&#x2F;bashrc，需要root用户修改。</p>
<p>第一次修改需要<code>source /etc/profile</code>刷新，之后不再需要。</p>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>linux</category>
        <category>basics</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>PATH</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中CPU相关概念</title>
    <url>/2022/05/02/linux_basics_cpu/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=283094&auto=1&height=32"></iframe></div>

<h1 id="1-CPU相关概念"><a href="#1-CPU相关概念" class="headerlink" title="1. CPU相关概念"></a>1. CPU相关概念</h1><p>中央处理单元(central processing unit, CPU)</p>
<p>在不同的情景中使用的CPU常常代表不同含义，主要区别物理CPU和逻辑CPU。</p>
<ol>
<li><strong>逻辑CPU(processor数量)</strong></li>
</ol>
<ul>
<li>由于物理CPU，核心(core)，SMT产生的计算能力翻倍，计算机的逻辑CPU的数量(也是常常说的总线程数)，符合下面的公式：</li>
</ul>
<p><strong>总的逻辑CPU数(processor数量) &#x3D; 物理CPU数量(计算机主板的CPU硬件&#x2F;插槽socket的数量) * 每颗物理CPU的核心数(core) * 每个核心的同时多线程数量&#x2F;超线程数量</strong></p>
<ol start="2">
<li><strong>物理CPU(physical CPU)</strong></li>
</ol>
<ul>
<li>计算机主板上实际插入的CPU硬件个数，也是主板物理CPU插槽(socket)的数量。</li>
<li>通常只有服务器上才会有多个物理CPU，一般的办公&#x2F;家用计算机主板上只有一个物理CPU。</li>
</ul>
<ol start="3">
<li><strong>核心(core)</strong></li>
</ol>
<ul>
<li>核心是在物理CPU上的硬件。</li>
<li>单个物理CPU上，可能存在单个&#x2F;多个核心数量(所谓的单核、双核、四核等)。</li>
</ul>
<ol start="4">
<li><strong>同时多线程技术(simultaneous multithreading, SMT)</strong></li>
</ol>
<ul>
<li>每个核心(core)的同时多线程数量。</li>
<li>同时多线程技术(simultaneous multithreading, SMT)是实现单个核心(core)同一时刻能够执行多线程数的技术。以充分利用单个核心(core)的计算能力。AMD和其他CPU厂商常用SMT的称呼。</li>
<li>超线程技术(hyper–threading, HT)：Intel的称呼，是SMT的一种具体技术实现。</li>
<li>在许多情境下，这个技术产生的计算能力又被称为**虚拟核心(virtual core)<strong>，或者</strong>逻辑处理器(logical processor)<strong>，或者直接称作</strong>线程(thread)**。</li>
</ul>
<h1 id="2-查询CPU相关信息"><a href="#2-查询CPU相关信息" class="headerlink" title="2. 查询CPU相关信息"></a>2. 查询CPU相关信息</h1><ol>
<li>CPU相关详细信息在文件<code>/proc/cpuinfo</code>中</li>
</ol>
<ul>
<li><code>cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</code> #查看逻辑CPU数量，即processor数量</li>
<li><code>cat /proc/cpuinfo| grep &quot;physical id&quot;| sort| uniq| wc -l</code> #查看物理CPU数量</li>
<li><code>cat /proc/cpuinfo | grep &quot;cpu cores&quot; | uniq</code> #查看单个物理CPU的核心(core)的数量</li>
</ul>
<ol start="2">
<li><code>lscpu</code>命令会列出CPU相关信息</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Architecture:        x86_64</span><br><span class="line">CPU op-mode(s):      32-bit, 64-bit</span><br><span class="line">Byte Order:          Little Endian</span><br><span class="line">CPU(s):              32 # 逻辑CPU总数，即processor数量</span><br><span class="line">On-line CPU(s) list: 0-31</span><br><span class="line">Thread(s) per core:  2 #每个核心的同时多线程数量</span><br><span class="line">Core(s) per socket:  8 #每个物理CPU的核心数量</span><br><span class="line">Socket(s):           2 #物理CPU数量/插槽数量</span><br><span class="line">NUMA node(s):        2</span><br><span class="line">Vendor ID:           GenuineIntel</span><br><span class="line">CPU family:          6</span><br><span class="line">Model:               62</span><br><span class="line">Model name:          Intel(R) Xeon(R) CPU E5-2650 v2 @ 2.60GHz</span><br><span class="line">Stepping:            4</span><br><span class="line">CPU MHz:             3287.925</span><br><span class="line">CPU max MHz:         3400.0000</span><br><span class="line">CPU min MHz:         1200.0000</span><br><span class="line">BogoMIPS:            5187.48</span><br><span class="line">Virtualization:      VT-x</span><br><span class="line">L1d cache:           32K</span><br><span class="line">L1i cache:           32K</span><br><span class="line">L2 cache:            256K</span><br><span class="line">L3 cache:            20480K</span><br><span class="line">NUMA node0 CPU(s):   0-7,16-23</span><br><span class="line">NUMA node1 CPU(s):   8-15,24-31</span><br><span class="line">Flags:               fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm cpuid_fault epb pti ssbd ibrs ibpb stibp tpr_shadow vnmi flexpriority ept vpid fsgsbase smep erms xsaveoptdtherm ida arat pln pts md_clear flush_l1d</span><br></pre></td></tr></table></figure>

<h1 id="3-references"><a href="#3-references" class="headerlink" title="3. references"></a>3. references</h1><ol>
<li>wiki：CPU：<a href="https://en.wikipedia.org/wiki/Central_processing_unit">https://en.wikipedia.org/wiki/Central_processing_unit</a></li>
<li>CPU介绍：<a href="https://zhuanlan.zhihu.com/p/86855590">https://zhuanlan.zhihu.com/p/86855590</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>linux</category>
        <category>basics</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>CPU</tag>
        <tag>物理CPU</tag>
        <tag>逻辑CPU</tag>
        <tag>核心</tag>
      </tags>
  </entry>
  <entry>
    <title>单系(monophyly)、并系(paraphyly)和复系(polyphyly)及相关定义</title>
    <url>/2021/09/20/concept_monophyly.paraphyly.polyphyly/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1842025914&auto=1&height=32"></iframe></div>

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/Monophyly%2C_paraphyly%2C_polyphyly.png/1280px-Monophyly%2C_paraphyly%2C_polyphyly.png" width=100% title="单系-并系-复系示意图" alt="单系-并系-复系示意图" align=center/>

<p><strong><p align="center">Figure 1. 单系-并系-复系示意图</strong><br>from <a href="https://en.wikipedia.org/wiki/Monophyly">wikipedia: monophyly</a></p></p>
<h1 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h1><ol>
<li>分类<br> <strong>分类</strong>就是根据共有属性，将对象群进行分门别类。对象的属性有多少种（一般是无穷多种），就可以有多少种分类方法&#x2F;分类依据。</li>
<li>分类在生物学领域的应用<br> <strong>分类在生物学领域的应用</strong>是依据生物的特征将生物进行分门别类整理，而生物学的分类的目的是为了准确描述生物间的亲缘关系。</li>
<li>分支分类学（cladistics）<br> 也叫支序分类学，是指一种用分支图（系统进化关系树） 来对生物进行分类和描述进化关系的分类学。</li>
</ol>
<h1 id="2-单系-monophyly"><a href="#2-单系-monophyly" class="headerlink" title="2. 单系-monophyly"></a>2. 单系-monophyly</h1><ol>
<li>定义</li>
</ol>
<ul>
<li>单系(monophyly)是指一组仅由共同祖先种群及其所有直系后代组成的分类群。</li>
<li>通过共有衍征被归类到一起的类群。</li>
<li>一个等效的术语是holophyly。</li>
</ul>
<ol start="2">
<li>例子<br>单系类群的例子有哺乳动物，鸟类。</li>
<li>单系的意义<br>单系群是真正意义完整的分类群，是生物学上分类追求的结果。</li>
</ol>
<h1 id="3-并系-paraphyly"><a href="#3-并系-paraphyly" class="headerlink" title="3. 并系-paraphyly"></a>3. 并系-paraphyly</h1><ol>
<li>定义</li>
</ol>
<ul>
<li>并系群是由一个共同祖先和所有后代减去一个或多个单系群组成。</li>
<li>通过共有祖征被归类到一起的类群。</li>
<li>并系群是不完整的单系群，导致不完整的原因是部分单系群的祖征丢失。</li>
<li>并系群大多是由于传统形态分类年代的认知偏差产生的具有共同形态特征的非自然类群，随着分子生物学的发展纠正了许多原来认为的单系类群为并系类群。</li>
</ul>
<ol start="2">
<li>例子<br>并系类群的例子有苔藓植物，蕨类植物，爬行动物，鱼类，原核生物。</li>
<li>分类学上的处理</li>
</ol>
<ul>
<li>分类学上对并系类群一般做合并处理。</li>
<li>例如传统概念的夹竹桃科（Apocynaceae）是个并系，与萝藦科（Asclepiadaceae）之后的广义夹竹桃科则成为一个单系类群。</li>
</ul>
<h1 id="4-多系-x2F-复系-polyphyly"><a href="#4-多系-x2F-复系-polyphyly" class="headerlink" title="4. 多系&#x2F;复系-polyphyly"></a>4. 多系&#x2F;复系-polyphyly</h1><ol>
<li>定义</li>
</ol>
<ul>
<li>多系是指一个包含的成员来自两个或多个分支，且没有包含所有成员的最近共同祖先的分类群。</li>
<li>通过趋同共性被归类到一起的类群。</li>
<li>也是由于传统认知偏差造成的非自然类群，但具有共同特征且有科学价值。</li>
<li>广泛一点说，任何不适单系或者并系的分类群都可以被称为多系。</li>
</ul>
<ol start="2">
<li>例子</li>
</ol>
<ul>
<li>多系类群的例子有果树，水生昆虫，寄生植物，多肉植物，食虫植物等。</li>
</ul>
<ol start="3">
<li>分类学上的处理</li>
</ol>
<ul>
<li>分类学上对多系类群一般做拆分处理。</li>
<li>例如传统的毛茛科（Ranunculaceae）是多系类群，包含芍药属（Paeonia），星叶草属（Circaeaster）和狭义的毛茛科，把三个部分拆分，芍药属独立成为芍药科（Paeoniaceae），星叶草属独立成为星叶草科（Circaeasteraceae），狭义的毛茛科依然保持，则成为三个独立的单系类群。</li>
</ul>
<h1 id="5-物种概念中的单系和并系"><a href="#5-物种概念中的单系和并系" class="headerlink" title="5. 物种概念中的单系和并系"></a>5. 物种概念中的单系和并系</h1><p>物种概念要求物种是单系的，但由于部分类群祖征的丢失，并系物种在自然界中很常见。<br>研究表明，多达20%的动物物种和20%-50%的植物物种是并系的。</p>
<h2 id="5-1-一些例子"><a href="#5-1-一些例子" class="headerlink" title="5.1. 一些例子"></a>5.1. 一些例子</h2><p>并系群-排除的单系群-对应的完整单系群</p>
<ul>
<li>鱼fish-四足类Tetrapoda-脊椎动物Vertebrate</li>
<li>爬行动物Reptiles-鸟类birds-蜥形目Sauropsida</li>
<li>猴子Monkey-人猿总科Hominoidea-类人猿目Simiiformes</li>
</ul>
<h1 id="6-references"><a href="#6-references" class="headerlink" title="6. references"></a>6. references</h1><ol>
<li>wiki:cladistics：<a href="https://en.wikipedia.org/wiki/Cladistics">https://en.wikipedia.org/wiki/Cladistics</a></li>
<li>wiki:monophyly：<a href="https://en.wikipedia.org/wiki/Monophyly">https://en.wikipedia.org/wiki/Monophyly</a></li>
<li>wiki:paraphyly：<a href="https://en.wikipedia.org/wiki/Paraphyly">https://en.wikipedia.org/wiki/Paraphyly</a></li>
<li>wiki:polyphyly：<a href="https://en.wikipedia.org/wiki/Polyphyly">https://en.wikipedia.org/wiki/Polyphyly</a></li>
<li>ArtemisiaLiu’s weibo：<a href="https://www.weibo.com/ttarticle/p/show?id=2309404308383288185230">https://www.weibo.com/ttarticle/p/show?id=2309404308383288185230</a></li>
<li><a href="http://wap.sciencenet.cn/blog-3454407-1262077.html?mobile=1">http://wap.sciencenet.cn/blog-3454407-1262077.html?mobile=1</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bio</category>
        <category>concept</category>
      </categories>
      <tags>
        <tag>monophyly</tag>
        <tag>paraphyly</tag>
        <tag>polyphyly</tag>
        <tag>cladistics</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器的硬件和开机流程的简介，以及BIOS和磁盘阵列控制器的设置</title>
    <url>/2023/04/19/linux_operation.and.maintenance_RAID.Controller.Card/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=399341112&auto=1&height=32"></iframe></div>

<h1 id="1-服务器介绍"><a href="#1-服务器介绍" class="headerlink" title="1. 服务器介绍"></a>1. 服务器介绍</h1><h2 id="1-1-课题组的16服务器硬件介绍"><a href="#1-1-课题组的16服务器硬件介绍" class="headerlink" title="1.1. 课题组的16服务器硬件介绍"></a>1.1. 课题组的16服务器硬件介绍</h2><ol>
<li>服务器：惠普HPE_ProLiant_DL580_Gen9</li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/HPE_ProLiant_DL580_Gen9_Server_按钮和指示灯.jpg?raw=true" title="HPE_ProLiant_DL580_Gen9_Server_按钮和指示灯" width="80%" />

<p><strong><p align="center">HPE_ProLiant_DL580_Gen9_Server_按钮和指示灯</p></strong></p>
<ul>
<li>服务器内部能看到外装的Dell的LSI MegaRaid SAS Controller磁盘阵列控制卡(RAID Controller)和USB3.0扩展卡(USB3.0 Extender)。</li>
<li>两个外装设备都可拆卸。先按蓝色零件开启固定挡板，使固定挡板弹开，即可把RAID Controller和USB3.0 Extender拔出。装回两张卡后，把固定挡板盖上，并按紧（要同时按服务器后面）直到咔的一声表明固定挡板开关关上。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/HPE_ProLiant_DL580_Gen9_Server_服务器内部.jpg?raw=true" title="HPE_ProLiant_DL580_Gen9_Server_服务器内部" width="80%" />

<p><strong><p align="center">HPE_ProLiant_DL580_Gen9_Server_服务器内部</p></strong></p>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/HPE_ProLiant_DL580_Gen9_Server_顶盖说明书.jpg?raw=true" title="HPE_ProLiant_DL580_Gen9_Server_顶盖说明书" width="80%" />

<p><strong><p align="center">HPE_ProLiant_DL580_Gen9_Server_顶盖说明书</p></strong></p>
<ol start="2">
<li>磁盘阵列（RAID）：戴尔 Dell_PowerVault_MD1200</li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/RAID_Dell_PowerVault_MD1200.jpg?raw=true" title="RAID_Dell_PowerVault_MD1200" width="80%" />

<p><strong><p align="center">RAID_Dell_PowerVault_MD1200</p></strong></p>
<ol start="3">
<li>磁盘阵列控制卡：服务器自带的Smart Array P830i Controller</li>
<li>磁盘阵列控制卡（RAID Controller）：外装的Dell的LSI MegaRaid SAS Controller（用来连接服务器和磁盘阵列）</li>
</ol>
<ul>
<li>SAS线（连接磁盘阵列和服务器的数据传输线）两端接口一样。</li>
<li>16服务器的磁盘阵列有两根，服务器上面的接口接磁盘阵列上面的接口，服务器下面的接口接磁盘阵列下面的接口，不能混接。</li>
<li>如果SAS线在服务器连接处的右边，每根SAS线对应亮黄灯，则表明磁盘阵列卡是正常工作连接的。</li>
<li>磁盘阵列卡可以取出，先关机并拔除SAS线，然后打开服务器的顶盖，在右上方插着磁盘阵列卡和USB3.0外接卡。需要先按左上方的蓝色按钮打开固定挡板（参考服务器内部的图片），使得固定阵列卡和USB3.0外接卡的开关打开，才能取出两张卡。装回两张卡后，把固定挡板盖上，并按紧（要同时按服务器后面）直到咔的一声表明开关关上。</li>
</ul>
<ol start="5">
<li>USB3.0扩展卡</li>
</ol>
<ul>
<li>USB3.0扩展卡比磁盘阵列卡小，用于连接移动硬盘等外部存储设备。</li>
<li>20230417开机故障把16服务器的USB3.0外接卡移除了，避免它导致服务器降级影响开机。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/USB3.0扩展卡1.jpg?raw=true" title="USB3.0扩展卡1" width="80%" />

<p><strong><p align="center">USB3.0扩展卡1</p></strong></p>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/USB3.0扩展卡2.jpg?raw=true" title="USB3.0扩展卡2" width="80%" />

<p><strong><p align="center">USB3.0扩展卡2</p></strong></p>
<h2 id="1-2-课题组的16服务器软件介绍"><a href="#1-2-课题组的16服务器软件介绍" class="headerlink" title="1.2. 课题组的16服务器软件介绍"></a>1.2. 课题组的16服务器软件介绍</h2><ol>
<li>内核</li>
</ol>
<ul>
<li>内核版本号 kernel 4.18.0-147.el8.x86_64，其他版本与磁盘阵列驱动不匹配，会导致无法识别磁盘阵列。开机时需要选择内核版本，默认是最新的4.18.0-240版本。</li>
<li><code>uname -a</code> 可以查看内核版本</li>
</ul>
<h1 id="2-操作"><a href="#2-操作" class="headerlink" title="2. 操作"></a>2. 操作</h1><h2 id="2-1-正常开机界面"><a href="#2-1-正常开机界面" class="headerlink" title="2.1. 正常开机界面"></a>2.1. 正常开机界面</h2><p>开机后进行初始化和自检，依次显示如下界面。</p>
<ol>
<li>开机过程1EarlyProcessorInitialization</li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/开机过程1EarlyProcessorInitialization.jpg?raw=true" title="开机过程1EarlyProcessorInitialization" width="80%" />

<p><strong><p align="center">开机过程1EarlyProcessorInitialization</p></strong></p>
<ol start="2">
<li>开机过程2BIOS_Boot</li>
</ol>
<ul>
<li>在这一步可以通过F9进入System Utilities，F10进入Intelligent Provisioning，F11进入Boot Menu，F12进入Network Boot</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/开机过程2BIOS_Boot1.jpg?raw=true" title="开机过程2BIOS_Boot1" width="80%" />

<p><strong><p align="center">开机过程2BIOS_Boot1</p></strong></p>
<ul>
<li>如果按下F9，屏幕上会对应亮起，需等待检测完毕自动进入Boot界面<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/开机过程2BIOS_Boot2.jpg?raw=true" title="开机过程2BIOS_Boot2" width="80%" /></li>
</ul>
<p><strong><p align="center">开机过程2BIOS_Boot2</p></strong></p>
<ol start="3">
<li>正常开机</li>
</ol>
<ul>
<li>如果开机后不进行任何操作，正常开机最后会进入等待登录的命令行界面或图形界面，这时正常开机结束，就可以远程登录啦。</li>
</ul>
<h2 id="2-2-更改启动模式"><a href="#2-2-更改启动模式" class="headerlink" title="2.2. 更改启动模式"></a>2.2. 更改启动模式</h2><p>16服务器默认是UEFI Mode启动。如果服务器开机故障，可以尝试在BIOS Mode下启动以做检测或更改设置。</p>
<ol>
<li>开机</li>
<li>经过EarlyProcessorInitialization页面，到BIOS Boot页面时，按下F9，等待系统自动进入System Utilities界面。在这个界面可以进行许多系统的设置。</li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/F9_SystemUtilities.jpg?raw=true" title="F9_SystemUtilities" width="80%" />

<p><strong><p align="center">F9_SystemUtilities</p></strong></p>
<ol start="3">
<li>更改启动模式。依次选择System Configuration-BIOS&#x2F;Platform Configuration(RBSU)-Boot Options-Boot Mode。Boot Mode代表服务器使用什么模式启动。然后从UEFI Mode转变成Legacy BIOS Mode模式。</li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/BIOSmode_RBSU_BootMode.jpg?raw=true" title="BIOSmode_RBSU_BootMode" width="80%" />

<p><strong><p align="center">BIOSmode_RBSU_BootMode</p></strong></p>
<ol start="4">
<li>还可以更改自动开机设置。依次选择System Configuration-BIOS&#x2F;Platform Configuration(RBSU)-Server Availability-Automatic Power-On。这里的Always Power On&#x2F;Off是代表通电后总是自动开机&#x2F;关机，Restore Last Power State代表通电后使用上次的开机&#x2F;关机状态来决定是否开机。</li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/BIOSmode_RBSU_ServerAvailability.jpg?raw=true" title="BIOSmode_RBSU_ServerAvailability" width="80%" />

<p><strong><p align="center">BIOSmode_RBSU_ServerAvailability</p></strong></p>
<ol start="5">
<li>F10保存所有设置后，Ctrl+Alt+Delete重启服务器，这次是以Legacy BIOS Mode模式启动了。</li>
</ol>
<h2 id="2-3-RAID控制卡的设置"><a href="#2-3-RAID控制卡的设置" class="headerlink" title="2.3. RAID控制卡的设置"></a>2.3. RAID控制卡的设置</h2><ol>
<li>RAID控制卡的设置需要在Legacy BIOS Mode模式下启动服务器，参考上面一节操作。</li>
<li>Legacy BIOS Mode模式启动服务器的前面的初始化和自检过程一样，先开机过程1EarlyProcessorInitialization，再开机过程2BIOS_Boot，第二个页面只有Boot Mode这一行内容不一样，别的都一样。</li>
<li>然后进入下面的页面，Booting in legacy BIOS mode，出现Expandable RAID Controller BIOS时按下ctrl+R进入RAID控制卡设置界面（ps：出现的时间很短，需要尽快按下ctrl+R）。</li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/开机过程3Bootmode.jpg?raw=true" title="开机过程3Bootmode" width="80%" />

<p><strong><p align="center">开机过程3Bootmode</p></strong></p>
<ol start="4">
<li>磁盘阵列控制卡（RAID Controller）设置界面</li>
</ol>
<ul>
<li>在这个界面可以更改RAID控制卡的设置</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/RAID设置1VirtualDiskManagement.jpg?raw=true" title="RAID设置1VirtualDiskManagement" width="80%" />

<p><strong><p align="center">RAID设置1VirtualDiskManagement</p></strong></p>
<ul>
<li>空格键可以显示RAID硬盘的详细参数</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/RAID设置1VirtualDiskManagementDetails.jpg?raw=true" title="RAID设置1VirtualDiskManagementDetails" width="80%" />

<p><strong><p align="center">RAID设置1VirtualDiskManagementDetails</p></strong></p>
<ul>
<li>Tab键在不同的标签页之间转换，在Controller Management标签页可以进行控制卡的管理。空格键可以在是否选中高亮的选项之间转换。改变设置之后要APPLY使其生效。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/operation_and_maintenance/RAID设置2ControllerManagement.jpg?raw=true" title="RAID设置2ControllerManagement" width="80%" />

<p><strong><p align="center">RAID设置2ControllerManagement</p></strong></p>
<ol start="5">
<li>Enable BIOS Stop on Error选项的解释</li>
</ol>
<ul>
<li>上图中Settings里的Enable BIOS Stop on Error默认是选上的（前面有X符号）。</li>
<li>选上Enable BIOS Stop on Error这个选项代表如果开机时有报错信息就让BIOS停止工作（BIOS停止工作意味着无法正常开机），这个时候如果硬盘或者硬盘的扇区出现问题，或者其他任何硬件出现问题，系统发生降级，RAID控制卡会记录这次降级，并认定为Error信息，从而停止BIOS工作，导致无法正常开机。</li>
<li>如果不选这个选项，发生系统降级导致Error信息也不会停止BIOS工作。</li>
</ul>
<ol start="6">
<li>可能的开机故障处理方案，去除Enable BIOS Stop on Error设置。</li>
</ol>
<ul>
<li>开机故障：前段时间（2023&#x2F;04&#x2F;17）服务器停电关机后开机出现故障，在开机过程2BIOS_Boot这个页面的Power and Thermal Calibration这一步时，屏幕转入无信号页面并一直保持在无信号页面，服务器不断尝试重启（声音变大变小，无限循环）。ctrl+alt+delete命令重启无效，长按电源键强制重启后服务器的健康监测灯变成红色，有时UID灯也亮起。</li>
<li>解决方案就是把Enable BIOS Stop on Error设置改为不选中，就顺利开机了。</li>
</ul>
<ol start="7">
<li>设置完毕，应用之后Ctrl+Alt+Delete重启，F9进入BIOS界面修改BIOS Mode回UEFI Mode启动，再重启即可。</li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>linux</category>
        <category>operation and maintenance</category>
      </categories>
      <tags>
        <tag>server</tag>
        <tag>hardware</tag>
        <tag>RAID</tag>
        <tag>RAID Controller</tag>
        <tag>BIOS</tag>
        <tag>Boot Mode</tag>
        <tag>USB3.0 Extender</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统的服务器开机自动挂载硬盘的设置</title>
    <url>/2023/04/24/linux_operation.and.maintenance_auto.mount/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=399341112&auto=1&height=32"></iframe></div>

<h1 id="Linux系统的服务器开机自动挂载硬盘的设置方法"><a href="#Linux系统的服务器开机自动挂载硬盘的设置方法" class="headerlink" title="Linux系统的服务器开机自动挂载硬盘的设置方法"></a>Linux系统的服务器开机自动挂载硬盘的设置方法</h1><p>这里介绍两种方法进行安装了Linux系统的服务器开机后自动挂载硬盘的设置，两种方法各有其特点。使用第一种方法挂载，失败后不影响操作系统运行，还可以手动挂载；第二种方法使用UUID识别硬盘，可以避免因为盘符改变造成的挂载不成功。</p>
<h2 id="方法一：在-etc-rc-local内添加挂载命令"><a href="#方法一：在-etc-rc-local内添加挂载命令" class="headerlink" title="方法一：在/etc/rc.local内添加挂载命令"></a>方法一：在<code>/etc/rc.local</code>内添加挂载命令</h2><ol>
<li>操作步骤</li>
</ol>
<ul>
<li><code>vi /etc/rc.local</code>打开文件，在文件最后一行添加挂载命令，如挂载<code>/dev/sdb1</code>到<code>/disk1</code>上则挂载命令为<code>mount /dev/sdb1 /disk1</code>，并保存。</li>
<li>执行命令<code>chmod +x /etc/rc.d/rc.local</code>赋值文件执行权限。</li>
<li>下次服务器开机即会执行<code>/etc/rc.d/rc.local</code>里的命令。</li>
</ul>
<ol start="2">
<li>注意事项</li>
</ol>
<ul>
<li>在文件<code>/etc/rc.local</code>内添加挂载命令，如果输入的挂载命令错误，云服务器重启时不会影响操作系统正常运行。</li>
<li>此方法通过盘符进行自动挂载，云硬盘进行挂载卸载操作、云服务器硬重启时盘符会产生改变或者漂移，建议只有一块数据盘（vdb）时采用该方法设置自动挂载。</li>
</ul>
<h2 id="方法二：修改配置文件-etc-fstab"><a href="#方法二：修改配置文件-etc-fstab" class="headerlink" title="方法二：修改配置文件/etc/fstab"></a>方法二：修改配置文件<code>/etc/fstab</code></h2><ol>
<li>操作步骤（root用户）</li>
</ol>
<ul>
<li>备份<code>/etc/fstab</code>文件：<code>cp /etc/fstab /etc/fstab.bak</code></li>
<li>查看挂载硬盘的信息（UUID和文件类型）：<code>blkid /dev/sdb1</code></li>
<li>显示如下：<code>/dev/sdb1: UUID=&quot;37013e09-db10-4680-ad01-2a141597ce43&quot; BLOCK_SIZE=&quot;512&quot; TYPE=&quot;xfs&quot; PARTLABEL=&quot;primary&quot; PARTUUID=&quot;9002b507-946b-496d-8c8f-a09003c96465&quot;</code></li>
<li>在文件<code>/etc/fstab</code>最后一行中写入此硬盘的挂载信息，格式为<code>UUID=37013e09-db10-4680-ad01-2a141597ce43 /disk1 xfs defaults 0 0</code>，注意UUID和TYPE一定要填写正确，然后保存。</li>
<li>运行命令<code>cat /etc/fstab</code>查看挂载信息是否保存</li>
</ul>
<ol start="2">
<li>注意事项</li>
</ol>
<ul>
<li>如果配置文件信息有误，重启云服务器时会进入维护模式，需要修改配置信息正确才能正常进入操作系统。</li>
<li>通过将信息写入<code>/etc/fstab</code>中进行自动化挂载云硬盘操作时，建议不要使用盘符以及分区id，建议使用文件系统的UUID，因为当云硬盘涉及到挂载和卸载操作时盘符会产生改变或者漂移。</li>
</ul>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>linux</category>
        <category>operation and maintenance</category>
      </categories>
      <tags>
        <tag>server</tag>
        <tag>mount</tag>
        <tag>auto</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的常用命令连接符（command connector）</title>
    <url>/2022/01/16/linux_shell_command.connector/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=2117115&auto=1&height=32"></iframe></div>

<h1 id="1-常用命令连接符"><a href="#1-常用命令连接符" class="headerlink" title="1. 常用命令连接符"></a>1. 常用命令连接符</h1><p>多条命令放在一行时，需要在命令之间使用命令连接符，包括<code>;</code>,<code>&amp;&amp;</code>,<code>||</code>等。</p>
<h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1. ;"></a>1.1. <code>;</code></h2><p><code>;</code>是最简单的命令连接符。</p>
<p><code>command1; command2; command3</code>表示多个命令顺序执行，命令间没有逻辑联系。</p>
<h2 id="1-2-amp-amp"><a href="#1-2-amp-amp" class="headerlink" title="1.2. &amp;&amp;"></a>1.2. <code>&amp;&amp;</code></h2><p><code>&amp;&amp;</code>逻辑与命令连接符。</p>
<p><code>command1 &amp;&amp; command2 &amp;&amp; command3</code>表示从左往右按顺序执行命令，如果中间有命令执行失败，则中断在失败的命令处不继续往下执行。即左边的命令执行成功才执行右边的命令；当左边命令执行失败就不会执行右边命令。</p>
<h2 id="1-3"><a href="#1-3" class="headerlink" title="1.3. ||"></a>1.3. <code>||</code></h2><p><code>||</code>逻辑或命令连接符。</p>
<p><code>command1 ||command2 || command3</code>表示从左往右按顺序执行命令，如果中间有命令执行成功，则中断在成功的命令处不继续往下执行。即左边的命令执行成功时，停止执行右边的命令；只有当左边的命令执行失败时，才执行右边的命令。</p>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>command connector</tag>
      </tags>
  </entry>
  <entry>
    <title>shell的几种循环语法</title>
    <url>/2021/10/10/linux_shell_loop/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1697043&auto=1&height=32"></iframe></div>

<h1 id="1-shell的几种循环语法间的差异"><a href="#1-shell的几种循环语法间的差异" class="headerlink" title="1. shell的几种循环语法间的差异"></a>1. shell的几种循环语法间的差异</h1><h2 id="1-1-for-loop"><a href="#1-1-for-loop" class="headerlink" title="1.1. for-loop"></a>1.1. for-loop</h2><ol>
<li><code>for i in $(cat file.txt);do echo $i; done</code></li>
</ol>
<ul>
<li>for循环每次都是以空格&#x2F;制表符为分割符输出，所以i变量不是一整行内容，而是单个单元格的内容。想要获取一整行内容，可以先将空格换成别的字符，输出时再替换回来。比如<code>for i in $(sed &#39;s/\t/#/g&#39; file.txt); do echo $i |sed &#39;s/#/\t/g&#39;; done</code></li>
<li>【更耗内存】cat会一次性把file.txt所有内容输入到内存中；</li>
</ul>
<h2 id="1-2-while-loop"><a href="#1-2-while-loop" class="headerlink" title="1.2. while-loop"></a>1.2. while-loop</h2><ol>
<li><code>while read line; do echo $line; done &lt; file.txt</code></li>
</ol>
<ul>
<li>【更省内存】按行读取文件，读取到line变量是一整行内容。</li>
</ul>
<ol start="2">
<li><code>cat file.txt | while read line; do echo $line; done</code></li>
</ol>
<ul>
<li>【更耗内存】cat会一次性把file.txt所有内容输入到内存中；<br>因为管道|的使用，while read line在子shell中按行调用，line变量也是一整行内容。<br>这个和多线程控制脚本batch_run.sh冲突。</li>
</ul>
<h1 id="2-循环语法常用命令符号"><a href="#2-循环语法常用命令符号" class="headerlink" title="2. 循环语法常用命令符号"></a>2. 循环语法常用命令符号</h1><h2 id="2-1-amp-amp"><a href="#2-1-amp-amp" class="headerlink" title="2.1. &amp;&amp; ;"></a>2.1. &amp;&amp; ;</h2><p>一行for&#x2F;while循环中，执行多条命令的代码常写成这种形式：<code>for i in $(cat file.txt);do grep $i sum.txt &amp;&amp; echo $i; j=$i+3;done</code>。</p>
<p>包含了三条命令：</p>
<ul>
<li><code>grep $i sum.txt</code></li>
<li><code>break</code></li>
<li><code>echo $i</code></li>
</ul>
<p>其中<code>grep $i sum.txt</code>和<code>echo $i</code>以<code>&amp;&amp;</code>相连，<code>j=$i+3</code>与其他两条命令以<code>;</code>相连。</p>
<p><code>&amp;&amp;</code>和<code>;</code>都是用于连接同一行的两条命令的；代表前一条命令执行完再接着执行下一条命令；区别在于<code>&amp;&amp;</code>需要上一条命令执行成功才执行下一条命令；<code>;</code>则只是命令分隔符，上一条命令执行成功与否不影响下一条命令的执行。</p>
<p>再多介绍一个命令符<code>||</code>，当用<code>||</code>连接两条命令时，表示前一条命令执行成功时，停止执行后面的命令；只有当前一条命令执行失败时，才执行后一条命令。</p>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>loop</tag>
        <tag>for</tag>
        <tag>while</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维命令 —— top</title>
    <url>/2022/05/02/linux_shell_top/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=283093&auto=1&height=32"></iframe></div>

<p><code>top</code> 用于交互式监控Linux上动态实时进程，按线程数从大到小排序。</p>
<h1 id="1-top的输出"><a href="#1-top的输出" class="headerlink" title="1. top的输出"></a>1. top的输出</h1><p>在shell终端输入<code>top</code>回车，就可以查看许多系统运行的实时信息。如下图所示：</p>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/linux_command.top.default.jpg?raw=true" width=90% title="top默认输出示例" align=center/>

<p><strong><p align="center">Figure 1. top默认输出示例</p></strong></p>
<p>top的默认输出包含两个区域：水平信息的汇总区（红框部分）和垂直信息的任务区（蓝框部分）。汇总区显示有关进程和资源使用情况的统计信息，而任务区显示当前正在运行的所有进程的列表。</p>
<p>下面一一说明各个参数的含义：</p>
<h2 id="1-1-汇总区"><a href="#1-1-汇总区" class="headerlink" title="1.1. 汇总区"></a>1.1. 汇总区</h2><p>汇总区共有5行。</p>
<ol>
<li>第一行：任务队列信息。同<code>uptime</code>命令输出一致。</li>
</ol>
<table>
<thead>
<tr>
<th>显示</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>top - 15:30:36</td>
<td>系统当前时间(system time)</td>
</tr>
<tr>
<td>up 29 days, 54 min</td>
<td>系统运行时长(uptime)</td>
</tr>
<tr>
<td>7 users</td>
<td>当前登录的用户&#x2F;会话数量(user sessions)</td>
</tr>
<tr>
<td>load average: 4.92, 4.90, 4.96</td>
<td>系统平均负载，即任务队列的平均长度。三个数值分别为1min，5min，15min前到现在的平均值</td>
</tr>
</tbody></table>
<ol start="2">
<li>第二行：任务进程信息 Tasks</li>
</ol>
<table>
<thead>
<tr>
<th>显示</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>498 total</td>
<td>进程总数</td>
</tr>
<tr>
<td>3 running</td>
<td>正在运行的进程数</td>
</tr>
<tr>
<td>316 sleeping</td>
<td>睡眠状态的进程数</td>
</tr>
<tr>
<td>0 stopped</td>
<td>停止状态的进程数</td>
</tr>
<tr>
<td>0 zombie</td>
<td>僵尸状态的进程数</td>
</tr>
</tbody></table>
<ol start="3">
<li>第三行：CPU信息 %Cpu(s)。如果有多个CPU，可能会有多行，每行单独显示一个CPU。</li>
</ol>
<table>
<thead>
<tr>
<th>显示</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>6.1 us</td>
<td>用户空间占用CPU百分比</td>
</tr>
<tr>
<td>0.2 sy</td>
<td>内核空间占用CPU百分比</td>
</tr>
<tr>
<td>0.0 ni</td>
<td>用户进程空间内改变过优先级的进程占用CPU百分比</td>
</tr>
<tr>
<td>93.7 id</td>
<td>空闲CPU百分比</td>
</tr>
<tr>
<td>0.0 wa</td>
<td>等待输入输出的CPU时间百分比</td>
</tr>
<tr>
<td>0.0 hi</td>
<td>硬件CPU中断占用百分比</td>
</tr>
<tr>
<td>0.0 si</td>
<td>软中断占用百分比</td>
</tr>
<tr>
<td>0.0 st</td>
<td>虚拟机占用百分比</td>
</tr>
</tbody></table>
<ol start="4">
<li>第四行：内存信息 KiB Mem</li>
</ol>
<table>
<thead>
<tr>
<th>显示</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>33012627+total</td>
<td>物理内存总量</td>
</tr>
<tr>
<td>93989232 free</td>
<td>空闲内存总量</td>
</tr>
<tr>
<td>27405860 used</td>
<td>使用的物理内存总量</td>
</tr>
<tr>
<td>20873120+buff&#x2F;cache</td>
<td>用作内核缓存的内存量</td>
</tr>
</tbody></table>
<ol start="5">
<li>第五行：交换区信息 KiB Swap</li>
</ol>
<table>
<thead>
<tr>
<th>显示</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>63998972 total</td>
<td>交换区总量</td>
</tr>
<tr>
<td>63280912 free</td>
<td>空闲交换区总量</td>
</tr>
<tr>
<td>718060 used</td>
<td>使用的交换区总量</td>
</tr>
<tr>
<td>30034761+avail Mem</td>
<td>缓冲的交换区总量。内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小,相应的内存再次被换出时可不必再对交换区写入</td>
</tr>
</tbody></table>
<h2 id="1-2-任务区"><a href="#1-2-任务区" class="headerlink" title="1.2. 任务区"></a>1.2. 任务区</h2><p>任务区每行代表一个进程的信息。</p>
<p>这里把每一列的含义列在这里：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>PID</td>
<td>进程id，即标识进程的唯一的身份证号</td>
</tr>
<tr>
<td>2</td>
<td>PPID</td>
<td>父进程id</td>
</tr>
<tr>
<td>3</td>
<td>RUSER</td>
<td>真实用户名Real user name</td>
</tr>
<tr>
<td>4</td>
<td>UID</td>
<td>进程所有者的用户id</td>
</tr>
<tr>
<td>5</td>
<td>USER</td>
<td>进程所有者的用户名</td>
</tr>
<tr>
<td>6</td>
<td>GROUP</td>
<td>进程所有者的组名</td>
</tr>
<tr>
<td>7</td>
<td>TTY</td>
<td>启动进程的终端名。不是从终端启动的进程则显示为 ?</td>
</tr>
<tr>
<td>8</td>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>9</td>
<td>NI</td>
<td>nice值。负值表示高优先级，正值表示低优先级</td>
</tr>
<tr>
<td>10</td>
<td>P</td>
<td>最后使用的CPU，仅在多CPU环境下有意义</td>
</tr>
<tr>
<td>11</td>
<td>%CPU</td>
<td>上次更新到现在的CPU时间占用百分比</td>
</tr>
<tr>
<td>12</td>
<td>TIME</td>
<td>进程使用的CPU时间总计，单位秒</td>
</tr>
<tr>
<td>13</td>
<td>TIME+</td>
<td>进程使用的CPU时间总计，单位1&#x2F;100秒</td>
</tr>
<tr>
<td>14</td>
<td>%MEM</td>
<td>进程使用的物理内存百分比</td>
</tr>
<tr>
<td>15</td>
<td>VIRT</td>
<td>进程使用的虚拟内存总量，单位kb。VIRT&#x3D;SWAP+RES</td>
</tr>
<tr>
<td>16</td>
<td>SWAP</td>
<td>进程使用的虚拟内存中，被换出的大小，单位kb。</td>
</tr>
<tr>
<td>17</td>
<td>RES</td>
<td>进程使用的、未被换出的物理内存大小，单位kb。RES&#x3D;CODE+DATA</td>
</tr>
<tr>
<td>18</td>
<td>CODE</td>
<td>可执行代码占用的物理内存大小，单位kb</td>
</tr>
<tr>
<td>19</td>
<td>DATA</td>
<td>可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</td>
</tr>
<tr>
<td>20</td>
<td>SHR</td>
<td>共享内存大小，单位kb</td>
</tr>
<tr>
<td>21</td>
<td>nFLT</td>
<td>页面错误次数</td>
</tr>
<tr>
<td>22</td>
<td>nDRT</td>
<td>最后一次写入到现在，被修改过的页面数。</td>
</tr>
<tr>
<td>23</td>
<td>S</td>
<td>进程状态(D&#x3D;不可中断的睡眠状态,R&#x3D;运行,S&#x3D;睡眠,T&#x3D;跟踪&#x2F;停止,Z&#x3D;僵尸进程)</td>
</tr>
<tr>
<td>24</td>
<td>COMMAND</td>
<td>命令名&#x2F;命令行</td>
</tr>
<tr>
<td>25</td>
<td>WCHAN</td>
<td>若该进程在睡眠，则显示睡眠中的系统函数名</td>
</tr>
<tr>
<td>26</td>
<td>Flags</td>
<td>任务标志，参考 sched.h</td>
</tr>
</tbody></table>
<h1 id="2-top的交互命令"><a href="#2-top的交互命令" class="headerlink" title="2. top的交互命令"></a>2. top的交互命令</h1><p>当使用<code>top</code>命令显示汇总区和任务区后，还可以使用交互命令进行特定显示。</p>
<h2 id="2-1-常用交互命令"><a href="#2-1-常用交互命令" class="headerlink" title="2.1. 常用交互命令"></a>2.1. 常用交互命令</h2><ol>
<li>q：退出程序</li>
</ol>
<ul>
<li>要退出程序，可以按键盘上的“q”。</li>
</ul>
<ol start="2">
<li>上下箭头键&#x2F;PgUp和PgDn键：任务区的翻页</li>
<li>f&#x2F;F：字段&#x2F;列管理</li>
</ol>
<ul>
<li>默认情况下任务区仅显示部分字段&#x2F;列： PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 。</li>
<li>通过 f&#x2F;F 键可以显示任务区所有列的列表，被激活的字段会标记星号(*)并粗体显示。</li>
<li>字段&#x2F;列的添加或删除：上下箭头键来移动到字段，空格键进行选中或去粗选中。</li>
<li>q退出界面。</li>
</ul>
<ol start="4">
<li>h或者?：显示交互命令的帮助界面</li>
<li>k：终止一个进程</li>
</ol>
<ul>
<li>系统将提示输入需要终止的进程PID，以及需要发送给该进程什么样的信号。</li>
<li>一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。</li>
</ul>
<ol start="6">
<li>u：显示特定用户的进程</li>
</ol>
<ul>
<li>系统将提示输入用户名(留空代表所有用户)，回车后即可显示指定用户的进程。</li>
</ul>
<ol start="7">
<li>r：即renice，改变一个进程的优先级别(NI值)</li>
</ol>
<ul>
<li>系统提示用户输入需要改变的进程PID(默认是第一个PID进程)，然后提示输入需要改变的进程优先级值(NI值，一般修改前为0)，在已有NI值上加上这个输入值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。</li>
<li>试了下，输入正值(优先级降低)可以生效，输入负值(优先级升高)显示Permission denied。</li>
</ul>
<ol start="8">
<li>s：改变两次刷新之间的延迟时间</li>
</ol>
<ul>
<li>系统将提示用户输入新的时间，单位为秒(s)。如果有小数，就换算成毫秒(ms)。输入0值则系统将不断刷新，默认值是3s。</li>
<li>需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。</li>
</ul>
<ol start="9">
<li>o或者O：激活流程过滤</li>
</ol>
<ul>
<li>系统会提示输入过滤器表达式，回车后只显示符合表达式的进程。</li>
<li>过滤器表达式是指定属性和值之间关系的语句。示例：<code>COMMAND=getty: 过滤 COMMAND 属性中包含“getty”的进程</code>,<code>!COMMAND=getty: 过滤 COMMAND 属性中没有“getty”的进程</code>,<code>%CPU&gt;3.0：过滤 CPU 使用率超过 3% 的进程</code>。</li>
<li>清除添加的任何过滤器，按”&#x3D;”。</li>
</ul>
<ol start="10">
<li>W：保存当前设置到<code>~/.toprc</code>设置文件中</li>
</ol>
<ul>
<li>如果对top的输出做了任何更改，可以将当前设置写入<code>~/.toprc</code>文件中以供以后使用。</li>
</ul>
<h2 id="2-2-切换显示内容"><a href="#2-2-切换显示内容" class="headerlink" title="2.2. 切换显示内容"></a>2.2. 切换显示内容</h2><ol>
<li>l：切换显示平均负载和启动时间信息(汇总区第一行)。</li>
<li>t：切换显示进程和CPU状态信息(汇总区第二、三行)，共四种视图。  </li>
<li>m：切换显示内存信息(汇总区第四、五行)，共四种视图。</li>
<li>c：切换显示命令名称和绝对路径的完整命令行。 </li>
<li>z：以红色突出显示正在运行的进程的开关。 </li>
<li>i：忽略空闲，睡眠和僵死进程的开关。</li>
<li>R：任务区默认降序排列，切换到升序排列的开关。</li>
<li>S：切换累计时间模式的开关。 </li>
<li>1：数字1为切换 汇总区第三行CPU信息的两种显示方式，总CPUs信息或者单个CPU信息。</li>
</ol>
<ul>
<li>也可以用这个方式确定服务器的逻辑CPU数量。</li>
<li>但当系统的CPU数量过多(比如超过36)无法显示全部逻辑CPU信息，还没找到怎么翻页。</li>
<li>所以最好还是用<code>cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</code>命令查看当前系统的逻辑CPU数量。</li>
</ul>
<ol start="10">
<li>H：任务区的进程显示切换为线程显示。</li>
<li>V：在正常显示和父子级层次结构显示间切换。</li>
</ol>
<h2 id="2-3-排序任务区"><a href="#2-3-排序任务区" class="headerlink" title="2.3. 排序任务区"></a>2.3. 排序任务区</h2><ol>
<li>M：根据驻留内存大小排序任务区。 </li>
<li>P：根据CPU利用率排序任务区。 </li>
<li>T：根据运行累计时间排序任务区。</li>
<li>N：根据进程ID排序任务区。</li>
</ol>
<h1 id="3-top的常用参数"><a href="#3-top的常用参数" class="headerlink" title="3. top的常用参数"></a>3. top的常用参数</h1><p>top命令的常用参数中许多都可以在交互式命令中实现。</p>
<p><code>top</code>命令的常用参数：top [-] [d] [p] [q] [c] [C] [S] [s] [n]</p>
<ol>
<li>-d 5：延迟时间，指定每两次屏幕信息刷新之间的时间间隔为5秒。 </li>
<li>-p 51524：通过指定进程ID(PID)来仅仅监控某个进程的状态，可用多个-p PID来指定多个进程ID。 </li>
<li>-u username：显示特定用户的进程。</li>
<li>-q：该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。 </li>
<li>-S：打开累计时间模式。</li>
<li>-s：打开安全操作模式。安全模式下用户无法更改和杀死任务，这将避免交互命令所带来的潜在危险。 </li>
<li>-i：使top不显示任何闲置或者僵死进程。 </li>
<li>-c：显示绝对路径命令行而不只是显示命令名。</li>
<li>-o %CPU：任务区按CPU使用率对进程进行降序排列显示。除了CPU使用率，还支持所有其他属性值。</li>
<li>-b：批处理模式。批处理模式程序基本上允许您将 top 命令输出结果发送到文件或其他程序。它将主要用于编写脚本和故障排除。</li>
<li>-n 5：5个循环显示后自动退出top界面。</li>
</ol>
<h1 id="4-top的应用"><a href="#4-top的应用" class="headerlink" title="4. top的应用"></a>4. top的应用</h1><p>top常用的运维应用案例</p>
<h2 id="4-1-通过平均负载-load-average-评估系统运行状态"><a href="#4-1-通过平均负载-load-average-评估系统运行状态" class="headerlink" title="4.1. 通过平均负载(load average)评估系统运行状态"></a>4.1. 通过平均负载(load average)评估系统运行状态</h2><ol>
<li>平均负载(load average)</li>
</ol>
<ul>
<li>平均负载是指系统正在执行的计算工作占系统计算资源的比例。</li>
<li>完全空闲的计算机的平均负载为 0，使用或等待 CPU 资源的每个正在运行的进程都会在平均负载上加 1。</li>
<li>单CPU情况下，0代表空载，1代表满载，超过1即超载。</li>
<li>单CPU情况下，良好的运行状况期望是平均负载在0-1之间，或不要超过1太多。</li>
</ul>
<ol start="2">
<li>查看平均负载</li>
</ol>
<ul>
<li><code>top</code>命令的汇总区的第一行中load average显示的三个数字即为1min，5min，15min前到现在的平均负载。这里的平均负载是所有CPU的总平均，还要根据CPU数量来计算单CPU平均负载。</li>
</ul>
<ol start="3">
<li>查看逻辑CPU数量(processor数量)</li>
</ol>
<ul>
<li><code>cat /proc/cpuinfo| grep &quot;processor&quot;| wc -l</code>可获得当前系统的逻辑CPU数量</li>
<li><code>lscpu</code>列出的CPU(s)信息也是逻辑CPU数量</li>
</ul>
<ol start="4">
<li>计算单CPU平均负载，评估系统运行现状</li>
</ol>
<ul>
<li>假设<code>top</code>命令中平均负载值为54，系统CPU数量为36，单个CPU的平均负载为1.5(&#x3D;54&#x2F;24)，代表系统过载率为50%(&#x3D;54&#x2F;36-1)。</li>
<li>假设<code>top</code>命令中平均负载值为18，系统CPU数量为36，单个CPU的平均负载为0.5(&#x3D;18&#x2F;24)，代表系统空闲率为50%(&#x3D;1-18&#x2F;36)。</li>
</ul>
<p>即达到，可根据<code>top</code>命令的平均负载和CPU数量快速判断系统运行状态。</p>
<h1 id="5-references"><a href="#5-references" class="headerlink" title="5. references"></a>5. references</h1><ol>
<li>top的manual：<a href="https://man7.org/linux/man-pages/man1/top.1.html">https://man7.org/linux/man-pages/man1/top.1.html</a></li>
<li>top命令指南：<a href="https://www.booleanworld.com/guide-linux-top-command/">https://www.booleanworld.com/guide-linux-top-command/</a></li>
<li>博客：top输出详解：<a href="https://www.jianshu.com/p/af584c5a79f2">https://www.jianshu.com/p/af584c5a79f2</a></li>
<li>博客：平均负载：<a href="https://www.howtogeek.com/194642/understanding-the-load-average-on-linux-and-other-unix-like-systems/">https://www.howtogeek.com/194642/understanding-the-load-average-on-linux-and-other-unix-like-systems/</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>linux</category>
        <category>operation and maintenance</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>运维</tag>
        <tag>top</tag>
        <tag>load average</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux系统中替换文本换行符</title>
    <url>/2021/10/10/linux_text.processing_replace.line.separator/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1697043&auto=1&height=32"></iframe></div>

<h1 id="替换换行符-x2F-多行变单行的几种方法"><a href="#替换换行符-x2F-多行变单行的几种方法" class="headerlink" title="替换换行符&#x2F;多行变单行的几种方法"></a>替换换行符&#x2F;多行变单行的几种方法</h1><ol>
<li><code>cat file.txt | xargs echo</code> #用xargs为echo传入参数，默认是把换行符替换成空格。【推荐】</li>
<li><code>cat file.txt | tr &#39;\n&#39; &#39; &#39;</code> #用tr把换行符替换成空格。【推荐】</li>
<li><code>cat file.txt | paste -sd &quot; &quot;</code> #用paste替换；-s是一次处理文件的所有行，而非并行处理每一行；-d指定分割符。</li>
<li><code>sed &#39;:a;N;s/\n/ /g;ta&#39; file.txt</code> #用sed处理；sed按行处理所以每次处理会自动添加换行符，<code>:a</code>在代码开始处设置标记a，代码执行结尾处通过跳转命令<code>ta</code>重新跳转到标号a处，重新执行代码，递归每行；N表示读入下一行。【很慢】</li>
<li><code>awk &#39;ORS=&quot; &quot;&#39; file.txt |head -c -1</code> #用awk处理；ORS(Output Record Separator)设置输出分隔符，把换行符换成空格。head -c -1代表截取文件除了最后一个字符的字符，用于去掉文本末多的分隔符，根据情况使用。</li>
<li><code>awk BEGIN&#123;RS=EOF&#125;&#39;&#123;gsub(/\n/,&quot; &quot;);print&#125;&#39; file.txt</code> #用awk处理，将RS(record separator)设置成EOF(end of file)，即将文件视为一个记录；再通过gsub函数将换行符\n替换成空格。</li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>linux</category>
        <category>text processing</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>line separator</tag>
        <tag>xargs</tag>
        <tag>tr</tag>
        <tag>paste</tag>
        <tag>sed</tag>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组注释（三）：基因功能注释</title>
    <url>/2021/05/17/omics_genome.annotation_function/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1842025914&auto=1&height=32"></iframe></div>


<p>基因功能的注释依赖于上一步的基因结构预测，根据预测结果从基因组上提取翻译后的<strong>蛋白序列</strong>和主流的数据库进行比对，完成功能注释。(有些也支持用DNA序列做功能注释的，但比较少。)</p>
<p>比较推荐的方案是：eggNOG-mapper网页注释和PANNZER2网页注释，如果有余力再加上interpro的本地注释。</p>
<p>功能注释的一般流程：1.选择数据库并下载，2.构建blastp索引，3.用blastp比对蛋白序列到数据库，4.结果整理。</p>
<p>有些软件集成了数据库和功能注释的多个流程，甚至提供服务器用于网页版注释，例如eggNOG-mapper和interproscan分别集成了eggNOG和interpro数据库，PANNZER2使用最新的UniProt数据库实现网页注释。</p>
<h1 id="1-数据库概述"><a href="#1-数据库概述" class="headerlink" title="1. 数据库概述"></a>1. 数据库概述</h1><p>根据数据库中已知编码基因的注释信息（包括motif、domain），基于同源比对，对基因中的模序和结构域、新基因编码的蛋白质功能、所参与的信号传导通路和代谢途径等的预测。基因组注释内容还可涉及蛋白激酶、病原与宿主互作、致病毒力因子预测、抗性基因等。<br>常用数据库：</p>
<ul>
<li><p>Nr：NCBI官方非冗余蛋白数据库，包括PDB, Swiss-Prot, PIR, PRF; 如果要用DNA序列，就是nt库。</p>
</li>
<li><p>UniProt：分为两部分。Swiss-Prot是UniProt数据库中经过人工校正的高质量蛋白数据库，蛋白序列得到实验的验证。TrEBL是UniProt数据库中未经过人工校正、机器自动注释的蛋白数据库。</p>
</li>
<li><p>eggNOG：EMBL创建，是对NCBI的COG数据库的拓展，提供了不同分类水平蛋白的直系同源分组（Orthologous Groups，OG）。</p>
</li>
<li><p>InterPro：EBI开发的一个整合的蛋白家族功能注释数据库，包括Gene3D、CDD、Pfam等10几个数据库。</p>
</li>
<li><p>Pfam: 蛋白结构域注释的分类系统。</p>
</li>
<li><p>GO: 基因本体论注释数据库。</p>
</li>
<li><p>KEGG: 代谢通路注释数据库。</p>
</li>
</ul>
<p>数据库的下载非常耗时，不管是eggnog还是interproscan，linux下几十KB&#x2F;s，window下几百KB&#x2F;s(需科学上网)，耗时长度以天计算，可以尝试先在window系统下载，再转移到linux下。</p>
<h2 id="1-1-Nr-x2F-Nt数据库"><a href="#1-1-Nr-x2F-Nt数据库" class="headerlink" title="1.1. Nr&#x2F;Nt数据库"></a>1.1. Nr&#x2F;Nt数据库</h2><p><a href="ftp://ftp.ncbi.nlm.nih.gov/blast/db/FASTA/nr.gz">nr数据库</a>；<br><a href="ftp://ftp.ncbi.nlm.nih.gov/blast/db/FASTA/nt.gz">nt数据库</a>；</p>
<h2 id="1-2-UniProt数据库（Swiss-Prot和TrEMBL）"><a href="#1-2-UniProt数据库（Swiss-Prot和TrEMBL）" class="headerlink" title="1.2. UniProt数据库（Swiss-Prot和TrEMBL）"></a>1.2. UniProt数据库（Swiss-Prot和TrEMBL）</h2><p>UniProt数据库包括人工校正的高质量数据库Swiss-Prot和软件自动注释的TrEMBL数据库。</p>
<p><a href="ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_sprot.fasta.gz">Swiss-Prot数据库</a>：高质量，手工注释，非冗余的蛋白质序列数据库。非常可靠。</p>
<p><a href="ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_trembl.fasta.gz">TrEMBL数据库</a>：自动注释的蛋白质序列数据库。</p>
<p>UniProt将完整数据库分类拆分成几个<a href="ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/taxonomic_divisions/">子库</a>。包括古菌，真菌，植物，人，哺乳动物，脊椎动物，无脊椎动物，啮齿动物等。</p>
<h2 id="1-3-GO数据库"><a href="#1-3-GO数据库" class="headerlink" title="1.3. GO数据库"></a>1.3. GO数据库</h2><p>[GO数据库](<a href="http://geneontology.org/docs/download-ontology/%EF%BC%89">http://geneontology.org/docs/download-ontology/）</a></p>
<h2 id="1-4-KEGG数据库"><a href="#1-4-KEGG数据库" class="headerlink" title="1.4. KEGG数据库"></a>1.4. KEGG数据库</h2><p>KEGG(Kyoto Encyclopedia of Genes and Genomes)京都基因和基因组百科全书，是研究Pathway代谢通路最主要的数据库，整合了基因组、化学、系统及疾病和健康的信息。</p>
<h2 id="1-5-COG直系同源蛋白数据库"><a href="#1-5-COG直系同源蛋白数据库" class="headerlink" title="1.5. COG直系同源蛋白数据库"></a>1.5. COG直系同源蛋白数据库</h2><p><a href="ftp://ftp.ncbi.nlm.nih.gov/pub/COG/COG2014/data/">COG数据库</a>:NCBI开发的用于同源蛋白注释的数据库。<br>fun2003-2014.tab是COG的分类信息，将COG的功能分为26个类别，每个类别用一个字母表示。<br>cognames2003-2014.tab是COG的详细信息，包括编号，对应的分类，功能描述等。<br>cog2003-2014.csv是蛋白和COG对应关系。<br>prot2003-2014.fa.gz是fa格式的蛋白序列和注释信息。</p>
<h2 id="1-6-KOG数据库"><a href="#1-6-KOG数据库" class="headerlink" title="1.6. KOG数据库"></a>1.6. KOG数据库</h2><p>KOG（Clusters of orthologous groups for eukaryotic complete genomes）真核生物蛋白相邻类的聚簇。构成每个KOG的蛋白都是被假定来自一个祖先蛋白，要么是orthologs，要么是paralogs。orthologs是指来自不同物种的由垂直家系（物种形成）进化而来的蛋白，并且保留与原始蛋白相同的功能；paralogs是指在一定物种中来源于基因复制的蛋白，可能会进化成新的与原来有关的功能。<br><a href="ftp://ftp.ncbi.nlm.nih.gov/pub/COG/KOG/kyva">KOG数据库</a></p>
<h2 id="1-7-eggNOG数据库"><a href="#1-7-eggNOG数据库" class="headerlink" title="1.7. eggNOG数据库"></a>1.7. eggNOG数据库</h2><p>eggNOG（evolutionary genealogy of genes：non-supervised orthologous groups）由EMBL创建，是对NCBI的COG数据库的拓展，提供了不同分类水平蛋白的直系同源分组（Orthologous Groups，OG），包括真核生物，原核生物，病毒的信息。拓展了COG的分类，采用无监督聚类算法在全基因组范围内推导基因功能，更适合谱系特征基因的分析。</p>
<p><a href="http://eggnog5.embl.de/">eggNOG数据库</a>中，e5.proteomes.faa是所有的蛋白组序列，e5.taxid_info.tsv是taxid对应的物种名及完整的谱系信息，e5.og_annotations.tsv是所有NOG group信息（第一列为Taxid，第二列为NOG groups，第三列为COG归属，第四列为Function）。per_tax_level下不同taxonomy level的members.tsv文件分别是相应level的蛋白序列id和NOG group的对应关系（第一列taxid，第二列NOG groups，第三列为该NOG group所包含的蛋白序列数目，第四列为该NOG group所包含的物种数目，第五列是该NOG group所包含的蛋白序列id，第六列是该NOG group所包含的物种taxid。</p>
<h2 id="1-8-pfam数据库"><a href="#1-8-pfam数据库" class="headerlink" title="1.8. pfam数据库"></a>1.8. pfam数据库</h2><p><a href="http://pfam.xfam.org/">pfam数据库</a>是蛋白质家族数据库，根据多序列比对结果和隐马尔科夫模型，将蛋白分成不同家族。</p>
<h2 id="1-9-string数据库"><a href="#1-9-string数据库" class="headerlink" title="1.9. string数据库"></a>1.9. string数据库</h2><p><a href="https://string-db.org/">string数据库</a>。<br>搜寻已知蛋白质和预测蛋白质之间的相关关系的系统，包括蛋白质之间的物理作用和间接的功能相关性。基于染色体临近，系统进化谱，基因融合和基因芯片数据等计算基因或蛋白的共表达。<br>包括动物转录因子数据AnimalTFDB3.0，植物转录因子数据<a href="http://plntfdb.bio.uni-potsdam.de/v3.0/">PlnTFDB</a>，真菌转录因子数据库<a href="http://ftfd.snu.ac.kr/index.php?a=view">Fungal TFDB</a>。</p>
<p>植物转录因子数据库收录了大部分植物模式物种共20个种的84个转录因子家族，包含28193 protein models，26184 distinct protein sequences，支持在线blast和本地blast。<br>分析工具：<a href="http://itak.feilab.net/cgi-bin/itak/index.cgi">iTAK</a>，软件内置了PlantTFDB的数据库，可直接用于预测植物转录因子。<br>结果在classification.txt文件中。</p>
<h1 id="2-基因功能注释"><a href="#2-基因功能注释" class="headerlink" title="2. 基因功能注释"></a>2. 基因功能注释</h1><p>notes: 注释分析中要保证蛋白序列中没有代表氨基酸字符以外的字符，比如说有些软件会把最后一个终止密码子翻译成”.”或者”*”，需要删除。</p>
<h2 id="2-1-下载数据库手动注释–以Uniprot为例"><a href="#2-1-下载数据库手动注释–以Uniprot为例" class="headerlink" title="2.1. 下载数据库手动注释–以Uniprot为例"></a>2.1. 下载数据库手动注释–以Uniprot为例</h2><h3 id="2-1-1-下载数据库"><a href="#2-1-1-下载数据库" class="headerlink" title="2.1.1. 下载数据库"></a>2.1.1. 下载数据库</h3><p>这里以Uniprot为例，下载其他数据库后可用同样方法进行手动注释。</p>
<p>可以uniprot_sprot和uniprot_trembl的植物数据库合并在一起。<br><code>wget ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/taxonomic_divisions/uniprot_sprot_plants.dat.gz #</code>;<br><code>wget ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/taxonomic_divisions/uniprot_trembl_plants.dat.gz # 11.5G</code>;<br><code>zcat uniprot_sprot_plants.dat.gz uniprot_trembl_plants.dat.gz &gt; uniprot_plants.dat</code>;</p>
<p>转换格式：<br>用python的SeqIO模块转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Bio <span class="keyword">import</span> SeqIO</span><br><span class="line">count = SeqIO.convert(<span class="string">&quot;uniprot_plants.dat&quot;</span>,<span class="string">&quot;swiss&quot;</span>,<span class="string">&quot;uniprot_plants.fa&quot;</span>,<span class="string">&quot;fasta&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Converted %i records&quot;</span> % count)</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-构建blastp索引"><a href="#2-1-2-构建blastp索引" class="headerlink" title="2.1.2. 构建blastp索引"></a>2.1.2. 构建blastp索引</h3><p><code>makeblastdb -in uniprot_plants.fasta -dbtype prot -title uniprot_plants -parse_seqids</code><br>或者更快的<br><code>diamond makedb --in uniprot_plants.fasta -d uniprot_plants</code></p>
<h3 id="2-1-3-用blastp比对蛋白序列protein-fa和数据库uniprot-plants"><a href="#2-1-3-用blastp比对蛋白序列protein-fa和数据库uniprot-plants" class="headerlink" title="2.1.3. 用blastp比对蛋白序列protein.fa和数据库uniprot_plants"></a>2.1.3. 用blastp比对蛋白序列protein.fa和数据库uniprot_plants</h3><p><code>blastp -query protein.fa -out uniprot_plants.xml -db uniprot_plants.fasta -evalue 1e-5 -outfmt 6 -num_threads 24 &amp;</code><br>或者更快的<br><code>diamond blastp -d uniprot_plants.dmnd -q proteins.fasta --evalue 1e-5 &gt; blastp.outfmt6</code></p>
<h3 id="2-1-4-比对结果中筛选每个query的最佳subject"><a href="#2-1-4-比对结果中筛选每个query的最佳subject" class="headerlink" title="2.1.4. 比对结果中筛选每个query的最佳subject"></a>2.1.4. 比对结果中筛选每个query的最佳subject</h3><p>jcvi可用conda安装<br><code>python -m jcvi.formats.blast best -n 1 blastp.outfmt6</code><br>生成blastp.outfmt6.best</p>
<h3 id="2-1-5-使用add-annotation-from-dat-py根据blastp输出从dat提取GO-x2F-KEGG-x2F-同源基因"><a href="#2-1-5-使用add-annotation-from-dat-py根据blastp输出从dat提取GO-x2F-KEGG-x2F-同源基因" class="headerlink" title="2.1.5. 使用add_annotation_from_dat.py根据blastp输出从dat提取GO&#x2F;KEGG&#x2F;同源基因"></a>2.1.5. 使用add_annotation_from_dat.py根据blastp输出从dat提取GO&#x2F;KEGG&#x2F;同源基因</h3><p>python add_annotation_from_dat.py blastp.outfmt6.best uniprot_plants.dat<br>生成swiss_annotation.tsv文件；包含以下几列。</p>
<ul>
<li>gene id</li>
<li>uniprot accession</li>
<li>identity</li>
<li>homology species</li>
<li>EnsemblPlants</li>
<li>GO ID</li>
<li>GO component, CC&#x2F;MF&#x2F;BP</li>
<li>evidence</li>
</ul>
<p>参考脚本<a href="https://github.com/xuzhougeng/myscripts/blob/master/annotation/add_annotation_from_dat.py">add_annotation_from_dat.py</a></p>
<h3 id="2-1-6-blast2go"><a href="#2-1-6-blast2go" class="headerlink" title="2.1.6. blast2go"></a>2.1.6. blast2go</h3><p>blast2go的功能是将blast注释结果转换成GO注释，但使用较为复杂，下载数据库耗时长，不推荐使用。<br><a href="https://www.plob.org/article/1299.html">blast2go教程</a>；<a href="https://www.jianshu.com/p/ad44b2a837c9">blast2go教程</a><br>下载数据库<br>wget <a href="ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/gene_info.gz">ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/gene_info.gz</a> #650M<br>wget <a href="ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/gene2accession.gz">ftp://ftp.ncbi.nlm.nih.gov/gene/DATA/gene2accession.gz</a> #2.3G<br>wget <a href="ftp://ftp.pir.georgetown.edu/databases/idmapping/idmapping.tb.gz">ftp://ftp.pir.georgetown.edu/databases/idmapping/idmapping.tb.gz</a> #10G<br>wget <a href="http://release.geneontology.org/2017-01-01/mysql_dumps/go_monthly-assocdb-data.gz">http://release.geneontology.org/2017-01-01/mysql_dumps/go_monthly-assocdb-data.gz</a> #6.3G</p>
<h2 id="2-2-eggnog-mapper注释"><a href="#2-2-eggnog-mapper注释" class="headerlink" title="2.2. eggnog-mapper注释"></a>2.2. eggnog-mapper注释</h2><p>eggNOG(evolutionary genealogy of genes: Non-supervised Orthologous Groups)。<br><a href="http://eggnog5.embl.de/download/emapperdb-5.0.0/">eggNOG数据库</a>是数据库，eggnog-mapper是使用eggnog数据库作为参考的注释软件或网页，<a href="http://eggnog-mapper.embl.de/">eggnog-mapper网页版</a>。</p>
<h3 id="2-2-1-eggNOG本地注释"><a href="#2-2-1-eggNOG本地注释" class="headerlink" title="2.2.1. eggNOG本地注释"></a>2.2.1. eggNOG本地注释</h3><p>下载数据库本地注释的方法：<br>在eggnog网站下载对应使用的数据库。<br><a href="http://eggnog5.embl.de/download/emapperdb-5.0.0/eggnog.db.gz">http://eggnog5.embl.de/download/emapperdb-5.0.0/eggnog.db.gz</a><br><a href="http://eggnogdb.embl.de/download/emapperdb-5.0.0/eggnog_proteins.dmnd.gz">http://eggnogdb.embl.de/download/emapperdb-5.0.0/eggnog_proteins.dmnd.gz</a><br>注释命令：<br>python2 &#x2F;home&#x2F;leon&#x2F;software&#x2F;3.Function&#x2F;eggnog-mapper.orginal&#x2F;emapper.py -i Tov.final.all.maker.transcripts.fasta -o run_egg –override  -m diamond  –cpu 80</p>
<h3 id="2-2-2-eggNOG-mapper网页版注释"><a href="#2-2-2-eggNOG-mapper网页版注释" class="headerlink" title="2.2.2. eggNOG-mapper网页版注释"></a>2.2.2. eggNOG-mapper网页版注释</h3><h4 id="2-2-2-1-注释原理"><a href="#2-2-2-1-注释原理" class="headerlink" title="2.2.2.1. 注释原理"></a>2.2.2.1. 注释原理</h4><p>注释分为三步：</p>
<ol>
<li>序列比对<br>用hmmer3对所有蛋白序列在eggNOG数据库中搜索，找到最佳匹配的HMM；再用phmmer在最佳匹配的HMM对应的一组eggNOG蛋白中进一步搜索，每条蛋白序列的最佳匹配结果以seed orthlog形式存放。<br>除了HMMER3还可选DIAMOND直接对所有eggNOG蛋白序列进行搜索，速度更快，若数据大或在eggNOG搜集的物种库中有近缘种可选择DIAMOND。</li>
<li>推测直系同源基因<br>基于预分析的eggNOG进化树数据库，提取最佳匹配seed orthlog的蛋白的一组更精细的直系同源基因，根据bit-score或E-value对结果过滤，剔除同源性不高的结果。</li>
<li>功能注释<br>用于搜索的蛋白序列对应的直系同源基因的功能描述就是最终的注释结果。比如说GO, KEGG, COG等。</li>
</ol>
<h4 id="2-2-2-2-注释"><a href="#2-2-2-2-注释" class="headerlink" title="2.2.2.2. 注释"></a>2.2.2.2. 注释</h4><p>推荐使用<a href="http://eggnog-mapper.embl.de/">eggnog-mapper网页版</a>注释，避免下载数据库的繁琐。限制10万条蛋白序列，数量超过可以切分后分开注释。</p>
<p>只需要上传氨基酸序列，点击提交；然后<strong>在收到的邮件里点击链接，开始任务</strong>即可。</p>
<h4 id="2-2-2-3-注释结果"><a href="#2-2-2-3-注释结果" class="headerlink" title="2.2.2.3. 注释结果"></a>2.2.2.3. 注释结果</h4><p>eggnog-mapper会生成五个文件:</p>
<ul>
<li>[project_name].emapper.gff: gff注释文件。</li>
<li>[project_name].emapper.orthologs: 搜索匹配到的物种和orthologs的信息。</li>
<li>[project_name].emapper.seed_orthologs: 记录每个用于搜索序列对的的最佳的OG，也就是</li>
<li>[project_name].emapper.annotations.tsv: 该文件提供了最终的注释结果。大部分需要的内容都可以通过写脚本从从提取，一共有13列。</li>
<li>[project_name].emapper.annotations.xlsx：最终注释结果，另一种格式。</li>
</ul>
<p>其中[project_name].emapper.annotations.tsv每一列对应的记录如下：</p>
<ol>
<li>query: 检索的基因名或者其他ID</li>
<li>seed_ortholog: eggNOG中最佳的蛋白匹配</li>
<li>evalue: 最佳匹配的e-value</li>
<li>score: 最佳匹配的bit-score</li>
<li>eggNOG_OGs：匹配到的eggNOG数据库里的OGs</li>
<li>max_annot_lvl：</li>
<li>COG_category：COG类别</li>
<li>Description：功能描述</li>
<li>Preferred_name: 预测的基因名，特别指的是类似AP2有一定含义的基因名，而不是- AT2G17950这类编号</li>
<li>GOs: 推测的GO的词条， 未必最新</li>
<li>EC：</li>
<li>KEGG_ko: 推测的KEGG KO词条， 未必最新</li>
<li>KEGG_Pathway：推测的KEGG通路词条</li>
<li>KEGG_Module：</li>
<li>KEGG_Reaction：</li>
<li>KEGG_rclass：</li>
<li>BRITE:</li>
<li>KEGG_TC:</li>
<li>CAZy</li>
<li>BiGG_Reaction: BiGG代谢反应的预测结果</li>
<li>PFAMs:注释到PFAM数据</li>
</ol>
<h4 id="2-2-2-4-结果整理"><a href="#2-2-2-4-结果整理" class="headerlink" title="2.2.2.4. 结果整理"></a>2.2.2.4. 结果整理</h4><ul>
<li><code>cat eggnog.web/*.emapper.annotations.tsv |sed &#39;/#.*/d&#39; |cut -f1,8,9 |awk -F&quot;\t&quot; &#39;&#123;print $1&quot;\t&quot;$3&quot;: &quot;$2&#125;&#39; |sed &#39;/-: -/d&#39;|sort -k 1.3n |uniq |sed &#39;1i\gene\teggnog.preferred.name: description&#39; &gt;eggnog.anno</code> 提取信息列：1（query），8（Description），9（Preferred name），10（GOs），12（KEGG_ko）列。然后提取1（query），8（Description），9（Preferred name）注释信息。eggnog注释是每个基因一行信息，所以eggnog.anno的行数就是注释到的基因数量。</li>
<li><code>cat eggnog.web/*.emapper.annotations.tsv |sed &#39;/#.*/d&#39; |cut -f1,10 |sed &#39;/\t-$/d&#39; |sort -k 1.3n |uniq |sed &#39;1i\gene\teggnog.go&#39; &gt;eggnog.go.anno</code> 提取信息列：1（query），10（GOs）的eggnog的GO注释信息。</li>
<li><code>cat eggnog.web/*.emapper.annotations.tsv |sed &#39;/#.*/d&#39; |cut -f1,12 |sed &#39;/\t-$/d&#39; |sort -k 1.3n |uniq |sed &#39;1i\gene\teggnog.kegg&#39; &gt;eggnog.kegg.anno</code> 提取信息列：1（query），12（KEGG_ko）的eggnog的KEGG注释信息。</li>
</ul>
<h2 id="2-3-InterProScan"><a href="#2-3-InterProScan" class="headerlink" title="2.3. InterProScan"></a>2.3. InterProScan</h2><h3 id="2-3-1-Interproscan"><a href="#2-3-1-Interproscan" class="headerlink" title="2.3.1. Interproscan"></a>2.3.1. Interproscan</h3><p>interpro是数据库，interproscan是可以使用interpro的注释软件。<br>如果序列少，可以使用<a href="http://www.ebi.ac.uk/interpro/search/sequence/">interproscan网页版</a>注释，避免下载数据库的繁琐。限制一次注释一条，长度小于40000个蛋白序列，超过可以切分后分开注释。</p>
<p>interproscan可实现多个数据库同时注释，包括：</p>
<ul>
<li>InterPro注释</li>
<li>Pfam数据库注释(可以通过hmmscan搜索pfam数据库完成)</li>
<li>PANTHER数据库注释</li>
<li>GO注释(可以基于NR和Pfam等数据库，然后BLAST2GO完成)</li>
<li>Reactome通路注释，不同于KEGG<br>还有很多数据库。</li>
</ul>
<h3 id="2-3-2-Interproscan的安装和数据库下载"><a href="#2-3-2-Interproscan的安装和数据库下载" class="headerlink" title="2.3.2. Interproscan的安装和数据库下载"></a>2.3.2. Interproscan的安装和数据库下载</h3><p>如果注释的文件比较大或者比较多，可以下载本地版注释，下载过程非常慢。根据你的linux版本和发布日期来选择最适版本，软件很大最近版大约9.1G。建议下载对应的md5文件，用 md5sum -c *.md5来检查下载的是否完全。</p>
<h4 id="2-3-2-1-Interproscan安装"><a href="#2-3-2-1-Interproscan安装" class="headerlink" title="2.3.2.1. Interproscan安装"></a>2.3.2.1. Interproscan安装</h4><p>interproscan软件地址：<a href="ftp://ftp.ebi.ac.uk/pub/software/unix/iprscan/5/">ftp://ftp.ebi.ac.uk/pub/software/unix/iprscan/5/</a>, 选择最新版本，比如5.47-82.0，则<code>wget ftp://ftp.ebi.ac.uk/pub/software/unix/iprscan/5/5.47-82.0/*</code>，版本号目录下有两个文件，一个软件的tar.gz压缩文件，一个对应的md5文件，都下下来。</p>
<h4 id="2-3-2-2-软件自带数据库"><a href="#2-3-2-2-软件自带数据库" class="headerlink" title="2.3.2.2. 软件自带数据库"></a>2.3.2.2. 软件自带数据库</h4><p>软件本身自带了很多数据库，不需要安装，5.47-82.0版本带有CDD-3.17,Coils-2.2.1,Gene3D-4.2.0,Hamap-2020_01,MobiDBLite-2.0,PANTHER-15.0,Pfam-33.1,PIRSF-3.10,PRINTS-42.0,ProSitePatterns-2019_11,ProSiteProfiles-2019_11,SFLD-4,SMART-7.1,SUPERFAMILY-1.75,TIGRFAM-15.0数据库。</p>
<h4 id="2-3-2-3-关于PANHTER数据库"><a href="#2-3-2-3-关于PANHTER数据库" class="headerlink" title="2.3.2.3. 关于PANHTER数据库"></a>2.3.2.3. 关于PANHTER数据库</h4><p>PANHTER(Protein ANalysis THrough Evolutionary Relationships) 数据库是Gene Ontology Phylogenetic Annotation Project的一部分。</p>
<ol>
<li>发现interproscan 5.47-82.0软件自带PANHTER数据库，所以不用单独下载啦。</li>
<li>若是没有带PANHTER数据库，则下载构建本地PANHTER数据库，需要下载并解压到软件安装目录下的 &#x2F;path of interproscan&#x2F;data&#x2F;。</li>
</ol>
<ul>
<li>PANHTER下载地址：<a href="ftp://ftp.ebi.ac.uk/pub/software/unix/iprscan/5/data/">ftp://ftp.ebi.ac.uk/pub/software/unix/iprscan/5/data/</a>,</li>
<li>选择最新版本，比如14.1，则<code>wget ftp://ftp.ebi.ac.uk/pub/software/unix/iprscan/5/panther-data-14.1.tar.gz*</code>，下载14.1和对应的md5文件。</li>
<li>md5验证两个文件下载完全后，tar zxf解压缩，并把PANHTER数据库放进interproscan的data目录下。</li>
</ul>
<h4 id="2-3-2-4-java和python版本检查"><a href="#2-3-2-4-java和python版本检查" class="headerlink" title="2.3.2.4. java和python版本检查"></a>2.3.2.4. java和python版本检查</h4><p>软件的运行依赖java11和python3，<code>java -version</code>和<code>python --version</code>检查版本是否正确。</p>
<h4 id="2-3-2-5-测试安装"><a href="#2-3-2-5-测试安装" class="headerlink" title="2.3.2.5. 测试安装"></a>2.3.2.5. 测试安装</h4><p>解压缩后运行 interproscan.sh 测试是否成功安装，弹出help界面就是成功安装，用测试文件运行下，<code>interproscan.sh -i test_proteins.fasta</code>，没报错则软件可正常运行。</p>
<h4 id="2-3-2-6-tips"><a href="#2-3-2-6-tips" class="headerlink" title="2.3.2.6. tips"></a>2.3.2.6. tips</h4><ul>
<li>如果本地化运行，可以把interproscan.properties文件里的<a href="precalculated.match.lookup.service.url=http://www.ebi.ac.uk/interpro/match-lookup">这行代码</a>注释掉，就不进行match.lookup检查，这个应该是更新数据库的检查。</li>
<li>如果不注释，在运行时存储interproscan数据库端网络慢时（大部分情况下）会输出一些Connection timed out和ERROR - Lookup version check failed的报错信息，但the analysis will continue to run locally.本地运行仍在继续。</li>
</ul>
<h3 id="2-3-3-Interproscan运行"><a href="#2-3-3-Interproscan运行" class="headerlink" title="2.3.3. Interproscan运行"></a>2.3.3. Interproscan运行</h3><p>常用运行参数<br><code>interproscan -i pep.fa -b out.iprscan -goterms -iprlookup -pa -dp -cpu 24</code></p>
<p>interproscan的参数：</p>
<ul>
<li><p>-i,–input 输入文件，一般要为fasta格式，注意不要带有除氨基酸符号的其他特殊符号（比如代表终止密码子的*），gene&#x2F;氨基酸的名称不能为空。</p>
</li>
<li><p>-b,–output-file-base 指定输出文件的路径和文件名，默认是输入文件的路径</p>
</li>
<li><p>-appl,–applications 指定使用Interpro中哪些数据库，默认使用全部数据库</p>
</li>
<li><p>-f,–formats 用于指定输出文件的后缀，蛋白序列默认输出TSV, XML and GFF3</p>
</li>
<li><p>-t,–seqtype 输入文件的序列类型，p为protein，n为dna&#x2F;rna，默认是p</p>
</li>
<li><p>-cpu 指定使用线程数</p>
</li>
<li><p>-goterms 打开GO注释，依赖iprlookup参数，switch on lookup of corresponding Gene Ontology annotation (IMPLIES -iprlookup option)</p>
</li>
<li><p>-iprlookup Also include lookup of corresponding InterPro annotation in the TSV and GFF3 output formats.</p>
</li>
<li><p>-pa Optional, switch on lookup of corresponding Pathway annotation (IMPLIES -iprlookup option)</p>
</li>
<li><p>-dp 关闭precalculated match lookup service，默认的是开启。根据md5值来快速检验这上传的数据是否已经被注释了，如果是已经注释了就直接出结果。</p>
</li>
</ul>
<h3 id="2-3-4-Interproscan结果解释"><a href="#2-3-4-Interproscan结果解释" class="headerlink" title="2.3.4. Interproscan结果解释"></a>2.3.4. Interproscan结果解释</h3><p>生成的out.tsv和out.gff3等是不同格式的注释文件，这里使用tsv格式。</p>
<p>tsv格式文件每一列含义：</p>
<ol>
<li>蛋白名字</li>
<li>序列MD5 disest</li>
<li>序列长度</li>
<li>所用的库（Pfam&#x2F;PANTHER&#x2F;RPINTS etc）</li>
<li>匹配的数据编号（PF00001&#x2F;PTHR00001 etc)</li>
<li>功能描述</li>
<li>起始位置</li>
<li>终止位置</li>
<li>e-value得分</li>
<li>匹配的状态T: true</li>
<li>日期</li>
<li>interPro 注释编号</li>
<li>interPro 注释描述</li>
<li>GO注释</li>
<li>Pathways 注释</li>
</ol>
<p>每行是一条蛋白序列注释到的每个数据库的每一个匹配，所以每个基因会有多行。<br>根据第四列-数据库名称来提取不同数据库的注释结果。这里提取pfam和PANTHER两个数据库的结果。</p>
<h3 id="2-3-5-Interproscan结果整理"><a href="#2-3-5-Interproscan结果整理" class="headerlink" title="2.3.5. Interproscan结果整理"></a>2.3.5. Interproscan结果整理</h3><ol>
<li>提取interpro数据库注释内容并转化成单基因单行格式<br><code>cat *.iprscan.tsv |cut -f1,12,13|grep &quot;IPR&quot;|awk &#39;&#123;print $1&quot;\t&quot;$2&quot;: &quot;$3&#125;&#39;|sort -k 1.3n|uniq |awk -F&quot;\t&quot; &#39;&#123;a[$1]=a[$1]$2&quot;; &quot;&#125;END&#123;for( i in a)&#123;print i&quot;\t&quot;a[i]&#125;&#125;&#39;|sed &quot;s/; $//g&quot; |sort -k 1.3n |sed &#39;1i\gene\tinterpro&#39; &gt;iprs.interpro.anno</code></li>
</ol>
<p>notes：</p>
<ul>
<li>注意排序和去重。</li>
<li>因为我的geneID是tg00001这种格式，只有两个字母，所以sort排序按数字从第三个<code>sort -k 1.3n</code>开始排序，可以根据不同geneID更改。</li>
<li>其中<code>awk -F&quot;\t&quot; &#39;&#123;a[$1]=a[$1]$2&quot;; &quot;&#125;END&#123;for( i in a)&#123;print i&quot;\t&quot;a[i]&#125;&#125;&#39;|sed &quot;s/; $//g&quot; |sort -k 1.3n</code>部分是单基因多行注释转化成单基因单行注释的命令。</li>
<li>用cut截取1，12，13三列是因为有些行没有12列及之后数据，直接用awk会失效。</li>
<li>用grep搜索IPR是因为直接用awk匹配第12列不能匹配完全，比如SUPERFAMILY数据库的比对就匹配不了。</li>
</ul>
<ol start="2">
<li><p>提取Pfam数据库注释结果并转化成单基因单行格式<br><code>cat *.iprscan.tsv  |awk &#39;$4 == &quot;Pfam&quot; &#123;print $1&quot;\t&quot;$5&quot;: &quot;$6&#125;&#39; |sort -k 1.3n |uniq|awk -F&quot;\t&quot; &#39;&#123;a[$1]=a[$1]$2&quot;; &quot;&#125;END&#123;for( i in a)&#123;print i&quot;\t&quot;a[i]&#125;&#125;&#39;|sed &quot;s/; $//g&quot; |sort -k 1.3n |sed &#39;1i\gene\tinterproscan.pfam&#39;&gt;iprs.pfam.anno</code></p>
</li>
<li><p>提取PANTHER数据库注释结果并转化成单基因单行格式<br><code>cat *.iprscan.tsv |awk &#39;$4 == &quot;PANTHER&quot; &#123;print $1&quot;\t&quot;$5&quot;: &quot;$6&#125;&#39;|sort -k 1.3n|uniq |awk -F&quot;\t&quot; &#39;&#123;a[$1]=a[$1]$2&quot;; &quot;&#125;END&#123;for( i in a)&#123;print i&quot;\t&quot;a[i]&#125;&#125;&#39;|sed &quot;s/; $//g&quot; |sort -k 1.3n |sed &#39;1i\gene\tinterproscan.panther&#39;&gt;iprs.panther.anno</code></p>
</li>
</ol>
<h2 id="2-4-PANNZER-Protein-ANNotation-with-Z-scoRE"><a href="#2-4-PANNZER-Protein-ANNotation-with-Z-scoRE" class="headerlink" title="2.4. PANNZER(Protein ANNotation with Z-scoRE)"></a>2.4. PANNZER(Protein ANNotation with Z-scoRE)</h2><h3 id="2-4-1-PANNZER"><a href="#2-4-1-PANNZER" class="headerlink" title="2.4.1. PANNZER"></a>2.4.1. PANNZER</h3><p>网站注释：<a href="http://ekhidna2.biocenter.helsinki.fi/sanspanz/">http://ekhidna2.biocenter.helsinki.fi/sanspanz/</a></p>
<ul>
<li>用于原核和真核蛋白序列的功能注释。</li>
<li>使用的Uniprot数据库，与数据库更新一致。</li>
<li>用于预测functional description (DE) 和 GO classes。</li>
</ul>
<p>注释速度：7万条序列4个小时。</p>
<h3 id="2-4-2-结果文件"><a href="#2-4-2-结果文件" class="headerlink" title="2.4.2. 结果文件"></a>2.4.2. 结果文件</h3><p>notes: </p>
<ul>
<li>网页版的结果，注意需要把进度条拉到最下面再复制保存文本，否则没有显示完全，ctrl+a全选只会选中已显示的内容，未显示的未被选中。</li>
<li>(20210813)今天发现不需要拉进度条这么繁琐，在网页右键另存为可以保存文本格式的结果。</li>
</ul>
<ol>
<li>*.anno.out.txt是蛋白序列的注释信息，包含六列：</li>
</ol>
<ul>
<li>qpid：序列ID；</li>
<li>type：original_DE,qseq（前两种类型是每个基因都有的）,DE,MF_ARGOT,BP_ARGOT,CC_ARGOT,EC_ARGOT等（后面的类型是注释到的基因才有的）；</li>
<li>score：匹配分数；</li>
<li>PPV：不知道是啥指标；</li>
<li>id：数字；</li>
<li>desc：功能描述；每个序列都有多行信息，没被注释到的序列只有两行第二列type分别为original_DE和qseq的基本信息。</li>
</ul>
<p>每个基因有只有一行第二列type为DE的数据，此时第六列的描述是对基因的功能描述，即我们想要的基因功能注释信息。</p>
<ol start="2">
<li>*.DE_prediction.txt是注释到DE（functional description）的序列的注释信息。<br>重要的是第一列（qpid）：基因id；第九列（desc）：DE描述信息，即注释到uniprot数据库的描述信息；第十列（genename）：基因名字。</li>
<li>*.GO_prediction.txt是注释到GO的序列的注释信息。<br>重要的是第一列（qpid）：基因id；第二列（ontology）：GO类别，BP&#x2F;MF&#x2F;CC三个类别；第三列（goid）：GO ID；第四列（desc）：GO描述信息。</li>
</ol>
<h3 id="2-4-3-结果整理"><a href="#2-4-3-结果整理" class="headerlink" title="2.4.3. 结果整理"></a>2.4.3. 结果整理</h3><ol>
<li><p><code>cat pannzer2/anno.out.txt |awk &#39;$2 == &quot;DE&quot; &#123;print $1&quot;\t&quot;$6&#125;&#39; |sort -k 1.3n |uniq |sed &#39;1i\gene\tpannzer2.uniprot&#39; &gt;pannzer2.uniprot.anno</code>把Uniprot数据库功能注释信息提取出来。</p>
</li>
<li><p><code>cat pannzer2/GO.out.txt |awk &#39;&#123;print $1&quot;\tGO:&quot;$3,$4&#125;&#39; |awk -F&quot;\t&quot; &#39;&#123;a[$1]=a[$1]$2&quot;; &quot;&#125;END&#123;for( i in a)&#123;print i&quot;\t&quot;a[i]&#125;&#125;&#39;|sed &quot;s/; $//g&quot; |sort -k 1.3n |uniq |sed &quot;1s/.*/gene\tpannzer2.go/&quot; &gt;pannzer2.go.anno</code>把Uniprot数据库的GO注释提取出来并转化成单基因单行信息。</p>
</li>
</ol>
<h2 id="2-5-Mercator4——植物基因组功能注释"><a href="#2-5-Mercator4——植物基因组功能注释" class="headerlink" title="2.5. Mercator4——植物基因组功能注释"></a>2.5. Mercator4——植物基因组功能注释</h2><p>网站注释：<a href="https://www.plabipd.de/portal/web/guest/mercator4/-/wiki/Mercator4/FrontPage">https://www.plabipd.de/portal/web/guest/mercator4/-/wiki/Mercator4/FrontPage</a></p>
<h3 id="2-5-1-注释原理"><a href="#2-5-1-注释原理" class="headerlink" title="2.5.1. 注释原理"></a>2.5.1. 注释原理</h3><ul>
<li>针对植物基因组的功能注释，以整个植物界的高质量带注释基因组为种子，找直系同源蛋白。</li>
<li>基于隐马尔可夫模型（HMM），用HMMER3软件的hmmscan对每条蛋白做HMM测试，然后被分到Bin-50类别下。</li>
<li>其余未被分类的蛋白与Swiss-Prot数据库做blastp比较，然后注释。</li>
</ul>
<p>注释速度：7万条蛋白3min注释完，神速！</p>
<h3 id="2-5-2-注释结果"><a href="#2-5-2-注释结果" class="headerlink" title="2.5.2. 注释结果"></a>2.5.2. 注释结果</h3><p>两个文件，点击即可下载。</p>
<ol>
<li>Mercator4 annotation results<br>一共有五列，每列信息都在单引号内：</li>
</ol>
<ul>
<li>BINCODE：有层级的有序数字列表</li>
<li>NAME：这一层级的功能名字，代表蛋白数据库里的功能层级</li>
<li>IDENTIFIER：基因ID，在末级层级才会有基因ID</li>
<li>DESCRIPTION：功能描述</li>
<li>TYPE：类型</li>
</ul>
<ol start="2">
<li>Mercator4 annotated fasta file</li>
</ol>
<h3 id="2-5-3-结果整理"><a href="#2-5-3-结果整理" class="headerlink" title="2.5.3. 结果整理"></a>2.5.3. 结果整理</h3><ol>
<li>从Mercator4 annotation results提取注释结果出来并转化成单基因单行信息格式，其中geneIDprefix根据基因名的前缀替换：</li>
</ol>
<p><code>cat mercator4v3/*.annotations.results.txt |awk -F&quot;\t&quot; &#39;$3 ~ &quot;geneIDprefix&quot; &#123;print $3&quot;\t&quot;$2&quot;: &quot;$4&#125;&#39; |sed &quot;s/&#39;//g&quot; |sort -k 1.3n |uniq |grep -v &quot;no hits&quot;|awk -F&quot;\t&quot; &#39;&#123;a[$1]=a[$1]$2&quot;; &quot;&#125;END&#123;for( i in a)&#123;print i&quot;\t&quot;a[i]&#125;&#125;&#39;|sed &quot;s/; $//g&quot; |sort -k 1.3n |sed &quot;s/not assigned.annotated/-/g&quot; |sed &quot;1i\gene\tmercator&quot;&gt;mercator.anno</code></p>
<p>注意检查是否还有no hits或者not assigned.annotated，有的话都替换掉。</p>
<ol start="2">
<li>从Mercator4 annotated fasta file中以”not annotated”作为关键词搜索，可以获取未被注释到的基因。</li>
</ol>
<h2 id="2-6-GFAP-functional-annotation-software-for-plants"><a href="#2-6-GFAP-functional-annotation-software-for-plants" class="headerlink" title="2.6. GFAP - functional annotation software for plants"></a>2.6. GFAP - functional annotation software for plants</h2><p>GFAP是windows下的一款基于python开发的软件，用于为植物基因组做功能注释。<br>2022年初发表在bioRxiv上，特地是运行非常快。</p>
<ul>
<li><a href="https://www.biorxiv.org/content/10.1101/2022.01.05.475154v1">GFAP paper</a></li>
<li><a href="https://gitee.com/simon198912167815/gfap-database">GFAP software and manual</a></li>
</ul>
<h1 id="3-基因功能注释的整合"><a href="#3-基因功能注释的整合" class="headerlink" title="3. 基因功能注释的整合"></a>3. 基因功能注释的整合</h1><p>提交功能注释文件有两种方案：</p>
<ol>
<li>整合功能注释和结构注释：把功能注释整理后添加到结构注释文件sample.gff第九列的product属性，与结构注释一同提交给NCBI等公共数据库</li>
<li>单独提供功能注释：通过Dryad【收费】或Figshare【免费】等文件分享网站单独提供功能注释文件</li>
</ol>
<h2 id="3-1-方案一：整合功能注释和结构注释"><a href="#3-1-方案一：整合功能注释和结构注释" class="headerlink" title="3.1. 方案一：整合功能注释和结构注释"></a>3.1. 方案一：整合功能注释和结构注释</h2><p>功能注释以product属性值的形式提供，添加到结构注释gff文件的第九列。</p>
<h3 id="3-1-1-基因功能注释整理"><a href="#3-1-1-基因功能注释整理" class="headerlink" title="3.1.1. 基因功能注释整理"></a>3.1.1. 基因功能注释整理</h3><p>不同软件的基因功能注释结果都预先进行了整理（参考各个软件后的注释整理部分），整理成两列的格式，首行为表头，第一列为基因ID（gene），第二列为基因功能注释的描述信息（标明注释来源），每个注释软件&#x2F;数据库的描述信息单独为一列。</p>
<p>目前共有9个文件被整理出来：</p>
<ol>
<li>eggnog.anno</li>
<li>eggnog.go.anno</li>
<li>eggnog.kegg.anno</li>
<li>iprs.interpro.anno</li>
<li>iprs.panther.anno</li>
<li>iprs.pfam.anno</li>
<li>mercator.anno</li>
<li>pannzer2.go.anno</li>
<li>pannzer2.uniprot.anno</li>
</ol>
<h3 id="3-1-2-合并功能注释和结构注释"><a href="#3-1-2-合并功能注释和结构注释" class="headerlink" title="3.1.2. 合并功能注释和结构注释"></a>3.1.2. 合并功能注释和结构注释</h3><p>合并步骤：</p>
<ol>
<li><p>整理注释结果<br>先把所有功能注释转换成单基因单注释的格式(单基因多行注释)，确保数据只有两列(基因ID列和功能注释列)，并删除除了product值以外的内容，比如iprs.panther.anno文件中的pantherid号，整理成pannzer2.uniprot.anno文件的形式，两列数据，第一列基因ID，第二列注释到的产物product值。</p>
</li>
<li><p>合并多个注释结果<br>cat *anno|sort -f|uniq -i|awk ‘$2 !&#x3D; “” {print $0}’ &gt;merge.anno<br>合并多个注释结果，排序sort，去重uniq，和去除空值行等处理；按照基因ID排序，生成单基因多行注释的merge.anno文件</p>
</li>
<li><p>过滤注释<br>最好的办法是在这一步做过滤filter。</p>
</li>
</ol>
<p><code>sed -i -E -e &quot;s/[,|()[]&#123;&#125;]//g&quot; -e &quot;s/^[-:/]//g&quot; -e &quot;s/[-:/]$//g&quot; -e &quot;s/[^a-zA-Z]+//g&quot; merge.anno</code></p>
<p>product值的不规范情况：</p>
<ul>
<li>包含逗号,（因为逗号是分隔符）</li>
<li>包含竖杠|</li>
<li>短横杠-开头或结尾</li>
<li>冒号:开头或结尾</li>
<li>斜杠&#x2F;开头或结尾</li>
<li>不包含字母</li>
<li>括号（包括圆括号,中括号和大括号）不完整的</li>
</ul>
<ol start="4">
<li><p>单注释转多注释<br>用<code>cat merge.anno |awk -F&quot;\t&quot; &#39;&#123;a[$1]=a[$1]$2&quot;,&quot;&#125;END&#123;for( i in a)&#123;print i&quot;\t&quot;a[i]&#125;&#125;&#39; |sed &quot;s/,$/;/g&quot;|sort -gk 1.3n|awk &#39;&#123;print $1&quot;\tproduct=&quot;$2&#125;&#39; &gt;product.list</code>命令从merge.anno生成product.list，每个基因单行的格式，还是两列，第一列基因ID，第二列若有多个注释用逗号隔开，用分号结尾。</p>
</li>
<li><p>添加product属性值<br>sample.gff与product.list合并，把结构注释和功能注释文件合并，功能注释以product属性值的形式加入gff文件的第九列内容。</p>
</li>
</ol>
<h2 id="3-2-方案二：单独提供功能注释"><a href="#3-2-方案二：单独提供功能注释" class="headerlink" title="3.2. 方案二：单独提供功能注释"></a>3.2. 方案二：单独提供功能注释</h2><h3 id="3-2-1-基因功能注释整理"><a href="#3-2-1-基因功能注释整理" class="headerlink" title="3.2.1. 基因功能注释整理"></a>3.2.1. 基因功能注释整理</h3><p>不同软件的基因功能注释结果都预先进行了整理（参考各个软件后的注释整理部分），整理成两列的格式，首行为表头，第一列为基因ID（gene），第二列为基因功能注释的描述信息（标明注释来源），每个注释软件&#x2F;数据库的描述信息单独为一列。</p>
<p>目前共有9个文件被整理出来：</p>
<ol>
<li>eggnog.anno</li>
<li>eggnog.go.anno</li>
<li>eggnog.kegg.anno</li>
<li>iprs.interpro.anno</li>
<li>iprs.panther.anno</li>
<li>iprs.pfam.anno</li>
<li>mercator.anno</li>
<li>pannzer2.go.anno</li>
<li>pannzer2.uniprot.anno</li>
</ol>
<h3 id="3-2-2-基因功能注释整合"><a href="#3-2-2-基因功能注释整合" class="headerlink" title="3.2.2. 基因功能注释整合"></a>3.2.2. 基因功能注释整合</h3><p>需要整合所有注释软件&#x2F;数据库的信息，只需根据第一列进行文件的合并。</p>
<h4 id="3-2-2-1-join命令"><a href="#3-2-2-1-join命令" class="headerlink" title="3.2.2.1. join命令"></a>3.2.2.1. join命令</h4><ol>
<li><p>实现合并a.anno和b.anno的方法：a.anno和b.anno都只有两列的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">join -t $&#x27;\t&#x27; -j 1 a.anno b.anno &gt;ab.tem #合并两个注释文件都注释到基因的行</span><br><span class="line">join -t $&#x27;\t&#x27; -j 1 -v 1 a.anno b.anno |awk -F&quot;\t&quot; &#x27;&#123;print $1&quot;\t&quot;$2&quot;\t-&quot;&#125;&#x27; &gt;a.tem #提取a.anno单独注释到基因的行</span><br><span class="line">join -t $&#x27;\t&#x27; -j 1 -v 2 a.anno b.anno |awk -F&quot;\t&quot; &#x27;&#123;print $1&quot;\t-\t&quot;$2&#125;&#x27; &gt;b.tem #提取b.anno单独注释到基因的行</span><br><span class="line">cat ab.tem a.tem b.tem |sort -k 1.3n &gt;ab.anno #合并注释文件</span><br><span class="line">rm ab.tem a.tem b.tem # 删除临时文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现合并ab.anno和c.anno的方法：ab.anno有三列，c.anno有两列的情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">join -t $&#x27;\t&#x27; -j 1 ab.anno c.anno &gt;abc.tem #合并两个注释文件都注释到基因的行</span><br><span class="line">join -t $&#x27;\t&#x27; -j 1 -v 1 ab.anno c.anno |awk -F&quot;\t&quot; &#x27;&#123;print $1&quot;\t&quot;$2&quot;\t&quot;$3&quot;\t-&quot;&#125;&#x27; &gt;ab.tem #提取ab.anno单独注释到基因的行</span><br><span class="line">join -t $&#x27;\t&#x27; -j 1 -v 2 ab.anno c.anno |awk -F&quot;\t&quot; &#x27;&#123;print $1&quot;\t-\t-\t&quot;$2&#125;&#x27; &gt;c.tem #提取c.anno单独注释到基因的行</span><br><span class="line">cat abc.tem ab.tem c.tem |sort -k 1.3n &gt;abc.anno #合并注释文件</span><br><span class="line">rm abc.tem ab.tem c.tem # 删除临时文件</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果多个文件，则两两依次合并。还没想到什么更简单的方法，就这样用join手动合并所有注释软件&#x2F;数据库的功能注释到一个文件吧。</p>
<h4 id="3-2-2-2-merge-file-key-property-title-cpp程序"><a href="#3-2-2-2-merge-file-key-property-title-cpp程序" class="headerlink" title="3.2.2.2. merge_file_key_property.title.cpp程序"></a>3.2.2.2. merge_file_key_property.title.cpp程序</h4><p>请大佬写了个合并功能注释的程序，merge_file_key_property.title.cpp，可以一次合并任意多个文件。</p>
<ol>
<li>编译<br><code>g++ -std=c++11 ./merge_file_key_property.cpp -o merge_file_key_property.o</code>生成执行文件*.o</li>
<li>执行<br><code> ./merge_file_key_property.o -h</code>查看参数</li>
</ol>
<p><code>./merge_file_key_property.o -a .anno -n 7 -p mc -q gene -o merged</code> 使用示范：-a指定合并的文件类型（比如.anno）；-n指定第一列字段长度（比如sp00001长度为7）；-p指定第一列关键词的前缀（基因名前缀，比如sp）；-q指定第一列关键词的标题（比如gene），作为表头；-o指定合并文件名的前缀。</p>
<h4 id="3-2-2-3-waiting…"><a href="#3-2-2-3-waiting…" class="headerlink" title="3.2.2.3. waiting…"></a>3.2.2.3. waiting…</h4><p>如果文件多且特征复杂，还是琢磨一下python或者R的merge功能吧。</p>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li><a href="https://www.jianshu.com/p/67dbafa86334">https://www.jianshu.com/p/67dbafa86334</a></li>
<li><a href="https://www.jianshu.com/p/e646c0fa6443">https://www.jianshu.com/p/e646c0fa6443</a></li>
<li>文章：<a href="http://xuzhougeng.top/archives/Function-anotation-with-swiss-prot-database">http://xuzhougeng.top/archives/Function-anotation-with-swiss-prot-database</a></li>
<li><a href="https://www.jianshu.com/p/4f4819f385d2">https://www.jianshu.com/p/4f4819f385d2</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>
]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>annotation</category>
      </categories>
      <tags>
        <tag>genome</tag>
        <tag>genome annotation</tag>
        <tag>functional annotation</tag>
        <tag>eggnog-mapper</tag>
        <tag>interproscan</tag>
        <tag>PANNZER2</tag>
        <tag>Mercator4</tag>
        <tag>GFAP</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组注释（四）：非编码RNA的注释-用Infernal软件对Rfam 12进行RNA注释</title>
    <url>/2022/04/22/omics_genome.annotation_ncRNA/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=283100&auto=1&height=32"></iframe></div>

<h1 id="1-ncRNA"><a href="#1-ncRNA" class="headerlink" title="1. ncRNA"></a>1. ncRNA</h1><p>非编码RNA(Non-coding RNA, ncRNA) 包括rRNA，tRNA，snRNA，snoRNA 和microRNA 等不编码蛋白质的RNA，它们转录后直接在RNA 水平上就能行使各自的生物学功能，并不需要翻译成蛋白质。</p>
<h1 id="2-注释软件"><a href="#2-注释软件" class="headerlink" title="2. 注释软件"></a>2. 注释软件</h1><ul>
<li>非编码RNA种类繁多，且结构特征各不相同，所以开发出了许多注释特定某一类RNA的软件，比如tRNAScan-SE预测tRNA，rnammer预测rRNA，snoScan 搜索带C&#x2F;D盒的snoRNAs，SnoGps 搜索带H&#x2F;ACA盒的snoRNAs，mirScan搜索microRNA等。</li>
<li>Sanger实验室开发了Infernal软件，建立了1600多个RNA家族，并对每个家族建立了一致性二级结构和协方差模型，形成了Rfam数据库。采用Rfam数据库中的每个RNA的协方差模型，结合Infernal软件可以预测出已有RNA家族的新成员，只是特异性比较差。</li>
</ul>
<p>如果不是专门研究ncRNA，可以用Infernal注释所有ncRNA。如果需要更精细的注释，则可以选择特定软件注释特定RNA。</p>
<p>这篇博客是介绍用Infernal程序与Rfam数据库一起用来注释与数据库中已知ncRNA同源的序列（这里用来注释完整的基因组）。注释结果包括tRNA，rRNA，snRNA，snoRNA和miRNA等。</p>
<h1 id="3-Infernal"><a href="#3-Infernal" class="headerlink" title="3. Infernal"></a>3. Infernal</h1><p><a href="http://eddylab.org/infernal/">Infernal</a>全称是”INFERence of RNA ALignment”，是一个用来检索DNA序列数据库中RNA序列和结构相似性的软件，通过协方差模型covariance models (CMs)来实现。</p>
<h2 id="3-1-安装Infernal"><a href="#3-1-安装Infernal" class="headerlink" title="3.1. 安装Infernal"></a>3.1. 安装Infernal</h2><p><code>conda install -c bioconda infernal</code><br>现在安装的是v1.1.4</p>
<p>安装后可使用的命令包括：</p>
<ul>
<li>cmpress：对cm文件进行压缩并建立索引。</li>
<li>cmscan：用提交的序列在cm数据库中进行检索。</li>
<li>cmalign：将RNA序列同协方差模型进行比对，并输出为stockholm格式。</li>
<li>cmbuild：通过多序列比对结果建立一个协方差模型，并保存在新文件中。</li>
<li>cmcalibrate：对协方差模型(CM)进行校准，在使用cmsearch和cmscan前CM模型需要先经过这个程序的处理。</li>
<li>cmconvert：用于格式转换，是将infernal 1.0以后的CM转化为当前版本需要的CM。但对1.0之前的版本无效。</li>
<li>cmemit：一个采样程序，从CM中进行采样并输出。</li>
<li>cmfetch：从一个大的CM文件中获取一个或多个CM。</li>
<li>cmsearch：用提交的CM模型在序列数据库中进行检索。</li>
<li>cmstat：对CM文件中的CM模型进行统计汇总。</li>
</ul>
<h1 id="4-Rfam"><a href="#4-Rfam" class="headerlink" title="4. Rfam"></a>4. Rfam</h1><p><a href="http://rfam.xfam.org/">Rfam</a>是RNA family数据库，包括ncRNA序列和ncRNA的二级结构，每个family用多序列比对和协方差模型covariance model (CM)来表示。</p>
<ol>
<li>下载Rfam数据库</li>
</ol>
<ul>
<li><code>wget http://ftp.ebi.ac.uk/pub/databases/Rfam/CURRENT/Rfam.cm.gz</code><br>在<a href="http://rfam.xfam.org/">Rfam</a>网站下载Rfam最新版本的CM数据库（目前是Rfam 14.7）</li>
<li><code>gunzip Rfam.cm.gz</code><br>解压数据库</li>
</ul>
<ol start="2">
<li>下载clanin</li>
</ol>
<ul>
<li><code>wget http://ftp.ebi.ac.uk/pub/databases/Rfam/CURRENT/Rfam.clanin</code><br>在<a href="http://rfam.xfam.org/">Rfam</a>网站下载Rfam数据库配套的clanin文件。</li>
</ul>
<h1 id="5-注释ncRNA"><a href="#5-注释ncRNA" class="headerlink" title="5. 注释ncRNA"></a>5. 注释ncRNA</h1><h2 id="5-1-建库"><a href="#5-1-建库" class="headerlink" title="5.1. 建库"></a>5.1. 建库</h2><ul>
<li><code>cmpress Rfam.cm</code><br>使用cmpress压缩并建立索引，生成Rfam.cm.i1f, Rfam.cm.i1i, Rfam.cm.i1m, Rfam.cm.i1p。</li>
</ul>
<h2 id="5-2-注释"><a href="#5-2-注释" class="headerlink" title="5.2. 注释"></a>5.2. 注释</h2><ol>
<li>序列索引<br>推荐的参数：</li>
</ol>
<p><code>nohup cmscan -Z 512 --cut_ga --rfam --nohmmonly --fmt 2 --tblout sample.tblout -o sample.result --clanin Rfam.clanin Rfam.cm genome.fa &amp;</code></p>
<ul>
<li>-Z：根据基因组大小来定，基因组大小的2倍，Mb单位，选一个整数。比如256Mb的基因组，-Z 512。</li>
<li><code>--cut_ga --rfam --nohmmonly --fmt 2</code>：推荐使用</li>
<li>–tblout sample.tblout：指定table格式输出文件</li>
<li>-o sample.result：指定比对结果输出文件</li>
<li>–clanin Rfam.clanin：指定clanin文件</li>
<li>Rfam.cm genome.fa：指定数据库Rfam.cm和基因组genome.fa</li>
</ul>
<p>note：-o sample.result要放在Rfam.cm genome.fa前面，否则报错。</p>
<p>此步骤<strong>耗时</strong>参考：250Mb基因组，默认线程，耗时2.5h。</p>
<ol start="2">
<li>结果文件</li>
</ol>
<ul>
<li>sample.result：比对结果</li>
<li>sample.tblout：table格式结果</li>
</ul>
<h2 id="5-3-整理结果"><a href="#5-3-整理结果" class="headerlink" title="5.3. 整理结果"></a>5.3. 整理结果</h2><h3 id="5-3-1-将注释结果整理成gff3文件"><a href="#5-3-1-将注释结果整理成gff3文件" class="headerlink" title="5.3.1. 将注释结果整理成gff3文件"></a>5.3.1. 将注释结果整理成gff3文件</h3><p>gff3文件可用于提交注释到数据库。</p>
<p>用perl脚本<a href="https://github.com/yanzhongsino/bioscripts/blob/main/saved_scripts/infernal-tblout2gff.pl">infernal-tblout2gff.pl</a>实现，脚本来自<a href="https://www.cnblogs.com/jessepeng/p/15392809.html%E3%80%82">https://www.cnblogs.com/jessepeng/p/15392809.html。</a></p>
<p><code>perl infernal-tblout2gff.pl --cmscan --fmt2 sample.tblout &gt;sample.infernal.ncRNA.gff3</code></p>
<h3 id="5-3-2-统计各类ncRNA总数"><a href="#5-3-2-统计各类ncRNA总数" class="headerlink" title="5.3.2. 统计各类ncRNA总数"></a>5.3.2. 统计各类ncRNA总数</h3><ol>
<li><p>整理注释结果文件sample.tblout<br>提取必需的列，非重叠区域或重叠区域得分高的区域<br><code>awk &#39;BEGIN&#123;OFS=&quot;\t&quot;;&#125;&#123;if(FNR==1) print &quot;target_name\taccession\tquery_name\tquery_start\tquery_end\tstrand\tscore\tEvalue&quot;; if(FNR&gt;2 &amp;&amp; $20!=&quot;=&quot; &amp;&amp; $0!~/^#/) print $2,$3,$4,$10,$11,$12,$17,$18; &#125;&#39; sample.tblout &gt;sample.tblout.xls</code></p>
</li>
<li><p>下载rfam注释</p>
</li>
</ol>
<ul>
<li>在<a href="https://rfam.xfam.org/">rfam官网</a>，选择【SEARCH】-【Entry type】</li>
<li>然后选中所有的Entry types（包括Gene，Intron，Cis-regulatory element），点击【Submit】，会列出所有RNA family的注释信息。</li>
<li>手动选择所有注释信息，复制，粘贴到新建的空白文本文件rfam.txt并保存。</li>
<li>把rfam.txt传输到服务器，最好用<code>dos2unix rfam.txt</code>转换文件格式为unix版本。</li>
<li>拆分第三列<code>cat rfam.txt | awk &#39;BEGIN &#123;FS=OFS=&quot;\t&quot;&#125;&#123;split($3,x,&quot;;&quot;);class=x[2];print $1,$2,$3,$4,class&#125;&#39; &gt; rfam_anno.txt</code></li>
</ul>
<p>rfam注释文件rfam_anno.txt包含了所有rfam的类型type和功能描述description信息。</p>
<ol start="3">
<li>统计ncRNA注释结果<br><code>awk &#39;BEGIN&#123;OFS=FS=&quot;\t&quot;&#125;ARGIND==1&#123;a[$2]=$5;&#125;ARGIND==2&#123;type=a[$1]; if(type==&quot;&quot;) type=&quot;Others&quot;; count[type]+=1;&#125;END&#123;for(type in count) print type, count[type];&#125;&#39; rfam_anno.txt sample.tblout.xls &gt;sample.ncRNA.statistic</code></li>
</ol>
<p>sample.ncRNA.statistic输出示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> riboswitch	1</span><br><span class="line"> ribozyme	1</span><br><span class="line"> tRNA	699</span><br><span class="line">Others	41</span><br><span class="line"> miRNA	188</span><br><span class="line"> antisense	4</span><br><span class="line"> rRNA	233</span><br><span class="line"> snRNA	698</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>统计细分分类</li>
</ol>
<ul>
<li>也可以根据细分分类分别统计，细分分类参考<a href="https://rfam.xfam.org/">rfam官网</a>，【SEARCH】-【Entry type】。</li>
<li>可参考的统计值包括每个细分ncRNA的数量(copy)，平均长度(average length)，总长(total length)，总长占基因组的比例（Percent of the genome）等</li>
<li>统计后整理成发表文章用的表格。</li>
</ul>
<p>比如：snRNA包括snoRNA和splicing，snoRNA包括CD-box，HACA-box和scaRNA。下面用统计CD-box这个细分分类的ncRNA举例。</p>
<ul>
<li>提取CD-box的Accession(RF00000格式)：<code>grep &quot;CD-box&quot; rfam_anno.txt |cut -f1 &gt;cdbox.tem</code></li>
<li>提取注释到的CD-box信息：<code>grep -f cdbox.tem mc.tblout.xls &gt;cdbox.txt</code></li>
<li>cdbox.txt的行数就是CD-box的数量；利用第四五列的位置信息，即可统计平均长度(average length)，总长(total length)，<strong>注意正反链</strong>。</li>
</ul>
<h1 id="6-references"><a href="#6-references" class="headerlink" title="6. references"></a>6. references</h1><ol>
<li><a href="https://www.cnblogs.com/jessepeng/p/15392809.html">https://www.cnblogs.com/jessepeng/p/15392809.html</a></li>
<li><a href="http://www.360doc.com/content/18/1119/05/52645714_795799901.shtml">http://www.360doc.com/content/18/1119/05/52645714_795799901.shtml</a></li>
<li><a href="https://genehub.wordpress.com/2019/08/08/%E6%A4%8D%E7%89%A9%E5%9F%BA%E5%9B%A0%E7%BB%84ncrna%E9%A2%84%E6%B5%8B%EF%BC%88trna%E3%80%81rrna%E3%80%81snrna%E3%80%81mirna%EF%BC%89/">https://genehub.wordpress.com/2019/08/08/%E6%A4%8D%E7%89%A9%E5%9F%BA%E5%9B%A0%E7%BB%84ncrna%E9%A2%84%E6%B5%8B%EF%BC%88trna%E3%80%81rrna%E3%80%81snrna%E3%80%81mirna%EF%BC%89/</a></li>
<li><a href="http://embracethesky.cn/2018/07/08/%e4%bd%bf%e7%94%a8infernal%e5%af%b9rfam-12%e8%bf%9b%e8%a1%8crna%e6%b3%a8%e9%87%8a/#more-99">http://embracethesky.cn/2018/07/08/%e4%bd%bf%e7%94%a8infernal%e5%af%b9rfam-12%e8%bf%9b%e8%a1%8crna%e6%b3%a8%e9%87%8a/#more-99</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>annotation</category>
      </categories>
      <tags>
        <tag>genome</tag>
        <tag>genome annotation</tag>
        <tag>ncRNA</tag>
        <tag>Infernal</tag>
        <tag>Rfam</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组注释（一）：重复序列注释</title>
    <url>/2021/08/02/omics_genome.annotation_repeat/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=365639&auto=1&height=32"></iframe></div>

<p><strong>防坑指南</strong></p>
<ol>
<li>基因组在组装后，注释前。<code>seqkit seq -u lower.geno &gt;upper.geno</code>改为碱基全部大写的形式，因为小写碱基有些软件是识别成soft-masked的形式，影响注释预测，edta的TIR预测和geta软件都有可能报错。（这个坑我已经踩两次了，唉~）</li>
</ol>
<p><strong>写在前面</strong></p>
<p>多种参数和条件用下来推荐的方案是：</p>
<ol>
<li>RepeatModeler自我训练</li>
<li>RepeatMasker加载Repbase数据库，并用-species参数指定近缘种，参考RepeatModeler自我训练结果做重复序列预测</li>
<li>EDTA，提供转录组组装的CDS序列做过滤，实现Denovo的TE预测。</li>
<li>结合RepeatMasker和EDTA的结果作为最终基因组的重复序列注释。</li>
</ol>
<h1 id="1-重复序列注释"><a href="#1-重复序列注释" class="headerlink" title="1. 重复序列注释"></a>1. 重复序列注释</h1><p>重复序列占基因组非常高的比例，对重复序列的注释一般是做基因组注释的第一步。常用的基因组重复序列注释软件有RepeatMasker, RepeatModeler, EDTA。</p>
<p>转座子(transposable elements,TE)是可以在基因组内改变位置的一段DNA序列，通常由DNA复制造成，TE是基因组的重要组成部分。</p>
<table>
    <caption><h4>转座子(transposable elements,TEs)的分类</h4></caption>
    <thead>
    <tr>
        <th>转座子</br>(transposable elements,TEs)</th>
        <th>功能</th>
        <th colspan="2">分类</th>
        <th>结构特征</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td rowspan="5"><h6>I 类元件</br>/逆转录转座子(retrotransposons)</h6></td>
        <td rowspan="5">在“复制和粘贴”转座机制中作为RNA中间体</td>
        <td rowspan="3">长末端重复(long terminal repeat, LTR)逆转录转座子</td>
        <td>Ty3-gypsy类</td>
        <td>LTR 元件具有 5 bp 目标位点重复(TSD)；LTR-Gypsy元件为 5'-TG...CA-3'。</td>
    </tr>
    <tr>
        <td>Ty1-copia类</td>
        <td>LTR 元件具有 5 bp 目标位点重复(TSD)；LTR-Copia元件的标准末端序列为 5'-TG...C/G/TA-3'</td>
    </tr>
    <tr>
        <td>其他，比如BEL-Pap类，内源性反转录病毒(HERV,MER4)等</td>
        <td>---</td>
    </tr>
    <tr>
        <td rowspan="2">非长末端重复(non-LTR)逆转录转座子</td>
        <td>长散布核元件</br>(LINEs,long interspersed nuclear element)</td>
        <td rowspan="2">non-LTR 具有可变长度的 TSD 或完全缺乏 TSD，而是与插入时侧翼序列的缺失相关。non-LTR 通常在元件的 3' 末端有一个末端 poly-A 尾</td>
    </tr>
    <tr>
        <td>短散布核元件</br>(SINEs,short interspersed nuclear element)</td>
    </tr>
    <tr>
        <td rowspan="7"><h6>II 类元件</br>/DNA 转座子(DNA transposons)</h6></td>
        <td rowspan="7">在“剪切和粘贴”转座机制中作为DNA中间体</td>
        <td rowspan="5">Terminal Inverted Repeat(TIR)元件</br>(TIR末端反向重复序列,这里指具有TIRs结构的DNA转座子，包括微型反向转座元件MITEs)</td>
        <td>CACTA</td>
        <td>CACTA元素被相对较短的TIRs(15-100bp)识别，这些TIRs以保守的CACTA...TAGTG基序终止，有3bp TSD。</td>
    </tr>
    <tr>
        <td>Mutator</td>
        <td>两侧通常有非常大的反向重复序列inverted repeats(200-500bp)，两侧有9bp的目标位点重复。</td>
    </tr>
    <tr>
        <td>PIF/Harbinger</td>
        <td>包含通常以一小段C/G结束，两侧有富含T/A的3bpTSD的短TIRs。许多是具有共同的富含G的TIR序列的旅游团(Tourist Group)的MITEs</td>
    </tr>
    <tr>
        <td>Tc1/Mariner</td>
        <td>包含长度约10-30bp，通常两侧有TA的TSD的短TIRs。</td>
    </tr>
    <tr>
        <td>hAT</td>
        <td>只有极少数被分类在TREP。特征还不好描述，TIR可以很短(几个bp)，两侧有一个8bp的TSD。</td>
    </tr>
    <tr>
        <td colspan="2">Helitron</td>
        <td>通过滚环机制复制，因此不产生 TSD 序列，也没有 TIR，但具有特征 5'-TC…CTRR-3' 末端序列，通常在元素的 3' 端附近有一个富含 GC 的短茎环结构。</td>
    </tr>
    <tr>
        <td colspan="2">Mavericks</br>非TE重复序列</br>(non-TE repeat sequence)</td>
        <td>大尺寸，15-40 kbp</br>包含长的TIRs(几百对碱基)</br>包含保守的5'-AG...TC-3'末端</td>
    </tr>
    <tr>
        <td rowspan="3">串联重复(tandem repeats)</td>
        <td rowspan="3">串联重复序列是一个或多个核苷酸的模式重复发生，并且重复彼此直接相邻的序列。</td>
        <td colspan="2">二核苷酸重复(dinucleotide repeat)</br>三核苷酸重复(trinucleotide repeat)</td>
        <td>根据重复单元的核苷酸数量，可以分为二核苷酸重复(dinucleotide repeat)，三核苷酸重复(trinucleotide repeat)等。</td>
    </tr>
    <tr>
        <td>小卫星(minisatellite)：</br>当重复单元的核苷酸数量为10-60时，称为小卫星，通常重复5-50次。</td>
        <td>微卫星(microsatellites)：</br>在遗传谱系或法医领域，又被称为短串联重复(short tandem repeats,STR)，在植物遗传学领域，又被称为简单序列重复(simple sequence repeat, SSR)</td>
        <td>小卫星中那些重复单元中核苷酸数量较少的被称为微卫星重复，核苷酸数量从1到6或者更多，没有统一规定。</td>
    </tr>
    <tr>
        <td colspan="2">可变数量串联重复(variable number tandem repeat, VNTR)</td>
        <td>当重复单元拷贝数在所分析的群体中是可变时，被称为可变数量串联重复(VNTR)。MeSH将VNTR分类在小卫星下。</td>
    </tr>
    </tbody>
</table>

<h1 id="2-RepeatMasker"><a href="#2-RepeatMasker" class="headerlink" title="2. RepeatMasker"></a>2. RepeatMasker</h1><h2 id="2-1-RepeatMasker介绍"><a href="#2-1-RepeatMasker介绍" class="headerlink" title="2.1. RepeatMasker介绍"></a>2.1. RepeatMasker介绍</h2><p>RepeatMasker是基因组重复序列检测的常用工具。一般依赖于已有的重复序列参考库Repbase作同源预测。对于绝大部分目标真核物种，都收录在Repbase中。</p>
<h2 id="2-2-RepeatMasker安装"><a href="#2-2-RepeatMasker安装" class="headerlink" title="2.2. RepeatMasker安装"></a>2.2. RepeatMasker安装</h2><ol>
<li><p>conda安装<br><code>conda install -c bioconda repeatmasker</code></p>
</li>
<li><p>加载Repbase数据库【推荐】</p>
</li>
</ol>
<ul>
<li><p>强烈建议加载<a href="https://www.girinst.org/server/RepBase/index.php">Repbase数据库</a>，遗传信息研究所发布的重复DNA数据库，收录了非常多的物种基因组的重复序列信息，目前是需要付费的，加载后重复序列注释率得到很大提升。</p>
</li>
<li><p>上传了一个20181026的版本到百度云盘，可以下载：<br>链接：<a href="https://pan.baidu.com/s/1g43z1DyHtiGxAGJMiC4nZQ">https://pan.baidu.com/s/1g43z1DyHtiGxAGJMiC4nZQ</a><br>提取码：ckc4</p>
</li>
<li><p>下载解压后把目录下两个文件RMRBSeqs.embl和README.RMRBSeqs放到RepeatMasker安装目录的Libraries目录下，如果是conda安装的在pathto&#x2F;anaconda3&#x2F;share&#x2F;RepeatMasker&#x2F;Libraries&#x2F;下。</p>
</li>
</ul>
<ol start="3">
<li>配置依赖</li>
</ol>
<ul>
<li><p>在RepeatMasker目录下运行<code>perl ./configure</code>，依次配置trf的位置，选择搜索引擎（4选1，推荐RMBlast或者HMMER（nhmmer命令），可以配置多个，但运行时只能用一种，选完再选5）。</p>
</li>
<li><p>一般如果依赖的软件安装成功加入环境变量了，会在配置依赖时自动出现依赖软件的路径，如果没有则手动输入依赖软件的路径。最后提示RepeatMasker is now ready to use即表示配置成功。</p>
</li>
</ul>
<h2 id="2-3-RepeatMasker使用"><a href="#2-3-RepeatMasker使用" class="headerlink" title="2.3. RepeatMasker使用"></a>2.3. RepeatMasker使用</h2><h3 id="2-3-1-查看数据库中的物种"><a href="#2-3-1-查看数据库中的物种" class="headerlink" title="2.3.1. 查看数据库中的物种"></a>2.3.1. 查看数据库中的物种</h3><ol>
<li>Repbase数据库配置好以后，用<code>RepeatMasker/util/queryRepeatDatabse.pl -tree &gt;species.txt</code>可以在species.txt中查看数据库中的物种列表。</li>
<li>查看RepeatMasker&#x2F;Libraries&#x2F;taxonomy.dat文件，也有所有已收录物种的名称。</li>
</ol>
<ul>
<li>找到数据库中已有训练的物种或者近缘种后，在使用RepeatMasker时用参数-species指定库中已有物种作为参考。</li>
</ul>
<h3 id="2-3-2-RepeatModeler自我训练"><a href="#2-3-2-RepeatModeler自我训练" class="headerlink" title="2.3.2. RepeatModeler自我训练"></a>2.3.2. RepeatModeler自我训练</h3><ul>
<li>大部分情况下数据库中没有待注释物种的近缘种，此时最好用RepeatModeler等软件进行自我训练，用denovo预测来构建重复序列数据库。</li>
<li>即使数据库中已有近缘种，有时候Repbase注释重复区的效果不是很好，也推荐进行自我训练。</li>
</ul>
<h4 id="2-3-2-1-RepeatModeler安装"><a href="#2-3-2-1-RepeatModeler安装" class="headerlink" title="2.3.2.1. RepeatModeler安装"></a>2.3.2.1. RepeatModeler安装</h4><ol>
<li>RepeatModeler依赖：</li>
</ol>
<ul>
<li>配置好的RepeatMasker</li>
<li>RECON：Denovo Repeat Finder</li>
<li>RepeatScout：Denovo Repeat Finder</li>
<li>NSEG</li>
</ul>
<ol start="2">
<li><p>RepeatModeler支持conda安装：<code>conda install -c bioconda repeatmodeler</code></p>
</li>
<li><p>或者下载源码编译，再一步步指定依赖软件路径，类似RepeatMasker的安装过程。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://repeatmasker.org/RepeatModeler/RepeatModeler-open-1.0.11.tar.gz</span><br><span class="line">tar xzvf RepeatModeler-open-1.0.11.tar.gz</span><br><span class="line"> </span><br><span class="line">cd RepeatModeler-open-1.0.11</span><br><span class="line">chmod -R 755 *</span><br><span class="line">perl ./configure</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-2-RepeatModeler使用"><a href="#2-3-2-2-RepeatModeler使用" class="headerlink" title="2.3.2.2. RepeatModeler使用"></a>2.3.2.2. RepeatModeler使用</h4><ol>
<li>建库</li>
</ol>
<p>生成sample.nhr,.nin,.nnd,.nni,.nog,.nsq,.translation 7个文件</p>
<p><code>mkdir db &amp;&amp; cd db</code><br><code>BuildDatabase -name sample -engine ncbi sample.fa</code></p>
<ol start="2">
<li>self-training</li>
</ol>
<p><code>nohup RepeatModeler -pa 8 -database db/sample -engine ncbi &amp;</code></p>
<ul>
<li>耗时数天。</li>
<li>-pa 限制的是core的进程，如果服务器是4核，想设置32个线程跑，应该设置-pa 8。</li>
<li>-databse指定库</li>
<li>-engine指定引擎<br>运行跑6 rounds，前4轮有几分钟到十几分钟的-pa线程×cores的超负荷运行，后两轮每轮约1-2h的-pa线程×cores的超负荷运行。</li>
</ul>
<ol start="3">
<li>结果文件</li>
</ol>
<ul>
<li>sample-families.fa （用于repeatmasker指定lib）</li>
<li>sample-families.stk（用于上传到Dfam数据库）</li>
<li>生成目录下RM_21945.SatAug11650032020，内含consensi.fa文件（自身比对找到的一致性序列）</li>
<li>consensi.fa.classified文件（fa格式），包含所有repeat序列和分类，序列id里包含了序列名称和是否能被repeatmasker识别的状态，如果不能被识别就标记Unknown。</li>
</ul>
<p>consensi.fa.classified文件即为训练结果，重复序列数据库，用作其他软件的输入。</p>
<ol start="4">
<li>处理</li>
</ol>
<p>如果想要更加可信的结果，可以把标记为Unknown的去除，留下的保存为ModelerID.lib，作为后续使用。</p>
<ul>
<li><p><code>seqkit grep -r -i -p &quot;Unknown&quot; -v ./RM_21945.SatAug11650032020/consensi.fa.classified &gt; ModelerID.lib</code>  #从consensi.fa.classified 文件提取可以被识别（就是序列id不含Unknown的序列）</p>
</li>
<li><p><code>seqkit grep -r -i -p &quot;Unknown&quot;  ./RM_21945.SatAug11650032020/consensi.fa.classified &gt; Modelerunknown.lib</code>  #从consensi.fa.classified 文件提取不能被识别（就是序列id含Unknown的序列）</p>
</li>
</ul>
<h3 id="2-3-3-RepeatMasker运行"><a href="#2-3-3-RepeatMasker运行" class="headerlink" title="2.3.3. RepeatMasker运行"></a>2.3.3. RepeatMasker运行</h3><p><code>RepeatMasker sample.fa -species &quot;Arachis ipaensis&quot; -pa 12 -lib consensi.fa.classified -poly -html -gff -dir repeatmasker</code></p>
<p><strong>参数解释：</strong></p>
<ul>
<li>-species 选择RepeatMasker数据库中已有近缘物种，比如”Arachis ipaensis”，可用RepeatMasker&#x2F;util&#x2F;queryRepeatDatabase.pl -tree &gt;species.txt获取已有物种列表。但RepeatMasker-4.1.1版本及以后不再提供queryRepeatDatabase.pl脚本，而是由famdb.py代替。</li>
<li>-pa 线程，用RMBlast引擎会用到4核，即设置-pa 12会用到48线程。</li>
<li>-lib RepeatModeler.consensi.fa.classified RepeatModeler自我训练的库</li>
<li>-poly 在file.poly中保存多态的polymorphic的简单重复序列，即微卫星重复序列。</li>
<li>-html输出xhtml格式文件</li>
<li>-gff输出gff格式文件</li>
<li>-dir 指定输出文件的目录，默认时当下目录</li>
</ul>
<h3 id="2-3-4-RepeatMasker结果"><a href="#2-3-4-RepeatMasker结果" class="headerlink" title="2.3.4. RepeatMasker结果"></a>2.3.4. RepeatMasker结果</h3><ul>
<li>sample.fa.tbl：结果报告，统计了基因组长度，GC含量，重复序列长度及各类重复序列占比等。</li>
<li>sample.fa.out：将基因组中预测得到的重复序列和参考序列相比的碱基替换频率、插入&#x2F;删除率，以及重复序列的位置、结构、类型等信息展示出。</li>
<li>sample.fa.out.gff：sample.fa.out的gff格式。</li>
<li>sample.fa.out.html：sample.fa.out的网页形式。</li>
<li>sample.fa.polyout：通过-poly参数，额外将sample.fa.out中的微卫星注释提取出来。微卫星注释是一种Simple_repeat序列，可以通过*.polyout将*.out的微卫星注释删除。有研究者认为微卫星不能算作严格的重复序列类型，还有研究者甚至认为Simple_repeat全都不能算。</li>
<li>sample.fa.cat.ga：记录了基因组序列和数据库中参考重复序列的比对详情，其中“i”和“v”分别代表了碱基转换（transitions）和颠换（transversions），“-”表示该位点存在碱基插入&#x2F;删除。。</li>
<li>sample.fa.masked：将重复序列屏蔽成N碱基的masked基因组。</li>
</ul>
<p>其中，sample.fa.out每一列含义：</p>
<ul>
<li>第一列：比对分值，SW score</li>
<li>第二列：替代率 perc div.</li>
<li>第三列：碱基缺失百分率</li>
<li>第四列：在重复序列中碱基缺失百分率</li>
<li>第五列：query sequence</li>
<li>第六列：查询序列起始位置</li>
<li>第七列：查询序列终止位置</li>
<li>第八列：查询区域中超出比对区域碱基的数- 目，也就是没有比对上的碱基数</li>
<li>第九列：+&#x2F;-(C)</li>
<li>第十列：比上的重复序列名称，类型命名</li>
<li>第十一列：比上重复序列的分类，和- repeatmolder 中*.classed 是一样的</li>
<li>第十二列：比上的在数据库中的起始位置</li>
<li>第十三列：比上的在数据库中的终止位置</li>
<li>第十四列：在第十列上超出比对区域碱基的数目，也就是没有比对上的碱基数</li>
<li>第十五列：比对区域的ID，随机给的</li>
</ul>
<h1 id="3-EDTA-The-Extensive-de-novo-TE-Annotator"><a href="#3-EDTA-The-Extensive-de-novo-TE-Annotator" class="headerlink" title="3. EDTA(The Extensive de novo TE Annotator)"></a>3. EDTA(The Extensive de novo TE Annotator)</h1><h2 id="3-1-EDTA介绍"><a href="#3-1-EDTA介绍" class="headerlink" title="3.1. EDTA介绍"></a>3.1. EDTA介绍</h2><p><a href="https://github.com/oushujun/EDTA#quick-installation-using-conda-linux64">EDTA</a>是一个用于自动化全基因组的转座元件(transposable elements,TE)从头注释(de-novo)注释和评估TE注释的综合软件。</p>
<img src="https://github.com/oushujun/EDTA/raw/master/development/EDTA%20workflow.png?raw=true" title="EDTA流程图" width="90%" />

<p><strong><p align="center">Figure 1. EDTA流程图</strong><br>from <a href="https://github.com/oushujun/EDTA#quick-installation-using-conda-linux64">github: EDTA</a></p></p>
<p><strong>EDTA运行和调用软件的流程：</strong></p>
<ol>
<li>LTR预测</li>
</ol>
<ul>
<li>LTR_FINDER预测LTR</li>
<li>LTRharvest预测LTR</li>
<li>LTR_retriever确认前两个软件预测的LTR</li>
</ul>
<ol start="2">
<li>TIR预测</li>
</ol>
<ul>
<li>Generic Repeat Finder</li>
<li>TIR-Learner预测TIR</li>
</ul>
<ol start="3">
<li>Helitrons预测</li>
</ol>
<ul>
<li>HelitronScanner</li>
</ul>
<ol start="4">
<li>filter过滤</li>
</ol>
<ul>
<li>以上三种TE预测结束后做basic filter获得full-length TEs</li>
<li>进一步做advance filter，获得raw library</li>
<li>与指定的curated library合并</li>
<li>用RepeatModeler做训练</li>
<li>用指定的CDS做最后的filters</li>
</ul>
<ol start="5">
<li>获得最终的final TE library</li>
<li>Annotation</li>
<li>Evaluation</li>
</ol>
<h2 id="3-2-EDTA-安装"><a href="#3-2-EDTA-安装" class="headerlink" title="3.2. EDTA 安装"></a>3.2. EDTA 安装</h2><p>参考<a href="https://github.com/oushujun/EDTA#installation">开发者推荐的安装方式</a></p>
<p><strong>注意RepeatMasker安装的Repbase库的加入，参考RepeatMasker的安装。</strong></p>
<h3 id="3-2-1-quick-installation-using-conda"><a href="#3-2-1-quick-installation-using-conda" class="headerlink" title="3.2.1. quick installation using conda"></a>3.2.1. quick installation using conda</h3><ol>
<li><p>下载EDTA<br><code>git clone https://github.com/oushujun/EDTA.git</code></p>
</li>
<li><p>用EDTA.yml创建新的环境和安装依赖<br><code>conda env create -f EDTA.yml</code></p>
</li>
</ol>
<h3 id="3-2-2-another-installation-using-conda"><a href="#3-2-2-another-installation-using-conda" class="headerlink" title="3.2.2. another installation using conda"></a>3.2.2. another installation using conda</h3><ol>
<li><p>【推荐】创建新的环境并进入<br><code>conda create -n EDTA</code><br><code>conda activate EDTA</code></p>
</li>
<li><p>三种方式安装EDTA：</p>
</li>
</ol>
<ul>
<li><p>安装EDTA<br><code>conda install -c bioconda -c conda-forge edta</code></p>
</li>
<li><p>安装EDTA和指定版本依赖<br><code>conda install -c conda-forge -c bioconda edta python=3.6 tensorflow=1.14 &#39;h5py&lt;3&#39;</code></p>
</li>
<li><p>用mamba加速安装<br><code>conda install -c conda-forge mamba</code><br><code>mamba install -c conda-forge -c bioconda edta python=3.6 tensorflow=1.14 &#39;h5py&lt;3&#39;</code></p>
</li>
</ul>
<h3 id="3-2-3-singularity安装"><a href="#3-2-3-singularity安装" class="headerlink" title="3.2.3. singularity安装"></a>3.2.3. singularity安装</h3><p><code>singularity pull EDTA.sif docker://oushujun/edta:&lt;tag&gt;</code></p>
<h3 id="3-2-4-docker安装"><a href="#3-2-4-docker安装" class="headerlink" title="3.2.4. docker安装"></a>3.2.4. docker安装</h3><p><code>docker pull docker://oushujun/edta:&lt;tag&gt;</code></p>
<p>singularity和docker安装我没用过，参考开发者说明吧。</p>
<h2 id="3-3-EDTA-使用"><a href="#3-3-EDTA-使用" class="headerlink" title="3.3. EDTA 使用"></a>3.3. EDTA 使用</h2><p><code>nohup EDTA.pl --genome sample.fa --cds sample.cds --species others --step all --sensitive 1 --anno 1 --evaluate 1 -t 36 &amp;</code></p>
<p><strong>参数解释：</strong></p>
<ul>
<li>–genome 基因组文件</li>
<li>–cds 提供这个种或近缘种的CDS序列（不能包括introns和UTR），用于最终过滤。</li>
<li>–rmout 提供其他软件做的同源TE注释（比如repeatmasker的.out文件），如果不提供则默认使用EDTA - library用于masking。</li>
<li>–species [Rice|Maize|others]三种可选</li>
<li>–step    [all|filter|final|anno]</li>
<li>-sensitive: 是否用RepeatModeler分析剩下的TE，默认是0，不要。RepeatModeler会增加运行时间。</li>
<li>-anno: 是否在构建TE文库后进行全基因组预测，默认是0.</li>
<li>-evalues: 默认是0，需要同时设置-anno 1才能使用。能够评估注释质量，但会显著增加分析时间。</li>
<li>–overwrite默认是0，设定为1会删除已有结果重新运行，建议保持默认，运行中断可以继续运行。</li>
</ul>
<p>简化推荐版：<br><code>nohup EDTA.pl --genome sample.fa --cds sample.cds --species others --step all --anno 1 -t 36 &amp;</code></p>
<h2 id="3-4-结果文件"><a href="#3-4-结果文件" class="headerlink" title="3.4. 结果文件"></a>3.4. 结果文件</h2><ul>
<li>genome.mod.EDTA.TElib.fa：最终结果，非冗余的TE库。如果在输入文件中用–curatedlib指定的修正版TE库，则该文件中也将包含这部分序列。</li>
<li>genome.mod.EDTA.TElib.novel.fa: 新TE类型。该文件包括在输入文件中用–curatedlib指定的修正版TE库没有的TE序列，即genome.mod.EDTA.TElib.fa减去–curatedlib指定库(需要–curatedlib参数)。</li>
<li>genome.mod.EDTA.TEanno.gff: 全基因组TE的注释。该文件包括结构完整和结构不完整的TE的注释（需要–anno 1参数）。</li>
<li>genome.mod.EDTA.TEanno.sum: 对全基因组TE注释的总结（需要–anno 1参数）。</li>
<li>genome.mod.MAKER.masked: 低阈值TE的屏蔽。该文件中仅包括长TE（&gt;&#x3D; 1 kb）序列(需要–anno 1参数)。</li>
<li>genome.mod.EDTA.TE.fa.stat.redun.sum: 简单TE的注释偏差(需要–evaluate 1参数)。</li>
<li>genome.mod.EDTA.TE.fa.stat.nested.sum：嵌套型TE注释的偏差（需要–evaluate 1参数）。</li>
<li>genome.mod.EDTA.TE.fa.stat.all.sum: 注释偏差的概述（需要–evaluate 1参数）。</li>
</ul>
<h2 id="3-5-评估已有TE注释"><a href="#3-5-评估已有TE注释" class="headerlink" title="3.5. 评估已有TE注释"></a>3.5. 评估已有TE注释</h2><p>当已有TE库结果，想要与其他软件（比如RepeatMasker）预测结果比较，可以用EDTA的脚本<code>lib-test.pl</code>进行，评估是通过与参考注释进行比较来进行的。</p>
<ol>
<li>用RepeatMasker根据已有TE库进行注释</li>
</ol>
<p><code>RepeatMasker -pa 36 -q -no_is -norna -nolow -div 40 -lib sample.TE.lib.fasta -cutoff 225 sample.fa</code></p>
<ol start="2">
<li>用lib-test.pl进行TE注释的比较和评估</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">perl lib-test.pl -genome genome.fasta -std genome.stdlib.RM.out -tst genome.testlib.RM.out -cat [options]</span><br><span class="line">	-genome	[file]	FASTA format genomesequence</span><br><span class="line">	-std	[file]	RepeatMasker .out file of the standard library</span><br><span class="line">	-tst	[file]	RepeatMasker .out file of the test library</span><br><span class="line">	-cat	[string]	Testing TE category. Use one of LTR|nonLTR|LINE|SINE|TIR|MITEHelitron|Total|Classified</span><br><span class="line">	-N	[0|1]	Include Ns in total length of the genome. Defaule: 0 (not include Ns).</span><br><span class="line">	-unknown	[0|1]	Include unknownannotations to the testing category. This should be used when</span><br><span class="line">				the test library has no classification and you assume they all belong to the</span><br><span class="line">				target category specified by -cat. 	Default: 0 (not include unknowns)</span><br><span class="line">	-rand	[int]	A randum number used to identify the current run. (default:generate automatically)</span><br><span class="line">	-threads|-t	[int]	Number of threads torun this program. Default: 4</span><br></pre></td></tr></table></figure>

<p><code>lib-test.pl -genome sample.fa -std genome.stdlib.RM.out -tst genome.testlib.RM.out -cat LTR</code></p>
<h2 id="3-6-notes"><a href="#3-6-notes" class="headerlink" title="3.6. notes"></a>3.6. notes</h2><ul>
<li>基因组的碱基全部大写，因为小写在一些软件是被认为进行了soft-masked的，在TIR预测时会报错。</li>
<li>-t设置线程，当运行到调用RMBlast引擎时，默认使用四核，如果服务器是四核，则实际使用线程为设置的-t的四倍（RepeatMasker和RepeatModeler的-pa设置线程有一样的问题），EDTA支持断点续跑，可以先设置-t 高一点，运行到RMBlast时，kill掉，重新设置低一点的-t。</li>
<li>预测有时运行会报错缺一些perl的module，例如Bio，安装缺失的module，再次运行即可。</li>
<li>关于–rmout，当使用这个参数指定同源TE注释时，不使用EDTA的同源注释，而是用这个参数指定的库做同源注释，最终结果是这个同源注释加上EDTA其他注释的完整的intact TEs结果。所以当提供的repeatmasker文件预测结果非常全面时，使用这个参数；如果提供的库对物种TE的预测结果不够全面，使用这个参数反而会降低最终预测结果，不建议使用这个参数。不知道是否提供的库是否全面，有时间就有这个参数和没这个参数的结果比较选用，没时间就直接不用这个参数。参考<a href="https://github.com/oushujun/EDTA/issues/193">issue</a>。</li>
<li>HelitronScanner预测Helitrons默认需要400G运行内存，若不够会出现如下报错，把运行内存上限升高后再次运行即可：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR: Raw Helitron results not found in sample.fa.mod.EDTA.raw/sample.fa.mod.Helitron.raw.fa</span><br><span class="line">	If you believe the program is working properly, this may be caused by the lack of intact Helitrons in your genome. Consider to use the --force 1 parameter to overwrite this check</span><br></pre></td></tr></table></figure>

<h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ol>
<li><a href="https://en.wikipedia.org/wiki/Tandem_repeat">https://en.wikipedia.org/wiki/Tandem_repeat</a></li>
<li><a href="https://en.wikipedia.org/wiki/Microsatellite">https://en.wikipedia.org/wiki/Microsatellite</a></li>
<li><a href="http://www.repeatmasker.org/RepeatModeler/">http://www.repeatmasker.org/RepeatModeler/</a></li>
<li><a href="https://www.cnblogs.com/zhanmaomao/p/12345462.html">https://www.cnblogs.com/zhanmaomao/p/12345462.html</a></li>
<li><a href="https://www.jianshu.com/p/ddd1c9a74fde">https://www.jianshu.com/p/ddd1c9a74fde</a></li>
<li><a href="https://www.jianshu.com/p/dfa89f394882">https://www.jianshu.com/p/dfa89f394882</a></li>
<li><a href="https://wheat.pw.usda.gov/ITMI/Repeats/Repeat_types.html">https://wheat.pw.usda.gov/ITMI/Repeats/Repeat_types.html</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>annotation</category>
      </categories>
      <tags>
        <tag>genome</tag>
        <tag>genome annotation</tag>
        <tag>repeat sequences</tag>
        <tag>transposable elements(TE)</tag>
        <tag>RepeatMasker</tag>
        <tag>RepeatModeler</tag>
        <tag>EDTA</tag>
        <tag>tandem repeat</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组组装和注释结果的整理</title>
    <url>/2021/08/10/omics_genome.management/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1833352&auto=1&height=32"></iframe></div>


<h1 id="1-基因组整理【组装之后，注释之前】"><a href="#1-基因组整理【组装之后，注释之前】" class="headerlink" title="1. 基因组整理【组装之后，注释之前】"></a>1. 基因组整理【组装之后，注释之前】</h1><h2 id="1-1-基因组碱基整理"><a href="#1-1-基因组碱基整理" class="headerlink" title="1.1. 基因组碱基整理"></a>1.1. 基因组碱基整理</h2><p>基因组碱基-u修改成大写字母形式，同时建议使用-w 0把序列输出限定为一行序列。</p>
<p><code>seqkit seq -u -w 0 genome.old.fa&gt;genome.new.fa</code></p>
<h2 id="1-2-基因组碱基小写带来的问题："><a href="#1-2-基因组碱基小写带来的问题：" class="headerlink" title="1.2. 基因组碱基小写带来的问题："></a>1.2. 基因组碱基小写带来的问题：</h2><ol>
<li>edta运行TIR预测时，报错并中断运行。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EDTA/bin/TIR-Learner2.5/Module2/RunGRF.py&quot;, line 79, in &lt;module&gt;</span><br><span class="line">    if (len(str(records[0].seq))&gt;int(length)+500):</span><br><span class="line">IndexError: list index out of range</span><br><span class="line">cp: cannot stat &#x27;TIR-Learner/*-p&#x27;: No such file or directory</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>geta生成基因注释结果减少。<br>前期运行不受影响，会在geta生成的&#x2F;out.tmp&#x2F;6.combineGeneModels&#x2F;中合并前面步骤预测结果时把许多基因预测结果识别为partial而筛除掉本为完整的基因，可看到&#x2F;out.tmp&#x2F;6.combineGeneModels&#x2F;genome.gff3的gene数量是正常的，而out.tmp&#x2F;6.combineGeneModels&#x2F;genome.completed.gff3明显降低，&#x2F;out.tmp&#x2F;6.combineGeneModels&#x2F;genome.partial.gff3明显升高。out.tmp&#x2F;6.combineGeneModels&#x2F;genome.filter.gff3是最后的基因注释结果，即out.gff3也相应减少。</li>
<li>maker的某些运行步骤也会出错。</li>
</ol>
<h2 id="1-3-基因组序列ID修改"><a href="#1-3-基因组序列ID修改" class="headerlink" title="1.3. 基因组序列ID修改"></a>1.3. 基因组序列ID修改</h2><h3 id="1-3-1-排序【optional】–根据需要选择"><a href="#1-3-1-排序【optional】–根据需要选择" class="headerlink" title="1.3.1. 排序【optional】–根据需要选择"></a>1.3.1. 排序【optional】–根据需要选择</h3><p>按长度对基因组contigs进行从长到短的排序</p>
<p><code>seqkit sort -l -r -w 0 genome.old.fa &gt;genome.sort.fa</code> </p>
<h3 id="1-3-2-重命名【推荐】"><a href="#1-3-2-重命名【推荐】" class="headerlink" title="1.3.2. 重命名【推荐】"></a>1.3.2. 重命名【推荐】</h3><p>最好重命名成长度一致的数字，避免后期分析遇到contig1和contig11同时被匹配的问题。</p>
<ol>
<li>solution A【速度最快，推荐】<br>序列IDs按顺序命名为1-n的数字，–nr-width可以设置数字的长度，长度为5时第一条序列名称为00001。</li>
</ol>
<p><code>seqkit replace -p &#39;.*&#39; -r &#123;nr&#125; --nr-width 5 genome.sort.fa</code> </p>
<ol start="2">
<li>solution B<br>把序列id重命名成1-n的数字</li>
</ol>
<p><code>awk &#39;BEGIN&#123;i=0 ; FS=&quot;,&quot; ; OFS=&quot;,&quot;&#125;&#123; if(/&gt;/)&#123;gsub($1,&quot;&gt;&quot;++i,$1);print $0&#125;else&#123;print $0&#125;&#125;&#39; genome.sort.fa&gt;genome.fa</code> </p>
<p>基因组的序列id改为scaf001的形式</p>
<p><code>sed -i &quot;s/&gt;/&gt;scaf/g&quot; genome.fa</code> </p>
<ol start="3">
<li>solution C<br>把基因组序列id的数字1-100改成0001-0100这种数字位数相同的格式。这个没有solution A快，只推荐在不想做大规模更改的情况下使用。</li>
</ol>
<p>用下面脚本实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">j=1</span><br><span class="line">for i in `seq -w 1 0100` #把相同数字位数的0001-0100依次赋值给变量i</span><br><span class="line">do</span><br><span class="line">	sed -i -E -e &quot;s/scaffold$j$/scaffold_$i/g&quot; -e &quot;s/scaffold$j([^0-9])/scaffold_$i\1/g&quot; species.fa #两次替换，第一次替换scaffold$j为行尾的字符串（比如在基因组序列文件中），第二次替换scaffold$j不为行尾的字符串，[^0-9]代表不为数字的任意一个字符，\1代表替换前括号([^0-9])中的内容。</span><br><span class="line">	sed -i -E -e &quot;s/scaffold$j$/scaffold_$i/g&quot; -e &quot;s/scaffold$j([^0-9])/scaffold_$i\1/g&quot; species.gff #同上，替换其他文件，比如gff文件。</span><br><span class="line">	j=$(($j+1)) #把1-100依次赋值给变量j</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h1 id="2-基因组注释整理【注释结果整理】"><a href="#2-基因组注释整理【注释结果整理】" class="headerlink" title="2. 基因组注释整理【注释结果整理】"></a>2. 基因组注释整理【注释结果整理】</h1><h2 id="GFF3toolkit【推荐】"><a href="#GFF3toolkit【推荐】" class="headerlink" title="GFF3toolkit【推荐】"></a>GFF3toolkit【推荐】</h2><p>推荐使用GFF3toolkit来进行gff3注释文件的整理，具体介绍参考博客<a href="https://yanzhongsino.github.io/2022/05/24/biosoft_fileformat_GFF3toolkit/">GFF3toolkit blog</a>。</p>
<p>GFF3toolkit包含许多模块：</p>
<ul>
<li>gff3_QC：检测gff3格式错误</li>
<li>gff3_fix：修正gff3格式错误</li>
<li>gff3_merge：合并两个gff3文件</li>
<li>gff3_sort：根据scaffold，coordinates坐标来排序gff3文件</li>
<li>gff3_to_fasta：根据基因组fasta和注释gff生成gene&#x2F;cds&#x2F;protein&#x2F;exon等序列</li>
</ul>
<h2 id="2-1-合并多个注释结果"><a href="#2-1-合并多个注释结果" class="headerlink" title="2.1. 合并多个注释结果"></a>2.1. 合并多个注释结果</h2><p>基因组的基因结构注释，如果使用了多款软件进行，想要合并多套注释结果，并让注释的基因根据染色体和位置信息排序，可参考这个办法。</p>
<p>合并两个基因注释文件（若是多个就依次合并）</p>
<ol>
<li><p>输出A.gff中符合要求的行，即A.gff中与B.gff中位置有overlap的行。<br><code>bedtools intersect -a A.gff -b B.gff -wa &gt;A.dup.gff</code> </p>
</li>
<li><p>输出只在A.gff存在的行，即把A.dup.gff从A.gff中删除，需要两个文件都已排序，若未排序先sort排序再处理。<br><code>comm -1 A.gff A.dup.gff &gt;A.filter.gff</code> </p>
</li>
<li><p>合并B.gff和A.gff中与B.gff不重复的部分。<br><code>cat B.gff A.filter.gff &gt;sample.gff</code></p>
</li>
</ol>
<h2 id="2-2-重命名注释结果【可选】"><a href="#2-2-重命名注释结果【可选】" class="headerlink" title="2.2. 重命名注释结果【可选】"></a>2.2. 重命名注释结果【可选】</h2><p>根据需要选择【非必要的】，根据染色体位置顺序对注释的基因结果进行排序和重命名整理。<br>除了基因注释外，不同分析源都可能发现新的基因，增加注释的基因数量，从而打乱顺序。</p>
<h3 id="2-2-1-排序"><a href="#2-2-1-排序" class="headerlink" title="2.2.1. 排序"></a>2.2.1. 排序</h3><ol>
<li>把sample.gff3中gene替换成1gene，mRNA替换成2mRNA，exon替换成3exon，CDS替换成4CDS；目的是确保排序后单个基因内部的顺序是1-2-3-4。<br><code>sed -i -e &quot;s/gene/1gene/g&quot; -e &quot;s/mRNA/2mRNA/g&quot; -e &quot;s/exon/3exon/g&quot; -e &quot;s/CDS/4CDS/g&quot; sample.gff3</code></li>
<li>根据染色体位置排序。按照第一列第四个字符，第四列数值，第五列数值逆序依次排序。<br><code>cat sample.gff3 |sort -k 1.4n -k 4n -k 5nr &gt;sample.sort.gff3</code></li>
<li>获得的sample.sort.gff3文件再1gene替换成gene，234类似替换。<br><code>sed -i -e &quot;s/1gene/gene/g&quot; -e &quot;s/2mRNA/mRNA/g&quot; -e &quot;s/3exon/exon/g&quot; -e &quot;s/4CDS/CDS/g&quot; sample.sort.gff3</code></li>
</ol>
<h3 id="2-2-2-重命名"><a href="#2-2-2-重命名" class="headerlink" title="2.2.2. 重命名"></a>2.2.2. 重命名</h3><ol>
<li>复制一份注释文件用于修改和替换<br><code>cp sample.sort.gff3 sample.new.gff3</code></li>
<li>获取旧ID的list。获取sample.sort.gff3第九列中的ID值。<br><code>cat sample.new.gff3 | awk &#39;$3==&quot;gene&quot; &#123;print $9&#125;&#39;|sed -e &quot;s/;.*//g&quot; -e &quot;s/ID=//g&quot; &gt;old.name</code></li>
<li>获取新ID的list。<br><code>for i in $(seq -w 1 </code>cat old.name|wc -l<code>); do echo scaf$i; done &gt;new.name</code></li>
<li>合并旧的和新的ID。<br><code>paste -d &quot;/&quot; old.name new.name &gt; old2new.name</code></li>
<li>生成替换脚本old2new.sh。<br><code>sed -e &quot;s/^/sed -i \&quot;s\//g&quot; -e &quot;s/$/\/g sample.new.gff3/g\&quot;&quot; old2new.name &gt;old2new.sh</code></li>
<li>运行替换脚本，会直接替换sample.new.gff3文件的旧ID为新ID，可能会运行较长时间。<br><code>sh old2new.sh</code></li>
</ol>
<p>ps：这部分代码可实现，但是是非常冗余的代码量（水平有限），且未必适用所有注释文件，谨慎参考。</p>
<h2 id="2-3-从注释文件提取序列"><a href="#2-3-从注释文件提取序列" class="headerlink" title="2.3. 从注释文件提取序列"></a>2.3. 从注释文件提取序列</h2><p>用gffread根据注释文件从基因组提取基因序列:</p>
<ul>
<li>从基因组genome.fa和注释文件sample.gff3获取cds序列<br><code>gffread -x sample.cds.fa -g genome.fa sample.gff3</code></li>
<li>从基因组genome.fa和注释文件sample.gff3获取exon序列<br><code>gffread -w sample.exon.fa -g genome.fa sample.gff3</code></li>
<li>从基因组genome.fa和注释文件sample.gff3获取protein序列<br><code>gffread -y sample.protein.fa -g genome.fa sample.gff3</code></li>
</ul>
<h2 id="2-4-从注释文件提取intron信息"><a href="#2-4-从注释文件提取intron信息" class="headerlink" title="2.4. 从注释文件提取intron信息"></a>2.4. 从注释文件提取intron信息</h2><p>脚本<a href="https://github.com/yanzhongsino/bioscripts/blob/main/modifiedscripts/extract_intron_info.pl">extract_intron_info.pl</a></p>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
      </categories>
      <tags>
        <tag>genome</tag>
        <tag>genome annotation</tag>
        <tag>sort</tag>
        <tag>rename</tag>
        <tag>combine</tag>
        <tag>extract</tag>
      </tags>
  </entry>
  <entry>
    <title>用k-mer分析进行基因组调查：（一）基本原理</title>
    <url>/2022/05/25/omics_genome.survey_01.intro/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=283096&auto=1&height=32"></iframe></div>

<p><strong>用k-mer分析进行基因组调查系列：</strong></p>
<ul>
<li>（一）基本原理：<a href="https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/">https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/</a></li>
<li>（二）用Smudgeplot估计倍性：<a href="https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/">https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/</a></li>
<li>（三）用jellyfish进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/">https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/</a></li>
<li>（四）用KMC进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/</a></li>
<li>（五）用GenomeScope评估基因组特征：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/</a></li>
<li>（六）用GCE分步实现：<a href="https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/">https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/</a></li>
<li>（七）用KmerGenie一步实现：<a href="https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/">https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/</a></li>
</ul>
<p><strong>【推荐】用Smudgeplot评估物种倍性后，用组合jellyfish+GenomeScope1.0做二倍体物种的基因组调查，用组合KMC+GenomeScope2.0做多倍体物种的基因组调查。</strong></p>
<h1 id="1-基因组调查-genome-survey"><a href="#1-基因组调查-genome-survey" class="headerlink" title="1. 基因组调查(genome survey)"></a>1. 基因组调查(genome survey)</h1><h2 id="1-1-基因组调查"><a href="#1-1-基因组调查" class="headerlink" title="1.1. 基因组调查"></a>1.1. 基因组调查</h2><p>基因组调查(genome survey)指基因组特征评估，一般指通过k-mer分析二代测序数据，获得基因组大小(genome size)，杂合度(heterozygosity)，重复序列比例，GC含量等基因组信息的手段。</p>
<ol>
<li><p>基因组调查介绍<br>在无参考基因组的情况下，使用中低深度的短片段测序所得的reads进行基因组调查(genome survey)，初步评估基因组特征，包括基因组大小(genome size)，杂合度(heterozygosity)，重复序列比例，GC含量等，从而为后续的基因组测序、组装和结构注释方案提供参考依据。</p>
</li>
<li><p>基因组调查的目的<br>基因组调查主要目的是获取两个方面的信息，一个是基因组的大小，一个是基因组复杂程度。</p>
</li>
</ol>
<ul>
<li>基因组大小(genome size)<br>因为测序费用是以测序量为单价计算，所以基因组越大，测序费用越高。</li>
<li>基因组复杂程度<br>基因组越复杂(杂合度越高，重复序列占比越高)，意味着测序难度和组装难度越大。</li>
</ul>
<ol start="3">
<li>基因组调查实践</li>
</ol>
<ul>
<li>为了准确估计基因组信息，建议测序深度为50X（即预估基因组大小的50倍），最小也不低于25X。</li>
<li>做基因组调查和后续做基因组denovo测序需要使用同一个个体，因为有些物种个体间的基因组特征有较大的差异，且同一个个体做survey的illumina数据可用于组装。</li>
<li>预估基因组大小可以通过已有研究粗略判断，包括流式细胞研究，近缘种研究，也推荐植物在<a href="https://cvalues.science.kew.org/">C值数据库网站</a>里查询。</li>
<li>基因组调查(genome survey)常常使用<strong>k-mer分析</strong>来实现。</li>
</ul>
<h2 id="1-2-基因组复杂程度"><a href="#1-2-基因组复杂程度" class="headerlink" title="1.2. 基因组复杂程度"></a>1.2. 基因组复杂程度</h2><p>基因组复杂程序的判断标准包括：基因组大小，倍性，杂合度，重复序列比例，GC含量等。</p>
<p>一般而言，基因组越大，重复序列比例越高; GC含量异常低或异常高，重复序列比例也会很高；多倍体基因组的杂合度高于二倍体。</p>
<p>判断基因组复杂程度可以参考以下经验性标准：</p>
<ul>
<li><strong>简单基因组</strong>: 单倍体；或纯合二倍体；或杂合度低于0.5%, 且重复序列低于50%, 且GC含量在35%-65%的二倍体。</li>
<li><strong>复杂基因组</strong>: 杂合度在0.5%~1.2%之间，或重复序列高于50%，或GC含量异常(&lt;35%或&gt;65%)的二倍体，或者多倍体。</li>
<li><strong>高复杂基因组</strong>: 杂合度&gt;1.2%；或重复序列占比大于65%。</li>
</ul>
<h1 id="2-k-mer分析"><a href="#2-k-mer分析" class="headerlink" title="2. k-mer分析"></a>2. k-mer分析</h1><p>k-mer分析可以用在生物信息学许多方面，这篇博客的k-mer分析特指用于基因组调查的k-mer分析方法。</p>
<h2 id="2-1-k-mer相关概念"><a href="#2-1-k-mer相关概念" class="headerlink" title="2.1. k-mer相关概念"></a>2.1. k-mer相关概念</h2><ol>
<li>monomeric unit (mer): 单体单元，单位是nt或者bp。通常用于双链核酸中的单位，100 mer DNA相当于每一条链有100nt，那么整条链就是100bp。</li>
<li>k-mer概念<br>在生物信息学中，k-mer是指包含在一段序列中的长度为k的子串。一段长度为L的核酸序列，以一个碱基为步长滑动，一共可以生成(L-K+1)个k-mers，另外还可以用这段核酸的反向互补序列再生成一次k-mer。</li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/omics_genome.survey_Kmer.png?raw=true" title="k-mer示例" width="90%" align=center/>

<p><strong><p align="center">Figure 1. k-mer示例，图片来源： <a href="https://cloud.tencent.com/developer/article/1613847">k-mer与基因组</a></p></strong></p>
<h2 id="2-2-k-mer分析步骤"><a href="#2-2-k-mer分析步骤" class="headerlink" title="2.2. k-mer分析步骤"></a>2.2. k-mer分析步骤</h2><ol>
<li>通过切割二代测序的reads为k-mers</li>
<li>统计k-mer的总数和每一种k-mer的频数</li>
<li>绘制k-mer的频数分布图</li>
<li>根据k-mer的频数分布的主峰峰值判定k-mer的期望深度(即主峰对应的k-mer频数)。</li>
<li>根据k-mer的期望深度和k-mer的总数估计基因组大小。</li>
<li>根据低频k-mer估计数据错误率，并修正基因组大小的估计。</li>
<li>根据k-mer的其他峰估计k-mer的杂合度和重复序列比例。</li>
</ol>
<h2 id="2-3-k-mer原理"><a href="#2-3-k-mer原理" class="headerlink" title="2.3. k-mer原理"></a>2.3. k-mer原理</h2><p>k-mer分析应用的前提假设是测序的reads是随机分布在基因组上的。</p>
<p>首先定义几个变量，方便解释原理：</p>
<ul>
<li>基因组大小：G</li>
<li>read读长：L</li>
<li>reads总条数：n</li>
<li>k-mer长度：K</li>
</ul>
<h3 id="2-3-1-碱基深度分布"><a href="#2-3-1-碱基深度分布" class="headerlink" title="2.3.1. 碱基深度分布"></a>2.3.1. 碱基深度分布</h3><ol>
<li>单条read测序覆盖到某一个碱基的概率：$L&#x2F;G$。</li>
<li>因为L&#x2F;G很小，n很大，每个碱基覆盖深度服从泊松分布。</li>
<li>则每个碱基的覆盖深度的期望为：$d&#x3D;(L&#x2F;G)*n$。</li>
</ol>
<h3 id="2-3-2-k-mer深度分布"><a href="#2-3-2-k-mer深度分布" class="headerlink" title="2.3.2. k-mer深度分布"></a>2.3.2. k-mer深度分布</h3><ol>
<li>一个大小为G的基因组可以产生的k-mer种类约为G。</li>
</ol>
<ul>
<li>假设一个基因组产生的K都是unique的，从一个大小为G的基因组可以得到$(G-K+1)$种不同的k-mer。</li>
<li>一般而言，基因组大小G在几百Mb或者Gb为单位，远大于K和1，所以K和1可以忽略不计，约等于G种k-mer。</li>
</ul>
<ol start="2">
<li>单条read测序完全覆盖某种k-mer的概率：$(L-K+1)&#x2F;G$。</li>
</ol>
<ul>
<li>k-mer种类的总数约为G</li>
<li>单条read能产生的k-mer种类数量为$(L-K+1)$。</li>
<li>假设read随机分布在基因组上，单条read测序完全覆盖某种k-mer的概率就为：$(L-K+1)&#x2F;G$。</li>
</ul>
<ol start="3">
<li>同样因为$(L-K+1)&#x2F;G$很小，n很大，每种k-mer的覆盖深度服从泊松分布。</li>
<li>每种k-mer的覆盖深度的期望为：$D&#x3D;((L-K+1)&#x2F;G)*n$。</li>
<li>由此可以得到，基因组大小为：$G&#x3D;(L-K+1)*n&#x2F;D$。</li>
</ol>
<h3 id="2-3-3-基因组大小"><a href="#2-3-3-基因组大小" class="headerlink" title="2.3.3. 基因组大小"></a>2.3.3. 基因组大小</h3><ol>
<li>计算总k-mer个数N和k-mer期望深度D</li>
</ol>
<ul>
<li>对测序reads进行k-mer分割，获得总k-mer个数N。</li>
<li>统计所有分割的k-mer，绘制频数分布图。</li>
<li>理想情况下(不考虑测序错误、序列重复性和杂合序列的条件下)，k-mer的频数分布遵循泊松分布，可以将频数分布峰值的k-mer频数作为k-mer的期望深度D。</li>
</ul>
<ol start="2">
<li>通过下面公式可知，基因组大小$G&#x3D;N&#x2F;D$。</li>
</ol>
<ul>
<li>k-mer的总数量$N&#x3D;(L-K+1)*n$</li>
<li>k-mer的期望深度$D&#x3D;((L-K+1)&#x2F;G)*n$</li>
</ul>
<p>只要通过k-mer分析计算得到k-mer的总数量N和k-mer的期望深度D，则可以算出基因组大小G。</p>
<h3 id="2-3-4-基因组调查"><a href="#2-3-4-基因组调查" class="headerlink" title="2.3.4. 基因组调查"></a>2.3.4. 基因组调查</h3><p>在不考虑测序错误、序列重复性和杂合序列的条件下，k-mer的深度分布遵循泊松分布。但实际情况是三者都存在，所以需要计算错误率，重复序列占比和杂合度，并根据计算结果修正对基因组大小的估计。</p>
<h4 id="2-3-4-1-错误率"><a href="#2-3-4-1-错误率" class="headerlink" title="2.3.4.1. 错误率"></a>2.3.4.1. 错误率</h4><ul>
<li>测序错误：一般认为低频k-mer(K&#x3D;1,2…)是测序错误引起的，去除低频k-mer并计算错误率以修正基因组大小的估计。</li>
<li>一般把拐点前的低频k-mer当作错误去除。</li>
</ul>
<h4 id="2-3-4-2-重复序列占比"><a href="#2-3-4-2-重复序列占比" class="headerlink" title="2.3.4.2. 重复序列占比"></a>2.3.4.2. 重复序列占比</h4><ol>
<li>基因组中存在的重复序列会使对应的k-mer频数高于k-mer期望深度D。</li>
<li>在k-mer频数分布图中重复序列对应的k-mer会表现为频数大于主峰的一个重复峰。</li>
<li>根据主峰右侧的重复峰可以估计基因组的重复序列比例。<ul>
<li>通过模型计算一个阈值，比如阈值为1.6倍主峰，理论上单拷贝序列(非重复序列)出现在1.6倍主峰右边的概率很低，可以把1.6倍主峰之后的看作重复k-mer。</li>
<li>统计重复k-mer的总数量m，从而可以算出：重复序列的大小R&#x3D;重复k-mer的总数量m&#x2F;k-mer的期望深度D。</li>
<li>R&#x2F;G即为重复序列占基因组的比例。</li>
</ul>
</li>
</ol>
<h4 id="2-3-4-3-杂合度"><a href="#2-3-4-3-杂合度" class="headerlink" title="2.3.4.3. 杂合度"></a>2.3.4.3. 杂合度</h4><ol>
<li>基因组中存在的杂合序列会对应两种类型的k-mer，并使得这些k-mer频数低于k-mer期望深度D。</li>
<li>假设两种k-mer数量大致相等，在k-mer频数分布图中杂合序列对应的k-mer会表现为频数约为主峰一半的一个杂合峰。</li>
<li>根据主峰左侧的杂合峰可以估计基因组的杂合度。<ul>
<li>假设基因组中的杂合率为 h（每个碱基为杂合点的概率）,一个k-mer是纯合k-mer的概率为 $P1 &#x3D; (1-h)^k$, 则是杂合的概率 $P2 &#x3D; 1-P1 &#x3D; 1-(1-h)^k$。</li>
<li>假设产生的k-mer种类的总数为M，其中属于单拷贝序列(非重复序列)的k-mer种类。</li>
<li>在二倍体中，单拷贝序列(非重复序列)的同源区域，会产生 U×P2 的杂合k-mer，这个数是可以通过计算得到的：只要统计非重复k-mer的总数 M , M-U即为产生的杂合k-mer数。则 $M-U &#x3D; U×P2 &#x3D; U×(1-(1-h)^k)$。</li>
<li>通过计算，即可通过M和U的值得到基因组的杂合率h。</li>
</ul>
</li>
</ol>
<p>在实际应用过程中，估计了基因组的错误率、杂合度和重复序列比例后，重新修正基因组大小的估计，从而得到基因组调查的结果。</p>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/omics_genome.survey_GenomeScope1.0.png?raw=true" width=70% title="k-mer分析(软件GenomeScope)结果示例" align=center/>

<p><strong><p align="center">Figure 2. k-mer分析(GenomeScope)结果示例</p></strong></p>
<h2 id="2-4-k-mer用途"><a href="#2-4-k-mer用途" class="headerlink" title="2.4. k-mer用途"></a>2.4. k-mer用途</h2><p>许多分析都会用到k-mer的处理方法，把测序得到的reads通过截取k-mer后用于分析。</p>
<p>比如评估基因组特征，组装基因组，物种样品污染评估等。评估基因组特征(genome survey)包括评估基因组大小(size)，杂合度，重复序列比例等。</p>
<ol>
<li><p>组装基因组<br>组装基因组使用k-mer的目的主要是去除低频率的k-mer以提高组装结果准确性。</p>
</li>
<li><p>评估基因组大小(size)<br>在不考虑测序错误、序列重复性的条件下，k-mer的深度分布遵循泊松分布，可以将深度分布曲线的峰值作为期望测序深度。</p>
</li>
</ol>
<p>在k-mer原理部分解释了用k-mer评估基因组大小的公式：</p>
<p>$$基因组大小G&#x3D;总k-mer数量N&#x2F;k-mer期望深度D$$</p>
<ol start="3">
<li><p>评估基因组杂合度<br>根据k-mer频数分布图的杂合峰，可以估计基因组的杂合度。</p>
</li>
<li><p>评估基因组重复序列比例<br>根据k-mer频数分布图的重复峰，可以估计基因组的重复序列比例。</p>
</li>
<li><p>评估物种样品污染<br>根据k-mer频数分布图，可以评估测序样品污染情况。</p>
</li>
</ol>
<ul>
<li>如果k-mer频数分布图出现两个明显的峰，但两个峰的横坐标又不是二倍关系，那就可能是DNA污染导致的。</li>
<li>因为一个物种的杂合峰的频数约为主峰的一半，重复峰的频数约为主峰的两倍。</li>
<li>如果DNA中存在两个物种的样品(即有污染)，期望会出现对应的两个峰，且两个峰的横坐标之间也非两倍的关系，由此可以初步判定该测序样本存在污染。</li>
<li>至于具体是因为什么物种造成污染，则可以通过blast比对nr库进行简单的判断。</li>
</ul>
<p>除了通过k-mer频数分布评估DNA样品的污染程度外，还可以通过GC含量分布图判断，查看图中是否存在多个密度集中的类群。</p>
<h2 id="2-5-k-mer的优势和局限"><a href="#2-5-k-mer的优势和局限" class="headerlink" title="2.5. k-mer的优势和局限"></a>2.5. k-mer的优势和局限</h2><ol>
<li>增加准确率</li>
</ol>
<ul>
<li>二代测序的准确率已达到99.9%，但测序量非常大时，错误碱基的绝对数量(比如10亿碱基里错误碱基数量会达到1000万个)还是会对分析有很大的影响。</li>
<li>由于测序错误具有随机性，通过将reads切割产生的k-mer中，测序错误生成的k-mer绝大多数都是测序物种中不存在的k-mer，因此都只出现1次(或很少的几次)，要是将这些低频的k-mer去掉，就有较大可能去除测序错误，从而使得分析(基因组调查，组装基因组)结果更可靠。</li>
</ul>
<ol start="2">
<li>不适用过于复杂的基因组</li>
</ol>
<ul>
<li>k-mer分析适用于分析唯一主峰区域所占比例较大的基因组。</li>
<li>当基因组杂合非常高或者重复序列比例非常大时，其影响可能导致无法通过k-mer分析正确估计基因组大小。</li>
</ul>
<h2 id="2-6-k-mer的选择"><a href="#2-6-k-mer的选择" class="headerlink" title="2.6. k-mer的选择"></a>2.6. k-mer的选择</h2><h3 id="2-6-1-k-mer的大小选择"><a href="#2-6-1-k-mer的大小选择" class="headerlink" title="2.6.1. k-mer的大小选择"></a>2.6.1. k-mer的大小选择</h3><ol>
<li>K应该足够大到k-mer可以映射到基因组的唯一位置。</li>
<li>太大的k-mer会降低去除低频k-mer代表的错误碱基的概率(增加错误率)，也会降低k-mer深度(使得k-mer频数分布的峰不明显)，而且大的k-mer会增加计算资源的使用。</li>
<li>基因组调查一般选17，21比较常见。</li>
</ol>
<h3 id="2-6-2-选择k-mer的考虑"><a href="#2-6-2-选择k-mer的考虑" class="headerlink" title="2.6.2. 选择k-mer的考虑"></a>2.6.2. 选择k-mer的考虑</h3><ol>
<li>k-mer只能是奇数？</li>
</ol>
<ul>
<li>把k-mer设置成奇数是为了防止通过k-mer组装时，正反链混淆。</li>
<li>偶数的k-mer的反向互补序列常常与自身一样，从而组装k-mer时会混淆正反链的组装，奇数的k-mer就不存在这个问题。</li>
</ul>
<ol start="2">
<li>k-mer的长度代表了可能存在的k-mer种类的数量(4的K次方)，越长的k-mer片段映射的物种特异性越强。基因组越大，需要的k-mer越长。</li>
<li>当基因组中有较多重复序列时，可以用较大的k-mer来跨过高重复的区域，从而获得更加准确及完整的基因组草图；</li>
<li>由于reads上的碱基错误率的存在，选择较长的k-mer会带来较高的错误率，这也可以加大测序深度来弥补。</li>
<li>如果是用于组装基因组，为了得到更加完整的基因组，要尽可能使用较长的k-mer用于组装。</li>
</ol>
<h1 id="3-k-mer分析软件"><a href="#3-k-mer分析软件" class="headerlink" title="3. k-mer分析软件"></a>3. k-mer分析软件</h1><h2 id="3-1-k-mer分析软件简介"><a href="#3-1-k-mer分析软件简介" class="headerlink" title="3.1. k-mer分析软件简介"></a>3.1. k-mer分析软件简介</h2><p>k-mer分析分为<strong>k-mer频数统计</strong>和<strong>基因组特征评估</strong>两步。此外，Smudgeplot还可以用k-mer分析评估物种的倍性。</p>
<ol>
<li>jellyfish</li>
</ol>
<ul>
<li>jellyfish可以实现第一步k-mer频数统计。</li>
<li>特点是使用Hash表存储数据，能多线程运行；速度快，内存消耗小。</li>
</ul>
<ol start="2">
<li>KMC</li>
</ol>
<ul>
<li>KMC可以实现第一步k-mer频数统计。</li>
</ul>
<ol start="3">
<li>GenomeScope</li>
</ol>
<ul>
<li>GenomeScope可以实现第二步，利用k-mer频数统计结果进行基因组特征评估。</li>
<li>1.0版本用于二倍体物种，2.0版本用于多倍体物种。</li>
</ul>
<ol start="4">
<li>KAT(The k-mer Analysis Toolkit)</li>
</ol>
<ul>
<li>KAT(The k-mer Analysis Toolkit)可以实现k-mer频数统计和基因组特征评估两步。</li>
<li>包含多个工具来帮助用户通过使用k-mer对测序数据进行简单分析，如组装完整性、测序错误、是否有污染等。</li>
</ul>
<ol start="5">
<li>GCE</li>
</ol>
<ul>
<li>GCE可以分别实现k-mer频数统计和基因组特征评估两步。</li>
</ul>
<ol start="6">
<li>KmerGenie</li>
</ol>
<ul>
<li>KmerGenie可以同时实现k-mer频数统计和基因组特征评估两步。</li>
<li>最大优点在于可以实现在多个预设k-mer下的自动分析，除了进行常规的k-mer频数统计之外，还能够基于不同k-mer自动计算基因组大小，并为基因组组装评估一个最佳组装k-mer数值作为备选。</li>
</ul>
<h2 id="3-2-一些使用软件的经验总结"><a href="#3-2-一些使用软件的经验总结" class="headerlink" title="3.2. 一些使用软件的经验总结"></a>3.2. 一些使用软件的经验总结</h2><ul>
<li>【推荐】用Smudgeplot评估物种倍性后，用组合jellyfish+GenomeScope1.0做二倍体物种的基因组调查，用组合KMC+GenomeScope2.0做多倍体物种的基因组调查。</li>
<li>k-mer长度常用17&#x2F;21。</li>
<li>软件KmerGenie，GCE和jellyfish获取的频数分布表，都可用于软件genomescope和GCE第二步骤的分析。</li>
<li>由于GCE第一步骤支持的最大k-mer频数为255，大于255的数据被合并；而jellyfish统计到10000行，预估结果会更为准确。</li>
<li>GenomeScope对于高重复序列的基因组统计的基因组大小会偏小，建议max kmer coverage设置大一点，大于等于10000。</li>
<li>有些软件有另一个参数需注意和设定，单倍体模式还是杂合模式，可以两种模式都分析，查看差别。</li>
<li>实践经验发现，k-mer值设置得越高，估计出来的基因组size会越大；</li>
<li>另外，在jellyfish里的jellyfish histo统计频数分布时，用参数-h 10000把统计上限调高，以及在GenomeScope阶段，Max kmer coverage设置的大一些(即统计进的kmer数量越多)，估算出来的基因组大小也会略大一些。</li>
</ul>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li>wiki_k-mer: <a href="https://en.wikipedia.org/wiki/k-mer">https://en.wikipedia.org/wiki/k-mer</a></li>
<li>genome survey：<a href="https://xuzhougeng.top/archives/genome-survey-using-kmers">https://xuzhougeng.top/archives/genome-survey-using-kmers</a></li>
<li>xuzhougeng’s blog：<a href="https://www.jianshu.com/p/85de8f025899">https://www.jianshu.com/p/85de8f025899</a></li>
<li>k-mer与基因组组装：<a href="https://cloud.tencent.com/developer/article/1613847">https://cloud.tencent.com/developer/article/1613847</a></li>
<li>k-mer分析和原理：<a href="https://www.bbsmax.com/A/lk5aQMxP51/">https://www.bbsmax.com/A/lk5aQMxP51/</a></li>
<li>jellyfish paper：<a href="https://academic.oup.com/bioinformatics/article/27/6/764/234905?login=true">https://academic.oup.com/bioinformatics/article/27/6/764/234905?login=true</a></li>
<li>jellyfish github：<a href="https://github.com/gmarcais/Jellyfish">https://github.com/gmarcais/Jellyfish</a></li>
<li>GenomeScope1.0 github：<a href="https://github.com/schatzlab/genomescope">https://github.com/schatzlab/genomescope</a></li>
<li>KAT github：<a href="https://github.com/TGAC/KAT">https://github.com/TGAC/KAT</a></li>
<li>GCE github：<a href="https://github.com/fanagislab/GCE">https://github.com/fanagislab/GCE</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>genome survey</category>
      </categories>
      <tags>
        <tag>genome survey</tag>
        <tag>genome</tag>
        <tag>k-mer</tag>
        <tag>jellyfish</tag>
        <tag>KMC</tag>
        <tag>GenomeScope</tag>
        <tag>Smudgeplot</tag>
        <tag>KAT</tag>
        <tag>GCE</tag>
        <tag>KmerGenie</tag>
      </tags>
  </entry>
  <entry>
    <title>用k-mer分析进行基因组调查：（二）用Smudgeplot估计倍性</title>
    <url>/2022/12/31/omics_genome.survey_02.Smudgeplot/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=276895&auto=1&height=32"></iframe> </div>

<p><strong>用k-mer分析进行基因组调查系列：</strong></p>
<ul>
<li>（一）基本原理：<a href="https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/">https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/</a></li>
<li>（二）用Smudgeplot估计倍性：<a href="https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/">https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/</a></li>
<li>（三）用jellyfish进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/">https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/</a></li>
<li>（四）用KMC进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/</a></li>
<li>（五）用GenomeScope评估基因组特征：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/</a></li>
<li>（六）用GCE分步实现：<a href="https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/">https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/</a></li>
<li>（七）用KmerGenie一步实现：<a href="https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/">https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/</a></li>
</ul>
<p><strong>【推荐】用Smudgeplot评估物种倍性后，用组合jellyfish+GenomeScope1.0做二倍体物种的基因组调查，用组合KMC+GenomeScope2.0做多倍体物种的基因组调查。</strong></p>
<h1 id="1-Smudgeplot"><a href="#1-Smudgeplot" class="headerlink" title="1. Smudgeplot"></a>1. Smudgeplot</h1><p>Smudgeplot是2020年与GenomeScope2.0一起发表的用于估计物种的倍性的软件。开发者计划接下来把Smudgeplot整合进GenomeScope。</p>
<h1 id="2-Smudgeplot原理"><a href="#2-Smudgeplot原理" class="headerlink" title="2. Smudgeplot原理"></a>2. Smudgeplot原理</h1><p>Smudgeplot从k-mer数据库中提取杂合k-mer对，然后训练杂合k-mer对。</p>
<p>通过比较k-mer对覆盖度的总数(CovA + CovB)和相对覆盖度(CovB &#x2F; (CovA + CovB))，统计杂合k-mers对的数量，Smudgeplot可以解析基因组结构。</p>
<h1 id="3-Smudgeplot安装"><a href="#3-Smudgeplot安装" class="headerlink" title="3. Smudgeplot安装"></a>3. Smudgeplot安装</h1><ol>
<li>依赖<br>依赖是<a href="https://github.com/tbenavi1/KMC">tbenavi1&#x2F;KMC</a>和<a href="https://github.com/tbenavi1/genomescope2.0">GenomeScope2.0</a>。</li>
</ol>
<ul>
<li>用于统计k-mers频数的软件。建议<a href="https://github.com/tbenavi1/KMC">tbenavi1&#x2F;KMC</a>，里面包括一个smudge_pairs程序，用来找杂合k-mer对。也可以用jellyfish代替KMC，参考<a href="https://github.com/KamilSJaron/smudgeplot/wiki/manual-of-smudgeplot-with-jellyfish">manual of smudgeplot with jellyfish</a>。</li>
<li><a href="https://github.com/tbenavi1/genomescope2.0">GenomeScope2.0</a></li>
</ul>
<ol start="2">
<li>安装<br><code>conda install -c bioconda smudgeplot</code> #conda安装</li>
</ol>
<h1 id="4-Smudgeplot使用"><a href="#4-Smudgeplot使用" class="headerlink" title="4. Smudgeplot使用"></a>4. Smudgeplot使用</h1><h2 id="4-1-KMC-Smudgeplot"><a href="#4-1-KMC-Smudgeplot" class="headerlink" title="4.1. KMC+Smudgeplot"></a>4.1. KMC+Smudgeplot</h2><h3 id="4-1-1-用KMC计算k-mer频率，生成k-mer频率表"><a href="#4-1-1-用KMC计算k-mer频率，生成k-mer频率表" class="headerlink" title="4.1.1. 用KMC计算k-mer频率，生成k-mer频率表"></a>4.1.1. 用KMC计算k-mer频率，生成k-mer频率表</h3><ol>
<li><p>运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir tmp</span><br><span class="line">ls *.fastq.gz &gt; FILES</span><br><span class="line">kmc -k21 -t8 -m64 -ci1 -cs10000 @FILES kmcdb tmp #计算k-mer频率，生成二进制文件kmcdb.kmc_pre和kmcdb.kmc_suf</span><br><span class="line">kmc_tools transform kmcdb histogram kmcdb_k21.hist -cx10000 #生成k-mer频数直方表kmcdb_k21.hist</span><br><span class="line">rm -rf tmp</span><br></pre></td></tr></table></figure>
</li>
<li><p>kmc命令参数：</p>
</li>
</ol>
<ul>
<li>-k21：k-mer长度设置为21</li>
<li>-t8：线程8</li>
<li>-m64：内存64G，设置使用RAM的大致数量，范围1-1024。</li>
<li>-ci1 -cs10000：统计k-mer coverages覆盖度范围在[1-10000]的。</li>
<li>@FILES：保存了输入文件列表的文件名为FILES</li>
<li>kmcdb：KMC数据库的输出文件名前缀</li>
<li>tmp：临时目录</li>
</ul>
<ol start="3">
<li>kmc_tools命令参数：</li>
</ol>
<ul>
<li>-cx10000：储存在直方图文件中counter的最大值。</li>
</ul>
<h3 id="4-1-2-选择覆盖阈值"><a href="#4-1-2-选择覆盖阈值" class="headerlink" title="4.1.2. 选择覆盖阈值"></a>4.1.2. 选择覆盖阈值</h3><ul>
<li>可以目视检查k-mer直方图，选择覆盖阈值上(U)下(L)限。</li>
<li>也可以用命令估计覆盖阈值上(U)下(L)限。L的取值范围是[20-200]，U的取值范围是[500-3000]。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L=$(smudgeplot.py cutoff kmcdb_k21.hist L)</span><br><span class="line">U=$(smudgeplot.py cutoff kmcdb_k21.hist U)</span><br><span class="line">echo $L $U # these need to be sane values</span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-提取阈值范围的k-mers，计算k-mer-pairs"><a href="#4-1-3-提取阈值范围的k-mers，计算k-mer-pairs" class="headerlink" title="4.1.3. 提取阈值范围的k-mers，计算k-mer pairs"></a>4.1.3. 提取阈值范围的k-mers，计算k-mer pairs</h3><ol>
<li>smudge_pairs</li>
</ol>
<ul>
<li>用<code>kmc_tools</code>提取k-mers，然后用KMC的<code>smudge_pairs</code>计算k-mer pairs。</li>
<li><code>smudge_pairs</code>比<code>smudgeplot.py hetkmers</code>使用更少内存，速度更快地寻找杂合k-mer pairs。<ul>
<li><code>kmc_tools transform kmcdb -ci&quot;$L&quot; -cx&quot;$U&quot; reduce kmcdb_L&quot;$L&quot;_U&quot;$U&quot;</code> 根据L和U过滤，生成二进制文件kmcdb_L10_U680.kmc_pre和kmcdb_L10_U680.kmc_suf</li>
<li><code>smudge_pairs kmcdb_L&quot;$L&quot;_U&quot;$U&quot; kmcdb_L&quot;$L&quot;_U&quot;$U&quot;_coverages.tsv kmcdb_L&quot;$L&quot;_U&quot;$U&quot;_pairs.tsv &gt; kmcdb_L&quot;$L&quot;_U&quot;$U&quot;_familysizes.tsv</code></li>
</ul>
</li>
</ul>
<ol start="2">
<li>smudgeplot.py</li>
</ol>
<ul>
<li>如果没有安装KMC，可以用<code>kmc_dump</code>提取k-mers。</li>
<li>然后用<code>smudgeplot.py hetkmers</code>计算k-mer pairs。</li>
<li><code>kmc_tools transform kmcdb -ci&quot;$L&quot; -cx&quot;$U&quot; dump -s kmcdb_L&quot;$L&quot;_U&quot;$U&quot;.dump #生成kmcdb_L10_U680.dump</code></li>
<li><code>smudgeplot.py hetkmers -o kmcdb_L&quot;$L&quot;_U&quot;$U&quot; &lt; kmcdb_L&quot;$L&quot;_U&quot;$U&quot;.dump # 生成kmcdb_L10_U680_coverages.tsv和kmcdb_L10_U680_sequences.tsv，耗时约1h</code></li>
</ul>
<h3 id="4-1-4-生成热度图-smudgeplot"><a href="#4-1-4-生成热度图-smudgeplot" class="headerlink" title="4.1.4. 生成热度图(smudgeplot)"></a>4.1.4. 生成热度图(smudgeplot)</h3><ol>
<li>命令<br><code>smudgeplot.py plot kmcdb_L&quot;$L&quot;_U&quot;$U&quot;_coverages.tsv -o smudgeplot</code></li>
</ol>
<ul>
<li>-o指定输出文件前缀，默认smudgeplot</li>
<li>-t指定图中的title</li>
</ul>
<ol start="2">
<li>结果</li>
</ol>
<ul>
<li>生成两个基础的热度图。一个log尺度smudgeplot_smudgeplot_log10.png；一个线性尺度smudgeplot_smudgeplot.png</li>
<li>smudgeplot_summary_table.tsv，下面是文件示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">peak	kmers [#]	kmers [proportion]	summit B / (A + B)	summit A + B</span><br><span class="line">AB	10703792	1	0.49	44.2</span><br></pre></td></tr></table></figure>

<ul>
<li>smudgeplot_verbose_summary.txt，下面是文件示例：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1n coverage estimates (Coverage of every haplotype; Don&#x27;t confuse with genome coverage whichis (ploidy * 1n coverage).)</span><br><span class="line">* User defined 1n coverage:</span><br><span class="line">* Subset 1n coverage estimate:	16.4</span><br><span class="line">* Highest peak 1n coverage estimate:	23.1</span><br><span class="line">1n coverage used in smudgeplot (one of the three above):	23.1</span><br><span class="line">* Proposed ploidy:	2</span><br><span class="line">* Minimal number of heterozygous loci:	509705</span><br><span class="line">Note: This number is NOT an estimate of the total number heterozygous loci, it&#x27;s merly setting the lower boundary if the inference of heterozygosity peaks is correct.</span><br><span class="line">* Proportion of heterozygosity carried by pairs in different genome copies (table)</span><br><span class="line">  genome_copies propotion_of_heterozygosity</span><br><span class="line">1             2                           1</span><br><span class="line">* Proportion of heterozygosity carried by paralogs:	0</span><br><span class="line">* Summary of all detected peaks (table)</span><br><span class="line">  peak kmers [#] kmers [proportion] summit B / (A + B) summit A + B</span><br><span class="line">2   AB  10703792                  1               0.49         44.2</span><br></pre></td></tr></table></figure>

<ul>
<li>smudgeplot_warnings.txt</li>
</ul>
<h2 id="4-2-jellyfish-Smudgeplot"><a href="#4-2-jellyfish-Smudgeplot" class="headerlink" title="4.2. jellyfish+Smudgeplot"></a>4.2. jellyfish+Smudgeplot</h2><p>用jellyfish代替KMC</p>
<ol>
<li><p>用jellyfish计算k-mer频率，生成k-mer频率表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jellyfish count -C -m 21 -s 1000000000 -t 8 *.fastq -o kmer_counts.jf</span><br><span class="line">jellyfish histo kmer_counts.jf &gt; kmer_k21.hist</span><br></pre></td></tr></table></figure>
</li>
<li><p>提取阈值范围的k-mers，计算k-mer pairs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L=$(smudgeplot.py cutoff kmer_k21.hist L)</span><br><span class="line">U=$(smudgeplot.py cutoff kmer_k21.hist U)</span><br><span class="line">echo $L $U</span><br><span class="line">jellyfish dump -c -L $L -U $U kmer_counts.jf | smudgeplot.py hetkmers -o kmer_pairs</span><br><span class="line"># note that if you would like use --middle flag, you would have to sort the jellyfish dump first</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成smudgeplot污热度图</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smudgeplot.py plot kmer_pairs_coverages_2.tsv -o my_genome</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="4-3-Smudgeplot结果"><a href="#4-3-Smudgeplot结果" class="headerlink" title="4.3. Smudgeplot结果"></a>4.3. Smudgeplot结果</h2><ol>
<li>热度图</li>
</ol>
<ul>
<li>热度图，横坐标是相对覆盖度 (CovB &#x2F; (CovA + CovB)) ，纵坐标是总覆盖度 (CovA + CovB) ，颜色是k-mer对的频率。</li>
<li>每个单倍型结构都在图上呈现一个”污点(smudge)”，污点的热度表示单倍型结构在基因组中出现的频率，频率最高的单倍型结构即为预测的物种倍性结果。(比如这个图提供了三倍体的证据，AAB的频率最高)</li>
</ul>
<img src="https://user-images.githubusercontent.com/8181573/45959760-f1032d00-c01a-11e8-8576-ff0512c33da9.png" width=80% title="Smudgeplot热度图" align=center/>

<p><strong><p align="center">Figure 5. Smudgeplot热度图。<br>图片来源： <a href="https://github.com/KamilSJaron/smudgeplot">Smudgeplot github</a></p></strong></p>
<ol start="2">
<li>smudgeplot_verbose_summary.txt</li>
</ol>
<ul>
<li>文件中可以提取预测的最终倍性结果：“* Proposed ploidy:    2”</li>
</ul>
<h1 id="5-KMC-x2F-jellyfish结果用于GenomeScope进行基因组调查"><a href="#5-KMC-x2F-jellyfish结果用于GenomeScope进行基因组调查" class="headerlink" title="5. KMC&#x2F;jellyfish结果用于GenomeScope进行基因组调查"></a>5. KMC&#x2F;jellyfish结果用于GenomeScope进行基因组调查</h1><ul>
<li>通过KMC&#x2F;jellyfish获得的频数分布表结果kmcdb_k21.hist可用于GenomeScope进行基因组调查</li>
</ul>
<p><code>Rscript genomescope.R kmcdb_k21.hist &lt;k-mer_length&gt; &lt;read_length&gt; &lt;output_dir&gt; [kmer_max] [verbose]</code></p>
<h1 id="6-批量运行脚本"><a href="#6-批量运行脚本" class="headerlink" title="6. 批量运行脚本"></a>6. 批量运行脚本</h1><p>如果样品数量非常多，可以用脚本自动遍历每个样品来运行。</p>
<p>把样品名称整理成样品列表（sample.list），修改下面脚本中的&#x2F;path&#x2F;to&#x2F;data&#x2F;为数据所在路径，即可运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for i in sample.list</span><br><span class="line">do</span><br><span class="line">	mkdir $i</span><br><span class="line">	cd $i</span><br><span class="line">    mkdir tmp</span><br><span class="line"></span><br><span class="line">    # 运行KMC，获得频数分布表sample_k21.hist</span><br><span class="line">	ls /path/to/data/$i* &gt; FILES</span><br><span class="line">	kmc -k21 -t8 -m64 -ci1 -cs10000 @FILES $i tmp</span><br><span class="line">	kmc_tools transform $i histogram &quot;$i&quot;_k21.hist -cx10000</span><br><span class="line">    rm -rf tmp</span><br><span class="line"></span><br><span class="line">    # 运行genomescope2.0，估计基因组特征（默认是二倍体-p 2）</span><br><span class="line">	genomescope.R -i &quot;$i&quot;_k21.hist -o ./ -k 21 -n &quot;$i&quot;_genomescope -p 2 &gt;&quot;$i&quot;_genomescope.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">    # 运行smudgeplot，估计</span><br><span class="line">	L=$(smudgeplot.py cutoff &quot;$&#123;i&#125;&quot;_k21.hist L)</span><br><span class="line">	U=$(smudgeplot.py cutoff &quot;$&#123;i&#125;&quot;_k21.hist U)</span><br><span class="line">	echo $L $U</span><br><span class="line">	kmc_tools transform $i -ci&quot;$L&quot; -cx&quot;$U&quot; dump -s &quot;$i&quot;_L&quot;$L&quot;_U&quot;$U&quot;.dump</span><br><span class="line">	smudgeplot.py hetkmers -o &quot;$i&quot;_L&quot;$L&quot;_U&quot;$U&quot; &lt; &quot;$i&quot;_L&quot;$L&quot;_U&quot;$U&quot;.dump # 耗时步骤，约1h</span><br><span class="line">	smudgeplot.py plot &quot;$i&quot;_L&quot;$L&quot;_U&quot;$U&quot;_coverages.tsv -o $i -t $i</span><br><span class="line">	cd ..</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h1 id="7-references"><a href="#7-references" class="headerlink" title="7. references"></a>7. references</h1><ol>
<li>GenomeScope 2.0 + Smudgeplot paper：<a href="https://www.nature.com/articles/s41467-020-14998-3">https://www.nature.com/articles/s41467-020-14998-3</a></li>
<li>Smudgeplot github：<a href="https://github.com/KamilSJaron/smudgeplot">https://github.com/KamilSJaron/smudgeplot</a></li>
<li>genomescope2.0 github：<a href="https://github.com/tbenavi1/genomescope2.0">https://github.com/tbenavi1/genomescope2.0</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>genome survey</category>
      </categories>
      <tags>
        <tag>genome survey</tag>
        <tag>genome</tag>
        <tag>k-mer</tag>
        <tag>KMC</tag>
        <tag>GenomeScope</tag>
        <tag>Smudgeplot</tag>
      </tags>
  </entry>
  <entry>
    <title>用k-mer分析进行基因组调查：（四）用KMC进行k-mer频数统计</title>
    <url>/2022/06/05/omics_genome.survey_04.KMC/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=283101&auto=1&height=32"></iframe></div>

<p><strong>用k-mer分析进行基因组调查系列：</strong></p>
<ul>
<li>（一）基本原理：<a href="https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/">https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/</a></li>
<li>（二）用Smudgeplot估计倍性：<a href="https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/">https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/</a></li>
<li>（三）用jellyfish进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/">https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/</a></li>
<li>（四）用KMC进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/</a></li>
<li>（五）用GenomeScope评估基因组特征：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/</a></li>
<li>（六）用GCE分步实现：<a href="https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/">https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/</a></li>
<li>（七）用KmerGenie一步实现：<a href="https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/">https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/</a></li>
</ul>
<p><strong>【推荐】用Smudgeplot评估物种倍性后，用组合jellyfish+GenomeScope1.0做二倍体物种的基因组调查，用组合KMC+GenomeScope2.0做多倍体物种的基因组调查。</strong></p>
<h1 id="1-k-mer进行基因组调查的软件概况"><a href="#1-k-mer进行基因组调查的软件概况" class="headerlink" title="1. k-mer进行基因组调查的软件概况"></a>1. k-mer进行基因组调查的软件概况</h1><p>k-mer进行基因组调查分为<strong>k-mer频数统计</strong>和<strong>基因组特征评估</strong>两步。</p>
<ul>
<li>KMC可以实现第一步k-mer频数统计。</li>
<li>KMC的结果sample.histo可以用在GenomeScope上，实现第二步基因组特征评估。</li>
</ul>
<h1 id="2-KMC-简介"><a href="#2-KMC-简介" class="headerlink" title="2. KMC 简介"></a>2. KMC 简介</h1><ul>
<li>KMC是一个用来从FASTQ&#x2F;FASTA文件中计算k-mers的基于KMC二进制数据库的程序。</li>
<li>KMC是波兰的Silesian University of Technology的算法和软件学院的<a href="https://refresh-bio.github.io/">REFRESH Bioinformatics Group</a>开发的工具。</li>
<li>2017年发布了第三个版本，KMC3。</li>
<li>KMC是主要基于C语言的程序。</li>
</ul>
<h1 id="3-KMC-安装"><a href="#3-KMC-安装" class="headerlink" title="3. KMC 安装"></a>3. KMC 安装</h1><ol>
<li>版本<br>有两个版本的KMC，一般使用第一个版本，Smudgeplot评估物种倍性时用到了第二个版本。</li>
</ol>
<ul>
<li>一个是<a href="https://refresh-bio.github.io/">REFRESH Bioinformatics Group</a>的<a href="https://github.com/refresh-bio/KMC">refresh-bio&#x2F;KMC</a>。</li>
<li>一个是GenomeScope2.0的开发团队tbenavi1修改的<a href="https://github.com/tbenavi1/KMC">tbenavi1&#x2F;KMC</a></li>
</ul>
<ol start="2">
<li>下载<br>在<a href="https://github.com/refresh-bio/KMC/releases">KMC download</a>找对应系统的最新版本KMC软件，下载解压缩即可使用。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir KMC &amp;&amp; cd KMC</span><br><span class="line">wget https://github.com/refresh-bio/KMC/releases/download/v3.2.1/KMC3.2.1.linux.tar.gz #下载最新版本的KMC</span><br><span class="line">tar -xzf KMC3.2.1.linux.tar.gz #解压缩和解包，生成bin文件夹和include文件夹</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用<br>解压缩后bin目录下会包含可执行文件，可直接使用，建议加入环境变量，包括：</li>
</ol>
<ul>
<li>bin&#x2F;kmc：计算k-mer频数的主程序</li>
<li>bin&#x2F;kmc_dump：在kmc生成数据库中列出k-mers的程序</li>
<li>bin&#x2F;kmc_tools：允许操作kmc数据库的程序</li>
</ul>
<h1 id="4-KMC-运行"><a href="#4-KMC-运行" class="headerlink" title="4. KMC 运行"></a>4. KMC 运行</h1><p>用KMC计算k-mer频率，生成k-mer频数直方表和k-mer直方图。</p>
<ol>
<li><p>运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir tmp #创建临时文件夹</span><br><span class="line">ls *.fastq.gz &gt; FILES #用于分析的clean reads路径保存到文件FILES中</span><br><span class="line">kmc -k21 -t16 -m64 -ci1 -cs10000 @FILES kmcdb tmp #计算k-mer频率</span><br><span class="line">kmc_tools transform kmcdb histogram sample.histo -cx10000 #生成k-mer频数直方表sample.histo和k-mer直方图</span><br></pre></td></tr></table></figure>
</li>
<li><p>kmc命令参数</p>
</li>
</ol>
<ul>
<li>-k21：k-mer长度设置为21</li>
<li>-t16：线程16</li>
<li>-m64：内存64G，设置使用RAM的大致数量，范围1-1024。</li>
<li>-ci1 -cs10000：统计k-mer coverages覆盖度范围在[1-10000]的。</li>
<li>@FILES：保存了输入文件列表的文件名为FILES</li>
<li>kmcdb：KMC数据库的输出文件名前缀</li>
<li>tmp：临时目录</li>
</ul>
<ol start="3">
<li>kmc_tools命令参数</li>
</ol>
<ul>
<li>-cx10000：储存在直方图文件中counter的最大值。</li>
</ul>
<ol start="4">
<li>结果<br>生成的sample.histo可用于第二步GenomeScope的分析。</li>
</ol>
<h1 id="5-基因组特征评估"><a href="#5-基因组特征评估" class="headerlink" title="5. 基因组特征评估"></a>5. 基因组特征评估</h1><p>获得k-mer频数分布表sample.histo后</p>
<ul>
<li>推荐用<a href="http://qb.cshl.edu/genomescope">GenomeScope1.0</a>或者<a href="http://qb.cshl.edu/genomescope/genomescope2.0/">GenomeScope2.0</a>或者GenomeScope的R脚本来做基因组特征评估和画图。</li>
<li>也可直接用R绘制sample.histo的频率分布直方图&#x2F;频率分布曲线。</li>
</ul>
<h2 id="5-1-GenomeScope-网页版"><a href="#5-1-GenomeScope-网页版" class="headerlink" title="5.1. GenomeScope 网页版"></a>5.1. GenomeScope 网页版</h2><h3 id="5-1-1-GenomeScope1-0-网页版-——-适用于二倍体物种"><a href="#5-1-1-GenomeScope1-0-网页版-——-适用于二倍体物种" class="headerlink" title="5.1.1. GenomeScope1.0 网页版 —— 适用于二倍体物种"></a>5.1.1. GenomeScope1.0 网页版 —— 适用于二倍体物种</h3><ol>
<li>在<a href="http://qb.cshl.edu/genomescope/">GenomeScope1.0 网页版</a>上传前一步获得的k-mer频数分布表sample.histo文件。</li>
<li>设置参数k-mer length为第一步选择的k-mer长度值，这里是17；参数Read length为序列读长，一般为150；最后一个参数Max kmer coverage建议修改成更大的10000，以统计更多的k-mers。</li>
<li>结果显示预估的基因组大小，杂合度，重复率等信息。</li>
</ol>
<h3 id="5-1-2-GenomeScope2-0-网页版-——-适用于多倍体物种"><a href="#5-1-2-GenomeScope2-0-网页版-——-适用于多倍体物种" class="headerlink" title="5.1.2. GenomeScope2.0 网页版 —— 适用于多倍体物种"></a>5.1.2. GenomeScope2.0 网页版 —— 适用于多倍体物种</h3><p><a href="http://qb.cshl.edu/genomescope/genomescope2.0">GenomeScope2.0 网页版</a>也是类似的步骤。</p>
<h2 id="5-2-R绘制"><a href="#5-2-R绘制" class="headerlink" title="5.2. R绘制"></a>5.2. R绘制</h2><ul>
<li>R绘制k-mer频数分布曲线初步查看基因组特征。</li>
<li>获得kmer_plot.png为频数分布曲线，可根据曲线峰值对基因组大小进行计算和预估。</li>
</ul>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#R 脚本示例</span></span><br><span class="line">kmer <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&#x27;sample.histo&#x27;</span><span class="punctuation">)</span></span><br><span class="line">kmer <span class="operator">&lt;-</span> subset<span class="punctuation">(</span>kmer<span class="punctuation">,</span> V1 <span class="operator">&gt;=</span><span class="number">5</span> <span class="operator">&amp;</span> V1 <span class="operator">&lt;=</span><span class="number">500</span><span class="punctuation">)</span> <span class="comment">#对频数范围5-500的数据进行绘制 </span></span><br><span class="line">Frequency <span class="operator">&lt;-</span> kmer<span class="operator">$</span>V1</span><br><span class="line">Number <span class="operator">&lt;-</span> kmer<span class="operator">$</span>V2</span><br><span class="line">png<span class="punctuation">(</span><span class="string">&#x27;kmer_plot.png&#x27;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>Frequency<span class="punctuation">,</span> Number<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&#x27;l&#x27;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&#x27;blue&#x27;</span><span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h1 id="6-references"><a href="#6-references" class="headerlink" title="6. references"></a>6. references</h1><ol>
<li>KMC3 paper：<a href="https://academic.oup.com/bioinformatics/article/33/17/2759/3796399">https://academic.oup.com/bioinformatics/article/33/17/2759/3796399</a></li>
<li>refresh-bio&#x2F;KMC：<a href="https://github.com/refresh-bio/KMC">https://github.com/refresh-bio/KMC</a></li>
<li>tbenavi1&#x2F;KMC github：<a href="https://github.com/tbenavi1/KMC">https://github.com/tbenavi1/KMC</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>genome survey</category>
      </categories>
      <tags>
        <tag>genome survey</tag>
        <tag>genome</tag>
        <tag>k-mer</tag>
        <tag>KMC</tag>
        <tag>GenomeScope</tag>
      </tags>
  </entry>
  <entry>
    <title>用k-mer分析进行基因组调查：（三）用jellyfish进行k-mer频数统计</title>
    <url>/2022/05/27/omics_genome.survey_03.jellyfish/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=283097&auto=1&height=32"></iframe></div>

<p><strong>用k-mer分析进行基因组调查系列：</strong></p>
<ul>
<li>（一）基本原理：<a href="https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/">https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/</a></li>
<li>（二）用Smudgeplot估计倍性：<a href="https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/">https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/</a></li>
<li>（三）用jellyfish进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/">https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/</a></li>
<li>（四）用KMC进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/</a></li>
<li>（五）用GenomeScope评估基因组特征：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/</a></li>
<li>（六）用GCE分步实现：<a href="https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/">https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/</a></li>
<li>（七）用KmerGenie一步实现：<a href="https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/">https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/</a></li>
</ul>
<p><strong>【推荐】用Smudgeplot评估物种倍性后，用组合jellyfish+GenomeScope1.0做二倍体物种的基因组调查，用组合KMC+GenomeScope2.0做多倍体物种的基因组调查。</strong></p>
<h1 id="1-k-mer进行基因组调查的软件"><a href="#1-k-mer进行基因组调查的软件" class="headerlink" title="1. k-mer进行基因组调查的软件"></a>1. k-mer进行基因组调查的软件</h1><p>k-mer进行基因组调查分为<strong>k-mer频数统计</strong>和<strong>基因组特征评估</strong>两步。</p>
<ul>
<li>jellyfish可以实现第一步k-mer频数统计。</li>
<li>jellyfish的结果sample.histo可以用在GenomeScope上，实现第二步基因组特征评估。</li>
</ul>
<h1 id="2-jellyfish-简介"><a href="#2-jellyfish-简介" class="headerlink" title="2. jellyfish 简介"></a>2. jellyfish 简介</h1><p>jellyfish是Center for Bioinformatics and Computational Biology在2011年研发的一款对DNA的k-mers计数的软件，用Hash表储存数据，能多线程运行。</p>
<h1 id="3-jellyfish-安装"><a href="#3-jellyfish-安装" class="headerlink" title="3. jellyfish 安装"></a>3. jellyfish 安装</h1><ol>
<li>conda安装</li>
</ol>
<ul>
<li><code>conda install -c bioconda jellyfish</code> #安装的是v2.2.10</li>
</ul>
<ol start="2">
<li>github安装</li>
</ol>
<ul>
<li>在<a href="https://github.com/gmarcais/Jellyfish">github：jellyfish</a>上通过源码安装。</li>
</ul>
<h1 id="4-jellyfish-运行"><a href="#4-jellyfish-运行" class="headerlink" title="4. jellyfish 运行"></a>4. jellyfish 运行</h1><p>一般先用<code>jellyfish count</code>进行k-mer计数，然后用<code>jellyfish histo</code>对结果进行统计，获得k-mer的频数分布直方表sample.histo。</p>
<h2 id="4-1-count-——-k-mer计数"><a href="#4-1-count-——-k-mer计数" class="headerlink" title="4.1. count —— k-mer计数"></a>4.1. count —— k-mer计数</h2><ol>
<li><p>命令<br><code>jellyfish count -m 17 -s 10G -t 12 -C -o sample.jf &lt;(zcat sample_1.fq.gz) &lt;(zcat sample_2.fq.gz)</code></p>
</li>
<li><p>参数</p>
</li>
</ol>
<ul>
<li>sample_1.clean.fq sample_2.clean.fq：使用的PE reads，不支持压缩格式*.fq.gz输入文件，如果不解压缩，也可以用<code>&lt;(zcat sample_1.fq.gz) &lt;(zcat sample_2.fq.gz)</code>代替<code>sample_1.fq sample_2.fq</code>; 或者使用这种形式<code>zcat *fq.gz | jellyfish count /dev/fd/0</code>，其中<code>/dev/fd/0</code>是进程输入标志，代表管道前结果传递。</li>
<li>-m 17: k-mer长度设置为17bp。如果基因组大小为G(单位是bp)，k-mer长度推荐设置成log(200*G)&#x2F;log(4)。500Mbp的基因组对应约为17，1Gbp的19，10Gbp的21。</li>
<li>-s 1000M：存储用的hash表大小为1000M，这个参数识别单位M(Mbp)和G(Gbp)。若该值不够大，则会生成多个hash文件，以数字区分文件名。最好设置的值大于总的独特的(distinct)k-mer数，这样生成的文件只有一个。如果基因组大小为G，每个reads有一个错误，总共有n条reads，则该值可以设置为[(G + n)&#x2F;0.8]。</li>
<li>-t 12：线程12</li>
<li>-C：对DNA正负链都进行统计，表示考虑DNA正义与反义链，遇到反义kmer时，计入正义kmer频数中。如果是双端测序reads，需要这个参数。</li>
<li>-o sample.jf：结果文件名为sample.jf，会生成k-mer计数文件sample.jf，是hash的二进制文件。</li>
<li>c 7：k-mer的计数结果所占的最大比特数，默认支持的最大数字是2^7&#x3D;128。该值最大，消耗内存越大。</li>
<li>-out-counter-len&#x3D;4：输出的二进制hash文件中的计数结果所占的字节数，一个字节是8比特，则默认支持的最大数字是2^32&#x3D;4.3G。</li>
<li>不推荐用-Q，会将低质量的碱基替换成N。</li>
<li>-L：不输出低于此值的k-mer</li>
<li>-U：不输出高于此值的k-mer</li>
</ul>
<ol start="3">
<li>输出</li>
</ol>
<ul>
<li>sample.jf：hash格式储存的k-mer频数文件</li>
</ul>
<h2 id="4-2-histo-——-统计k-mer频率"><a href="#4-2-histo-——-统计k-mer频率" class="headerlink" title="4.2. histo —— 统计k-mer频率"></a>4.2. histo —— 统计k-mer频率</h2><ol>
<li>命令<br><code>jellyfish histo -t 12 sample.jf &gt; sample.histo</code></li>
</ol>
<p>统计k-mer计数(sample.jf)得到k-mer频数分布直方表(sample.histo)。</p>
<ol start="2">
<li>参数</li>
</ol>
<ul>
<li>-t 12：线程12。</li>
<li>-l 1：x的最小值，默认是1。结果会将小于此值的所有的k-mer的数目作为(x‐1)的值总结到一行。</li>
<li>-h 10000：x的最大值，默认是10000。结果会将大于此值的所有的k-mer的数目作为(x+1)的值总结到一行。</li>
<li>-i 1：x轴取值间隔，每隔该数值取值，默认为1。</li>
</ul>
<ol start="3">
<li>结果</li>
</ol>
<ul>
<li>k-mer频数分布直方表(sample.histo)包含空格分隔的两列数据。</li>
<li>第一列代表k值出现的次数x(x&#x3D;1,2,3…)，第二列是出现了x次的kmer的种类的数量y。</li>
<li>sample.histo的两列即是kmer分布频率直方图的x和y轴的值。</li>
</ul>
<h2 id="4-3-merge-合并【按需选择】"><a href="#4-3-merge-合并【按需选择】" class="headerlink" title="4.3. merge 合并【按需选择】"></a>4.3. merge 合并【按需选择】</h2><p>如果jellyfish count模块输出结果的二进制hash文件有多个，需要将多个hash文件合并，合并到merge.jf。</p>
<p><code>jellyfish merge sample_hash1.jf sample_hash2.jf sample_hash3.jf -o merge.jf</code></p>
<h2 id="4-4-stats-统计【可选】"><a href="#4-4-stats-统计【可选】" class="headerlink" title="4.4. stats 统计【可选】"></a>4.4. stats 统计【可选】</h2><p><code>jellyfish stats sample.jf -o counts_stats.txt</code></p>
<p>可以用stats模块来统计出k-mer总数（Total），特异的k-mer数目（Distinct），只出现过一次的k-mer数量（Unique），频数最高的k-mer数量（Max_count）等信息。</p>
<h1 id="5-基因组特征评估"><a href="#5-基因组特征评估" class="headerlink" title="5. 基因组特征评估"></a>5. 基因组特征评估</h1><p>获得k-mer频数分布表sample.histo后，推荐用<a href="http://qb.cshl.edu/genomescope">GenomeScope1.0</a>或者<a href="http://qb.cshl.edu/genomescope/genomescope2.0/">GenomeScope2.0</a>或者GenomeScope的R脚本来做基因组特征评估和画图。也可直接用R绘制sample.histo的频率分布直方图&#x2F;频率分布曲线。</p>
<h2 id="5-1-GenomeScope-网页版"><a href="#5-1-GenomeScope-网页版" class="headerlink" title="5.1. GenomeScope 网页版"></a>5.1. GenomeScope 网页版</h2><h3 id="5-1-1-GenomeScope1-0-网页版-——-适用于二倍体物种"><a href="#5-1-1-GenomeScope1-0-网页版-——-适用于二倍体物种" class="headerlink" title="5.1.1. GenomeScope1.0 网页版 —— 适用于二倍体物种"></a>5.1.1. GenomeScope1.0 网页版 —— 适用于二倍体物种</h3><ol>
<li>在<a href="http://qb.cshl.edu/genomescope/">GenomeScope1.0 网页版</a>上传前一步获得的k-mer频数分布表sample.histo文件。</li>
<li>设置参数k-mer length为第一步选择的k-mer长度值，这里是17；参数Read length为序列读长，一般为150；最后一个参数Max kmer coverage建议修改成更大的10000，以统计更多的k-mers。</li>
<li>结果显示预估的基因组大小，杂合度，重复率等信息。</li>
</ol>
<h3 id="5-1-2-GenomeScope2-0-网页版-——-适用于多倍体物种"><a href="#5-1-2-GenomeScope2-0-网页版-——-适用于多倍体物种" class="headerlink" title="5.1.2. GenomeScope2.0 网页版 —— 适用于多倍体物种"></a>5.1.2. GenomeScope2.0 网页版 —— 适用于多倍体物种</h3><p><a href="http://qb.cshl.edu/genomescope/genomescope2.0">GenomeScope2.0 网页版</a>也是类似的步骤。</p>
<h2 id="5-2-R绘制"><a href="#5-2-R绘制" class="headerlink" title="5.2. R绘制"></a>5.2. R绘制</h2><p>R绘制k-mer频数分布曲线初步查看基因组特征。<br>获得kmer_plot.png为频数分布曲线，可根据曲线峰值对基因组大小进行计算和预估。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#R 脚本示例</span></span><br><span class="line">kmer <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&#x27;sample.histo&#x27;</span><span class="punctuation">)</span></span><br><span class="line">kmer <span class="operator">&lt;-</span> subset<span class="punctuation">(</span>kmer<span class="punctuation">,</span> V1 <span class="operator">&gt;=</span><span class="number">5</span> <span class="operator">&amp;</span> V1 <span class="operator">&lt;=</span><span class="number">500</span><span class="punctuation">)</span> <span class="comment">#对频数范围5-500的数据进行绘制 </span></span><br><span class="line">Frequency <span class="operator">&lt;-</span> kmer<span class="operator">$</span>V1</span><br><span class="line">Number <span class="operator">&lt;-</span> kmer<span class="operator">$</span>V2</span><br><span class="line">png<span class="punctuation">(</span><span class="string">&#x27;kmer_plot.png&#x27;</span><span class="punctuation">)</span></span><br><span class="line">plot<span class="punctuation">(</span>Frequency<span class="punctuation">,</span> Number<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&#x27;l&#x27;</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&#x27;blue&#x27;</span><span class="punctuation">)</span></span><br><span class="line">dev.off<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h1 id="6-references"><a href="#6-references" class="headerlink" title="6. references"></a>6. references</h1><ol>
<li>jellyfish paper：<a href="https://academic.oup.com/bioinformatics/article/27/6/764/234905?login=true">https://academic.oup.com/bioinformatics/article/27/6/764/234905?login=true</a></li>
<li>jellyfish github：<a href="https://github.com/gmarcais/Jellyfish">https://github.com/gmarcais/Jellyfish</a></li>
<li>jellyfish参数推荐：<a href="https://www.bilibili.com/read/cv16360242">https://www.bilibili.com/read/cv16360242</a></li>
<li>chenlianfu blog: jellyfish参数推荐：<a href="http://www.chenlianfu.com/?p=806">http://www.chenlianfu.com/?p=806</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>genome survey</category>
      </categories>
      <tags>
        <tag>genome survey</tag>
        <tag>genome</tag>
        <tag>k-mer</tag>
        <tag>jellyfish</tag>
        <tag>GenomeScope</tag>
      </tags>
  </entry>
  <entry>
    <title>用k-mer分析进行基因组调查：（五）用GenomeScope评估基因组特征</title>
    <url>/2022/06/05/omics_genome.survey_05.GenomeScope/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=283098&auto=1&height=32"></iframe> </div>

<p><strong>用k-mer分析进行基因组调查系列：</strong></p>
<ul>
<li>（一）基本原理：<a href="https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/">https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/</a></li>
<li>（二）用Smudgeplot估计倍性：<a href="https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/">https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/</a></li>
<li>（三）用jellyfish进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/">https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/</a></li>
<li>（四）用KMC进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/</a></li>
<li>（五）用GenomeScope评估基因组特征：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/</a></li>
<li>（六）用GCE分步实现：<a href="https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/">https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/</a></li>
<li>（七）用KmerGenie一步实现：<a href="https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/">https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/</a></li>
</ul>
<p><strong>【推荐】用Smudgeplot评估物种倍性后，用组合jellyfish+GenomeScope1.0做二倍体物种的基因组调查，用组合KMC+GenomeScope2.0做多倍体物种的基因组调查。</strong></p>
<h1 id="1-k-mer进行基因组调查的软件概况"><a href="#1-k-mer进行基因组调查的软件概况" class="headerlink" title="1. k-mer进行基因组调查的软件概况"></a>1. k-mer进行基因组调查的软件概况</h1><p>k-mer进行基因组调查分为<strong>k-mer频数统计</strong>和<strong>基因组特征评估</strong>两步。</p>
<ul>
<li>GenomeScope可以实现第二步基因组特征评估。</li>
<li>需要在jellyfish&#x2F;KMC等软件的第一步结果k-mer频数分布表的基础上，GenomeScope才可实现。</li>
</ul>
<p>推荐第一步获取k-mer频数分布表的命令：</p>
<ol>
<li><p>jellyfish</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jellyfish count -C -m 21 -s 1000000000 -t 10 *.fastq -o sample.jf #计算k-mer频率，生成sample.jf</span><br><span class="line">jellyfish histo -t 10 sample.jf &gt; sample.histo #生成k-mer频数直方表sample.histo和k-mer直方图</span><br></pre></td></tr></table></figure>
</li>
<li><p>KMC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir tmp</span><br><span class="line">ls *.fastq.gz &gt; FILES</span><br><span class="line">kmc -k21 -t16 -m64 -ci1 -cs10000 @FILES kmcdb tmp #计算k-mer频率</span><br><span class="line">kmc_tools transform kmcdb histogram sample.histo -cx10000 #生成k-mer直方图</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="2-GenomeScope概况"><a href="#2-GenomeScope概况" class="headerlink" title="2. GenomeScope概况"></a>2. GenomeScope概况</h1><ul>
<li>GenomeScope可以利用第一步jellyfish或KMC等其他软件分析得到k-mer频数分布表(sample.histo文件)实现第二步<strong>基因组特征评估</strong>。</li>
<li>GenomeScope1.0在2017年发表，用于二倍体物种的基因组调查；2020年又发表了GenomeScope 2.0版本，用于多倍体物种的基因组调查，并发布了用于判断物种倍性的Smudgeplot。</li>
<li><strong>GenomeScope1.0</strong>的基因组特征结果包括基因组大小(genome size)，杂合度(heterozygosity)，重复序列比例，GC含量等。</li>
<li><strong>GenomeScope2.0</strong>的基因组特征结果包括基因组大小(genome size)，杂合度(heterozygosity)，重复序列比例，GC含量，基因型比例，和基因组结构(同源&#x2F;异源多倍体)等。</li>
<li>GenomeScope有网页版和Linux本地版，功能一样；推荐网页版，免去安装的麻烦。</li>
</ul>
<h1 id="3-GenomeScope1-0-网页版【推荐】——-适用于二倍体物种"><a href="#3-GenomeScope1-0-网页版【推荐】——-适用于二倍体物种" class="headerlink" title="3. GenomeScope1.0 网页版【推荐】—— 适用于二倍体物种"></a>3. GenomeScope1.0 网页版【推荐】—— 适用于二倍体物种</h1><p><a href="http://qb.cshl.edu/genomescope">GenomeScope1.0 网页版</a>：<a href="http://qb.cshl.edu/genomescope">http://qb.cshl.edu/genomescope</a></p>
<ol>
<li><p>上传第一步获得的k-mer频数分布表sample.histo文件；</p>
</li>
<li><p>设置参数Kmer length为第一步选择的k-mer长度值，这里是17；</p>
</li>
<li><p>参数Read length为序列读长，一般为150；</p>
</li>
<li><p>参数Max kmer coverage默认是1000。</p>
<p> 建议按照物种情况修改，比如10000，以统计更准确。</p>
<p> 这个参数太小，可能造成过滤过多的Kmer，导致估计的基因组大小偏小的情况。</p>
<p> 这个参数太大则可能把高拷贝数量的DNA，比如叶绿体DNA，包括进Kmer的统计，造成GenomeScope算法的误差，所以还是不推荐使用-1或太大的值。</p>
</li>
<li><p>提交后几分钟就可以得到结果，保存结果图片可用于发表。</p>
</li>
</ol>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/omics_genome.survey_GenomeScope1.0.png?raw=true" width=70% title="GenomeScope1.0结果示例" align=center/>

<p><strong><p align="center">Figure 1. GenomeScope1.0结果示例</p></strong></p>
<h1 id="4-GenomeScope2-0-网页版-【推荐】-——-适用于多倍体物种"><a href="#4-GenomeScope2-0-网页版-【推荐】-——-适用于多倍体物种" class="headerlink" title="4. GenomeScope2.0 网页版 【推荐】 —— 适用于多倍体物种"></a>4. GenomeScope2.0 网页版 【推荐】 —— 适用于多倍体物种</h1><p><a href="http://qb.cshl.edu/genomescope/genomescope2.0">GenomeScope2.0 网页版</a>：<a href="http://qb.cshl.edu/genomescope/genomescope2.0">http://qb.cshl.edu/genomescope/genomescope2.0</a></p>
<p>GenomeScope2.0版本相较于1.0，进行了许多改进，主要是增加了多倍体物种的基因组调查，并提出Smudgeplot方法来估计基因组的倍性和基因组结构。</p>
<h2 id="4-1-GenomeScope-2-0-使用步骤"><a href="#4-1-GenomeScope-2-0-使用步骤" class="headerlink" title="4.1. GenomeScope 2.0 使用步骤"></a>4.1. GenomeScope 2.0 使用步骤</h2><ol>
<li>上传第一步获得的k-mer频数分布表histo文件；</li>
<li>设置参数Kmer length为第一步选择的k-mer长度值，这里是17；</li>
<li>参数倍性Ploidy根据物种的倍性设定，默认是二倍体，设置成2；</li>
<li>参数Max k-mer coverage默认是-1，即不限制最大k-mer深度。建议按照物种情况修改，比如10000，以统计更准确。这个参数太小，可能造成过滤过多的Kmer，导致估计的基因组大小偏小的情况。这个参数太大则可能把高拷贝数量的DNA，比如叶绿体DNA，包括进Kmer的统计，造成GenomeScope算法的误差，所以还是不推荐使用-1或太大的值。</li>
<li>参数Average k-mer coverage for polyploid genome默认是-1，即不进行筛选，可以根据情况调整。</li>
<li>提交后几分钟就可以得到结果，保存结果图片可用于发表。</li>
</ol>
<h2 id="4-2-GenomeScope-2-0-结果"><a href="#4-2-GenomeScope-2-0-结果" class="headerlink" title="4.2. GenomeScope 2.0 结果"></a>4.2. GenomeScope 2.0 结果</h2><h3 id="4-2-1-二倍体结果"><a href="#4-2-1-二倍体结果" class="headerlink" title="4.2.1. 二倍体结果"></a>4.2.1. <strong>二倍体</strong>结果</h3><p>二倍体的GenomeScope 2.0 结果与GenomeScope 1.0 结果的主要不同之处在于杂合度结果(het)变成了2.0版本的代表基因型的aa和ab的比例，其中杂合基因型ab的比例即为杂合度。2.0结果中的p值代表设置的物种倍性。</p>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/images/omics_genome.survey_GenomeScope2.0.png?raw=true" width=70% title="GenomeScope2.0二倍体结果示例" align=center/>

<p><strong><p align="center">Figure 2. GenomeScope2.0 二倍体结果示例</p></strong></p>
<h3 id="4-2-2-区分异源四倍体和同源四倍体"><a href="#4-2-2-区分异源四倍体和同源四倍体" class="headerlink" title="4.2.2. 区分异源四倍体和同源四倍体"></a>4.2.2. 区分<strong>异源四倍体</strong>和<strong>同源四倍体</strong></h3><p>GenomeScope2.0添加了参数倍性<strong>Ploidy</strong>，可以评估多倍体的基因组特征。</p>
<ol>
<li>四倍体共有两种可能的拓扑结构，代表着同源四倍体和异源四倍体，每种拓扑包含三种杂合基因型和一种纯合基因型，共有五种基因型。(五倍体有五种可能的拓扑，六倍体有十六种)</li>
<li>根据结果中杂合基因型的分布模式可以区分异源四倍体和同源四倍体。</li>
</ol>
<img src="https://media.springernature.com/full/springer-static/image/art%3A10.1038%2Fs41467-020-14998-3/MediaObjects/41467_2020_14998_Fig2_HTML.png?as=webp" width=80% title="四倍体的两种拓扑结构可能性" align=center/>

<p><strong><p align="center">Figure 3. 四倍体的两种拓扑结构可能性 a异源四倍体，b同源四倍体。 图片来源：<a href="https://www.nature.com/articles/s41467-020-14998-3">GenomeScope 2.0 paper</a></p></strong></p>
<ol start="3">
<li>GenomeScope2.0的<strong>四倍体</strong>结果</li>
</ol>
<p>在GenomeScope 2.0 的结果中，如果杂合基因型aaab的比例大于aabb，则认为该物种是异源四倍体；如果杂合基因型aaab的比例小于aabb，则认为该物种是同源四倍体。</p>
<img src="https://media.springernature.com/full/springer-static/image/art%3A10.1038%2Fs41467-020-14998-3/MediaObjects/41467_2020_14998_Fig6_HTML.png?as=webp" width=100% title="GenomeScope2.0多倍体结果示例" align=center/>

<p><strong><p align="center">Figure 4. GenomeScope2.0 多倍体结果示例 a异源四倍体，b同源四倍体。 图片来源：<a href="https://www.nature.com/articles/s41467-020-14998-3">GenomeScope 2.0 paper</a></p></strong></p>
<h1 id="5-GenomeScope1-0本地版-——-适用于二倍体物种"><a href="#5-GenomeScope1-0本地版-——-适用于二倍体物种" class="headerlink" title="5. GenomeScope1.0本地版 —— 适用于二倍体物种"></a>5. GenomeScope1.0本地版 —— 适用于二倍体物种</h1><p>GenomeScope1.0的本地版是用一个R脚本实现的，在<a href="https://github.com/schatzlab/genomescope">GenomeScope github</a>可以下载genomescope.R脚本，下载后把genomescope.R文件加入环境变量即可使用。。</p>
<p><code>Rscript genomescope.R sample.histo k-mer_length read_length output_dir [kmer_max] [verbose]</code></p>
<p>必需参数：</p>
<ul>
<li>sample.histo：频数分布直方表，jellyfish的结果。</li>
<li>k-mer_length：k-mer长度，通常是17，21，与jellyfish一致。</li>
<li>read_length：reads长度，这里是150bp的PE reads，所以是150。</li>
<li>output_dir：输出目录，结果图和文本都输出到这个目录。</li>
</ul>
<h1 id="6-GenomeScope2-0本地版-——-适用于多倍体物种"><a href="#6-GenomeScope2-0本地版-——-适用于多倍体物种" class="headerlink" title="6. GenomeScope2.0本地版 —— 适用于多倍体物种"></a>6. GenomeScope2.0本地版 —— 适用于多倍体物种</h1><h2 id="6-1-下载和安装"><a href="#6-1-下载和安装" class="headerlink" title="6.1. 下载和安装"></a>6.1. 下载和安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/tbenavi1/genomescope2.0.git #下载</span><br><span class="line">cd genomescope2.0/</span><br><span class="line">mkdir ~/R_libs #创建主目录下的R_libs文件夹用于安装本地R库</span><br><span class="line">echo &quot;R_LIBS=~/R_libs/&quot; &gt;&gt; ~/.Renviron #创建/编辑.Renviron文件，使得R在创建的R_libs文件夹加载库</span><br><span class="line">Rscript install.R #安装</span><br></pre></td></tr></table></figure>

<p>安装后把目录下的genomescope.R文件加入环境变量即可使用。</p>
<h2 id="6-2-使用"><a href="#6-2-使用" class="headerlink" title="6.2. 使用"></a>6.2. 使用</h2><p><code>genomescope.R -i histogram_file -o output_dir -k k-mer_length</code></p>
<p>参数：</p>
<ul>
<li>-i histogram_file：频数分布直方表，jellyfish或KMC的结果。</li>
<li>-k k-mer_length：k-mer长度，通常是17，21，与jellyfish&#x2F;KMC的设置一致。</li>
<li>-o output_dir：输出目录，结果图和文本都输出到这个目录。</li>
<li>-p ploidy：设置倍性。</li>
<li>-l lambda：设置测序的平均k-mer覆盖率的初始猜测。</li>
<li>-n name_prefix：设置输出文件的前缀。</li>
<li>-m max_kmercov：设置从分析中排除高频k-mers的截止值，根据物种情况确定，推荐1000或10000。</li>
</ul>
<h1 id="7-GenomeScope实践经验"><a href="#7-GenomeScope实践经验" class="headerlink" title="7. GenomeScope实践经验"></a>7. GenomeScope实践经验</h1><ol>
<li>实际使用中发现，GenomeScope1.0和2.0常常估算差异较大。建议二倍体还是使用GenomeScope1.0。</li>
</ol>
<ul>
<li>在估算一个约300Mb的二倍体基因组时，GenomeScope1.0估算出来267Mb，GenomeScope2.0估算出来149Mb。</li>
<li>在估算一个约6Gb的四倍体基因组时发现，GenomeScope1.0估算出来5.5Gb，GenomeScope2.0估算出来2.7Gb。</li>
</ul>
<h1 id="8-references"><a href="#8-references" class="headerlink" title="8. references"></a>8. references</h1><ol>
<li>GenomeScope 1.0 github：<a href="https://github.com/schatzlab/genomescope">https://github.com/schatzlab/genomescope</a></li>
<li>GenomeScope 2.0 github：<a href="https://github.com/tbenavi1/genomescope2.0">https://github.com/tbenavi1/genomescope2.0</a></li>
<li>GenomeScope 1.0 paper：<a href="https://academic.oup.com/bioinformatics/article/33/14/2202/3089939">https://academic.oup.com/bioinformatics/article/33/14/2202/3089939</a></li>
<li>GenomeScope 2.0 + Smudgeplot paper：<a href="https://www.nature.com/articles/s41467-020-14998-3">https://www.nature.com/articles/s41467-020-14998-3</a></li>
<li>Smudgeplot github：<a href="https://github.com/KamilSJaron/smudgeplot">https://github.com/KamilSJaron/smudgeplot</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>genome survey</category>
      </categories>
      <tags>
        <tag>genome survey</tag>
        <tag>genome</tag>
        <tag>k-mer</tag>
        <tag>KMC</tag>
        <tag>GenomeScope</tag>
        <tag>Smudgeplot</tag>
      </tags>
  </entry>
  <entry>
    <title>用k-mer分析进行基因组调查：（六）用GCE分步实现</title>
    <url>/2022/06/07/omics_genome.survey_06.GCE/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=283100&auto=1&height=32"></iframe></div>

<p><strong>用k-mer分析进行基因组调查系列：</strong></p>
<ul>
<li>（一）基本原理：<a href="https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/">https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/</a></li>
<li>（二）用Smudgeplot估计倍性：<a href="https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/">https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/</a></li>
<li>（三）用jellyfish进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/">https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/</a></li>
<li>（四）用KMC进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/</a></li>
<li>（五）用GenomeScope评估基因组特征：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/</a></li>
<li>（六）用GCE分步实现：<a href="https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/">https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/</a></li>
<li>（七）用KmerGenie一步实现：<a href="https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/">https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/</a></li>
</ul>
<p><strong>【推荐】用Smudgeplot评估物种倍性后，用组合jellyfish+GenomeScope1.0做二倍体物种的基因组调查，用组合KMC+GenomeScope2.0做多倍体物种的基因组调查。</strong></p>
<h1 id="1-k-mer进行基因组调查的软件"><a href="#1-k-mer进行基因组调查的软件" class="headerlink" title="1. k-mer进行基因组调查的软件"></a>1. k-mer进行基因组调查的软件</h1><p>k-mer进行基因组调查分为<strong>k-mer频数统计</strong>和<strong>基因组特征评估</strong>两步。</p>
<ul>
<li>GCE可以分步实现两步。第一步k-mer频数统计和第二步基因组特征评估。</li>
<li>GCE第一步的结果sample.histo可以用在GenomeScope和其他基因组特征评估的软件上，实现第二步。</li>
</ul>
<h1 id="2-GCE-简介"><a href="#2-GCE-简介" class="headerlink" title="2. GCE 简介"></a>2. GCE 简介</h1><p>GCE (genomic charactor estimator)是华大基因在2013年开发的一款基于贝叶斯模型的用于基因组调查的软件，在2020年发布了版本v2。</p>
<h1 id="3-GCE-安装"><a href="#3-GCE-安装" class="headerlink" title="3. GCE 安装"></a>3. GCE 安装</h1><h2 id="3-1-GCE-下载"><a href="#3-1-GCE-下载" class="headerlink" title="3.1. GCE 下载"></a>3.1. GCE 下载</h2><ul>
<li>GCE主要托管在BGI的ftp站点：<a href="ftp://ftp.genomics.org.cn/pub/gce%E3%80%82">ftp://ftp.genomics.org.cn/pub/gce。</a></li>
<li>也可以在GCE github：<a href="https://github.com/fanagislab/GCE%E4%B8%8A%E6%89%BE%E5%88%B0%E3%80%82">https://github.com/fanagislab/GCE上找到。</a></li>
</ul>
<h2 id="3-2-GCE-安装"><a href="#3-2-GCE-安装" class="headerlink" title="3.2. GCE 安装"></a>3.2. GCE 安装</h2><ol>
<li><p>已编译【推荐】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:fanagislab/GCE.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>未编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget ftp://ftp.genomics.org.cn/pub/gce/gce-1.0.2.tar.gz</span><br><span class="line">tar -xzvf gce-1.0.2.tar.gz #解压缩和解包</span><br><span class="line">make #编译</span><br></pre></td></tr></table></figure></li>
</ol>
<p>文件夹下有<code>kmerfreq</code>和<code>gce</code>两个命令。</p>
<p>老版本是<code>kmer_freq_hash</code>代替<code>kmerfreq</code>命令。</p>
<h1 id="4-GCE-运行"><a href="#4-GCE-运行" class="headerlink" title="4. GCE 运行"></a>4. GCE 运行</h1><p>GCE软件里包含两个主要的命令，<code>kmerfreq</code>用来完成第一步k-mer频数统计，<code>gce</code>用来完成第二步基因组特征评估。</p>
<h2 id="4-1-k-mer频数统计"><a href="#4-1-k-mer频数统计" class="headerlink" title="4.1. k-mer频数统计"></a>4.1. k-mer频数统计</h2><h3 id="4-1-1-运行"><a href="#4-1-1-运行" class="headerlink" title="4.1.1. 运行"></a>4.1.1. 运行</h3><ol>
<li>命令</li>
</ol>
<p><code>/path/gce-1.0.2/kmerfreq -k 17 -t 24 -p sample input.path &amp;&gt; kmer_freq.log</code></p>
<ol start="2">
<li>参数</li>
</ol>
<ul>
<li>-k 17：k-mer size</li>
<li>-t 24：线程</li>
<li>-p prefix：输出文件的前缀</li>
<li>input.path：输入数据的路径保存在input.path文本文件</li>
</ul>
<h3 id="4-1-2-输出文件"><a href="#4-1-2-输出文件" class="headerlink" title="4.1.2. 输出文件"></a>4.1.2. 输出文件</h3><ol>
<li><strong>sample.kmer.freq.stat</strong>：结果文件</li>
</ol>
<ul>
<li>结果文件sample.kmer.freq.stat，记录了每个k-mer频数的统计信息，用于生成GCE的输入文件。</li>
<li>之前的版本，该文件只统计到第255行，第255行之后的数据合并至第255行，表示k-mer出现频数&gt;&#x3D;255的片段总数。</li>
<li>现在这个版本(gce-1.0.2)上限变成了65534。</li>
</ul>
<ol start="2">
<li><strong>kmer_freq.log</strong>：运行日志文件</li>
</ol>
<ul>
<li>老版本的日志文件还对测序数据进行了简要统计。</li>
<li>在该文件的最下方，统计了k-mer片段总数、k-mer种类数、k-mer平均频数、碱基总数、reads平均长度、基因组大小的粗略估计等信息。</li>
</ul>
<h2 id="4-2-基因组特征评估"><a href="#4-2-基因组特征评估" class="headerlink" title="4.2. 基因组特征评估"></a>4.2. 基因组特征评估</h2><h3 id="4-2-1-获取参数"><a href="#4-2-1-获取参数" class="headerlink" title="4.2.1. 获取参数"></a>4.2.1. 获取参数</h3><ol>
<li>获取k-mer总数</li>
</ol>
<p><code>less sample.kmer.freq.stat | grep &quot;#Kmer indivdual number&quot;</code> </p>
<p>用于gce的-g参数</p>
<ol start="2">
<li>获取k-mer深度分布表</li>
</ol>
<p><code>less sample.kmer.freq.stat | perl -ne &#39;next if(/^#/ || /^\s/); print; &#39; | awk &#39;&#123;print $1&quot;\t&quot;$2&#125;&#39; &gt; sample.kmer.freq.stat.2colum</code></p>
<ul>
<li>sample.kmer.freq.stat.2colum文件包含两列数据，第一列是k-mer频数，第二列是频数对应的k-mer的种类数量。</li>
<li>预期第二列数据是泊松分布，有明显峰值；频数最小的(比如小于5)的那几列对应的k-mer数量高是测序错误造成的，频数最大的那列对应的k-mer数量高是把所有大于该列的频数进行合计数量造成的，两端都可以忽略。</li>
</ul>
<h3 id="4-2-2-运行gce"><a href="#4-2-2-运行gce" class="headerlink" title="4.2.2. 运行gce"></a>4.2.2. 运行gce</h3><ol>
<li>纯合模式</li>
</ol>
<p><code>gce -f sample.kmer.freq.stat.2colum -g 173854609857 &gt; gce.table 2&gt; gce.log</code></p>
<ol start="2">
<li>杂合模式</li>
</ol>
<p><code>gce -f sample.kmer.freq.stat.2colum -g 173854609857 -H 1 -c 75 &gt; gce2.table 2&gt; gce2.log</code></p>
<ol start="3">
<li>开发者建议</li>
</ol>
<p>对于不能判断纯合还是杂合的数据，可以先运行纯合模式，获得初始峰值(raw_peak)，即k-mer的期望深度，用作<code>-c</code>参数。</p>
<p>然后再用<code>-c</code>参数和<code>-H 1</code>参数运行杂合模式。最后比较两种模式的结果，从而判断哪种更适用当前数据。</p>
<h3 id="4-2-3-gce的参数"><a href="#4-2-3-gce的参数" class="headerlink" title="4.2.3. gce的参数"></a>4.2.3. gce的参数</h3><p>-f和-g是必需参数，其他都为可选参数。</p>
<ul>
<li>-f sample.freq.stat.2colum：k-mer频数分布表。</li>
<li>-g 173854609857：k-mer片段总数，通过上面命令获取，或者查看kmer_freq.log获取。</li>
<li>-H 1：默认是0。homozygous mode 纯合模式(0)，heterozgyous mode 杂合模式(1)。</li>
<li>-c 75：独特的k-mer的期望深度，通过肉眼检查sample.gce.table的峰值获取。</li>
<li>-b 1：有bias(1)，无(0)bias，默认是0。</li>
<li>-m 1：评估模型，离散模型(0)，连续模型(1)，默认是0。</li>
<li>-M 1500：设置最大深度，默认1500，大于1500的会被忽略。</li>
<li>-D 1：期望值的精度，默认是1。</li>
</ul>
<h3 id="4-2-4-结果"><a href="#4-2-4-结果" class="headerlink" title="4.2.4. 结果"></a>4.2.4. 结果</h3><p>生成两个文件：<strong>gce.table</strong>和<strong>gce.log</strong>。gce.table保存了用于作图的数据，gce.log日志文件最后记录了基因组特征评估结果的统计。</p>
<ol>
<li>gce.log文件最后记录了如下内容：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">raw_peak        effective_kmer_species  effective_kmer_individuals      coverage_depth  genome_size     a[1]    b[1]</span><br><span class="line">75      742400596       168346645871    75.8021 2.22087e+09     0.663012        0.271515</span><br></pre></td></tr></table></figure>

<p>含义：</p>
<ul>
<li>raw_peak： 覆盖度为 75 的 kmer 的种类数最多，为主峰。</li>
<li>effective_kmer_species：真实的k-mer种类的总数(去除测序错误造成的低频k-mers)</li>
<li>effective_kmer_individuals：真实的k-mer个体的总数(去除测序错误造成的低频k-mers)</li>
<li>coverage_depth：估算出的真实k-mers的覆盖深度</li>
<li>genome_size：基因组大小。</li>
</ul>
<p><strong>genome_size &#x3D; effective_kmer_individuals &#x2F; coverage_depth</strong></p>
<ul>
<li>a[1]： uniqe kmers (在基因组上仅出现 1 次的 kmer ) 的种类数占总种类数的比例。</li>
<li>b[1]： uniqe kmers (在基因组上仅出现 1 次的 kmer ) 的个体数占总个体数的比例。该值代表着基因组上拷贝数为 1 的序列比例。</li>
</ul>
<ol start="2">
<li>如果使用杂合模式<code>-H 1</code>，则会在gce.log文件最后额外得到下面信息：</li>
</ol>
<ul>
<li>a[1&#x2F;2]：a[1&#x2F;2]&#x3D;0.223671表示在所有的 uniqe kmers 种类中，有 0.223671 比例的 kmer 属于杂合 kmer 。</li>
<li>b[1&#x2F;2]：a[1&#x2F;2]&#x3D;0.326934 表示在所有的 uniqe kmers 个体中，有 0.326934 比例的 kmer 属于杂合 kmer 。<br>通过计算，还可以获得的信息：</li>
<li>k-mer种类的杂合率 kmer-species heterozygous ratio &#x3D; 0.125918，0.125918 是由 a[1&#x2F;2] 计算出来的。</li>
</ul>
<p>$$0.125918 &#x3D; a[1&#x2F;2] &#x2F; （ 2- a[1&#x2F;2] )$$ </p>
<ul>
<li>重复序列的含量 &#x3D; $$1 - b[1&#x2F;2] - b[1]$$</li>
</ul>
<h1 id="5-references"><a href="#5-references" class="headerlink" title="5. references"></a>5. references</h1><ol>
<li>GCE github：<a href="https://github.com/fanagislab/GCE">https://github.com/fanagislab/GCE</a></li>
<li>kmerfreq：<a href="https://github.com/fanagislab/kmerfreq">https://github.com/fanagislab/kmerfreq</a></li>
<li>GCE paper：<a href="https://arxiv.org/abs/1308.2012">https://arxiv.org/abs/1308.2012</a></li>
<li>GCE blog：<a href="http://www.chenlianfu.com/?p=2335">http://www.chenlianfu.com/?p=2335</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>genome survey</category>
      </categories>
      <tags>
        <tag>genome survey</tag>
        <tag>genome</tag>
        <tag>k-mer</tag>
        <tag>GCE</tag>
        <tag>kmerfreq</tag>
      </tags>
  </entry>
  <entry>
    <title>用k-mer分析进行基因组调查：（七）用KmerGenie一步实现</title>
    <url>/2022/06/19/omics_genome.survey_07.KmerGenie/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=27538254&auto=1&height=32"></iframe></div>

<p><strong>用k-mer分析进行基因组调查系列：</strong></p>
<ul>
<li>（一）基本原理：<a href="https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/">https://yanzhongsino.github.io/2022/05/25/omics_genome.survey_01.intro/</a></li>
<li>（二）用Smudgeplot估计倍性：<a href="https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/">https://yanzhongsino.github.io/2022/12/31/omics_genome.survey_02.Smudgeplot/</a></li>
<li>（三）用jellyfish进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/">https://yanzhongsino.github.io/2022/05/27/omics_genome.survey_03.jellyfish/</a></li>
<li>（四）用KMC进行k-mer频数统计：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_04.KMC/</a></li>
<li>（五）用GenomeScope评估基因组特征：<a href="https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/">https://yanzhongsino.github.io/2022/06/05/omics_genome.survey_05.GenomeScope/</a></li>
<li>（六）用GCE分步实现：<a href="https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/">https://yanzhongsino.github.io/2022/06/07/omics_genome.survey_06.GCE/</a></li>
<li>（七）用KmerGenie一步实现：<a href="https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/">https://yanzhongsino.github.io/2022/06/19/omics_genome.survey_07.KmerGenie/</a></li>
</ul>
<p><strong>【推荐】用Smudgeplot评估物种倍性后，用组合jellyfish+GenomeScope1.0做二倍体物种的基因组调查，用组合KMC+GenomeScope2.0做多倍体物种的基因组调查。</strong></p>
<h1 id="1-k-mer进行基因组调查的软件"><a href="#1-k-mer进行基因组调查的软件" class="headerlink" title="1. k-mer进行基因组调查的软件"></a>1. k-mer进行基因组调查的软件</h1><p>k-mer进行基因组调查分为<strong>k-mer频数统计</strong>和<strong>基因组特征评估</strong>两步。</p>
<ul>
<li>KmerGenie可以同时实现两步。第一步k-mer频数统计和第二步基因组特征评估。</li>
<li>KmerGenie第一步的结果可用于其他软件第二步基因组特征评估。</li>
<li>KmerGenie可以同时分析多个预设的k-mers，并选出一个最佳基因组组装k-mer值。</li>
</ul>
<h1 id="2-KmerGenie-简介"><a href="#2-KmerGenie-简介" class="headerlink" title="2. KmerGenie 简介"></a>2. KmerGenie 简介</h1><ul>
<li>KmerGenie在2014年第一次发表，2018年最近一次更新。开发用于基因组组装的参数k的最佳值的选择。</li>
<li>KmerGenie官网：<a href="http://kmergenie.bx.psu.edu/%E3%80%82">http://kmergenie.bx.psu.edu/。</a></li>
<li>官网包含软件的下载地址，示例报告，和版本更新记录。</li>
</ul>
<h1 id="3-KmerGenie-安装"><a href="#3-KmerGenie-安装" class="headerlink" title="3. KmerGenie 安装"></a>3. KmerGenie 安装</h1><p>在KmerGenie官网：<a href="http://kmergenie.bx.psu.edu/">http://kmergenie.bx.psu.edu/</a> 下载，目前最新版是18年更新的1.7051。</p>
<p>安装前需要python（&gt;&#x3D;2.7）和R支持，我用的anaconda的python，安装运行完成后自动把kmergenie命令添加到了<code>/anaconda3/bin/</code>下面，所以不用再次把kmergenie命令添加到环境变量了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://kmergenie.bx.psu.edu/kmergenie-1.7051.tar.gz</span><br><span class="line">tar -xzvf kmergenie-1.7051.tar.gz</span><br><span class="line">python setup.py install</span><br><span class="line">kmergenie -h</span><br></pre></td></tr></table></figure>

<h1 id="4-KmerGenie-运行"><a href="#4-KmerGenie-运行" class="headerlink" title="4. KmerGenie 运行"></a>4. KmerGenie 运行</h1><ol>
<li>命令</li>
</ol>
<p><code>kmergenie fastq_list.txt -o ./sample -l 17 -k 121 -s 10 -t 4 &gt; sample.log1.txt 2&gt; sample.log2.txt</code></p>
<ul>
<li>fastq_list.txt文件保存着fastq文件的位置和文件名，每个文件一行。</li>
<li>默认单倍体模式，以k-mer长度17为起始，121为终止，10为间隔逐一测试；程序运行线程数4。</li>
<li>结果输出在当前路径下，以sample为结果文件前缀名。</li>
<li>“sample.log1.txt”和“sample.log2.txt”分别为程序运行时的正确&#x2F;错误输出日志。</li>
</ul>
<ol start="2">
<li>参数</li>
</ol>
<ul>
<li>–diploid：使用二倍体模式，默认是单倍体模式（haploid）。</li>
<li>–one-pass：默认是两次评估（two passes），这个参数设置用来跳过在2bp分辨率上评估k的第二次评估。</li>
<li>-k 121：最大的k-mer值，默认是121。</li>
<li>-l 15：最小的k-mer值，默认是15。</li>
<li>-s 10：在最小和最大的k-mer值间的间隔，默认是10。意味着会进行k&#x3D;15,25,35…115,121的分析。</li>
<li>-e 200：程序运行内存，默认是每个线程200MB。</li>
<li>-t 8：线程数。</li>
<li>-o histograms：输出文件的前缀，默认是histograms。</li>
<li>–debug：开发者使用，输出R脚本。</li>
<li>–orig-hist：老程序的评估方法（更慢且准确性更低）。</li>
</ul>
<h1 id="5-KmerGenie-结果"><a href="#5-KmerGenie-结果" class="headerlink" title="5. KmerGenie 结果"></a>5. KmerGenie 结果</h1><ol>
<li>结果报告文件sample_report.html</li>
</ol>
<p>下载所有结果文件，打开sample_report.html，报告内容包括：</p>
<ul>
<li>开头以折线图的形式展示出在每种长度k-mer下，估算的基因组大小。</li>
<li>同时给出了<strong>最佳k-mer</strong>选择数值。其实就是将评估基因组总大小<strong>最高</strong>的那个k-mer值判定为<strong>最佳k-mer</strong>，为基因组组装时k-mer的选择提供参考。</li>
<li>折线图的详细说明，包括最佳k-mer的评估规则，以及当测序深度足够高时的k-mer选择等。</li>
<li>每种k-mer的频数分布图，在基因组的k-mer中可根据该图判定基因组杂合度或重复序列比例。</li>
</ul>
<ol start="2">
<li>频数分布表sample.histo</li>
</ol>
<ul>
<li>包括各k-mer取值下的频数分布表sample.histo和对应的频数分布图sample.histo.pdf。</li>
<li>如果想用某个k-mer的频数分布表做<strong>基因组特征评估</strong>，自己绘制频数分布图，可以使用sample.histo文件。</li>
</ul>
<ol start="3">
<li>所有k-mer取值评估的基因组大小记录在sample.dat</li>
</ol>
<ul>
<li>包括sample.dat和sample.dat.pdf。</li>
</ul>
<h1 id="6-notes"><a href="#6-notes" class="headerlink" title="6. notes"></a>6. notes</h1><ol>
<li>二倍体模式</li>
</ol>
<ul>
<li>如果待测物种是低杂合低重复的简单基因组，则使用<strong>单倍体模式</strong>。</li>
<li>如果是复杂基因组，使用<strong>二倍体模式</strong>。</li>
<li>如果不确定基因组简单还是复杂，可以先用单倍体模式运行，根据结果中是否有<strong>明显杂合峰</strong>判断，再运行二倍体模式。</li>
</ul>
<ol start="2">
<li>KmerGenie软件默认将k-mer频数曲线的纵坐标进行了log10转化<br>可以通过修改脚本来更改展示效果：</li>
</ol>
<ul>
<li>在脚本<code>kmergenie-1.7051/scripts/plot_histogram.r</code>中第110行，<code>suppressWarnings</code>函数的参数<code>log=&#39;y&#39;</code>设置的log10转化，可以通过去除<code>log=&#39;y&#39;</code>参数来展示未log10转化的原始坐标。</li>
<li>在脚本<code>kmergenie-1.7051/scripts/plot_histogram.r</code>中第110行，<code>suppressWarnings</code>函数的参数<code>covNormalized</code>改为<code>covNormalized[-c(1:5)]</code>来过滤掉Abundance&lt;5的区域。</li>
</ul>
<ol start="3">
<li>k-mer取值</li>
</ol>
<ul>
<li>KmerGenie软件是用于二代数据组装基因组推荐k-mer参数的。推荐的<strong>最佳k-mer</strong>是评估基因组最大的对应的k-mer。</li>
<li>在基因组组装时，<strong>k-mer的取值</strong>受测序深度的影响，若测序深度越高，可选择更高的k-mer进行尝试组装，以得到更长更完整的contigs序列。</li>
<li>但若在低深度测序模式下使用较高的k-mer进行组装时，就会引入较高的<strong>错误率</strong>。表现为k-mer频数分布曲线（纵坐标未进行log10转化的）的左侧由于测序错误导致的低频k-mer数量未随着k-mer频数升高下降至最低即产生了上升趋势。</li>
<li>用KmerGenie软件做基因组调查时，可以根据每个k-mer值的频数分布图结果选择更为合适的k-mer值做<strong>基因组特征评估</strong>。</li>
</ul>
<h1 id="7-references"><a href="#7-references" class="headerlink" title="7. references"></a>7. references</h1><ol>
<li>KmerGenie website：<a href="http://kmergenie.bx.psu.edu/">http://kmergenie.bx.psu.edu/</a></li>
<li>KmerGenie paper：<a href="https://academic.oup.com/bioinformatics/article/30/1/31/235479">https://academic.oup.com/bioinformatics/article/30/1/31/235479</a></li>
<li><a href="http://blog.sciencenet.cn/blog-3406804-1159967.html">http://blog.sciencenet.cn/blog-3406804-1159967.html</a></li>
<li><a href="https://www.jianshu.com/p/0251b55977c0">https://www.jianshu.com/p/0251b55977c0</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>
]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>genome survey</category>
      </categories>
      <tags>
        <tag>genome survey</tag>
        <tag>genome</tag>
        <tag>k-mer</tag>
        <tag>KmerGenie</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组质量评估：（三）用BUSCO评估基因组的完整性</title>
    <url>/2021/07/24/omics_genome_quality.assessment_BUSCO/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=3986241&auto=1&height=32"></iframe></div>

<h1 id="1-busco简介"><a href="#1-busco简介" class="headerlink" title="1. busco简介"></a>1. busco简介</h1><p>Benchmarking Universal Single-Copy Orthologs (BUSCO)是用于评估基因组组装和注释的完整性的工具。通过与已有单拷贝直系同源数据库的比较，得到有多少比例的数据库能够有比对，比例越高代表基因组完整度越好。</p>
<p>可以评估三种数据类型：</p>
<ol>
<li>组装的基因组；</li>
<li>转录组；</li>
<li>蛋白组（或者基因组注释基因对应的氨基酸序列）。</li>
</ol>
<p>使用需要评估的生物类别所属的数据库（从busco数据库下载）比对，得出比对上数据库的完整性比例的信息。</p>
<ul>
<li>BUSCO官网：<a href="https://busco.ezlab.org/">https://busco.ezlab.org</a></li>
<li>BUSCO v5数据库：<a href="https://busco-data.ezlab.org/v5/data/lineages/">https://busco-data.ezlab.org/v5/data/lineages/</a></li>
</ul>
<h1 id="2-busco安装"><a href="#2-busco安装" class="headerlink" title="2. busco安装"></a>2. busco安装</h1><ol>
<li>conda安装</li>
</ol>
<p><code>conda install -c conda-forge -c bioconda busco=5.3.2</code> #安装版本是5.3.2</p>
<ol start="2">
<li>手动安装</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://gitlab.com/ezlab/busco.git</span><br><span class="line">cd busco</span><br><span class="line">python3 setup.py install --user</span><br><span class="line">./bin/busco -h</span><br></pre></td></tr></table></figure>

<h1 id="3-busco数据库下载"><a href="#3-busco数据库下载" class="headerlink" title="3. busco数据库下载"></a>3. busco数据库下载</h1><p><code>busco --list-datasets</code> #查看busco可用的数据库。</p>
<p>下载对应的busco数据库；目前有v1-v5版本，根据需要评估的物种，尽量选用最新版本的最多基因的数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://busco-data.ezlab.org/v5/data/lineages/eudicots_odb10.2020-09-10.tar.gz</span><br><span class="line">tar -xzf eudicots_odb10.2020-09-10.tar.gz #会生成eudicots_odb10，这个就可以直接用了，注意不要修改后缀，必需是_odb10</span><br></pre></td></tr></table></figure>

<p>植物相关的数据库有：</p>
<table>
<thead>
<tr>
<th>类群</th>
<th>数据库</th>
<th>BUSCO groups数量</th>
</tr>
</thead>
<tbody><tr>
<td>真核生物</td>
<td><a href="https://busco-data.ezlab.org/v5/data/lineages/eukaryota_odb10.2020-09-10.tar.gz">eukaryota_odb10.2020-09-10.tar.gz</a></td>
<td>255</td>
</tr>
<tr>
<td>绿色植物</td>
<td><a href="https://busco-data.ezlab.org/v5/data/lineages/viridiplantae_odb10.2020-09-10.tar.gz">viridiplantae_odb10.2020-09-10.tar.gz</a></td>
<td>425</td>
</tr>
<tr>
<td>有胚植物</td>
<td><a href="https://busco-data.ezlab.org/v5/data/lineages/embryophyta_odb10.2020-09-10.tar.gz">embryophyta_odb10.2020-09-10.tar.gz</a></td>
<td>1614</td>
</tr>
<tr>
<td>真双子叶植物</td>
<td><a href="https://busco-data.ezlab.org/v5/data/lineages/eudicots_odb10.2020-09-10.tar.gz">eudicots_odb10.2020-09-10.tar.gz</a></td>
<td>2326</td>
</tr>
<tr>
<td>豆目</td>
<td><a href="https://busco-data.ezlab.org/v5/data/lineages/fabales_odb10.2020-08-05.tar.gz">fabales_odb10.2020-08-05.tar.gz</a></td>
<td>5366</td>
</tr>
</tbody></table>
<h1 id="4-busco使用"><a href="#4-busco使用" class="headerlink" title="4. busco使用"></a>4. busco使用</h1><h2 id="4-1-直接在命令中设定参数【需设置的参数较少时】"><a href="#4-1-直接在命令中设定参数【需设置的参数较少时】" class="headerlink" title="4.1. 直接在命令中设定参数【需设置的参数较少时】"></a>4.1. 直接在命令中设定参数【需设置的参数较少时】</h2><p><code>nohup busco -i genome.fa -c 10 -o busco -m geno -l busco_downloads/eudicots_odb10 --offline &amp;</code></p>
<ul>
<li>-i：指定需要分析的数据，组装的genome或者注释的蛋白序列或者组装的转录组dna序列;</li>
<li>-m：geno&#x2F;prot&#x2F;tran模式；</li>
<li>-c：指定线程；</li>
<li>-o：指定输出文件目录名；</li>
<li>-l：指定数据库</li>
<li>使用–offline离线模式</li>
</ul>
<p>非常不建议用busco的–auto-lineage模式，这个模式在运行busco时下载数据库，网络不好时连接的失败率非常高。推荐用<code>-l busco_downloads/eudicots_odb10 --offline</code>指定下载好的本地数据库，并使用离线模式。</p>
<h2 id="4-2-在设置文件中给出参数【需设置的参数较多时】"><a href="#4-2-在设置文件中给出参数【需设置的参数较多时】" class="headerlink" title="4.2. 在设置文件中给出参数【需设置的参数较多时】"></a>4.2. 在设置文件中给出参数【需设置的参数较多时】</h2><p><code>nohup busco --config config.ini</code><br>通过conda安装的config.ini配置文件在&#x2F;path&#x2F;to&#x2F;miniconda3&#x2F;envs&#x2F;busco5&#x2F;config&#x2F;目录下；直接复制一份到工作目录，修改使用即可。</p>
<p>把config.ini的示例文件中行首的分号;去掉，并把等号后的内容修改成设置的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># This is the BUSCOv5 configuration file template.</span><br><span class="line"># It is not necessary to use this, as BUSCO will use the dependencies available on your PATH by default.</span><br><span class="line"># The busco run parameters can all be set on the command line. See the help prompt (busco -h) for details.</span><br><span class="line">#</span><br><span class="line"># To use this file for an alternative configuration, or to specify particular versions of dependencies:</span><br><span class="line"># 1) edit the path and command values to match your desired dependency versions.</span><br><span class="line">#    WARNING: passing a parameter through the command line overrides the value specified in this file.</span><br><span class="line">#</span><br><span class="line"># 2) Enable a parameter by removing &quot;;&quot;</span><br><span class="line">#</span><br><span class="line"># 3) Make this config file available to BUSCO either by setting an environment variable</span><br><span class="line">#</span><br><span class="line">#                   export BUSCO_CONFIG_FILE=&quot;/path/to/myconfig.ini&quot;</span><br><span class="line">#</span><br><span class="line">#    or by passing it as a command line argument</span><br><span class="line">#</span><br><span class="line">#                   busco &lt;args&gt; --config /path/to/config.ini</span><br><span class="line">#</span><br><span class="line">[busco_run]</span><br><span class="line"># Input file</span><br><span class="line">;in = /path/to/input_file.fna</span><br><span class="line"># Run name, used in output files and folder</span><br><span class="line">;out = BUSCO_run</span><br><span class="line"># Where to store the output directory</span><br><span class="line">;out_path = /path/to/output_folder</span><br><span class="line"># Path to the BUSCO dataset</span><br><span class="line">;lineage_dataset = bacteria</span><br><span class="line"># Which mode to run (genome / proteins / transcriptome)</span><br><span class="line">;mode = genome</span><br><span class="line"># Run lineage auto selector</span><br><span class="line">;auto-lineage = True</span><br><span class="line"># Run auto selector only for non-eukaryote datasets</span><br><span class="line">;auto-lineage-prok = True</span><br><span class="line"># Run auto selector only for eukaryote datasets</span><br><span class="line">;auto-lineage-euk = True</span><br><span class="line"># How many threads to use for multithreaded steps</span><br><span class="line">;cpu = 16</span><br><span class="line"># Force rewrite if files already exist (True/False)</span><br><span class="line">;force = False</span><br><span class="line"># Restart a previous BUSCO run (True/False)</span><br><span class="line">;restart = False</span><br><span class="line"># Blast e-value</span><br><span class="line">;evalue = 1e-3</span><br><span class="line"># How many candidate regions (contigs, scaffolds) to consider for each BUSCO</span><br><span class="line">;limit = 3</span><br><span class="line"># Metaeuk parameters for initial run</span><br><span class="line">;metaeuk_parameters=&#x27;--param1=value1,--param2=value2&#x27;</span><br><span class="line"># Metaeuk parameters for rerun</span><br><span class="line">;metaeuk_rerun_parameters=&quot;&quot;</span><br><span class="line"># Augustus parameters</span><br><span class="line">;augustus_parameters=&#x27;--param1=value1,--param2=value2&#x27;</span><br><span class="line"># Quiet mode (True/False)</span><br><span class="line">;quiet = False</span><br><span class="line"># Local destination path for downloaded lineage datasets</span><br><span class="line">;download_path = ./busco_downloads/</span><br><span class="line"># Run offline</span><br><span class="line">;offline=True</span><br><span class="line"># Ortho DB Datasets version</span><br><span class="line">;datasets_version = odb10</span><br><span class="line"># URL to BUSCO datasets</span><br><span class="line">;download_base_url = https://busco-data.ezlab.org/v4/data/</span><br><span class="line"># Download most recent BUSCO data and files</span><br><span class="line">;update-data = True</span><br><span class="line"># Use Augustus gene predictor instead of metaeuk</span><br><span class="line">;use_augustus = True</span><br><span class="line"></span><br><span class="line">[tblastn]</span><br><span class="line">path = /ncbi-blast-2.10.1+/bin/</span><br><span class="line">command = tblastn</span><br><span class="line"></span><br><span class="line">[makeblastdb]</span><br><span class="line">path = /ncbi-blast-2.10.1+/bin/</span><br><span class="line">command = makeblastdb</span><br><span class="line"></span><br><span class="line">[metaeuk]</span><br><span class="line">path = /metaeuk/build/bin/</span><br><span class="line">command = metaeuk</span><br><span class="line"></span><br><span class="line">[augustus]</span><br><span class="line">path = /augustus/bin/</span><br><span class="line">command = augustus</span><br><span class="line"></span><br><span class="line">[etraining]</span><br><span class="line">path = /augustus/bin/</span><br><span class="line">command = etraining</span><br><span class="line"></span><br><span class="line">[gff2gbSmallDNA.pl]</span><br><span class="line">path = /augustus/scripts/</span><br><span class="line">command = gff2gbSmallDNA.pl</span><br><span class="line"></span><br><span class="line">[new_species.pl]</span><br><span class="line">path = /augustus/scripts/</span><br><span class="line">command = new_species.pl</span><br><span class="line"></span><br><span class="line">[optimize_augustus.pl]</span><br><span class="line">path = /augustus/scripts/</span><br><span class="line">command = optimize_augustus.pl</span><br><span class="line"></span><br><span class="line">[hmmsearch]</span><br><span class="line">path = /usr/local/bin/</span><br><span class="line">command = hmmsearch</span><br><span class="line"></span><br><span class="line">[sepp]</span><br><span class="line">path = /home/biodocker/sepp/</span><br><span class="line">command = run_sepp.py</span><br><span class="line"></span><br><span class="line">[prodigal]</span><br><span class="line">path = /usr/local/bin/</span><br><span class="line">command = prodigal</span><br></pre></td></tr></table></figure>

<h1 id="5-busco结果"><a href="#5-busco结果" class="headerlink" title="5. busco结果"></a>5. busco结果</h1><p>结果在short_summary.txt后缀文件中。</p>
<p>一个例子</p>
<pre><code>    --------------------------------------------------
    |Results from dataset eudicots_odb10              |
    --------------------------------------------------
    |C:92.9%[S:72.4%,D:20.5%],F:1.8%,M:5.3%,n:2326    |
    |2162   Complete BUSCOs (C)                       |
    |1685   Complete and single-copy BUSCOs (S)       |
    |477    Complete and duplicated BUSCOs (D)        |
    |41     Fragmented BUSCOs (F)                     |
    |123    Missing BUSCOs (M)                        |
    |2326   Total BUSCO groups searched               |
    --------------------------------------------------
</code></pre>
<p>结果的解释：<br>使用的eudicots_odb10真双子叶植物数据库中共有2326个BUSCO groups，其中2162（92.9%）个BUSCO groups被完整比对上（包括1685个单拷贝和477个多拷贝），41个部分比对上，123个没有比对上。</p>
<p>通常用完整比对上的占总共的BUSCO groups的比例作为BUSCO的重要结果，越高越好，这里是92.9%&#x3D;2162&#x2F;2326。</p>
<h1 id="6-busco结果画图"><a href="#6-busco结果画图" class="headerlink" title="6. busco结果画图"></a>6. busco结果画图</h1><p>在执行完毕之后，可以使用generate_plot.py画条形图，可以进行多个物种间同一个库结果的比较。</p>
<ol>
<li>首先把所有的经过BUSCO检测的物种结果short_summary.txt后缀文件放到一个文件夹（result）下；</li>
<li>然后运行<code>python busco/scripts/generate_plot.py –wd result</code>；</li>
<li>generate_plot.py会在指定的目录下识别short_summary.specific&#x2F;genetic前缀文件，载入所有符合这个模式的文件，然后在result下生成busco_figure.R脚本。</li>
<li>然后运行这个脚本调用ggplot2生成图。如果当前环境的R中没有安装ggplot2，可以安装后自行运行脚本生成图。</li>
<li>可以修改busco_figure.R脚本以适应需要，比如修改标题（my_title），基因数量标签的尺寸（labsize）。</li>
</ol>
<h1 id="7-调用augustus【optional】"><a href="#7-调用augustus【optional】" class="headerlink" title="7. 调用augustus【optional】"></a>7. 调用augustus【optional】</h1><p>AUGUSTUS运行的时候需要额外设定2个环境变量，AUGUSTUS_CONFIG_PATH和BUSCO_CONFIG_FILE, 通过conda安装的这两个配置文件都在&#x2F;path&#x2F;to&#x2F;miniconda3&#x2F;envs&#x2F;busco5&#x2F;config目录下。</p>
<p>所以需要在.bashrc或.zshrc中加入下面这一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export AUGUSTUS_CONFIG_PATH=&quot;/path/to/anaconda3/envs/busco5/config</span><br><span class="line">export BUSCO_CONFIG_FILE=&quot;/path/to/anaconda3/envs/busco5/config/config.ini</span><br></pre></td></tr></table></figure>
<p>实现AUGUSTUS和BUSCO的设置。</p>
<h1 id="8-notes"><a href="#8-notes" class="headerlink" title="8. notes"></a>8. notes</h1><p>2021年06月23日开始写，07月24日今天终于完结。</p>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>quality assessment</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>genome</tag>
        <tag>quality assessment</tag>
        <tag>BUSCO</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组质量评估：（四）用LAI评估基因组组装的连贯性</title>
    <url>/2022/07/20/omics_genome_quality.assessment_LAI/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=26834823&auto=1&height=32"></iframe></div>

<h1 id="1-LAI简介"><a href="#1-LAI简介" class="headerlink" title="1. LAI简介"></a>1. LAI简介</h1><h2 id="1-1-LAI"><a href="#1-1-LAI" class="headerlink" title="1.1. LAI"></a>1.1. LAI</h2><ol>
<li>LTR</li>
</ol>
<p>关于重复序列和LTR的相关知识可以参考博客：基因组注释（一）：重复序列注释：<a href="https://yanzhongsino.github.io/2021/08/02/omics_genome.annotation_repeat/%E3%80%82">https://yanzhongsino.github.io/2021/08/02/omics_genome.annotation_repeat/。</a></p>
<ol start="2">
<li>LAI</li>
</ol>
<p>LTR组装指数(LTR Assembly Index, LAI)是用完整LTR-RTs在所有LTR-RTs的占比来评估基因组组装连贯性的一个指数。</p>
<h2 id="1-2-LAI评估基因组组装质量"><a href="#1-2-LAI评估基因组组装质量" class="headerlink" title="1.2. LAI评估基因组组装质量"></a>1.2. LAI评估基因组组装质量</h2><ul>
<li>LTR在基因组中的比例很高，且由于其重复性组装难度高，所以它的组装质量与基因组组装有密切关系。</li>
<li>期望基因组组装的连贯性越高，LTR的连贯性也越高。所以可以用LAI来评估基因组组装的连贯性。</li>
<li>LAI与基因组大小、基因组LTR-RT含量和基因空间评估指标（例如BUSCO和CEGMA）无关。</li>
<li>使用LAI评估基因组，完整LTR-RTs和总LTR-RTs至少占基因组大小的0.1%和5%。</li>
</ul>
<h2 id="1-3-LAI计算和评估方法"><a href="#1-3-LAI计算和评估方法" class="headerlink" title="1.3. LAI计算和评估方法"></a>1.3. LAI计算和评估方法</h2><ol>
<li>LAI计算公式</li>
</ol>
<p>$$Raw LAI &#x3D; (Intact LTR retrotransposon length &#x2F; Total LTR sequence length) × 100$$</p>
<ol start="2">
<li>LAI评估方法</li>
</ol>
<p>根据LAI开发者的文章，把LAI值分成三个类别，Draft级别（0≤LAI&lt;10），Reference级别（10≤LAI&lt;20），Gold级别（20≤LAI）。</p>
<p>LAI值按照如下评估标准进行分类：</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>LAI</th>
<th>Examples</th>
</tr>
</thead>
<tbody><tr>
<td>Draft</td>
<td>0 ≤ LAI &lt; 10</td>
<td>Apple (v1.0), Cacao (v1.0)</td>
</tr>
<tr>
<td>Reference</td>
<td>10 ≤ LAI &lt; 20</td>
<td>Arabidopsis (TAIR10), Grape (12X)</td>
</tr>
<tr>
<td>Gold</td>
<td>20 ≤ LAI</td>
<td>Rice (MSUv7), Maize (B73 v4)</td>
</tr>
</tbody></table>
<iframe height=850 width=90% src="https://academic.oup.com/view-large/126092648" frameborder=0 allowfullscreen></iframe>

<h1 id="2-计算LAI指数"><a href="#2-计算LAI指数" class="headerlink" title="2. 计算LAI指数"></a>2. 计算LAI指数</h1><h2 id="2-1-注释LTR时，顺带计算LAI【推荐】"><a href="#2-1-注释LTR时，顺带计算LAI【推荐】" class="headerlink" title="2.1. 注释LTR时，顺带计算LAI【推荐】"></a>2.1. 注释LTR时，顺带计算LAI【推荐】</h2><p>用LTR_FINDER_parallel和ltrharvest分别预测LTR，然后基于预测结果用LTR_retriever鉴定和确认LTR。</p>
<h3 id="2-1-1-LTR-FINDER-parallel预测LTR"><a href="#2-1-1-LTR-FINDER-parallel预测LTR" class="headerlink" title="2.1.1. LTR_FINDER_parallel预测LTR"></a>2.1.1. LTR_FINDER_parallel预测LTR</h3><p><code>LTR_FINDER_parallel -seq genome.fa -threads 10 -harvest_out -size 1000000 -time 300 -w 2 -C -D 15000 -d 1000 -L 7000 -l 100 -p 20 -M 0.85</code></p>
<ul>
<li>预测LTR,生成genome.fa.finder.combine.scn</li>
<li>其中，-w 2 -C -D 15000 -d 1000 -L 7000 -l 100 -p 20 -M 0.85参数部分是作者推荐；</li>
<li>-size, -time, -try1三个参数作者不建议修改</li>
<li>-harvest_out指定输出harvest格式的结果</li>
</ul>
<h3 id="2-1-2-ltrharvest预测LTR"><a href="#2-1-2-ltrharvest预测LTR" class="headerlink" title="2.1.2. ltrharvest预测LTR"></a>2.1.2. ltrharvest预测LTR</h3><ol>
<li>建基因组索引</li>
</ol>
<p><code>gt suffixerator -db genome.fa -indexname index/sample -tis -suf -lcp -des -ssp -sds-dna</code></p>
<ol start="2">
<li>预测LTR</li>
</ol>
<p><code>gt ltrharvest -index index/sample -minlenltr 100 -maxlenltr 7000 -mintsd 4 -maxtsd 6 -motif TGCA -motifmis 1 -similar 85 -vic 10 -seed 20 -seqids yes &gt; genome.harvest.scn</code></p>
<p>生成genome.harvest.scn</p>
<h3 id="2-1-3-合并预测结果【可选-amp-不推荐】"><a href="#2-1-3-合并预测结果【可选-amp-不推荐】" class="headerlink" title="2.1.3. 合并预测结果【可选&amp;不推荐】"></a>2.1.3. 合并预测结果【可选&amp;不推荐】</h3><p><code>cat genome.harvest.scn genome.fa.finder.combine.scn &gt; genome.rawLTR_merge.scn</code></p>
<p>因为LTR_FINDER_parallel和ltrharvest的预测结果都是一行一条信息，可以直接合并。</p>
<h3 id="2-1-4-LTR-retriever鉴定LTR"><a href="#2-1-4-LTR-retriever鉴定LTR" class="headerlink" title="2.1.4. LTR_retriever鉴定LTR"></a>2.1.4. LTR_retriever鉴定LTR</h3><p><code>LTR_retriever -genome genome.fa -inharvest genome.harvest.scn -infinder genome.fa.finder.combine.scn -threads 12 -u 4.79e-9</code></p>
<ul>
<li>这步骤耗时长。运行LTR_retriever默认会计算LAI指数，不用单独运行LAI。</li>
<li>生成的genome.out.LAI包含整个genome和每个contig的LAI指数。</li>
<li>如果前一步合并了多个LTR预测结果，则只需要在<code>-inharvest genome.rawLTR_merge.scn</code>输入合并结果。</li>
</ul>
<h2 id="2-2-单独计算LAI"><a href="#2-2-单独计算LAI" class="headerlink" title="2.2. 单独计算LAI"></a>2.2. 单独计算LAI</h2><ul>
<li>运行EDTA&#x2F;LTR_retriever预测LTR的基础上，可以利用已有的LTR预测结果计算LAI值，单独计算LAI耗时不长（&lt;10min）。</li>
<li>虽然EDTA也是调用LTR_retriever预测LTR，但默认不计算LAI。</li>
</ul>
<ol>
<li>输入文件</li>
</ol>
<ul>
<li>genome.fa.mod.pass.list：如果用EDTA调用LTR_retriever预测了LTR，则在此路径下可以找到这个文件：<code>/path/to/edta/genome.fa.mod.EDTA.raw/LTR/genome.fa.mod.pass.list</code>；如果用LTR_retriever直接预测的，在<code>LTR_retriever/genome.fa.mod.pass.list</code></li>
<li>genome.fa.mod.out：如果用EDTA预测了LTR，则在此路径下可以找到这个文件：<code>/path/to/edta/genome.fa.mod.EDTA.final/genome.fa.mod.out</code></li>
</ul>
<ol start="2">
<li>运行LAI</li>
</ol>
<p><code>nohup LAI -t 24 -genome genome.fa -intact genome.fa.mod.pass.list -all genome.fa.mod.out &amp;&gt; lai.out &amp;</code></p>
<ol start="3">
<li>参数</li>
</ol>
<ul>
<li>-t 24：blast使用的线程数量</li>
<li>-genome genome.fa：指定基因组</li>
<li>-intact genome.fa.mod.pass.list：指定LTR_retriever生成的非冗余LTR-RT文库列表</li>
<li>-all genome.fa.mod.out：指定RepeatMasker注释的所有LTR序列</li>
<li>-window 3000000：指定计算LAI的window，默认是3Mb</li>
<li>-step 300000：指定计算LAI的step，默认是300Kb</li>
<li>-q：快速评估LTR identity的模式，建议大基因组用，牺牲0.5%的精度。本人试过300Mb基因组非快速模式2分钟就出结果了，所以除非特别大的基因组，否则不建议用。</li>
<li>-qq：超快速模式。不评估LTR identity，只输出raw_LAT值（用于种间比较）。</li>
<li>-mono [file]：用文件提供序列名称，LAI只计算指定的序列。主要用于多倍体基因组，在文件中提供代表单倍体的序列。</li>
</ul>
<ol start="4">
<li>输出</li>
</ol>
<ul>
<li>sample.fa.mod.out.LAI：保存了raw_LAI值和LAI值，包括全基因组的和滑窗范围的。</li>
<li>sample.fa.mod.out.LAI.LTR.ava.age</li>
<li>sample.fa.mod.out.LAI.LTR.ava.out</li>
</ul>
<h1 id="3-references"><a href="#3-references" class="headerlink" title="3. references"></a>3. references</h1><ol>
<li>paper：<a href="https://academic.oup.com/nar/article/46/21/e126/5068908">https://academic.oup.com/nar/article/46/21/e126/5068908</a></li>
<li>github：<a href="https://github.com/oushujun/LTR_retriever">https://github.com/oushujun/LTR_retriever</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>quality assessment</category>
      </categories>
      <tags>
        <tag>genome</tag>
        <tag>LTR</tag>
        <tag>quality assessment</tag>
        <tag>LAI</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组质量评估：（二）用QUAST评估基因组组装</title>
    <url>/2021/08/23/omics_genome_quality.assessment_QUAST/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1697043&auto=1&height=32"></iframe></div>

<h1 id="1-QUAST是什么"><a href="#1-QUAST是什么" class="headerlink" title="1. QUAST是什么"></a>1. QUAST是什么</h1><p>QUAST(Quality Assessment Tool for Genome Assemblies)是基因组质量评估工具，通过计算各种指标来评估基因组的组装，包括N50,L50，GC含量等contig基本信息。</p>
<p>QUAST基于python开发，matplotlib绘图。</p>
<h1 id="2-QUAST网站"><a href="#2-QUAST网站" class="headerlink" title="2. QUAST网站"></a>2. QUAST网站</h1><ul>
<li>主页：<a href="http://quast.sourceforge.net/">http://quast.sourceforge.net/</a></li>
<li>github: <a href="https://github.com/ablab/quast">https://github.com/ablab/quast</a></li>
</ul>
<h1 id="3-QUAST安装"><a href="#3-QUAST安装" class="headerlink" title="3. QUAST安装"></a>3. QUAST安装</h1><ol>
<li>下载解压缩即可使用</li>
</ol>
<p>QUAST会在第一次使用时自动编译所有子部分，因此不需要安装，解压缩即可使用。</p>
<ul>
<li><code>wget -c https://github.com/ablab/quast/releases/download/quast_5.1.0rc1/quast-5.1.0rc1.tar.gz</code></li>
<li><code>tar -zxvf quast-5.1.0rc1.tar.gz</code></li>
<li><code>python quast.py --help</code></li>
<li><code>python quast.py --version</code></li>
</ul>
<ol start="2">
<li>conda安装</li>
</ol>
<p><code>conda install -y quast</code></p>
<ol start="3">
<li>Ubuntu 20.04系统上安装<br><code>sudo apt-get update &amp;&amp; sudo apt-get install -y pkg-config libfreetype6-dev libpng-dev python3-matplotlib</code></li>
</ol>
<h1 id="4-QUAST使用"><a href="#4-QUAST使用" class="headerlink" title="4. QUAST使用"></a>4. QUAST使用</h1><ol>
<li>简化版</li>
</ol>
<p><code>quast.py contigs.fas</code></p>
<ol start="2">
<li>全面版</li>
</ol>
<p><code>quast.py contigs_1.fa contigs_2.fa -r reference.fa -g genome.gff -1 reads1.fastq.gz -2 reads2.fastq.gz -o quast_out -t 12</code></p>
<ol start="3">
<li>参数</li>
</ol>
<ul>
<li>contigs.fa是必须提供的，即等待评估组装质量的基因组，可以多个同时评估。</li>
<li>-r reference.fa：参考基因组，可选；提供后有比较基因组的结果。</li>
<li>-g genome.gff：参考基因组的features文件，GFF,BED等格式</li>
<li>-1和-2：PE测序的FASTQ文件，可选</li>
<li>-o quast_out：指定结果输出目录</li>
<li>-t 12：线程</li>
<li>–large：大基因组推荐加上这个参数，相当于<code>-e -m 3000 -i 500 -x -k --k-mer-stats</code>，加上这个参数后运行时间长非常多，因为有-e会做基因组的基因预测，推荐大基因组使用完整参数<code>-m 3000 -i 500 -x -k</code>来节省时间。</li>
<li>-f：–gene-finding，用GeneMarkS(原核生物)或GeneMark-ES(真核生物)预测基因</li>
<li>-e：即–eukaryote，默认是用GeneMarkS预测原核生物，这个参数指定基因组是真核生物，主要影响基因预测。类似的还有–fungus。还有许多与基因预测相关的参数可选。</li>
<li>–rna-finding：用Barrnap预测ribosomal RNA genes</li>
<li>-b：用BUSCO计算保守的orthologs数量(only on Linux)</li>
<li>-m 500：小于指定长度的contig会被去除，默认是500bp。</li>
<li>-i 65：小于指定长度的alignment会被去除，默认是65bp。</li>
<li>-k：–k-mer-stats，基于k-mer计算质量参数，推荐用于大基因组。</li>
</ul>
<h1 id="5-QUAST结果"><a href="#5-QUAST结果" class="headerlink" title="5. QUAST结果"></a>5. QUAST结果</h1><ol>
<li>结果文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">report.txt      summary table</span><br><span class="line">report.tsv      tab-separated version, for parsing, or for spreadsheets (Google Docs, Excel, etc)  </span><br><span class="line">report.tex      Latex version</span><br><span class="line">report.pdf      PDF version, includes all tables and plots for some statistics</span><br><span class="line">report.html     everything in an interactive HTML file</span><br><span class="line">icarus.html     Icarus main menu with links to interactive viewers</span><br><span class="line">contigs_reports/        [only if a reference genome is provided]</span><br><span class="line">  misassemblies_report  detailed report on misassemblies</span><br><span class="line">  unaligned_report      detailed report on unaligned and partially unaligned contigs</span><br><span class="line">k_mer_stats/            [only if --k-mer-stats is specified]</span><br><span class="line">  kmers_report          detailed report on k-mer-based metrics</span><br><span class="line">reads_stats/            [only if reads are provided]</span><br><span class="line">  reads_report          detailed report on mapped reads statistics</span><br></pre></td></tr></table></figure>

<p>看report.html网页结果全面，会有图和数据，report.txt则是主要数据。</p>
<ol start="2">
<li>结果示例</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat report.txt</span><br><span class="line">Assembly                    sample</span><br><span class="line"># contigs (&gt;= 0 bp)         266</span><br><span class="line"># contigs (&gt;= 1000 bp)      266</span><br><span class="line"># contigs (&gt;= 5000 bp)      186</span><br><span class="line"># contigs (&gt;= 10000 bp)     159</span><br><span class="line"># contigs (&gt;= 25000 bp)     108</span><br><span class="line"># contigs (&gt;= 50000 bp)     30</span><br><span class="line">Total length (&gt;= 0 bp)      256218469</span><br><span class="line">Total length (&gt;= 1000 bp)   256218469</span><br><span class="line">Total length (&gt;= 5000 bp)   256043090</span><br><span class="line">Total length (&gt;= 10000 bp)  255847102</span><br><span class="line">Total length (&gt;= 25000 bp)  254902657</span><br><span class="line">Total length (&gt;= 50000 bp)  252626053</span><br><span class="line"># contigs                   266</span><br><span class="line">Largest contig              33924140</span><br><span class="line">Total length                256218469</span><br><span class="line">GC (%)                      42.94</span><br><span class="line">N50                         20460156</span><br><span class="line">N90                         13725599</span><br><span class="line">L50                         5</span><br><span class="line">L90                         11</span><br><span class="line"># N&#x27;s per 100 kbp           66.54</span><br></pre></td></tr></table></figure>

<p>references</p>
<ol>
<li><a href="http://quast.sourceforge.net/">http://quast.sourceforge.net/</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>quality assessment</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>genome</tag>
        <tag>quality assessment</tag>
        <tag>QUAST</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组质量评估：（一）概述</title>
    <url>/2022/07/10/omics_genome_quality.assessment_intro/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=509092165&auto=1&height=32"></iframe></div>

<p>(全文约1600字)</p>
<h1 id="1-基因组质量评估"><a href="#1-基因组质量评估" class="headerlink" title="1. 基因组质量评估"></a>1. 基因组质量评估</h1><ul>
<li>随着越来越多的组学测序数据的产生，基因组组装和注释变得越来越常见。</li>
<li>基因组组装和注释结果的质量评估对加强下游分析的科学性是非常有必要的。</li>
</ul>
<h1 id="2-EBP的评估标准"><a href="#2-EBP的评估标准" class="headerlink" title="2. EBP的评估标准"></a>2. EBP的评估标准</h1><p>Earth Biogenome Project（EBP）在2021年3月发布了4.0版本的核基因组组装质量标准报告。</p>
<p>可参考：<a href="https://www.earthbiogenome.org/assembly-standards%E3%80%82">https://www.earthbiogenome.org/assembly-standards。</a></p>
<h2 id="2-1-生物分组"><a href="#2-1-生物分组" class="headerlink" title="2.1. 生物分组"></a>2.1. 生物分组</h2><p>评估标准把生物分成三组，对不同组的生物提出了不同的标准：</p>
<ol>
<li>有足够DNA和材料可用的真核生物：6.C.Q40标准。</li>
</ol>
<ul>
<li>连续性（contiguity）：contig N50和scaffold N50达到Mbp级别</li>
<li>错误率（error rate）：小于1&#x2F;10000的错误率</li>
<li>&lt;5% false duplications</li>
<li>&gt;90% kmer completeness</li>
<li>&gt;90%的序列可以align到候选染色体上</li>
<li>&gt;90%的单拷贝保守基因是完整且单拷贝的，例如用BUSCO评估</li>
<li>来自同一个组织的&gt;90%转录本可以mapping到基因组</li>
<li>…</li>
</ul>
<ol start="2">
<li>DNA和材料有限的物种（例如单个个体的DNA&lt;100ng）：4.5.Q40标准</li>
</ol>
<ul>
<li>连续性（contiguity）：contig N50和scaffold N50达到10kbp级别</li>
<li>错误率（error rate）：小于1&#x2F;10000的错误率</li>
</ul>
<ol start="3">
<li>不可培养的单细胞真核生物</li>
</ol>
<ul>
<li>类似宏基因组学的标准，根据原核生物群落的经验来确定的。</li>
</ul>
<h2 id="2-2-附加要求"><a href="#2-2-附加要求" class="headerlink" title="2.2. 附加要求"></a>2.2. 附加要求</h2><p>由于自动化组装程序几乎都会在组装结果中保留一些错误，所以提出了一套质量控制标准，包括：</p>
<ol>
<li>将污染源和其他物种（例如共生物种&#x2F;寄生物种）的序列从目标物种的序列中分离去除。</li>
<li>识别初级组装（单倍型或假单倍型），应该是说尽量组装到染色体水平的意思。</li>
<li>分离去除和明确鉴定细胞器基因组。</li>
<li>只有A,C,G,T,N碱基，序列不应以Ns开头或结尾。</li>
</ol>
<p>此外，还鼓励：</p>
<ol>
<li>识别原始数据和生成的组装之间的不一致，以定位和消除结构错误（错误连接，丢失连接，错误重复）。</li>
<li>染色体的识别和命名，尤其是性染色体。</li>
<li>与已知的核型保持一致。</li>
</ol>
<h2 id="2-3-提交要求"><a href="#2-3-提交要求" class="headerlink" title="2.3. 提交要求"></a>2.3. 提交要求</h2><p>对于达到EBP要求的参考基因组，还需提交到公开数据库INSDC（GenBank&#x2F;EMBL&#x2F;DDBJ）以开放给科学同行。</p>
<ol>
<li>提交到公开数据库的基因组需要连接到一个BioProject，并建议以下图的结构进行组织和维护。</li>
</ol>
<img src="https://images.squarespace-cdn.com/content/v1/5a5e6c9518b27d27bddaf20f/1615423326812-P1BPYSR6KFUVW2CU89ZP/Screen+Shot+2021-03-10+at+7.41.45+PM.png?format=1500w" width=100% title="bioproject.png" align=center/>

<p><strong><p align="center">Figure 1. BioProjects的层级结构  图源：<a href="https://www.earthbiogenome.org/assembly-standards">https://www.earthbiogenome.org/assembly-standards</a></p></strong></p>
<ol start="2">
<li><p>同时将基因组的物种分配到NCBI分类数据库的“txid”条目，与分类学上有效的物种进行关联。如果暂时不存在有效物种名，可以用例如*Maylandia sp. “pearly”*的txid标识符。</p>
</li>
<li><p>样本个体名称也应规范。EBP建议每个基因组样本的个体都应按照规范获取一个生命树ID（ToLID）。</p>
</li>
</ol>
<ul>
<li>ToLID介绍：<a href="https://id.tol.sanger.ac.uk/">https://id.tol.sanger.ac.uk/</a></li>
<li>ToLID的组成，前两个小写字母是目及以上分类地位的代表（历史原因脊椎动物这里只有一个字母），接着是属名的前三个字母（第一个字母大写），和种加词的前四个字母（第一个字母大写），最后加上一个代表采样个体的数字（这个数字是按这个物种的采样顺序给的），更完整的版本还会在数字之后加上.version代表基因组的组装版本。</li>
<li>ToLID的一个例子，<strong>dhBauVari1.2</strong>。代表洋紫荆（Bauhinia variegata）物种的第一个个体的第二个组装版本。</li>
<li>其中<strong>d</strong>代表双子叶植物，<strong>h</strong>代表豆目，<strong>Bau</strong>是羊蹄甲属Bauhinia的前三个字母，<strong>Vari</strong>是种加词variegata的前四个字母，<strong>1</strong>代表第一个组装个体，<strong>.2</strong>代表第二个组装版本。</li>
<li>代表目及以上分类地位的前两个字母可以在<a href="https://gitlab.com/wtsi-grit/darwin-tree-of-life-sample-naming/-/tree/master/%E4%B8%8A%E7%9A%84prefix_assignment.xlsx%E6%96%87%E4%BB%B6%E9%87%8C%E6%9F%A5%E8%AF%A2%E5%88%B0%E3%80%82">https://gitlab.com/wtsi-grit/darwin-tree-of-life-sample-naming/-/tree/master/上的prefix_assignment.xlsx文件里查询到。</a></li>
</ul>
<h1 id="3-评估指标和评估工具"><a href="#3-评估指标和评估工具" class="headerlink" title="3. 评估指标和评估工具"></a>3. 评估指标和评估工具</h1><p>参考：<a href="https://www.earthbiogenome.org/assembly-standards%E3%80%82">https://www.earthbiogenome.org/assembly-standards。</a></p>
<p>常用的评估指标和评估工具包括：</p>
<ol>
<li>连贯性(continuity)：contig和scaffolds的N50，gaps数量，LAI</li>
<li>碱基准确性(base accuracy)：mapping rates</li>
<li>结构准确性(structural accuracy)：mapped reads的depth分布</li>
<li>组装和注释完整度(completeness)：BUSCO</li>
<li>染色体状态(chromosome status)：是否是染色体水平，染色体碱基占基因组的比例，尤其是性染色体。</li>
<li>单倍体相位(haplotype phasing)</li>
</ol>
<h2 id="3-1-评估指标"><a href="#3-1-评估指标" class="headerlink" title="3.1. 评估指标"></a>3.1. 评估指标</h2><img src="https://images.squarespace-cdn.com/content/v1/5a5e6c9518b27d27bddaf20f/1615423607652-3GBJA1Y1XUFCM4TT82BY/Screen+Shot+2021-03-10+at+7.46.19+PM.png?format=1500w" width=100% title="EBP_genomeassemblyquallity_metrics.png" align=center/>

<p><strong><p align="center">Figure 2. EBP建议的基因组组装质量评估指标  图源：<a href="https://www.earthbiogenome.org/assembly-standards">https://www.earthbiogenome.org/assembly-standards</a></p></strong></p>
<h2 id="3-2-评估工具"><a href="#3-2-评估工具" class="headerlink" title="3.2. 评估工具"></a>3.2. 评估工具</h2><img src="https://images.squarespace-cdn.com/content/v1/5a5e6c9518b27d27bddaf20f/1615424186322-90LC3ZP98PPTTGS3MYF5/Screen+Shot+2021-03-10+at+7.56.10+PM.png?format=1500w" width=100% title="EBP_genomeassemblyquallity_tools.png" align=center/>

<p><strong><p align="center">Figure 3. EBP建议的基因组组装质量评估工具  图源：<a href="https://www.earthbiogenome.org/assembly-standards">https://www.earthbiogenome.org/assembly-standards</a></p></strong></p>
<h2 id="3-3-其他"><a href="#3-3-其他" class="headerlink" title="3.3. 其他"></a>3.3. 其他</h2><p>本人总结了几种个人常用的指标和工具，包括：</p>
<ol>
<li>QUAST：评估基因组scaffold N50，L50等指数。</li>
<li>BUSCO：基因组和预测的蛋白组都可以用BUSCO评估基因组组装或注释的完整度(completeness)。</li>
<li>LAI：通过LTR组装指数评估基因组的连贯性(continuity)。</li>
<li>raw reads mapping法：把测序的reads（包括pacbio，Illumina，RNA-seq reads等）映射回组装好的基因组，评估mapping rate，genome coverage，depth分布等指标。这有非常多工具可用。</li>
<li>除了EBP建议的工具，还有许多其他工具。</li>
</ol>
<ul>
<li>比如FastaSeqStats用来评估基因组组装。</li>
<li>对于污染（contaminations），尤其是小的contigs的污染，还可以用blobtools进行评估和处理。</li>
</ul>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li><a href="https://www.earthbiogenome.org/assembly-standards">https://www.earthbiogenome.org/assembly-standards</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>quality assessment</category>
      </categories>
      <tags>
        <tag>genome</tag>
        <tag>organelle</tag>
        <tag>quality assessment</tag>
        <tag>transcriptome</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组质量评估：（五）mapping法：5. 用软件QualiMap统计BAM文件</title>
    <url>/2022/07/31/omics_genome_quality.assessment_mapping_QualiMap/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=18511124&auto=1&height=32"></iframe></div>

<h1 id="1-QualiMap简介"><a href="#1-QualiMap简介" class="headerlink" title="1. QualiMap简介"></a>1. QualiMap简介</h1><ul>
<li>QualiMap是用于统计bam文件的基于java的软件，结果包含详细的统计信息和可视化图形，以及每条contig的mapping情况。</li>
<li>官网（<a href="http://qualimap.conesalab.org/%EF%BC%89%E6%9C%89%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E3%80%82">http://qualimap.conesalab.org/）有软件的详细介绍。</a></li>
<li>每个模块运行的输入输出文件的案例都可以在这里查看：<a href="http://qualimap.conesalab.org/doc_html/samples.html#bam-samples">http://qualimap.conesalab.org/doc_html/samples.html#bam-samples</a></li>
</ul>
<h1 id="2-QualiMap的模块"><a href="#2-QualiMap的模块" class="headerlink" title="2. QualiMap的模块"></a>2. QualiMap的模块</h1><ol>
<li><strong>bamqc模块</strong>（BAM QC）：用于单个NGS样本bam文件的QC统计。</li>
<li><strong>rnaseq模块</strong>（RNA-seq QC）：用于转录组RNA-seq样本bam文件的QC统计。</li>
<li><strong>multi-bamqc模块</strong>（Multi-sample BAM QC）：用于多样本NGS的bam文件的分组QC统计，即包含个体数据，又包含分组比较。</li>
<li><strong>counts模块</strong>（Counts QC）：可用于转录组数据计数的统计，用于量化表达水平。</li>
<li><strong>clustering模块</strong>：用于表观基因组（例如甲基化）特征的聚类。</li>
<li><strong>comp-counts模块</strong>：输入bam文件和注释文件，计算映射到每个区域的reads数量。</li>
</ol>
<h1 id="3-下载安装"><a href="#3-下载安装" class="headerlink" title="3. 下载安装"></a>3. 下载安装</h1><p>下载解压即可使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://bitbucket.org/kokonech/qualimap/downloads/qualimap_v2.2.1.zip</span><br><span class="line">unzip qualimap_v2.2.1.zip</span><br><span class="line">cd qualimap_v2.2.1</span><br><span class="line">./qualimap -h</span><br></pre></td></tr></table></figure>

<h1 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h1><h2 id="4-1-bamqc模块"><a href="#4-1-bamqc模块" class="headerlink" title="4.1. bamqc模块"></a>4.1. bamqc模块</h2><p>bamqc模块用于单个NGS样本bam文件的统计。</p>
<ol>
<li>运行</li>
</ol>
<p><code>qualimap bamqc -bam sample.bam -outformat PDF:HTML -outdir out -nt 12 --java-mem-size=10G</code></p>
<ol start="2">
<li>参数</li>
</ol>
<ul>
<li>-bam sample.bam：指定bam文件。</li>
<li>-outformat PDF:HTML：输出文件格式PDF和HTML，默认是HTML。</li>
<li>-outdir out：输出文件的目录，不指定则生成sample_stats目录。</li>
<li>-nt 12：线程12，默认是144。</li>
<li>–java-mem-size&#x3D;10G：设置最大内存为10G，建议每个模块都设置。</li>
</ul>
<ol start="3">
<li>结果</li>
</ol>
<p>所有结果下载后，可以用浏览器打开qualimapReport.html或者打开report.pdf，可以参考给出的结果例子：<a href="https://rawgit.com/kokonech/kokonech.github.io/master/qualimap/HG00096.chr20_bamqc/qualimapReport.html%E3%80%82">https://rawgit.com/kokonech/kokonech.github.io/master/qualimap/HG00096.chr20_bamqc/qualimapReport.html。</a></p>
<p>包括以下几部分内容：</p>
<ul>
<li>globals：reads的mapping情况</li>
<li>ACGT content：四种碱基和N的含量</li>
<li>Coverage：深度</li>
<li>Mapping Quality：平均值</li>
<li>Insert Size：平均值和标准差</li>
<li>Mismatches and indels：统计值</li>
<li>Chromosome stats：每条染色体的长度，mapped bases，mean coverage，standard deviation。</li>
<li>Coverage across reference：贯穿整个基因组的深度（coverage）和GC含量</li>
<li>Coverage Histogram：深度分布</li>
<li>genome fraction coverage</li>
<li>duplication rate histogram</li>
<li>mapped reads nucleotide content</li>
<li>mapped reads GC-content distribution</li>
<li>mapped reads clipping profile</li>
<li>homopolymer indels</li>
<li>mapping quality across reference</li>
<li>mapping quality histogram</li>
<li>insert size across reference</li>
<li>insert size histogram</li>
</ul>
<p>QualiMap的所有coverage都是深度，而不是覆盖度。</p>
<h2 id="4-2-rnaseq模块"><a href="#4-2-rnaseq模块" class="headerlink" title="4.2. rnaseq模块"></a>4.2. rnaseq模块</h2><p>与bamqc模块相似，用于RNA-seq数据的bam文件的统计。</p>
<ol>
<li>运行</li>
</ol>
<p><code>qualimap rnaseq -bam rnaseq_sample.bam -outdir rnaseq_out -outformat PDF:HTML --java-mem-size=10G</code></p>
<ol start="2">
<li>参数</li>
</ol>
<ul>
<li>-bam rnaseq_sample.bam：输入的bam文件。</li>
<li>-outdir rnaseq_out：输出文件的目录。</li>
<li>-outformat PDF:HTML：输出文件格式PDF和HTML，默认是HTML。</li>
<li>–java-mem-size&#x3D;10G：设置最大内存为10G。</li>
</ul>
<h2 id="4-3-multi-bamqc模块"><a href="#4-3-multi-bamqc模块" class="headerlink" title="4.3. multi-bamqc模块"></a>4.3. multi-bamqc模块</h2><p>多样本NGS的bam文件的统计和比较。</p>
<ol>
<li>运行</li>
</ol>
<p><code>qualimap multi-bamqc -r -d qualimap.list -outdir out -outformat PDF:HTML --java-mem-size=10G</code></p>
<ol start="2">
<li>参数</li>
</ol>
<ul>
<li>-r：<code>multi-bamqc</code>模块可以输入bam文件或者<code>bamqc</code>模块的结果，如果输入bam文件则需加-r参数。</li>
<li>-d qualimap.list：输入文件列表，qualimap有三列，每行一个样本，第一列样品名称，第二列包含路径的bam文件&#x2F;bamqc结果目录，第三列组名。</li>
<li>如果用-r，qualimap.list的第二列则应为bam文件，此时multi-bamqc模块会先对每个样本运行bamqc，bamqc的结果存放在bam文件所在目录下，再进行multi-bamqc的统计。默认是用4个线程，一个样本一个样本单独跑bamqc。</li>
<li>-outdir out：结果文件输出目录。</li>
<li>-outformat PDF:HTML：结果文件格式，pdf和html都要。</li>
<li>–java-mem-size&#x3D;10G：设置最大内存为10G。</li>
</ul>
<h2 id="4-4-counts-clustering-comp-counts模块"><a href="#4-4-counts-clustering-comp-counts模块" class="headerlink" title="4.4. counts,clustering,comp-counts模块"></a>4.4. counts,clustering,comp-counts模块</h2><p>此外，还有counts,clustering,comp-counts模块。</p>
<p>… …</p>
<h1 id="5-tips"><a href="#5-tips" class="headerlink" title="5. tips"></a>5. tips</h1><p>如果遇到报错RAM不足，可以加上参数<code>--java-mem-size=10G</code>指定内存上限。</p>
<h1 id="6-references"><a href="#6-references" class="headerlink" title="6. references"></a>6. references</h1><ol>
<li><a href="http://qualimap.conesalab.org/">http://qualimap.conesalab.org/</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>quality assessment</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>genome</tag>
        <tag>quality assessment</tag>
        <tag>mapping</tag>
        <tag>sam</tag>
        <tag>bam</tag>
        <tag>depth</tag>
        <tag>QualiMap</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组质量评估：（五）mapping法：6. 用软件bamdst统计BAM文件</title>
    <url>/2022/07/31/omics_genome_quality.assessment_mapping_bamdst/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=5351733&auto=1&height=32"></iframe></div>

<h1 id="1-bamdst简介"><a href="#1-bamdst简介" class="headerlink" title="1. bamdst简介"></a>1. bamdst简介</h1><p>bamdst（<a href="https://github.com/shiquan/bamdst%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E7%BB%9F%E8%AE%A1bam%E6%96%87%E4%BB%B6%E7%9B%AE%E6%A0%87%E5%8C%BA%E5%9F%9F%E6%B7%B1%E5%BA%A6%E5%92%8C%E8%A6%86%E7%9B%96%E5%BA%A6%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%8C%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%85%A8%E9%9D%A2%EF%BC%8C%E5%8C%85%E6%8B%ACcoverage%EF%BC%8Cdepth%EF%BC%8Cmapping">https://github.com/shiquan/bamdst）是一个统计bam文件目标区域深度和覆盖度的工具，统计数据全面，包括coverage，depth，mapping</a> rate。</p>
<h1 id="2-下载安装"><a href="#2-下载安装" class="headerlink" title="2. 下载安装"></a>2. 下载安装</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/shiquan/bamdst.git</span><br><span class="line">cd bamdst</span><br><span class="line">make</span><br><span class="line">./bamdst -h</span><br></pre></td></tr></table></figure>

<h1 id="3-分析"><a href="#3-分析" class="headerlink" title="3. 分析"></a>3. 分析</h1><h2 id="3-1-输入文件"><a href="#3-1-输入文件" class="headerlink" title="3.1. 输入文件"></a>3.1. 输入文件</h2><ol>
<li>sample.bed</li>
</ol>
<ul>
<li>sample.bed文件包含分析的位置，共有三列，tab分隔。包括染色体名称，起始位置，终止位置。</li>
<li>如果计算基因组全部数据，则包含基因组所有染色体的位置。建议用genome.fa.fai索引文件转化生成<code>cat genome.fa.fai |awk &#39;&#123;print $1&quot;\t1\t&quot;$2&#125;&#39; &gt; sample.bed</code>。</li>
</ul>
<ol start="2">
<li>sample.bam</li>
</ol>
<ul>
<li>sample.bam文件需要已排序（samtools sort可实现）</li>
</ul>
<h2 id="3-2-运行"><a href="#3-2-运行" class="headerlink" title="3.2. 运行"></a>3.2. 运行</h2><p><code>bamdst -p sample.bed sample.bam -o ./</code></p>
<ul>
<li>-p sample.bed：指定bed文件</li>
<li>-o .&#x2F; ：输出目录</li>
</ul>
<h2 id="3-3-结果"><a href="#3-3-结果" class="headerlink" title="3.3. 结果"></a>3.3. 结果</h2><ol>
<li>coverage.report</li>
</ol>
<ul>
<li>总结的统计信息，包括reads的mapping rate，genome coverage，average depth等数据。示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## The file was created by bamdst</span><br><span class="line">## Version : 1.0.9</span><br><span class="line">## Files : ./sample.bam</span><br><span class="line">                               [Total] Raw Reads (All reads)	86430326</span><br><span class="line">                                       [Total] QC Fail reads	0</span><br><span class="line">                                        [Total] Raw Data(Mb)	10773.87</span><br><span class="line">                                        [Total] Paired Reads	86430326</span><br><span class="line">                                        [Total] Mapped Reads	84639699</span><br><span class="line">                            [Total] Fraction of Mapped Reads	97.93% # mapping rate</span><br><span class="line">                                     [Total] Mapped Data(Mb)	10550.19</span><br><span class="line">                         [Total] Fraction of Mapped Data(Mb)	97.92%</span><br><span class="line">                                     [Total] Properly paired	82169742</span><br><span class="line">                         [Total] Fraction of Properly paired	95.07%</span><br><span class="line">                                [Total] Read and mate paired	84430784</span><br><span class="line">                    [Total] Fraction of Read and mate paired	97.69%</span><br><span class="line">                                          [Total] Singletons	208915</span><br><span class="line">                       [Total] Read and mate map to diff chr	1568692</span><br><span class="line">                                               [Total] Read1	43215163</span><br><span class="line">                                               [Total] Read2	43215163</span><br><span class="line">                                        [Total] Read1(rmdup)	42319713</span><br><span class="line">                                        [Total] Read2(rmdup)	42319986</span><br><span class="line">                                [Total] forward strand reads	42323338</span><br><span class="line">                               [Total] backward strand reads	42316361</span><br><span class="line">                                 [Total] PCR duplicate reads	0</span><br><span class="line">                     [Total] Fraction of PCR duplicate reads	0.00%</span><br><span class="line">                            [Total] Map quality cutoff value	20</span><br><span class="line">                       [Total] MapQuality above cutoff reads	76685486</span><br><span class="line">                 [Total] Fraction of MapQ reads in all reads	88.73%</span><br><span class="line">              [Total] Fraction of MapQ reads in mapped reads	90.60%</span><br><span class="line">                                       [Target] Target Reads	84639699</span><br><span class="line">              [Target] Fraction of Target Reads in all reads	97.93%</span><br><span class="line">           [Target] Fraction of Target Reads in mapped reads	100.00%</span><br><span class="line">                                    [Target] Target Data(Mb)	10457.94</span><br><span class="line">                              [Target] Target Data Rmdup(Mb)	9505.01</span><br><span class="line">                [Target] Fraction of Target Data in all data	97.07%</span><br><span class="line">             [Target] Fraction of Target Data in mapped data	99.13%</span><br><span class="line">                                      [Target] Len of region	256218203</span><br><span class="line">                                      [Target] Average depth	40.82 # average depth</span><br><span class="line">                               [Target] Average depth(rmdup)	37.10</span><br><span class="line">                                     [Target] Coverage (&gt;0x)	99.58% # genome coverage</span><br><span class="line">                                    [Target] Coverage (&gt;=4x)	99.12%</span><br><span class="line">                                   [Target] Coverage (&gt;=10x)	97.41%</span><br><span class="line">                                   [Target] Coverage (&gt;=30x)	68.46%</span><br><span class="line">                                  [Target] Coverage (&gt;=100x)	0.83%</span><br><span class="line">                                [Target] Target Region Count	266</span><br><span class="line">                                [Target] Region covered &gt; 0x	261</span><br><span class="line">                       [Target] Fraction Region covered &gt; 0x	98.12%</span><br><span class="line">                      [Target] Fraction Region covered &gt;= 4x	97.74%</span><br><span class="line">                     [Target] Fraction Region covered &gt;= 10x	94.36%</span><br><span class="line">                     [Target] Fraction Region covered &gt;= 30x	53.01%</span><br><span class="line">                    [Target] Fraction Region covered &gt;= 100x	12.78%</span><br><span class="line">                                          [flank] flank size	200</span><br><span class="line">           [flank] Len of region (not include target region)	256271403</span><br><span class="line">                                       [flank] Average depth	40.79</span><br><span class="line">                                         [flank] flank Reads	84639699</span><br><span class="line">                [flank] Fraction of flank Reads in all reads	97.93%</span><br><span class="line">             [flank] Fraction of flank Reads in mapped reads	100.00%</span><br><span class="line">                                      [flank] flank Data(Mb)	10452.76</span><br><span class="line">                  [flank] Fraction of flank Data in all data	97.02%</span><br><span class="line">               [flank] Fraction of flank Data in mapped data	99.08%</span><br><span class="line">                                      [flank] Coverage (&gt;0x)	99.54%</span><br><span class="line">                                     [flank] Coverage (&gt;=4x)	99.08%</span><br><span class="line">                                    [flank] Coverage (&gt;=10x)	97.36%</span><br><span class="line">                                    [flank] Coverage (&gt;=30x)	68.41%</span><br><span class="line">                                   [flank] Coverage (&gt;=100x)	0.83%</span><br></pre></td></tr></table></figure>

<ul>
<li>每个值具体的解释：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> [Total] Raw Reads (All reads) // All reads in the bam file(s).</span><br><span class="line"> [Total] QC Fail reads // Reads number failed QC, this flag is marked by other software,like bwa. See flag in the bam structure.</span><br><span class="line"> [Total] Raw Data(Mb) // Total reads data in the bam file(s).</span><br><span class="line">[Total] Paired Reads // Paired reads numbers.</span><br><span class="line">[Total] Mapped Reads // Mapped reads numbers.</span><br><span class="line">[Total] Fraction of Mapped Reads // Ratio of mapped reads against raw reads.</span><br><span class="line">[Total] Mapped Data(Mb) // Mapped data in the bam file(s).</span><br><span class="line">[Total] Fraction of Mapped Data(Mb) // Ratio of mapped data against raw data.</span><br><span class="line">[Total] Properly paired // Paired reads with properly insert size. See bam format protocol for details.</span><br><span class="line">[Total] Fraction of Properly paired // Ratio of properly paired reads against mapped reads</span><br><span class="line">[Total] Read and mate paired // Read (read1) and mate read (read2) paired.</span><br><span class="line">[Total] Fraction of Read and mate paired // Ratio of read and mate paired against mapped reads</span><br><span class="line">[Total] Singletons // Read mapped but mate read unmapped, and vice versa.</span><br><span class="line">[Total] Read and mate map to diff chr // Read and mate read mapped to different chromosome, usually because mapping error and structure variants.</span><br><span class="line">[Total] Read1 // First reads in mate paired sequencing</span><br><span class="line">[Total] Read2 // Mate reads</span><br><span class="line">[Total] Read1(rmdup) // First reads after remove duplications.</span><br><span class="line">[Total] Read2(rmdup) // Mate reads after remove duplications.</span><br><span class="line">[Total] forward strand reads // Number of forward strand reads.</span><br><span class="line">[Total] backward strand reads // Number of backward strand reads.</span><br><span class="line">[Total] PCR duplicate reads // PCR duplications.</span><br><span class="line">[Total] Fraction of PCR duplicate reads // Ratio of PCR duplications.</span><br><span class="line">[Total] Map quality cutoff value // Cutoff map quality score, this value can be set by -q. default is 20, because some variants caller like GATK only consider high quality reads.</span><br><span class="line">[Total] MapQuality above cutoff reads // Number of reads with higher or equal quality score than cutoff value.</span><br><span class="line">[Total] Fraction of MapQ reads in all reads // Ratio of reads with higher or equal Q score against raw reads.</span><br><span class="line">[Total] Fraction of MapQ reads in mapped reads // Ratio of reads with higher or equal Q score against mapped reads.</span><br><span class="line">[Target] Target Reads // Number of reads covered target region (specified by bed file).</span><br><span class="line">[Target] Fraction of Target Reads in all reads // Ratio of target reads against raw reads.</span><br><span class="line">[Target] Fraction of Target Reads in mapped reads // Ratio of target reads against mapped reads.</span><br><span class="line">[Target] Target Data(Mb) // Total bases covered target region. If a read covered target region partly, only the covered bases will be counted.</span><br><span class="line">[Target] Target Data Rmdup(Mb) // Total bases covered target region after remove PCR duplications. </span><br><span class="line">[Target] Fraction of Target Data in all data // Ratio of target bases against raw bases.</span><br><span class="line">[Target] Fraction of Target Data in mapped data // Ratio of target bases against mapped bases.</span><br><span class="line">[Target] Len of region // The length of target regions.</span><br><span class="line">[Target] Average depth // Average depth of target regions. Calculated by &quot;target bases / length of regions&quot;.</span><br><span class="line">[Target] Average depth(rmdup) // Average depth of target regions after remove PCR duplications.</span><br><span class="line">[Target] Coverage (&gt;0x) // Ratio of bases with depth greater than 0x in target regions, which also means the ratio of covered regions in target regions.</span><br><span class="line">[Target] Coverage (&gt;=4x) // Ratio of bases with depth greater than or equal to 4x in target regions.</span><br><span class="line">[Target] Coverage (&gt;=10x) // Ratio of bases with depth greater than or equal to 10x in target regions.</span><br><span class="line">[Target] Coverage (&gt;=30x) // Ratio of bases with depth greater than or equal to 30x in target regions.</span><br><span class="line">[Target] Coverage (&gt;=100x) // Ratio of bases with depth greater than or equal to 100x in target regions.</span><br><span class="line">[Target] Coverage (&gt;=Nx) // This is addtional line for user self-defined cutoff value, see --cutoffdepth</span><br><span class="line">[Target] Target Region Count // Number of target regions. In normal practise,it is the total number of exomes.</span><br><span class="line">[Target] Region covered &gt; 0x // The number of these regions with average depth greater than 0x.</span><br><span class="line">[Target] Fraction Region covered &gt; 0x // Ratio of these regions with average depth greater than 0x.</span><br><span class="line">[Target] Fraction Region covered &gt;= 4x // Ratio of these regions with average depth greater than or equal to 4x.</span><br><span class="line">[Target] Fraction Region covered &gt;= 10x // Ratio of these regions with average depth greater than or equal to 10x.</span><br><span class="line">[Target] Fraction Region covered &gt;= 30x // Ratio of these regions with average depth greater than or equal to 30x.</span><br><span class="line">[Target] Fraction Region covered &gt;= 100x // Ratio of these regions with average depth greater than or equal to 100x.</span><br><span class="line">[flank] flank size // The flank size will be count. 200 bp in default. Oligos could also capture the nearby regions of target regions.</span><br><span class="line">[flank] Len of region (not include target region) // The length of flank regions (target regions will not be count).</span><br><span class="line">[flank] Average depth // Average depth of flank regions.</span><br><span class="line">[flank] flank Reads // The total number of reads covered the flank regions. Note: some reads covered the edge of target regions, will be count in flank regions also. </span><br><span class="line">[flank] Fraction of flank Reads in all reads // Ratio of reads covered in flank regions against raw reads.</span><br><span class="line">[flank] Fraction of flank Reads in mapped reads // Ration of reads covered in flank regions against mapped reads.</span><br><span class="line">[flank] flank Data(Mb) // Total bases in the flank regions.</span><br><span class="line">[flank] Fraction of flank Data in all data // Ratio of total bases in the flank regions against raw data.</span><br><span class="line">[flank] Fraction of flank Data in mapped data // Ratio of total bases in the flank regions against mapped data.</span><br><span class="line">[flank] Coverage (&gt;0x) // Ratio of flank bases with depth greater than 0x.</span><br><span class="line">[flank] Coverage (&gt;=4x) // Ratio of flank bases with depth greater than or equal to 4x.</span><br><span class="line">[flank] Coverage (&gt;=10x) // Ratio of flank bases with depth greater than or equal to 10x.</span><br><span class="line">[flank] Coverage (&gt;=30x) // Ratio of flank bases with depth greater than or equal to 30x.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>chromosomes.report</li>
</ol>
<ul>
<li>每条染色体的depth和coverage信息，示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Chromosome	   DATA(%)	 Avg depth	    Median	 Coverage%	  Cov 4x %	 Cov 10x %	 Cov 30x %	Cov 100x %</span><br><span class="line">  MCscaf061	    0.00	   42.69	     41.0	  100.00	  100.00	   99.30	   86.09	    0.00</span><br><span class="line">  MCscaf062	    0.02	   66.31	     37.0	  100.0099.85	   99.26	   71.85	    0.40</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>insertsize.plot</li>
</ol>
<ul>
<li>推断的insert size分布。示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0	0	0.000000	41302164	1.000000</span><br><span class="line">1	0	0.000000	41302164	1.000000</span><br><span class="line">2	169	0.000004	41301995	0.999996</span><br><span class="line">3	154	0.000004	41301841	0.999992</span><br><span class="line">4	179	0.000004	41301662	0.999988</span><br><span class="line">5	220	0.000005	41301442	0.999982</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>uncover.bed</li>
</ol>
<ul>
<li>文件包含sample.bam在sample.bed上bad covered或uncovered region的区域。示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MCscaf062	3308	3324</span><br><span class="line">MCscaf062	13172	13219</span><br><span class="line">MCscaf063	1966	1988</span><br><span class="line">MCscaf064	154	177</span><br><span class="line">MCscaf065	4380	4388</span><br><span class="line">MCscaf065	15265	15278</span><br><span class="line">MCscaf065	49992	50000</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>depth_distribution.plot</li>
</ol>
<ul>
<li>示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0	1080969	0.004219	255137234	0.995781</span><br><span class="line">1	375560	0.001466	254761674	0.994315</span><br><span class="line">2	376656	0.001470	254385018	0.992845</span><br><span class="line">3	420120	0.001640	253964898	0.991206</span><br><span class="line">4	471142	0.001839	253493756	0.989367</span><br><span class="line">5	548760	0.002142	252944996	0.987225</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>depth.tsv.gz</li>
</ol>
<p>文件包含输入的sample.bed的每个位置的三种深度：</p>
<ul>
<li>raw depth：没有过滤的从bam文件直接提取的深度。coverage.report文件是用raw depth统计得到的。</li>
<li>rmdup depth：过滤掉duplicated reads，secondary alignment reads，low map quality reads(mapQ&lt;20)后计算的depth。开发者说类似<code>samtools depth</code>的结果，但应该是raw depth类似<code>samtools depth</code>，rmdup depth类似<code>samtools mpileup</code>才更准确。如果想用rmdup depth统计coverage.report，运行时加上参数“–use_rmdup”。</li>
<li>coverage depth：考虑deletion区域的raw depth，所以值会大于或等于raw depth的值。</li>
</ul>
<ol start="7">
<li>region.tsv.gz</li>
</ol>
<ul>
<li>文件包含输入的sample.bed的每个区域的average depth，median depth，coverage。</li>
</ul>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li><a href="https://github.com/shiquan/bamdst">https://github.com/shiquan/bamdst</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>quality assessment</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>genome</tag>
        <tag>quality assessment</tag>
        <tag>mapping</tag>
        <tag>sam</tag>
        <tag>bam</tag>
        <tag>depth</tag>
        <tag>bamdst</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组质量评估：（五）mapping法：4. 观察mapped reads的深度分布</title>
    <url>/2022/07/27/omics_genome_quality.assessment_mapping_depth_observe/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=26515663&auto=1&height=32"></iframe></div>

<h1 id="1-前情提要：mapping和depth"><a href="#1-前情提要：mapping和depth" class="headerlink" title="1. 前情提要：mapping和depth"></a>1. 前情提要：mapping和depth</h1><p>此篇博客在已经通过mapping获得SAM&#x2F;BAM文件，且进行深度统计获得深度分布文件的基础上进行分析，</p>
<ol>
<li>关于mapping获得SAM&#x2F;BAM文件的操作可以参考博客：</li>
</ol>
<p><a href="https://yanzhongsino.github.io/2022/07/23/omics_genome_quality.assessment_mapping_intro/">基因组质量评估：（五）mapping法：1. 简介</a></p>
<ol>
<li>关于通过SAM&#x2F;BAM文件统计深度分布可以参考博客：</li>
</ol>
<p><a href="https://yanzhongsino.github.io/2022/07/27/omics_genome_quality.assessment_mapping_depth_samtools/">基因组质量评估：（五）mapping法：3. 统计mapped reads的深度分布</a></p>
<h1 id="2-深度分布"><a href="#2-深度分布" class="headerlink" title="2. 深度分布"></a>2. 深度分布</h1><ul>
<li>在测序是随机分布的情况下，期望在基因组的所有染色体上，mapped reads的depth是均匀分布的。</li>
<li>把reads回mapping到组装好的基因组，通过计算depth，观察depth在基因组上的分布来判断组装的质量。</li>
</ul>
<h1 id="3-评估对象"><a href="#3-评估对象" class="headerlink" title="3. 评估对象"></a>3. 评估对象</h1><p>用clean reads映射（mapping）回组装好的初始基因组，然后查看mapping的效果。</p>
<ul>
<li>如果是长度不长的细胞器基因组，或者核基因组的特定位置，可以在IGV直接查看mapping情况。</li>
<li>如果是大的核基因组，则考虑过滤mapping得到的sam&#x2F;bam文件，然后计算深度和其他统计值来评估质量。</li>
</ul>
<h1 id="4-查看深度"><a href="#4-查看深度" class="headerlink" title="4. 查看深度"></a>4. 查看深度</h1><h2 id="4-1-背景"><a href="#4-1-背景" class="headerlink" title="4.1. 背景"></a>4.1. 背景</h2><ol>
<li>由于<strong>叶绿体基因组</strong>结构稳定，较少需要用这种方式评估组装质量；<strong>核基因组</strong>较大，肉眼观察不可实现，所以此方法多用于<strong>线粒体基因组</strong>组装质量和核基因组部分区域的评估。</li>
<li>在核与细胞器同时测序情况下，由于数量分布差异，期望测序深度是叶绿体&gt;线粒体&gt;核基因，且三者差异是数量级级别的。</li>
<li>评估线粒体基因组时，可以考虑是否有叶绿体&#x2F;核的reads映射到基因组上，并同时考虑水平基因转移的可能性。</li>
</ol>
<h2 id="线粒体基因组的mapping注意事项"><a href="#线粒体基因组的mapping注意事项" class="headerlink" title="线粒体基因组的mapping注意事项"></a>线粒体基因组的mapping注意事项</h2><ol>
<li>如果担心叶绿体派生的reads影响重组率的计算，可以把叶绿体基因组和线粒体基因组一起做reference做mapping，这样叶绿体的reads会被mapping到叶绿体上，从而起到过滤叶绿体派生reads的作用。</li>
<li>如果担心核基因派生的reads影响，可以用一个cutoff值(比如100bp)，小于100bp的mapping被筛除。同时在深度分布查看做进一步肉眼判断和筛除。</li>
</ol>
<h2 id="4-2-深度分布的查看"><a href="#4-2-深度分布的查看" class="headerlink" title="4.2. 深度分布的查看"></a>4.2. 深度分布的查看</h2><p>​可以在IGV等bam文件可视化的软件里直观地查看mapped reads的深度分布。</p>
<p>期望深度在全基因组范围保持相当，如果有极端高&#x2F;低的深度，则怀疑组装错误，或者映射了错误的reads，反映了错误或者特定特征的mapped reads。</p>
<ol>
<li>重复序列</li>
</ol>
<ul>
<li>如果基因组上存在重复序列，组装时只得到其中一个拷贝，则在这个拷贝处的mapped reads深度会是附近序列的两倍（三个拷贝就三倍）。</li>
<li>重复序列一般只分析超过100bp(或者&gt;50bp)的情况，这可以和核基因转移到线粒体的情况区别开。</li>
<li>重复序列之间非常接近，但不一定是完美匹配。</li>
</ul>
<ol start="2">
<li>水平基因转移【线粒体】</li>
</ol>
<ul>
<li>显著高的深度可能是叶绿体的reads。</li>
<li>显著低的深度可能是核的reads。</li>
<li>轻微高的深度可能是核转移到线粒体的情况（一般这种情况映射到的序列不长，&lt;100bp）。可以调整参数，只保留映射超过100bp的reads即可排除这种情况。</li>
</ul>
<ol start="3">
<li>异质性【线粒体】<br>由于一个细胞中有多个细胞器，细胞器之间还可能存在不同构象或不同碱基的位点。这种情况的存在称为<strong>细胞器的异质性</strong>（不常见）。</li>
</ol>
<p>具有异质位点的细胞器基因组的证据：</p>
<ul>
<li>排除重复序列映射的可能性。</li>
<li>异质位点映射的reads包含两种（也可能多种，以下同）碱基，一般少数种的占比超过5%就可能算异质性了。</li>
<li>异质位点映射的reads的两种碱基的深度加起来应该与周围位点的深度相当。</li>
<li>异质位点映射的reads不全都很短（&gt;100bp），双端测序的最好是成对映射。</li>
<li>异质位点周围的位点映射了同一read，且周围位点的mapping效果很好（单一碱基，均匀深度）。</li>
</ul>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>quality assessment</category>
      </categories>
      <tags>
        <tag>mitogenome</tag>
        <tag>genome</tag>
        <tag>organelle</tag>
        <tag>quality assessment</tag>
        <tag>mapping</tag>
        <tag>sam</tag>
        <tag>bam</tag>
        <tag>depth</tag>
        <tag>plastome</tag>
        <tag>samtools</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组质量评估：（五）mapping法：3. 统计mapped reads的深度分布</title>
    <url>/2022/07/27/omics_genome_quality.assessment_mapping_depth_samtools/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=2117115&auto=1&height=32"></iframe></div>

<h1 id="1-前情提要：mapping"><a href="#1-前情提要：mapping" class="headerlink" title="1. 前情提要：mapping"></a>1. 前情提要：mapping</h1><p>此篇博客在已通过mapping获得SAM&#x2F;BAM文件的基础上进行分析，</p>
<ol>
<li>关于mapping获得SAM&#x2F;BAM文件的操作可以参考博客：</li>
</ol>
<p><a href="https://yanzhongsino.github.io/2022/07/23/omics_genome_quality.assessment_mapping_intro/">基因组质量评估：（五）mapping法：1. 简介</a></p>
<h1 id="2-深度（depth）分布"><a href="#2-深度（depth）分布" class="headerlink" title="2. 深度（depth）分布"></a>2. 深度（depth）分布</h1><ul>
<li>在测序是随机分布的情况下，期望在基因组的所有染色体上，mapped reads的depth是均匀分布的。</li>
<li>把reads回mapping到组装好的基因组，通过计算depth，观察depth在基因组上的分布来判断组装的质量。</li>
</ul>
<h1 id="3-统计深度（depth）"><a href="#3-统计深度（depth）" class="headerlink" title="3. 统计深度（depth）"></a>3. 统计深度（depth）</h1><h2 id="3-1-samtools统计"><a href="#3-1-samtools统计" class="headerlink" title="3.1. samtools统计"></a>3.1. samtools统计</h2><p><code>samtools</code>的<code>depth</code>调用<code>mpileup</code>模块进行mapped reads的深度统计。</p>
<h3 id="3-1-1-samtools-depth统计"><a href="#3-1-1-samtools-depth统计" class="headerlink" title="3.1.1. samtools depth统计"></a>3.1.1. samtools depth统计</h3><ol>
<li>samtools depth统计</li>
</ol>
<ul>
<li><code>samtools depth illumina.bam &gt; depth.out</code></li>
</ul>
<ol start="2">
<li>输出</li>
</ol>
<ul>
<li>depth.out有三列数据，tab分隔。</li>
<li>第一列参考序列（染色体）名称；</li>
<li>第二列位置；</li>
<li>第三列比对上的reads数量（即depth）。</li>
</ul>
<h3 id="3-1-2-samtools-mpileup统计"><a href="#3-1-2-samtools-mpileup统计" class="headerlink" title="3.1.2. samtools mpileup统计"></a>3.1.2. samtools mpileup统计</h3><ol>
<li>运行</li>
</ol>
<ul>
<li><code>samtools mpileup -A -Q sample.bam &gt; mpileup.out</code></li>
</ul>
<ol start="2">
<li>输出</li>
</ol>
<ul>
<li>mpileup.out共有6列数据，tab分隔。</li>
<li>第一列参考序列（染色体）名称；</li>
<li>第二列位置；</li>
<li>第三列参考序列的碱基；</li>
<li>第四列比对上的reads数量（即depth）；</li>
<li>第五列比对上的情况；</li>
<li>第六列比对上的碱基的质量。</li>
</ul>
<ol start="3">
<li>第五列比对上的情况，具体解释：</li>
</ol>
<ul>
<li>*表示模糊碱基</li>
<li>大写表示在正链不匹配</li>
<li>小写表示在负链不匹配</li>
<li>^表示匹配的碱基是一个reads的开始，^后紧跟的ascii码减去33代表比对质量，修饰的是后面的碱基，后面紧跟的碱基代表该read的第一个碱基</li>
<li>$代表一个read的结束，该符号修饰前面的碱基</li>
<li>正则表达式<code>+[0-9]+[ACGTNacgtn]+</code>代表在该位点后插入的碱基。举例中chr1的2003928A后面有个+6GGGCCG，很可能是indel</li>
<li>正则表达式<code>-[0-9]+[ACGTNacgtn]+</code>代表在该位点后缺失的碱基</li>
</ul>
<h3 id="3-1-3-samtools-mpileup和samtools-depth的差异"><a href="#3-1-3-samtools-mpileup和samtools-depth的差异" class="headerlink" title="3.1.3. samtools mpileup和samtools depth的差异"></a>3.1.3. samtools mpileup和samtools depth的差异</h3><ol>
<li>差异</li>
</ol>
<ul>
<li><code>samtools depth</code>是调用了<code>samtools mpileup</code>进行的。</li>
<li>所以<code>samtools mpileup</code>可以设置更多参数进行过滤，也有一些默认的过滤参数；而<code>samtools depth</code>没有进行过滤。</li>
</ul>
<ol start="2">
<li><code>samtools mpileup</code>的默认过滤</li>
</ol>
<ul>
<li><code>samtools mpileup</code>默认过滤掉测序质量&lt;13的碱基；</li>
<li><code>samtools mpileup</code>默认过滤掉PE reads中比对异常的reads（包括双端都比上，但是两条配对reads之间的比对距离明显偏离了插入片段的长度分布，或者一端比对上而另一端没比对上）。除非加上-A参数保留异常reads，才与<code>samtools depth</code>一致。</li>
</ul>
<h2 id="3-2-其他方法"><a href="#3-2-其他方法" class="headerlink" title="3.2. 其他方法"></a>3.2. 其他方法</h2><p>除了这里提到的统计深度的方法，还有mosdepth,bamdst,quallimap等软件可以实现，在接下来的博客里会详细介绍。</p>
<h1 id="4-深度分布作图"><a href="#4-深度分布作图" class="headerlink" title="4. 深度分布作图"></a>4. 深度分布作图</h1><p>统计获得滑窗或者位点的深度后，可以作点图&#x2F;折线图来直观地观察深度在整个染色体上的分布。</p>
<h1 id="5-references"><a href="#5-references" class="headerlink" title="5. references"></a>5. references</h1><ol>
<li>samtools mpileup和samtools depth计算的depth不同的解释：<a href="https://zhuanlan.zhihu.com/p/73208822">https://zhuanlan.zhihu.com/p/73208822</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>quality assessment</category>
      </categories>
      <tags>
        <tag>mitogenome</tag>
        <tag>genome</tag>
        <tag>organelle</tag>
        <tag>quality assessment</tag>
        <tag>mapping</tag>
        <tag>sam</tag>
        <tag>bam</tag>
        <tag>depth</tag>
        <tag>plastome</tag>
        <tag>samtools</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组质量评估：（五）mapping法：1. 简介</title>
    <url>/2022/07/23/omics_genome_quality.assessment_mapping_intro/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=2192010&auto=1&height=32"></iframe></div>

<h1 id="1-基因组评估的方法——mapping法"><a href="#1-基因组评估的方法——mapping法" class="headerlink" title="1. 基因组评估的方法——mapping法"></a>1. 基因组评估的方法——mapping法</h1><p>把测序reads与组装好的基因组做alignment，这个操作常被称为mapping。mapping之后生成SAM&#x2F;BAM格式文件，通过分析SAM&#x2F;BAM格式文件，获取reads mapping回参考基因组的信息（比如mapping rate，coverage，depth），从而评估基因组组装的质量。</p>
<h2 id="1-1-mapping工具"><a href="#1-1-mapping工具" class="headerlink" title="1.1. mapping工具"></a>1.1. mapping工具</h2><p>不同的reads可以用不同的软件进行mapping</p>
<table>
<thead>
<tr>
<th>reads</th>
<th>mapping tools</th>
</tr>
</thead>
<tbody><tr>
<td>Illumina reads</td>
<td>BWA</td>
</tr>
<tr>
<td>Pacbio reads</td>
<td>minimap2</td>
</tr>
<tr>
<td>RNA-seq</td>
<td>HiSat2</td>
</tr>
</tbody></table>
<h2 id="1-2-评估指标"><a href="#1-2-评估指标" class="headerlink" title="1.2. 评估指标"></a>1.2. 评估指标</h2><p>主要是通过以下三个量化指标来评估组装质量：</p>
<ol>
<li>mapping rate</li>
</ol>
<ul>
<li>reads的mapping rate：$mapped reads number&#x2F;total reads number$</li>
<li>HiSat2对RNA-seq进行mapping时把mapping rate统计在log文件中</li>
<li><code>samtools flagstat</code>，bamdst等软件也可以统计mapping rate</li>
</ul>
<ol start="2">
<li>genome coverage</li>
</ol>
<ul>
<li>genome coverage：$mapped genome length&#x2F;total genome length$</li>
<li><code>samtools depth</code>，bedtools，bamdst等软件也可以统计genome coverage</li>
</ul>
<ol start="3">
<li>depth</li>
</ol>
<ul>
<li>平均depth：计算基因组的平均深度作为参考指标</li>
<li>depth的分布：基因组上每个碱基mapped碱基的数量称为单碱基的深度（depth），或者通过滑窗统计基因组上每个固定大小（比如1000bp）的窗口的mapped碱基的平均数量作为窗口深度，分析深度在基因组上的分布可以判断基因组组装的质量。</li>
<li>此外，通过可视化软件直观地查看reads在基因组上具体的mapping情况，也可以判断基因组组装是否存在错误碱基、组装结构问题。</li>
<li><code>samtools mpileup</code>,<code>samtools depth</code>，qualimap，bamdst，mosdepth等软件可以计算平均深度和深度分布信息。</li>
</ul>
<h1 id="2-mapping实操"><a href="#2-mapping实操" class="headerlink" title="2. mapping实操"></a>2. mapping实操</h1><p>用特定工具对各种reads进行mapping，生成SAM&#x2F;BAM文件。</p>
<h2 id="2-1-Illumina-reads：BWA"><a href="#2-1-Illumina-reads：BWA" class="headerlink" title="2.1. Illumina reads：BWA"></a>2.1. Illumina reads：BWA</h2><p>用BWA-MEM+samtools对Illumina reads进行mapping</p>
<ol>
<li>建索引</li>
</ol>
<ul>
<li><code>bwa index ref.fa</code></li>
</ul>
<ol start="2">
<li>bwa mapping</li>
</ol>
<ul>
<li><code>bwa mem -t 4 ref.fa R1.clean.fq r2.clean.fq | samtools sort -@ 4 -m 4G &gt; illumina.bam &amp;</code></li>
</ul>
<h2 id="2-2-PacBio-x2F-Nanopore-reads：minimap2"><a href="#2-2-PacBio-x2F-Nanopore-reads：minimap2" class="headerlink" title="2.2. PacBio&#x2F;Nanopore reads：minimap2"></a>2.2. PacBio&#x2F;Nanopore reads：minimap2</h2><p>用minimap2对三代reads进行mapping</p>
<ol>
<li>直接mapping</li>
</ol>
<ul>
<li><code>minimap2 -t 8 -ax map-pb ref.fa pacbio_reads.fq &gt;pacbio.sam &amp;</code></li>
<li><code>minimap2 -t 8 -ax map-ont ref.fa ont_reads.fq &gt;nanopore.sam &amp;</code></li>
</ul>
<ol start="2">
<li>参数</li>
</ol>
<ul>
<li>-t 8：线程</li>
<li>-a：输出sam格式，默认是PAF格式</li>
<li>-x: 选择数据类型，map-pb是pacbio数据，map-ont是nanopore数据。</li>
</ul>
<h2 id="2-3-RNA-seq-reads：HiSat2"><a href="#2-3-RNA-seq-reads：HiSat2" class="headerlink" title="2.3. RNA-seq reads：HiSat2"></a>2.3. RNA-seq reads：HiSat2</h2><h3 id="2-3-1-mapping"><a href="#2-3-1-mapping" class="headerlink" title="2.3.1. mapping"></a>2.3.1. mapping</h3><p>对于RNA-seq数据，用HiSat2进行reads的mapping。</p>
<ol>
<li>建索引</li>
</ol>
<ul>
<li><code>hisat2-build ref.fa ref.hisat</code></li>
</ul>
<ol start="2">
<li>mapping</li>
</ol>
<ul>
<li><code>hisat2 --dta -p 8 -x ref.index -1 rna1_1.fa -2 rna1_2.fa 2&gt;rna1_hisat.log |samtools sort -@ 12 &gt; rna1_hisat.bam &amp;</code> #样品1，保存rna1_hisat.log文件，里面有包括mapping rate的统计信息。</li>
<li><code>hisat2 --dta -p 8 -x ref.index -1 rna2_1.fa -2 rna2_2.fa 2&gt;rna2_hisat.log |samtools sort -@ 12 &gt; rna2_hisat.bam &amp;</code> #样品2，保存rna2_hisat.log文件，，里面有包括mapping rate的统计信息。</li>
</ul>
<ol start="3">
<li>merge</li>
</ol>
<ul>
<li><code>samtools merge -@ 8 merged_hisat.bam rna1_hisat.bam rna2_hisat.bam</code>  #合并多个bam文件到一个bam文件</li>
</ul>
<h1 id="3-评估指标"><a href="#3-评估指标" class="headerlink" title="3. 评估指标"></a>3. 评估指标</h1><h2 id="3-1-mapping-rate"><a href="#3-1-mapping-rate" class="headerlink" title="3.1. mapping rate"></a>3.1. mapping rate</h2><ol>
<li>mapping rate的计算公式</li>
</ol>
<ul>
<li>reads的mapping rate：$mapped reads number&#x2F;total reads number$</li>
</ul>
<ol start="2">
<li>mapping rate的计算工具</li>
</ol>
<ul>
<li>HiSat2对RNA-seq进行mapping时把mapping rate统计在log文件中</li>
<li><code>samtools flagstat</code>可用于统计mapping rate</li>
<li>bamdst等软件也可以统计mapping rate</li>
</ul>
<h2 id="3-2-genome-coverage"><a href="#3-2-genome-coverage" class="headerlink" title="3.2. genome coverage"></a>3.2. genome coverage</h2><ol>
<li>genome coverage的计算公式</li>
</ol>
<ul>
<li>genome coverage：$mapped genome length&#x2F;total genome length$</li>
</ul>
<ol start="2">
<li><code>samtools depth</code>统计genome coverage</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">samtools depth -aa sample.bam &gt;depth.out # 计算所有位点的深度</span><br><span class="line">u = $(cat depth.out |awk &#x27;$3 == 0 &#123;print $0&#125;&#x27;|wc -l) # 统计没有mapped碱基的长度，并赋值给u</span><br><span class="line">t = $(cat depth.out |wc -l) # 统计所有位点的长度，并赋值给t。这个值与与基因组大小一致。</span><br><span class="line">echo &quot;scale=5; 1-$u/$t&quot; | bc #计算基因组覆盖度</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>bedtools</li>
</ol>
<ul>
<li><code>bedtools genomecov</code>可以统计coverage，具体参数和结果还没看，留个坑。</li>
<li><code>bedtools genomecov -ibam sample.bam -d &gt;sample.depth</code></li>
</ul>
<h2 id="3-3-depth"><a href="#3-3-depth" class="headerlink" title="3.3. depth"></a>3.3. depth</h2><h3 id="3-3-1-depth分布的统计工具"><a href="#3-3-1-depth分布的统计工具" class="headerlink" title="3.3.1. depth分布的统计工具"></a>3.3.1. depth分布的统计工具</h3><ul>
<li><code>samtools mpileup</code>,<code>samtools depth</code>，qualimap，bamdst，mosdepth等软件可以计算平均深度和深度分布信息。</li>
</ul>
<h3 id="3-3-2-depth的具体指标"><a href="#3-3-2-depth的具体指标" class="headerlink" title="3.3.2. depth的具体指标"></a>3.3.2. depth的具体指标</h3><ol>
<li>平均depth</li>
</ol>
<ul>
<li>计算基因组的平均深度作为参考指标。</li>
</ul>
<ol start="2">
<li>depth分布</li>
</ol>
<ul>
<li>基因组上每个碱基mapped碱基的数量称为单碱基的深度（depth），或者通过滑窗统计基因组上每个固定大小（比如1000bp）的窗口的mapped碱基的平均数量作为窗口深度，分析深度在基因组上的分布可以判断基因组组装的质量。</li>
</ul>
<ol start="3">
<li>直接观察depth</li>
</ol>
<ul>
<li>此外，通过可视化软件直观地查看reads在基因组上具体的mapping情况，也可以判断基因组组装是否存在错误碱基、组装结构问题。</li>
</ul>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>quality assessment</category>
      </categories>
      <tags>
        <tag>mitogenome</tag>
        <tag>genome</tag>
        <tag>organelle</tag>
        <tag>quality assessment</tag>
        <tag>transcriptome</tag>
        <tag>mapping</tag>
        <tag>sam</tag>
        <tag>bam</tag>
        <tag>plastome</tag>
        <tag>BWA</tag>
        <tag>HiSat2</tag>
        <tag>minimap2</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组质量评估：（五）mapping法：2. samtools计算mapping rate</title>
    <url>/2022/07/23/omics_genome_quality.assessment_mapping_rate_samtools/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=18600061&auto=1&height=32"></iframe></div>

<h1 id="1-mapping-rate"><a href="#1-mapping-rate" class="headerlink" title="1. mapping rate"></a>1. mapping rate</h1><p>通过mapping把reads与组装好的基因组进行alignment，然后分析mapped reads的sam&#x2F;bam格式文件，统计mapping rate来评估基因组组装质量。期望mapping rate越接近100%，组装质量越高。</p>
<h1 id="2-Hisat2统计的mapping-rate"><a href="#2-Hisat2统计的mapping-rate" class="headerlink" title="2. Hisat2统计的mapping rate"></a>2. Hisat2统计的mapping rate</h1><p>运行Hisat2对RNA-seq进行mapping时生成的log文件<code>hisat.log</code>会保存着比对的mapping rate信息。</p>
<ol>
<li>hisat2比对统计结果hisat.log示例</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19429766 reads; of these: # reads总数</span><br><span class="line">  19429766 (100.00%) were paired; of these: # 配对的reads数量</span><br><span class="line">    1066192 (5.49%) aligned concordantly 0 times # 一致地比对了0次的reads数量</span><br><span class="line">    14853850 (76.45%) aligned concordantly exactly 1 time # 一致地比对了1次的reads数量</span><br><span class="line">    3509724 (18.06%) aligned concordantly &gt;1 times # 一致地比对了大于1次的reads数量</span><br><span class="line">    ----</span><br><span class="line">    1066192 pairs aligned concordantly 0 times; of these: # 一致地比对了0次的reads数量中：</span><br><span class="line">      54954 (5.15%) aligned discordantly 1 time # 不一致地比对了1次的reads数量</span><br><span class="line">    ----</span><br><span class="line">    1011238 pairs aligned 0 times concordantly or discordantly; of these: #一致或不一致地比对了0次的reads数量中：</span><br><span class="line">      2022476 mates make up the pairs; of these: # 配对的reads数量中：</span><br><span class="line">        1211647 (59.91%) aligned 0 times #比对0次的数量</span><br><span class="line">        607196 (30.02%) aligned exactly 1 time #比对1次的数量</span><br><span class="line">        203633 (10.07%) aligned &gt;1 times #比对大于1次的数量</span><br><span class="line">96.88% overall alignment rate # mapping rate，由mapped reads number/total reads number的比例计算得到</span><br><span class="line">[bam_sort_core] merging from 20 files and 4 in-memory blocks...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>hisat2结果解释</li>
</ol>
<ul>
<li>hisat.log结果中，<code>19429766 reads; of these:</code>及大部分包含的信息中，双端测序的reads是只统计一次的。比如19429766 reads代表的是有19429766对双端测序的reads，总reads数量是$19429766*2&#x3D;38859532$条。</li>
<li>在<code>2022476 mates make up the pairs; of these:</code>及之后包含的信息中，代表配对的reads数量，双端测序的reads是统计了配对的所有reads，总reads数量就是2022476条。</li>
</ul>
<ol start="3">
<li>hisat2的mapping rate的计算</li>
</ol>
<p>96.88%的overall alignment rate即为mapping rate，计算方法是：</p>
<p>$$mapping rate&#x3D;mapped reads number&#x2F;total reads number$$</p>
<ul>
<li>total reads number用的$19429766*2$。</li>
<li>mapped reads number包含：concordantly exactly 1 time(14853850*2)，aligned concordantly &gt;1 times(3509724*2)，aligned discordantly 1 time(54954*2)，mates make up the pairs中的aligned exactly 1 time(607196)和aligned &gt;1 times(203633)。</li>
</ul>
<p>  $$mapping rate&#x3D;((14853850+3509724+54954)*2+607196+203633)&#x2F;(19429766*2) &#x3D; 37647885&#x2F;38859532*100%&#x3D;96.88%$$</p>
<ul>
<li>mapped reads number的另一种计算方法：concordantly exactly 1 time(14853850)，aligned concordantly &gt;1 times(3509724)，aligned concordantly 0 times(1066192)中aligned到的所有reads，即除了aligned concordantly 0 times(1066192)中的aligned 0 times(1211647&#x2F;2)以外的所有reads。</li>
</ul>
<p>  $$mapping rate&#x3D;(14853850+3509724+54954+1066192-(1211647&#x2F;2))&#x2F;19429766*100%&#x3D;96.88%$$</p>
<h1 id="3-samtools-flagstat统计mapping-rate"><a href="#3-samtools-flagstat统计mapping-rate" class="headerlink" title="3. samtools flagstat统计mapping rate"></a>3. samtools flagstat统计mapping rate</h1><ol>
<li>samtools flagstat</li>
</ol>
<ul>
<li>如果hisat2运行时未保存log文件，也可以用<code>samtools flagstat</code>来计算reads的mapping统计值。</li>
<li>illumina reads和Pacbio reads等的sam&#x2F;bam文件也可以用这种方式统计mapping rate。</li>
<li>flagstat统计结果中，记录的是sam&#x2F;bam文件中reads的记录数量，即mapping record rate（双端测序包含配对的所有reads）。</li>
</ul>
<ol start="2">
<li>samtools flagstat统计</li>
</ol>
<ul>
<li><code>samtools flagstat output.bam &gt; output.flagstat</code></li>
</ul>
<ol start="3">
<li>output.flagstat的结果示例</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">51231959 + 0 in total (QC-passed reads + QC-failed reads) #共有51231959条reads通过QC+0条reads未通过QC，后面的信息行中+后的都是代表QC没通过的reads的数量。</span><br><span class="line">12372427 + 0 secondary</span><br><span class="line">0 + 0 supplementary</span><br><span class="line">0 + 0 duplicates</span><br><span class="line">50020312 + 0 mapped (97.63% : N/A) # 97.63%比例的reads mapping到参考序列上，这就是mapping record rate</span><br><span class="line">38859532 + 0 paired in sequencing</span><br><span class="line">19429766 + 0 read1 # 双端reads中read1的总数</span><br><span class="line">19429766 + 0 read2 # 双端reads中read2的总数</span><br><span class="line">36727148 + 0 properly paired (94.51% : N/A) # 94.51%比例的reads成对的映射上</span><br><span class="line">37160066 + 0 with itself and mate mapped # read映射上但配对read没映射上的数量</span><br><span class="line">487819 + 0 singletons (1.26% : N/A) # 1.26%比例的read没映射上的同时，配对read映射上了</span><br><span class="line">289948 + 0 with mate mapped to a different chr # reads和配对reads映射到不同染色体的情况下的reads数量</span><br><span class="line">205767 + 0 with mate mapped to a different chr (mapQ&gt;=5) # reads和配对reads映射到不同染色体，且映射质量大于等于5的情况下的reads数量</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>samtools flagstat的mapping record rate的计算方法</li>
</ol>
<p>$$mapping record rate&#x3D;mapped recorder number&#x2F;total recorder number&#x3D;((primary) mapped reads number + secondary mapped reads number)&#x2F;(total reads number + secondary mapped reads number)$$</p>
<p>其中，recorder number代表sam文件中去除header部分的比对记录数量（每行一条比对记录，即行数）。</p>
<p>同一reads可能多次mapping，有多条记录，所以recorder number的数量会比reads number多。</p>
<ul>
<li>mapped recorder number用的是50020312；</li>
<li>total recorder number用的是51231959；</li>
<li>secondary mapped reads number是12372427；</li>
</ul>
<p>$$mapping record rate&#x3D;50020312&#x2F;51231959*100%&#x3D;97.63%$$</p>
<p>有文章直接用mapping record rate，但建议用mapping rate来代表mapped reads的比例。</p>
<ol start="4">
<li>与hisat2的统计结果的不同</li>
</ol>
<ul>
<li>samtools flagstat的mapping record rate（97.63%）比hisat2的mapping rate（96.88%）高一些，原因在于计算方式的区别。</li>
</ul>
<ol start="5">
<li>计算mapping rate</li>
</ol>
<ul>
<li>通常我们在文章中使用reads的比例来代表mapping rate（即hisat2的计算方式），通过计算公式，可以利用samtools flagsta的统计数据计算mapping rate。</li>
</ul>
<p>$$mapping rate &#x3D; mapped reads number&#x2F;total reads number &#x3D; (mapped recorder number - secondary mapped reads number)&#x2F;(total recorder number - secondary mapped reads number) &#x3D; (50020312-12372427)&#x2F;(51231959-12372427) &#x3D; 37647885&#x2F;38859532*100% &#x3D; 96.88%$$</p>
<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li>hisat2和samtools flagstat计算的mapping rate不同的解释：<a href="https://zhuanlan.zhihu.com/p/73208822">https://zhuanlan.zhihu.com/p/73208822</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>quality assessment</category>
      </categories>
      <tags>
        <tag>genome</tag>
        <tag>quality assessment</tag>
        <tag>transcriptome</tag>
        <tag>mapping</tag>
        <tag>sam</tag>
        <tag>bam</tag>
        <tag>samtools</tag>
        <tag>HiSat2</tag>
        <tag>mapping rate</tag>
        <tag>samtools flagstat</tag>
      </tags>
  </entry>
  <entry>
    <title>基因组质量评估：（五）mapping法：7. 用软件mosdepth统计BAM文件的深度</title>
    <url>/2022/07/31/omics_genome_quality.assessment_mapping_mosdepth/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1514742&auto=1&height=32"></iframe></div>

<h1 id="1-mosdepth简介"><a href="#1-mosdepth简介" class="headerlink" title="1. mosdepth简介"></a>1. mosdepth简介</h1><p>mosdepth（<a href="https://github.com/brentp/mosdepth%EF%BC%89%E6%98%AF%E7%94%A8%E4%BA%8EWGS%EF%BC%8Cexome%EF%BC%8Ctargeted">https://github.com/brentp/mosdepth）是用于WGS，exome，targeted</a> sequencing的BAM&#x2F;CRAM文件的测序深度计算的软件，主要是用Nim语言写的（第一次听说这种语言）。</p>
<h1 id="2-mosdepth可以得到的数据包括"><a href="#2-mosdepth可以得到的数据包括" class="headerlink" title="2. mosdepth可以得到的数据包括"></a>2. mosdepth可以得到的数据包括</h1><ol>
<li>每个碱基深度的计算速度是samtools depth的约2倍。——对于 30X 基因组，大约需要 25 分钟的 CPU 时间。</li>
<li>给定窗口大小的平均每个窗口深度，可用于 CNV calling。</li>
<li>给定区域的 BED 文件的每个区域的平均值。</li>
<li>给定窗口大小的每个区域累积覆盖率（cumulative coverage）直方图的平均值或中值。</li>
<li>对于每个染色体和全基因组，在给定阈值或以上覆盖的碱基比例分布。</li>
<li>合并相邻碱基的量化输出，只要它们落在相同的覆盖范围内，例如（10-20）。</li>
<li>阈值输出以指示在给定阈值下每个区域中有多少个碱基被覆盖。</li>
<li>每条染色体和每条染色体指定区域内的平均深度的总结。</li>
<li>一个d4文件（比bigwig好）。</li>
</ol>
<h1 id="3-下载安装"><a href="#3-下载安装" class="headerlink" title="3. 下载安装"></a>3. 下载安装</h1><p>直接下载已编译文件，修改权限即可使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://github.com/brentp/mosdepth/releases/download/v0.3.3/mosdepth</span><br><span class="line">chmod +x mosdepth</span><br><span class="line">./mosdepth -h</span><br></pre></td></tr></table></figure>

<h1 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h1><ol>
<li>准备</li>
</ol>
<ul>
<li><code>samtools index sample.bam</code> # 生成bam文件的索引文件sample.bam.bai</li>
</ul>
<ol start="2">
<li>计算深度</li>
</ol>
<ul>
<li><code>mosdepth -t 4 out sample.bam</code></li>
</ul>
<ol start="3">
<li>参数</li>
</ol>
<ul>
<li>-t 4：线程，需要&lt;&#x3D;4</li>
<li>out：输出文件的前缀</li>
<li>sample.bam：待分析的bam文件</li>
<li>–by sample.bed：指定区域的bed文件，我分析整个基因组，没加这个参数。</li>
</ul>
<p>还有许多参数等着探索…</p>
<h1 id="5-结果"><a href="#5-结果" class="headerlink" title="5. 结果"></a>5. 结果</h1><ol>
<li>out.mosdepth.summary.txt</li>
</ol>
<ul>
<li>文件包含每条染色体和整个基因组的信息，长度，mapped 碱基数量，平均深度，最小深度和最大深度。示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chrom	length	bases	mean	min	max</span><br><span class="line">MCscaf001	12541575	440858440	35.15	0	3561</span><br><span class="line">MCscaf002	20211832	749371193	37.08	0	8181</span><br><span class="line">... ...</span><br><span class="line">MCscaf265	25000	897138	35.89	0	84</span><br><span class="line">MCscaf266	25000	913514	36.54	0	82</span><br><span class="line">total	256218469	10404013912	40.61	0	92318</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>out.mosdepth.global.dist.txt</li>
</ol>
<ul>
<li>文件包含累积分布，指示给定覆盖率阈值下覆盖的总碱基的比例。包含三列：染色体&#x2F;total，覆盖水平，该级别覆盖的碱基比例。示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MCscaf001	1961	0.00</span><br><span class="line">MCscaf001	1960	0.00</span><br><span class="line">MCscaf001	1957	0.00</span><br><span class="line">... ...</span><br><span class="line">total	2	0.99</span><br><span class="line">total	1	1.00</span><br><span class="line">total	0	1.00</span><br></pre></td></tr></table></figure>

<p>还可以用脚本<code>python scripts/plot-dist.py \*global.dist.txt</code>画图，输出<code>dist.html</code>，可以看出整个基因组的覆盖度的分布。</p>
<ol start="3">
<li>out.per-base.bed.gz</li>
</ol>
<ul>
<li>每个碱基的输出数据。</li>
</ul>
<ol start="4">
<li>out.per-base.bed.gz.csi</li>
</ol>
<h1 id="6-references"><a href="#6-references" class="headerlink" title="6. references"></a>6. references</h1><ol>
<li><a href="https://github.com/brentp/mosdepth">https://github.com/brentp/mosdepth</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
        <category>quality assessment</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>genome</tag>
        <tag>quality assessment</tag>
        <tag>mapping</tag>
        <tag>sam</tag>
        <tag>bam</tag>
        <tag>depth</tag>
        <tag>mosdepth</tag>
      </tags>
  </entry>
  <entry>
    <title>提交基因组到公共数据库 —— 以GenBank为例</title>
    <url>/2022/03/22/omics_genome_submit/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=31721697&auto=1&height=32"></iframe></div>

<h1 id="1-基因组数据库"><a href="#1-基因组数据库" class="headerlink" title="1. 基因组数据库"></a>1. 基因组数据库</h1><p>提交基因组组装的数据到公共数据库以实现共享，在发表提供基因组数据文章时在文章内提供基因组的accession number。</p>
<p>常用的公共数据库包括：</p>
<ul>
<li><a href="https://submit.ncbi.nlm.nih.gov/">NCBI-GenBank</a>：美国生物信息学国家中心</li>
<li><a href="https://www.ebi.ac.uk/">EMBL-EBI</a>：欧洲生物信息学研究所</li>
<li><a href="https://www.ddbj.nig.ac.jp/index-e.html">DDBJ</a>：日本DNA数据银行</li>
<li><a href="https://ngdc.cncb.ac.cn/?lang=zh">中国的国家基因组科学数据中心, National Genomics Data Center, NGDC</a>: 中国</li>
</ul>
<h1 id="2-基因组提交"><a href="#2-基因组提交" class="headerlink" title="2. 基因组提交"></a>2. 基因组提交</h1><p>可以单独提交基因组，也可以基因组和基因组注释一同提交。</p>
<p>单独提交基因组会比加上注释信息简单很多，因为加上注释信息一般都会面临多种注释错误(我的例子是4万个基因注释中包含了将近一千个错误需要手动修改)，但是现在基因组注释是非常基础的操作，所以还是建议加上注释文件更完整。如果发表时间紧张，可以考虑先提交基因组获得accession number(在文章里提供)，再提交注释(accession number不变)。</p>
<ul>
<li>单独提交基因组只需要准备基因组文件(fasta格式)，在提交网站填写基因组相关信息，上传基因组文件即可。</li>
<li>基因组与注释文件共同提交则需要对注释文件(gff或者bed格式)做检查和过滤后，用table2asn软件从基因组文件(fasta格式)和注释文件(gff或者bed格式)生成一个sqn文件，再提交sqn文件到提交网站上。当然，单独的基因组文件也可以转化成sqn格式再上传。</li>
</ul>
<p>在<a href="https://submit.ncbi.nlm.nih.gov/">NCBI的提交网站</a>可以选择各种数据类型，提交基因组就输入<strong>genome</strong>。</p>
<h1 id="3-文件准备"><a href="#3-文件准备" class="headerlink" title="3. 文件准备"></a>3. 文件准备</h1><p>在整理基因组文件，基因组结构注释和功能注释文件时，可以先用table2asn检测错误，以指导基因组改善(例如可能删除污染片段)，以及合并注释文件。</p>
<h2 id="3-1-基因组文件"><a href="#3-1-基因组文件" class="headerlink" title="3.1. 基因组文件"></a>3.1. 基因组文件</h2><p>基因组文件用fa格式储存，最好做一做污染过滤。</p>
<h2 id="3-2-注释文件"><a href="#3-2-注释文件" class="headerlink" title="3.2. 注释文件"></a>3.2. 注释文件</h2><ul>
<li>注释文件可以是tbl格式或者gff格式，我的习惯是用gff格式(许多注释软件结果也是gff格式)。</li>
<li>提交的注释文件可以只有结构注释(不提供功能注释，或者通过Dryad【收费】或Figshare【免费20GB容量】等文件分享网站提供功能注释文件)，也可以把功能注释整理后添加到结构注释文件的product属性值。</li>
</ul>
<h3 id="3-2-1-功能注释"><a href="#3-2-1-功能注释" class="headerlink" title="3.2.1. 功能注释"></a>3.2.1. 功能注释</h3><p>功能注释以product属性值的形式提供，添加到结构注释gff文件的第九列。</p>
<p>合并功能注释和结构注释可以参考博客<a href="https://yanzhongsino.github.io/2021/05/17/omics_genome.functional.annotation/">基因组注释(三)：基因功能注释</a></p>
<p>product值的不规范情况：</p>
<ul>
<li>包含逗号,（因为逗号是分隔符）</li>
<li>包含竖杠|</li>
<li>短横杠-开头或结尾</li>
<li>冒号:开头或结尾</li>
<li>斜杠&#x2F;开头或结尾</li>
<li>不包含字母</li>
<li>括号（包括圆括号,中括号和大括号）不完整的</li>
</ul>
<h1 id="4-提交基因组"><a href="#4-提交基因组" class="headerlink" title="4. 提交基因组"></a>4. 提交基因组</h1><h2 id="4-1-提交基因组到NCBI的GenBank"><a href="#4-1-提交基因组到NCBI的GenBank" class="headerlink" title="4.1. 提交基因组到NCBI的GenBank"></a>4.1. 提交基因组到NCBI的GenBank</h2><p>单独提交基因组只需要基因组(fasta格式)文件，在基因组提交网站<a href="https://submit.ncbi.nlm.nih.gov/subs/genome/">genome Submit Portal</a>操作。</p>
<ol>
<li>注册和登录NCBI账号</li>
<li>选择提交类型Submission Type：单个基因组Single genome或者批量多个基因组Batch&#x2F;multiple genomes</li>
</ol>
<p>然后进入信息填写页面：</p>
<ol>
<li><p>提交者信息Submitter</p>
<ul>
<li>包括姓名First and Last name，邮箱Email，单位Submitting organization(学校)，部门Department(学院)，街道Street，城市City，省&#x2F;州State&#x2F;Province，邮编Postal code，国家Country。</li>
<li>在最后可以选择<strong>Update my contact information in profile</strong>会更新填写的信息到账号，下一次新填写就默认填入提交者信息了。</li>
</ul>
</li>
<li><p>一般性的信息General info</p>
<ul>
<li>BioProject和BioSample可以先注册在这里提供accession number；也可以选择还未注册提交之后会增加填写BioProject和BioSample信息的步骤然后自动注册新的；</li>
<li>释放日期Release date可以指定日期，也可以提交通过后立即释放；释放日期可以提交后发邮件更改的；</li>
<li>基因组信息Genome info：如果保存到了sqn文件也可以选择**Genome Assembly structured comment is in the contig .sqn file(s)**就不需要填写(但我选了之后不识别还是不选填入)。包括组装日期Assembly date，组装方法Assembly method和版本，组装名称Assembly name，基因组覆盖度Genome coverage(这里其实是depth)，测序技术Sequencing technology；</li>
<li>确认信息：是否完整基因组，是否最终版，是否de novo从头组装即无参考组装，是否已有提交的更新，是否自动移除被系统认为是污染的序列(建议自动移除，否则可能发邮件让手动移除污染序列)；</li>
<li>Submission title可选填，建议填上以区别于其他提交。</li>
</ul>
</li>
<li><p>BioProject General Info</p>
<ul>
<li>提供创建新的BioProject的信息，项目题目Project title，项目描述Project description，和领域Relevance</li>
<li>可选项：相关的外部链接External links，基金grants</li>
</ul>
</li>
<li><p>Publications【only batch&#x2F;multiple genomes】：选填，发表文章的PubMed ID或者DOI号</p>
</li>
<li><p>BioSample Type：样品类型，选择Human&#x2F;Plant等</p>
</li>
<li><p>BioSample Attributes</p>
<ul>
<li>如果是批量提交基因组，可以用excel或csv表格提交多个BioSamples信息</li>
<li>样品名称Sample Name：区别于其他样品的唯一名称</li>
<li>生物名称Organism，可以填物种学名；个体描述isolate&#x2F;栽培名称cultivar&#x2F;生态型ecotype三选一填，年龄age&#x2F;发育阶段development stage二选一填</li>
<li>地理位置geographic location：可以填国家China</li>
<li>组织tissue：填写取样部位，eg leaf，flower，root，stem</li>
</ul>
</li>
<li><p>Genome Info【only batch&#x2F;multiple genomes】</p>
<ul>
<li>批量提交的基因组应该有相同的类型：要么只有染色体序列，要么都包含非染色体的序列(会被处理到WGD genome程序)</li>
<li>确认信息：是否完整基因组，是否最终版，是否de novo从头组装即无参考组装，是否已有提交的更新，是否自动移除被系统认为是污染的序列(建议自动移除，否则可能发邮件让手动移除污染序列)；</li>
</ul>
</li>
<li><p>Files</p>
<ul>
<li>提交基因组文件，单个基因组提交fasta格式或者sqn格式，批量基因组提交fasta格式或者asn.1格式</li>
<li>FTP或Aspera命令行上传文件夹(&gt;10GB)，或者网页提交(&lt;2GB)或Aspera Connect plugin(2-10GB)上传文件</li>
<li>提交之后会检查信息是否错误，提示修改</li>
</ul>
</li>
<li><p>空隙Gaps【only batch&#x2F;multiple genomes】</p>
<ul>
<li>基因组序列中的N的含义，是否随机合并序列(不用组装软件)，感觉一般都不会随机合并吧</li>
<li>指定代表gap的N的最小数量，是否有代表未知长度gap的N的数量(常用大于100个N代表未知长度的gap)，组装gap的证据的数据源</li>
</ul>
</li>
<li><p>Assignment【only single genomes】：确认是否有染色体序列，填写染色体序列信息，是否有质体或线粒体或质粒序列    </p>
</li>
<li><p>References【only single genomes】：序列作者和相关文章信息</p>
</li>
<li><p>Review&amp;Submit：最后检查一遍信息没错误就确认提交</p>
</li>
</ol>
<h2 id="4-2-提交基因组和注释"><a href="#4-2-提交基因组和注释" class="headerlink" title="4.2. 提交基因组和注释"></a>4.2. 提交基因组和注释</h2><p>提交带有注释的基因组的大致步骤：</p>
<ol>
<li>注册新的BioProject和BioSample</li>
<li>生成template.sbt文件</li>
<li>用table2asn把基因组(fsa)和注释文件(gff&#x2F;tbl)生成用于提交的sqn文件</li>
<li>根据生成的验证结果文件查看table2asn检查出来的错误，并修正基因组和注释文件中包含的错误</li>
<li>重新运行table2asn和修正错误(重复步骤3和4)直至没有错误</li>
<li>根据上一个部分<strong>提交基因组到NCBI的GenBank</strong>的步骤提交sqn文件到NCBI</li>
<li>提交后可能会收到邮件需要再次更改，更改后重新运行table2asn和修正错误(重复步骤3和4)直至没有错误在NCBI修正错误(提交新的sqn文件)</li>
</ol>
<h3 id="4-2-1-准备工作"><a href="#4-2-1-准备工作" class="headerlink" title="4.2.1. 准备工作"></a>4.2.1. 准备工作</h3><h4 id="4-2-1-1-注册新的BioProject和BioSample"><a href="#4-2-1-1-注册新的BioProject和BioSample" class="headerlink" title="4.2.1.1. 注册新的BioProject和BioSample"></a>4.2.1.1. 注册新的BioProject和BioSample</h4><ul>
<li>在网站<a href="https://submit.ncbi.nlm.nih.gov/subs/">submit</a>提交新的BioProject和BioSample</li>
<li>根据项目和样品信息，计划发表的信息填写，勾选自动生成Locus Tag Prefixes。</li>
<li>提交后马上可以获得BioProject ID(PRJNAxxxxxx)和BioSample ID(SAMNxxxxxxxx)，以及Locus Tag Prefixes(xxxxx)三个编号信息用于genome的提交填写。</li>
</ul>
<h4 id="4-2-1-2-生成template-sbt文件"><a href="#4-2-1-2-生成template-sbt文件" class="headerlink" title="4.2.1.2. 生成template.sbt文件"></a>4.2.1.2. 生成template.sbt文件</h4><p>在网站<a href="https://submit.ncbi.nlm.nih.gov/genbank/template/submission/">template</a>提交基因组信息和BioProject ID(PRJNAxxxxxx)和BioSample ID(SAMNxxxxxxxx)，生成template.sbt文件。</p>
<h3 id="4-2-2-生成提交文件"><a href="#4-2-2-生成提交文件" class="headerlink" title="4.2.2. 生成提交文件"></a>4.2.2. 生成提交文件</h3><p>用table2asn把基因组(fsa)和注释文件(gff&#x2F;tbl)生成用于提交的sqn文件。</p>
<p>table2asn还有一个功能，是在整理基因组文件，基因组结构注释和功能注释文件时，可以先用table2asn检测错误，以指导基因组(例如可能删除污染片段)，以及合并注释文件。</p>
<h4 id="4-2-2-1-table2asn简介"><a href="#4-2-2-1-table2asn简介" class="headerlink" title="4.2.2.1. table2asn简介"></a>4.2.2.1. table2asn简介</h4><p>table2asn用于把基因组和其他信息转换成NCBI的GenBank认可的ASN.1 (Abstract Syntax Notation 1)文本格式文件(sqn后缀)和其他用于协助修改的文件，是命令行格式的软件，取代了原来的老款软件tbl2asn。</p>
<p>另一个相同功能的图形界面软件是Genome Workbench(尝试了一下，数据量大的情况下Window版本会卡顿，还是推荐table2asn)。</p>
<h4 id="4-2-2-2-安装table2asn"><a href="#4-2-2-2-安装table2asn" class="headerlink" title="4.2.2.2. 安装table2asn"></a>4.2.2.2. 安装table2asn</h4><p>在网址下载对应系统(linux64,mac,win64)版本的table2asn安装包，解压缩，重命名为table2asn并设置权限(linux系统下运行<code>chmod 711 table2asn</code>)。</p>
<ul>
<li><a href="https://ftp.ncbi.nlm.nih.gov/asn1-converters/by_program/table2asn/">table2asn下载网址</a></li>
<li><a href="https://www.ncbi.nlm.nih.gov/genbank/table2asn/">table2asn 用法简介</a></li>
<li><a href="https://ftp.ncbi.nlm.nih.gov/asn1-converters/by_program/table2asn/DOCUMENTATION/table2asn_readme.txt">table2asn read me</a></li>
</ul>
<h4 id="4-2-2-3-运行table2asn"><a href="#4-2-2-3-运行table2asn" class="headerlink" title="4.2.2.3. 运行table2asn"></a>4.2.2.3. 运行table2asn</h4><ol>
<li>用法</li>
</ol>
<ul>
<li>最基本的用法：<code>table2asn -t template.sbt -indir ./</code></li>
<li>注释的基因组提交的基础用法：<code>table2asn -t template.sbt -indir ./ -outdir ./ -M n -Z -locus-tag-prefix L6164</code></li>
<li>注释的基因组提交推荐用法：<code>table2asn -t template.sbt -indir ./ -outdir ./ -M n -Z -a s -V vb -c fx -euk -augustus-fix -l paired-ends -gaps-min 1 -gaps-unknown 100 -locus-tag-prefix L6164 -j &quot;[organism=Bauhinia variegata][isolate=pink_petal]&quot; -logfile table2asn.log</code></li>
</ul>
<ol start="2">
<li>参数解释</li>
</ol>
<ul>
<li>-indir .&#x2F;: 指定存放sample.fsa和sample.gff&#x2F;.tbl文件的目录。自动识别目录下所有*.fsa和*.gff&#x2F;tbl文件，需要sample.fsa和sample.gff有相同前缀</li>
<li>-outdir .&#x2F;: 指定结果文件目录，默认与输入一致</li>
<li>-t: 指定template.sbt文件</li>
<li>-i sample.fsa：指定目录下的单个sample.fsa文件(单个基因组提交)，有基因组的最大限制（大概是2G内），超出限制可以只用-indir不用-i -f指定</li>
<li>-f sample.gff：指定目录下的sample.gff&#x2F;tbl文件，不能和-indir同用</li>
<li>-M n：用作原核或真核基因组提交，代替(-a s -V v -c f)，加上-Z就包含基因组特定的差异验证; -M t则是用作TSA提交，代替(-a s -V v -c f，加上TSA特定的验证)</li>
<li>-Z: 生成差异报告(Discrepancy report)，保存到sample.dr中；只推荐注释基因组或者转录组提交使用</li>
<li>-a s: 指定文件类型；-a a指任意格式，包括单个fasta或ASN.1(default)； -a s指一套不相关的序列，例如一个基因组组装；-a s1指物种内的居群集；-a s2指不同物种的系统集</li>
<li>-V: 验证数据，后面可以跟vbr的任意组合；v验证数据记录，结果保存在sample.val(含有错误的类型和严重程度)，错误总结保存在sample.stats；b生成sample.gbf的GenBank文件；r在不做国家检查的情况下验证(Validates without Country Check)</li>
<li>-c: 清理数据，后面可以跟fxdD的任意组合；f修正差异报告中特定类别的产物名称，被修正的产物名称保存在sample.fixedproducts；x扩展注释的features的1-2个核苷酸边界，使得连接gaps或序列末端；D&#x2F;d修正采样日期</li>
<li>-euk：为差异报告的测试指定是真核生物(eukaryotic lineage)</li>
<li>-augustus-fix：针对augustus的错误进行修正</li>
<li>-locus-tag-prefix L6164: 在向NCBI申请BioProject(以及BioSample)后会分配一个locus-tag-prefix前缀，在这里指定，不指定可能在sample.dr中报错FATAL: INCONSISTENT_PROTEIN_ID。</li>
<li>-gaps-min 1 -gaps-unknown 100: 指定序列中的N的含义，如未正确指定，可能在submit.stats中报错SEQ_INST.InternalNsInSeqRaw。-gaps-min 指定代表gap的连续Ns的最小数量，1指把大于等于1个的连续Ns碱基都转换成assembly_gaps。-gaps-unknown 指定代表未知长度的gap的连续Ns的</li>
<li>-l paired-ends: </li>
<li>-j “[organism&#x3D;Bauhinia variegata][isolate&#x3D;pink_petal]”: 用于指定样本名[organism]和个体名[isolate]，会添加进每一条序列的ID里；不指定可能在sample.stats中报错SEQ_DESCR.BioSourceMissing和SEQ_DESCR.NoSourceDescriptor。</li>
<li>-logfile bv.log:指定log文件，如果运q行有错误存放在log文件</li>
<li>-y：添加评论到每一条提交记录，例如-y “Contigs larger than 2kb have been annotated, representing approximately 87% of the total genome”</li>
</ul>
<h3 id="4-2-3-修正错误"><a href="#4-2-3-修正错误" class="headerlink" title="4.2.3. 修正错误"></a>4.2.3. 修正错误</h3><p>根据生成的验证结果修正注释错误，重复table2asn生成sqn文件和修正错误的步骤直至没有错误。</p>
<h4 id="4-2-3-1-查看错误"><a href="#4-2-3-1-查看错误" class="headerlink" title="4.2.3.1. 查看错误"></a>4.2.3.1. 查看错误</h4><p>查看运行table2asn生成的sample.stats，如果有ERROR-level的错误和部分特定的WARNING-level的错误就需要修正，通过sample.val查看错误的具体描述。<br>另外差异报告文件sample.dr中标注为FATAL的错误也需要修正。</p>
<p>下面是一个sample.stats文件的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Total messages:		86696</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">86259 WARNING-level messages exist</span><br><span class="line"></span><br><span class="line">SEQ_FEAT.CDSmRNArange:	219</span><br><span class="line">SEQ_FEAT.NotSpliceConsensusDonor:	300</span><br><span class="line">SEQ_FEAT.NotSpliceConsensusAcceptor:	585</span><br><span class="line">SEQ_FEAT.SeqFeatXrefFeatureMissing:	84578</span><br><span class="line">SEQ_FEAT.ShortExon:	577</span><br><span class="line"></span><br><span class="line">=================================================================</span><br><span class="line">437 ERROR-level messages exist</span><br><span class="line"></span><br><span class="line">SEQ_INST.StopInProtein:	109</span><br><span class="line">SEQ_INST.InternalNsInSeqRaw:	169</span><br><span class="line">SEQ_DESCR.BioSourceMissing:	47</span><br><span class="line">SEQ_DESCR.NoSourceDescriptor:	1</span><br><span class="line">SEQ_FEAT.InternalStop:	109</span><br><span class="line">SEQ_FEAT.NoStop:	2</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-2-注释规范"><a href="#4-2-3-2-注释规范" class="headerlink" title="4.2.3.2. 注释规范"></a>4.2.3.2. 注释规范</h4><p>报错常常是注释文件的注释不规范导致的，根据报错我总结出几点注释规范：</p>
<ol>
<li>同一个mRNA包含的exons与CDSs的数量和位置几乎一致；区别在于同一个mRNA的exons的起始和终止位置(第一个exon的首和最后一个exon的尾)与mRNA的起始和终止相同，包含5’UTR和3’UTR，CDSs则不包含5’UTR和3’UTR，所以CDSs的起始和终止位置不一定和exon相同。</li>
<li>第9列的产物属性product值不能包括逗号,(因为逗号是多个属性值的分隔符)，竖杠|，不能不包含字母，不能以短横杠-或冒号:结尾。最好先做好product值的过滤filter，再添加到gff注释文件。</li>
</ol>
<p>product值的不规范情况：</p>
<ul>
<li>包含逗号,（因为逗号是分隔符）</li>
<li>包含竖杠|</li>
<li>短横杠-开头或结尾</li>
<li>冒号:开头或结尾</li>
<li>斜杠&#x2F;开头或结尾</li>
<li>不包含字母</li>
<li>括号（包括圆括号和中括号）不完整的</li>
</ul>
<p>在整理基因组结构注释和功能注释时，可以先用table2asn检测错误，以指导注释合并。</p>
<h4 id="4-2-3-3-报错和修正方案"><a href="#4-2-3-3-报错和修正方案" class="headerlink" title="4.2.3.3. 报错和修正方案"></a>4.2.3.3. 报错和修正方案</h4><ul>
<li>table2asn运行结束后要根据输出文件的报错进行调整，并重新运行直至没有报错再提交给NCBI。</li>
<li>实践中发现修正一个错误后产生新的错误的情况是很常见的，所以多次运行table2asn也是很有必要的。</li>
<li>NCBI给出了<a href="https://www.ncbi.nlm.nih.gov/genbank/validation/">Validation and Discrepancy Report Error Explanations</a>和<a href="https://www.ncbi.nlm.nih.gov/genbank/genome_validation/">Validation Error Explanations for Genomes</a>可以参考报错含义和解决方案。</li>
</ul>
<p>下面我总结了一下我遇到的报错类型和修正方案：</p>
<h5 id="4-2-3-3-1-sample-stats-x2F-sample-val文件中报错ERROR"><a href="#4-2-3-3-1-sample-stats-x2F-sample-val文件中报错ERROR" class="headerlink" title="4.2.3.3.1. sample.stats&#x2F;sample.val文件中报错ERROR"></a>4.2.3.3.1. sample.stats&#x2F;sample.val文件中报错ERROR</h5><p>添加<code>pseudo=true</code>属性值的命令举例：<code>sed -i &#39;/ID=Bv00639;/ &#123;s/$/pseudo=true;/g&#125;&#39; sample.gff</code></p>
<ol>
<li><strong>SEQ_FEAT.InternalStop</strong> 和 <strong>SEQ_INST.StopInProtein</strong><ul>
<li>当gff的CDS位置有中间终止密码子时报错</li>
<li>可以修改CDS序列位置，去除中间终止密码子。如果无法去除中间终止密码子，可以在sample.gff文件对应的gene行(第三列为gene的那行)的第九列添加<code>pseudo=true</code>属性值代表序列无法被翻译。</li>
</ul>
</li>
<li><strong>SEQ_FEAT.NoStop</strong><ul>
<li>当gff的CDS位置无终止密码子时</li>
<li>可以延长CDS序列位置，直至出现终止密码子。如果无法找到终止密码子，可以在sample.gff文件对应的gene行(第三列为gene的那行)的第九列添加<code>pseudo=true</code>属性值代表序列无法被翻译。</li>
</ul>
</li>
<li><strong>SEQ_FEAT.AbuttingIntervals</strong><ul>
<li>当gff注释的一个基因的exons位置相邻时。</li>
<li>可以合并两个相邻的exons，更改位置。</li>
</ul>
</li>
<li><strong>SEQ_FEAT.SeqLocOrder</strong><ul>
<li>当gff的exon&#x2F;CDS间的位置有重叠时。</li>
<li>可以参考mRNA和CDS序列的位置更改重叠的exon&#x2F;CDS位置，删除多余的exon&#x2F;CDS；exons的边界和mRNA一致，数量和CDS一致。</li>
</ul>
</li>
<li><strong>SEQ_FEAT.CDSmRNAXrefLocationProblem</strong><ul>
<li>当gff注释CDS和exon的位置或数量不一致时</li>
<li>可以更改exon或CDS位置和数量。</li>
</ul>
</li>
<li><strong>SEQ_FEAT.CDSwithMultipleMRNAs</strong><ul>
<li>当gff注释CDS和exon的位置不一致时，这个报错添加<code>pseudo=true</code>属性值之后还是存在。实践发现有时与<strong>SEQ_FEAT.CDSmRNAmismatchCount</strong>一同出现且数量一致。</li>
<li>需要更改exon或CDS位置和数量。</li>
</ul>
</li>
<li><strong>SEQ_FEAT.ShortIntron</strong><ul>
<li>含有短于11bp的内含子时</li>
<li>可以修正intron的位置使它长于11bp，或者在gene那行第九列添加<code>pseudo=true</code>属性值，或者在table2asn的命令中中加上参数<code>-c s</code>代表标记为”LOW QUALITY PROTEIN”。</li>
</ul>
</li>
<li><strong>SEQ_FEAT.TransLen</strong><ul>
<li>表示蛋白质长度与预测的蛋白质长度不匹配，运行错误</li>
<li>建议重跑table2asn，报错持续存在就写邮件把sample.sqn和运行的命令行发给NCBI(<a href="mailto:&#x67;&#101;&#x6e;&#x6f;&#x6d;&#101;&#115;&#x40;&#x6e;&#x63;&#98;&#x69;&#46;&#110;&#x6c;&#109;&#46;&#110;&#x69;&#104;&#x2e;&#x67;&#111;&#x76;">&#x67;&#101;&#x6e;&#x6f;&#x6d;&#101;&#115;&#x40;&#x6e;&#x63;&#98;&#x69;&#46;&#110;&#x6c;&#109;&#46;&#110;&#x69;&#104;&#x2e;&#x67;&#111;&#x76;</a>)让帮忙修改这个错误。</li>
</ul>
</li>
<li><strong>SEQ_FEAT.BadInternalCharacter</strong><ul>
<li>表示gff的第9列的属性值attributes中包含不符合规定的字符，例如”|”符号。</li>
<li>删除第9列属性值包含的”|”符号</li>
</ul>
</li>
<li><strong>SEQ_FEAT.BadTrailingHyphen</strong></li>
</ol>
<ul>
<li>当gff的第9列的属性值attributes中以连字符”-“结尾时</li>
<li>删除第9列属性值包含的”-“符号</li>
</ul>
<ol start="11">
<li><strong>SEQ_FEAT.BadTrailingCharacter</strong><ul>
<li>当gff的第9列的属性值attributes中以连字符”:”结尾时。</li>
<li>删除第9列属性值包含的”:”结尾符号</li>
</ul>
</li>
<li>当gff的product属性不符合蛋白产物名称规定时，会生成Adiantum.nelumboides.fixedproducts文件，记录把不符合规定的product属性值改为<strong>hypothetical protein</strong>。可以提取不符合规定的product属性值用于product的filter。</li>
</ol>
<h5 id="4-2-3-3-2-sample-stats-x2F-sample-val文件中的报警WARNING"><a href="#4-2-3-3-2-sample-stats-x2F-sample-val文件中的报警WARNING" class="headerlink" title="4.2.3.3.2. sample.stats&#x2F;sample.val文件中的报警WARNING"></a>4.2.3.3.2. sample.stats&#x2F;sample.val文件中的报警<strong>WARNING</strong></h5><p>部分WARNING也需要修复；比如<strong>SEQ_FEAT.SeqFeatXrefNotReciprocal</strong>和<strong>SEQ_FEAT.DuplicateFeat</strong>虽然是在WARNING-level messages中，但上传给NCBI后收到邮件让修改后重新提交。</p>
<ol>
<li><strong>SEQ_FEAT.SeqFeatXrefNotReciprocal</strong><ul>
<li>exon和CDS的位置或数量不一致且有中间终止密码子导致</li>
<li>可以调整exon和CDS的位置和数量；可能引入<strong>SEQ_FEAT.InternalStop</strong> 和 <strong>SEQ_INST.StopInProtein</strong> 或 <strong>SEQ_FEAT.ShortIntron</strong> 错误，若引入则在gene行的第九列添加<code>pseudo=true</code>属性值；也可以直接添加<code>pseudo=true</code>属性值。</li>
<li>实践发现一个例子，<strong>SEQ_FEAT.SeqFeatXrefNotReciprocal</strong>的数量与<strong>SEQ_FEAT.CDSmRNAmismatchCount</strong>和<strong>SEQ_FEAT.CDSmRNAMismatchLocation</strong>一样，上传给NCBI后收到邮件让修改<strong>SEQ_FEAT.CDSmRNAmismatchCount</strong>和<strong>SEQ_FEAT.CDSmRNAMismatchLocation</strong>。这种情况修改exon和CDS的位置和数量很可能导致<strong>SEQ_FEAT.InternalStop</strong> 和 <strong>SEQ_INST.StopInProtein</strong>错误，所以建议直接在gene行的第九列添加<code>pseudo=true</code>属性值。</li>
</ul>
</li>
<li><strong>SEQ_FEAT.DuplicateFeat</strong><ul>
<li>当gff在同样的位置注释了多个gene时。</li>
<li>需要删除其中一个，或者修改重复gene注释为一个gene的多个可变剪切的注释。</li>
</ul>
</li>
<li><strong>SEQ_FEAT.GeneXrefStrandProblem</strong><ul>
<li>基因的CDS或exon位置信息不一致时，可能报错</li>
<li>修改位置信息为一致，或者在gene行的第九列添加<code>pseudo=true</code>属性值；</li>
</ul>
</li>
</ol>
<h5 id="4-2-3-3-3-sample-dr文件中的报错FATAL"><a href="#4-2-3-3-3-sample-dr文件中的报错FATAL" class="headerlink" title="4.2.3.3.3. sample.dr文件中的报错FATAL"></a>4.2.3.3.3. sample.dr文件中的报错FATAL</h5><ol>
<li><p><strong>FATAL</strong><br><code>cat sample.dr |grep &quot;FATAL&quot;</code>查看FATAL报错信息，如果物种不是细菌则可以忽略BACTERIAL_开头的报错信息；CONTAINED_CDS开头的信息不影响提交，也可暂时忽略。</p>
</li>
<li><p><strong>FATAL: SUSPECT_PRODUCT_NAMES</strong><br>如果product属性值中有错误格式会报错，比如含有不完整的括号，会显示<strong>FATAL: SUSPECT_PRODUCT_NAMES: 9 features contain unbalanced brackets or parentheses</strong>，需要处理(添加括号或者删除括号)。</p>
</li>
<li><p><strong>GENES_OPPOSITE_STRANDS</strong></p>
</li>
</ol>
<ul>
<li>在sample.dr文件里搜索“DUP_GENES”，如果得到下面的信息，代表有24个基因重复注释到了相同位置的正反链。</li>
<li>类似<strong>SEQ_FEAT.DuplicateFeat</strong>报错，但是是重复注释到正反链。<blockquote>
<p>DUP_GENES_OPPOSITE_STRANDS: 24 genes match other genes in the same location, but on the opposite strand</p>
</blockquote>
</li>
<li>这条信息后面会给出24个基因的位置，删除重复的12条注释，或者修改重复gene注释为一个gene的多个可变剪切的注释。</li>
</ul>
<h3 id="4-2-4-在线提交"><a href="#4-2-4-在线提交" class="headerlink" title="4.2.4. 在线提交"></a>4.2.4. 在线提交</h3><p>根据上一个部分<strong>提交基因组到NCBI的GenBank</strong>的步骤提交sqn文件到NCBI</p>
<h3 id="4-2-5-提交后修改"><a href="#4-2-5-提交后修改" class="headerlink" title="4.2.5. 提交后修改"></a>4.2.5. 提交后修改</h3><p>提交给NCBI后会收到邮件通知处理进度，如果有错误，会在提交网站显示Error提交状态，并收到需要更改的邮件。根据邮件提示修正注释错误，重复table2asn生成sqn文件和修正错误的步骤直至没有错误在NCBI修正错误(提交新的sqn文件)。</p>
<p>下面记录了我遇到的邮件中提到的错误和修改方案：</p>
<ol>
<li><strong>SEQ_FEAT.SeqFeatXrefNotReciprocal</strong><br>实践经验1</li>
</ol>
<ul>
<li>exon和CDS的位置或数量不一致且有中间终止密码子导致。</li>
<li>可以调整exon和CDS的位置和数量；可能引入<strong>SEQ_FEAT.InternalStop</strong> 和 <strong>SEQ_INST.StopInProtein</strong>错误；若引入则在gene行的第九列添加<code>pseudo=true</code>属性值；</li>
</ul>
<p>实践经验2</p>
<ul>
<li>exon和CDS的位置或数量不一致且有中间终止密码子导致。同时存在数量一致的<strong>SEQ_FEAT.CDSmRNAmismatchCount</strong>和<strong>SEQ_FEAT.CDSmRNAMismatchLocation</strong>。</li>
<li>在gene行的第九列添加<code>pseudo=true</code>属性值后，<strong>SEQ_FEAT.SeqFeatXrefNotReciprocal</strong>和<strong>CDSmRNAMismatchLocation</strong>消失并转化成ERROR水平信息<strong>SEQ_FEAT.CDSwithMultipleMRNAs</strong>，数量与<strong>SEQ_FEAT.CDSmRNAmismatchCount</strong>一致。</li>
<li>调整exon和CDS的位置和数量，并且在gene行的第九列添加<code>pseudo=true</code>属性值。</li>
</ul>
<ol start="2">
<li><strong>SEQ_FEAT.DuplicateFeat</strong></li>
</ol>
<ul>
<li>这个错误是同一位置注释到多个基因引起的，可以提取邮件中的gene ID(重复基因的第二个)信息，保存成gene ID list，然后用命令<code>grep -v -f geneID.list sample.gff &gt;sample.revised.gff</code>删除list里的注释信息。</li>
<li>如果邮件里没有gene ID信息，可以用<code>cat sample.val |grep DuplicateFeat</code>里查看错误的位置信息，根据位置信息查找gff的重复注释位置，并删除其中一个基因注释。</li>
<li>除了直接删除重复的整个基因注释外，还可以把重复基因的注释变成一个基因的多个可变剪切注释(删除重复基因的gene注释，把重复基因的mRNA注释的parent属性改为另一个基因)。</li>
</ul>
<ol start="3">
<li><strong>Discrepancy</strong><br>Discrepancy.txt文件中保存了一些不符合标准的报错，比如product属性值中有横杠起始的元素，或者括号不完全，根据Discrepancy.txt文件指出的错误一条条修改。</li>
</ol>
<p><code>cat sample.dr |grep &quot;FATAL&quot;</code>查看FATAL报错信息，如果物种不是细菌则可以忽略BACTERIAL_开头的报错信息；CONTAINED_CDS开头的信息不影响提交，也可暂时忽略。<br>如果product属性值中有不完整的括号，会显示<strong>FATAL: SUSPECT_PRODUCT_NAMES: 9 features contain unbalanced brackets or parentheses</strong>，需要处理需要处理(添加括号或者删除括号)。</p>
<h2 id="4-3-提交状态"><a href="#4-3-提交状态" class="headerlink" title="4.3. 提交状态"></a>4.3. 提交状态</h2><p>在提交网页，提交后会显示提交状态，经过一轮机器自动验证和两轮人工检查后可公开数据。</p>
<p>提交状态含义：</p>
<ol>
<li>Unfinished</li>
</ol>
<ul>
<li>提交未完成</li>
<li>提交如果没有最后确认，会保存已填写内容，随时可以登陆账号点击未完成的提交号继续提交。</li>
</ul>
<ol start="2">
<li>Queued</li>
</ol>
<ul>
<li>提交在等待自动验证</li>
<li>刚提交的任务会进入自动验证环节</li>
</ul>
<ol start="3">
<li>Error</li>
</ol>
<ul>
<li>错误</li>
<li>有文件有错误需要修正或者再次提交；会提供错误具体信息的文件和邮件通知。</li>
</ul>
<ol start="4">
<li>Processing</li>
</ol>
<ul>
<li>处理中</li>
<li>提交通过自动验证，等待NCBI员工手动检查</li>
</ul>
<ol start="5">
<li>Processing and accession number present</li>
</ol>
<ul>
<li>处理中，并且显示了序列号</li>
<li>提交通过了NCBI员工的首次检查，等待NCBI员工的最终检查</li>
<li>如果提交有问题最终检查员工会发邮件告知</li>
<li>如果指定了释放日期，提交会在释放日期前再做最终检查；也就是说释放日期前都保持在这个提交状态</li>
</ul>
<ol start="6">
<li>Processed</li>
</ol>
<ul>
<li>已处理</li>
<li>数据已被公开释放，在这之前做的任何更改都会包含在释放数据中，但在提交网站不会显示修改。</li>
</ul>
<h1 id="5-references"><a href="#5-references" class="headerlink" title="5. references"></a>5. references</h1><ol>
<li>genomes submission guide：<a href="https://www.ncbi.nlm.nih.gov/genbank/genomesubmit/">https://www.ncbi.nlm.nih.gov/genbank/genomesubmit/</a></li>
<li>table2asn：<a href="https://www.ncbi.nlm.nih.gov/genbank/table2asn/">https://www.ncbi.nlm.nih.gov/genbank/table2asn/</a></li>
<li>table2asn documentation：<a href="https://ftp.ncbi.nlm.nih.gov/asn1-converters/by_program/table2asn/DOCUMENTATION/">https://ftp.ncbi.nlm.nih.gov/asn1-converters/by_program/table2asn/DOCUMENTATION/</a></li>
<li>Validation and Discrepancy Report Error Explanations：<a href="https://www.ncbi.nlm.nih.gov/genbank/validation/">https://www.ncbi.nlm.nih.gov/genbank/validation/</a></li>
<li>Validation Error Explanations for Genomes：<a href="https://www.ncbi.nlm.nih.gov/genbank/genome_validation/">https://www.ncbi.nlm.nih.gov/genbank/genome_validation/</a></li>
<li>Discrepancy Report：<a href="https://www.ncbi.nlm.nih.gov/genbank/asndisc/">https://www.ncbi.nlm.nih.gov/genbank/asndisc/</a></li>
<li>MODULE valid：<a href="https://github.com/genome-vendor/sequin/blob/master/errmsg/valid.msg">https://github.com/genome-vendor/sequin/blob/master/errmsg/valid.msg</a></li>
<li>annotating genomes with gff3：<a href="https://www.ncbi.nlm.nih.gov/genbank/genomes_gff/">https://www.ncbi.nlm.nih.gov/genbank/genomes_gff/</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>genome</category>
      </categories>
      <tags>
        <tag>genome</tag>
        <tag>GenBank</tag>
        <tag>genome submit</tag>
        <tag>tbl2asn</tag>
        <tag>table2asn</tag>
      </tags>
  </entry>
  <entry>
    <title>使用BankIt提交细胞器基因组组装和注释到NCBI</title>
    <url>/2022/06/30/omics_organelle_submit/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=509092165&auto=1&height=32"></iframe></div>

<h1 id="准备上传的文件"><a href="#准备上传的文件" class="headerlink" title="准备上传的文件"></a>准备上传的文件</h1><ol>
<li>基因组fasta文件</li>
<li>注释tbl格式文件</li>
</ol>
<p>tbl格式文件推荐用GB2sequin来准备。</p>
<p>参考博客-转换GenBank文件为tbl格式：<a href="https://yanzhongsino.github.io/2022/06/16/biosoft_fileformat_gb2tbl/%E3%80%82">https://yanzhongsino.github.io/2022/06/16/biosoft_fileformat_gb2tbl/。</a></p>
<h1 id="上传步骤"><a href="#上传步骤" class="headerlink" title="上传步骤"></a>上传步骤</h1><h2 id="上传工具"><a href="#上传工具" class="headerlink" title="上传工具"></a>上传工具</h2><p>BankIt：<a href="https://www.ncbi.nlm.nih.gov/WebSub/index.cgi">https://www.ncbi.nlm.nih.gov/WebSub/index.cgi</a></p>
<p>使用BankIt在线上传，允许一次提交多个细胞器基因组序列。</p>
<h2 id="上传步骤-1"><a href="#上传步骤-1" class="headerlink" title="上传步骤"></a>上传步骤</h2><ol>
<li>选择上传的数据类别。细胞器基因组选择Sequence data not listed above：organelle。下面列几个常用的：</li>
</ol>
<ul>
<li>Eukaryotic and Prokaryotic Genomes(WGS or Complete): 组装好的真核和原核物种的基因组</li>
<li>Transcriptome Shotgun Assembly (TSA)：组装好的转录组</li>
<li>Unassembled sequence reads (SRA)：未组装的测序reads</li>
<li>Sequence data not listed above：mRNA, genomic DNA, organelle, ncRNA, plasmids…：其他测序数据，细胞器基因组选这个。</li>
</ul>
<ol start="2">
<li>Contact：填写上传人的信息，包括姓名，学院，学校，地址，城市，地区&#x2F;省份，邮编，国家，和接收上传信息的邮箱【重要】。</li>
<li>Reference：填写提供序列的作者和出版信息。</li>
<li>Sequencing Technology：填写测序方法信息，包括测序平台，是否是组装的数据，组装软件和版本，组装样品名称，覆盖度。</li>
<li>Nucleotide：填写序列的信息。</li>
</ol>
<ul>
<li>序列发布的时间，可以指定日期，也可以一通过上传审核就发布。</li>
<li>分子类型（Molecule Type）：细胞器基因组选的genomic DNA</li>
<li>拓扑结构（Topology）：线型分子（Linear）还是环形分子（Circular）。</li>
<li>是否是完整的细胞器基因组：yes&#x2F;no。</li>
<li>核苷酸序列格式：fasta或者alignment，选的fasta</li>
<li>上传细胞器基因组的fasta文件</li>
</ul>
<ol start="6">
<li>Organism：填写Organism name信息，可填物种的学名。</li>
<li>Submission Category：测序reads是上传者测序的还是使用的其他已上传序列数据。如果是使用其他已上传reads进行的组装则需要提供已上传reads的accession number。</li>
<li>Source Modifiers：资源信息。</li>
</ol>
<ul>
<li>Organelle&#x2F;Location: 叶绿体&#x2F;线粒体&#x2F;其他器官。</li>
<li>Source Modifier可以填写Country；对应的value填写China。</li>
</ul>
<ol start="9">
<li>Features：提供注释信息，可以选择tbl文件或者手动填写注释表格，tbl文件的ID和提交的序列ID需要一致。</li>
<li>Review and Correct：回顾和确认填写的信息，即可完成提交。</li>
</ol>
<p>没什么问题的话，两个工作日内会发邮件告知GenBank accession numbers，可用于文章引用。</p>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>organelle</category>
      </categories>
      <tags>
        <tag>mitogenome</tag>
        <tag>plastome</tag>
        <tag>submit</tag>
      </tags>
  </entry>
  <entry>
    <title>线粒体的重复介导重组的鉴定和计算重组频率</title>
    <url>/2023/03/14/omics_organelle_recombination.frequency/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=105213&auto=1&height=32"></iframe></div>

<h1 id="1-线粒体的重复介导重组（repeat-mediated-recombination）"><a href="#1-线粒体的重复介导重组（repeat-mediated-recombination）" class="headerlink" title="1. 线粒体的重复介导重组（repeat-mediated recombination）"></a>1. 线粒体的重复介导重组（repeat-mediated recombination）</h1><ol>
<li>线粒体的重复序列</li>
</ol>
<ul>
<li>通常在植物线粒体上存在重复序列（这里的重复序列不是核基因组的TE等转座元件的概念，就是一段序列在另一个位置同时存在完全一致的序列），则有可能介导重组，从而生成线粒体的多种构象。重复序列常常成对存在（也有一些超过两个），被称作重复对（repeat pairs）。</li>
</ul>
<ol start="2">
<li>鉴定的背景</li>
</ol>
<ul>
<li>Illumina PE测序是双端测序，测序获得的reads常见的长度是150bp。一对reads的联合体的长度被称为插入尺寸（insert size）。插入尺寸（insert size）常在350bp左右，但具体的每对测序reads都不一样，要通过把reads进行mapping到参考序列上，才能测量insert size。</li>
<li>如果是repeat pairs的长度小于测序reads的insert size长度，可以构建两种构象（参考构象和重组构象），把reads mapping到两种构象来判断repeat pairs是否介导重组（如果两种构象都有mapped reads则是repeat pair介导重组的证据），并且通过mapped reads的计数来计算重组频率（recombination frequency）。</li>
</ul>
<h1 id="2-鉴定重复"><a href="#2-鉴定重复" class="headerlink" title="2. 鉴定重复"></a>2. 鉴定重复</h1><h2 id="2-1-鉴定重复的脚本"><a href="#2-1-鉴定重复的脚本" class="headerlink" title="2.1. 鉴定重复的脚本"></a>2.1. 鉴定重复的脚本</h2><p>这篇文章Repeats of Unusual Size in Plant Mitochondrial Genomes: Identification, Incidence and Evolution： <a href="https://academic.oup.com/g3journal/article/9/2/549/6026745">https://academic.oup.com/g3journal/article/9/2/549/6026745</a> 总结了植物线粒体基因组的重复序列的特征。研究表明，植物线粒体基因组比动物的要大，包含大量的非编码DNA，突变率低，重排率高。</p>
<ul>
<li>文章提供了python脚本ROUSFinder.py，用在鉴定线粒体的重复序列上。</li>
<li>脚本是python2写的，依赖主要有blastn。</li>
<li>有以下三个版本。</li>
</ul>
<ol>
<li>ROUSFinder.py</li>
</ol>
<ul>
<li>调用blastn进行一条序列与自身的成对比对。</li>
<li>默认参数是最小重复50bp，E value 10,000， match的赏分是+1，mismatch的罚分是-20。</li>
<li>脚本贴在下面：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> sys, math, os, argparse, csv  </span><br><span class="line">csv.field_size_limit(sys.maxsize)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># January 16, 2018 version 1.1  </span></span><br><span class="line"><span class="comment"># Find dispersed repeated sequences in genomes.   </span></span><br><span class="line"><span class="comment"># Designed for plant mitochondrial genomes of up to a few Mbp.  </span></span><br><span class="line"><span class="comment"># May be very slow with larger genomes.   </span></span><br><span class="line"><span class="comment"># Blast can also sometimes give odd results with large or highly repetetive genomes.  </span></span><br><span class="line"><span class="comment"># Gaps, or runs of &#x27;N&#x27;s in the sequence will definitely give weird results.   </span></span><br><span class="line"><span class="comment"># The program assumes there aren&#x27;t any, and that the longest repeat will be the full sequence to itself.  </span></span><br><span class="line"><span class="comment"># If there are long repeats in the output that are listed as being only at one location, this is probably what happened.  </span></span><br><span class="line"><span class="comment"># If there are a lot of repeats within repeats the results can also be odd.  </span></span><br><span class="line"><span class="comment"># Copyright Alan C. Christensen, University of Nebraska, 2018  </span></span><br><span class="line"><span class="comment"># No guarantees, warranties, support, or anything else is implicit or explicit.  </span></span><br><span class="line"><span class="comment"># Input is a fasta format file of a sequence. Genbank format works but generates lots of error messages in stdout.  </span></span><br><span class="line"><span class="comment"># Output is a list of unique, ungapped repeated sequences, fasta formatted.  </span></span><br><span class="line"><span class="comment"># The names are in the format &#x27;&gt;Repeat/ROUS_name_start_end_length&#x27;.  </span></span><br><span class="line"><span class="comment"># Percent identity is limited to &gt;=99%, to allow for sequencing errors of &lt;1%.  </span></span><br><span class="line"><span class="comment"># A table of repeats with the coordinates of each one is generated.  </span></span><br><span class="line"><span class="comment"># A list of repeat name, length and copy number is generated.  </span></span><br><span class="line"><span class="comment"># A binned table of the total number of repeats in size ranges is generated.  </span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># PARAMETERS  </span></span><br><span class="line"><span class="comment">#   REQUIRED:  </span></span><br><span class="line"><span class="comment">#      input file in fasta format  </span></span><br><span class="line"><span class="comment">#   Optional  </span></span><br><span class="line"><span class="comment">#      -o output file name  </span></span><br><span class="line"><span class="comment">#      -m minimum length of exact matches to keep  </span></span><br><span class="line"><span class="comment">#      -b path to blastn (default is /usr/bin/)  </span></span><br><span class="line"><span class="comment">#      -k keep temp files  </span></span><br><span class="line"><span class="comment">#      -gb to write the repeats to a genbank format file  </span></span><br><span class="line">  </span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;Find repeats in a fasta sequence file&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;infile&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Input .fasta file&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-o&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;outfile&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Output file name seed, default is input_repeats&#x27;</span>, default=<span class="string">&#x27;default&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-m&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;minlen&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Minimum length of matches to keep, default=24&#x27;</span>, default=<span class="string">&#x27;24&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-b&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;blast_path&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Path to blastn program, default is /usr/bin/&#x27;</span>, default=<span class="string">&#x27;/usr/bin/&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-k&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, dest=<span class="string">&#x27;keep&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;True to keep temp files&#x27;</span>, default=<span class="literal">False</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-gb&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, dest=<span class="string">&#x27;genbank&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;True to write GenBank format file&#x27;</span>, default=<span class="literal">False</span>)  </span><br><span class="line">results = parser.parse_args()  </span><br><span class="line">infile = results.infile  </span><br><span class="line">outfile = results.outfile  </span><br><span class="line">minlen = <span class="built_in">int</span>(results.minlen)  </span><br><span class="line">blast_path = results.blast_path  </span><br><span class="line">keep = results.keep  </span><br><span class="line">genbank = results.genbank  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># It might be useful to define the wordsize as something less than minlen, so both variables are used.  </span></span><br><span class="line"><span class="comment"># Wordsize smaller than minlen would give smaller core identical sequences in the middle of repeats.  </span></span><br><span class="line"><span class="comment"># An example might be to change this to wordsize = str(int(minlen/2)).  </span></span><br><span class="line">wordsize = <span class="built_in">str</span>(minlen)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># If no output file seed is specified, make one by stripping leading directory information  </span></span><br><span class="line"><span class="comment"># and stripping trailing .fa or .fasta from the input file name and using that.  </span></span><br><span class="line"><span class="keyword">if</span> outfile == <span class="string">&#x27;default&#x27;</span>:  </span><br><span class="line">    outfile = infile  </span><br><span class="line">    <span class="keyword">if</span> outfile.count(<span class="string">&#x27;/&#x27;</span>) &gt; <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(outfile.count(<span class="string">&#x27;/&#x27;</span>)):  </span><br><span class="line">            index = outfile.index(<span class="string">&#x27;/&#x27;</span>)  </span><br><span class="line">            outfile = outfile[index+<span class="number">1</span>:]  </span><br><span class="line">    <span class="keyword">if</span> outfile.endswith(<span class="string">&#x27;.fa&#x27;</span>) <span class="keyword">or</span> outfile.endswith(<span class="string">&#x27;.fasta&#x27;</span>):  </span><br><span class="line">        outfile = outfile.rstrip(<span class="string">&#x27;fasta&#x27;</span>)  </span><br><span class="line">    outfile = outfile.rstrip(<span class="string">&#x27;.&#x27;</span>)  </span><br><span class="line">outfa = outfile+<span class="string">&#x27;_rep.fasta&#x27;</span>  </span><br><span class="line">outtab = outfile+<span class="string">&#x27;_rep_table.txt&#x27;</span>  </span><br><span class="line">outbin = outfile+<span class="string">&#x27;_binned.txt&#x27;</span>  </span><br><span class="line">outcount = outfile+<span class="string">&#x27;_rep_counts.txt&#x27;</span>  </span><br><span class="line">outgb = outfile+<span class="string">&#x27;_repeats.gb.txt&#x27;</span>  </span><br><span class="line">tempblast = outfile+<span class="string">&#x27;_tempblast.txt&#x27;</span>  </span><br><span class="line">temprepeats = outfile+<span class="string">&#x27;_temprepeats.txt&#x27;</span>  </span><br><span class="line">tempparse = outfile+<span class="string">&#x27;_sequence_parsing.txt&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Get sequence name and length from fasta file.  </span></span><br><span class="line">seq = <span class="built_in">open</span>(infile, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">seqname = seq.readline()  </span><br><span class="line">seqname = seqname.lstrip(<span class="string">&#x27;&gt; &#x27;</span>)  </span><br><span class="line">seqname = seqname.rstrip()  </span><br><span class="line">seqlen = <span class="number">0</span>   </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> seq:  </span><br><span class="line">    <span class="keyword">if</span>(line[<span class="number">0</span>] == <span class="string">&quot;&gt;&quot;</span>):  </span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line">    seqlen += <span class="built_in">len</span>(line.strip())  </span><br><span class="line">seq.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># run blastn with query file plus strand (removing first line which is full length sequence), minus strand, and concatenate  </span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Performing self-blastn comparison with &#x27;</span>+seqname  </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+infile+<span class="string">&#x27; -strand plus -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward 1 -penalty -20 -ungapped -dust no -soft_masking false -evalue 1000 -outfmt &quot;10 qstart qend length sstart send mismatch sstrand qseq&quot; | tail -n+2 &gt; tempblast1.txt&#x27;</span>)  </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+infile+<span class="string">&#x27; -strand minus -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward 1 -penalty -20 -ungapped -dust no -soft_masking false -evalue 1000 -outfmt &quot;10 qstart qend length sstart send mismatch sstrand qseq&quot; &gt; tempblast2.txt&#x27;</span>)  </span><br><span class="line">os.system(<span class="string">&#x27;cat tempblast1.txt tempblast2.txt &gt; &#x27;</span>+tempblast)  </span><br><span class="line">os.system(<span class="string">&#x27;rm tempblast1.txt tempblast2.txt&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># open tempblast.txt, convert to list of lists, and sort by length and position descending  </span></span><br><span class="line"><span class="comment"># This is necessary because blastn does not output every possible pair of hits when there are more than 2 copies of a repeat  </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Sorting alignments...&#x27;</span>  </span><br><span class="line">f = <span class="built_in">open</span>(tempblast, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">reader = csv.reader(f)  </span><br><span class="line">alignments = <span class="built_in">list</span>(reader)  </span><br><span class="line">f.close()  </span><br><span class="line">alignments = <span class="built_in">sorted</span>(alignments, key=<span class="keyword">lambda</span> x: (-<span class="number">1</span>*<span class="built_in">int</span>(x[<span class="number">2</span>]), -<span class="number">1</span>*<span class="built_in">int</span>(x[<span class="number">0</span>])))  </span><br><span class="line">alignments.append([<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;X&#x27;</span>])  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># New list of uniques  </span></span><br><span class="line"><span class="comment"># Text file &#x27;_sequence_parsing.txt&#x27; includes the information on how duplicates were found.  </span></span><br><span class="line"><span class="comment"># Start at row 0. Compare to subsequent rows.   </span></span><br><span class="line"><span class="comment"># If repeat length is different from the next row, it has passed all the tests, write it to the file.  </span></span><br><span class="line"><span class="comment"># If query or subject coordinates are the same as the query or subject or reversed coordinates  </span></span><br><span class="line"><span class="comment"># of a subsequent row, it is not unique, so go to the next row and do the comparisons again.  </span></span><br><span class="line"><span class="comment"># Thanks to Alex Kozik for repeatedly testing and finding bugs in the algorithm.  </span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Finding unique repeats...&#x27;</span>  </span><br><span class="line">uniques = []  </span><br><span class="line">sp = <span class="built_in">open</span>(tempparse, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alignments)):  </span><br><span class="line">    sp.write(<span class="string">&#x27;row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(alignments[row][<span class="number">2</span>]) &lt; minlen:  </span><br><span class="line">        <span class="comment"># This won&#x27;t happen unless the word_size is defined as something other than minlen.  </span></span><br><span class="line">        <span class="comment"># That could be useful under some circumstances.  </span></span><br><span class="line">        sp.write(<span class="string">&#x27;row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is less than minlength&#x27;</span>)  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> compare <span class="keyword">in</span> <span class="built_in">range</span>(row+<span class="number">1</span>,<span class="built_in">len</span>(alignments)):  </span><br><span class="line">            <span class="keyword">if</span> alignments[row][<span class="number">2</span>] != alignments[compare][<span class="number">2</span>]:   </span><br><span class="line">                uniques.append(alignments[row])  </span><br><span class="line">                sp.write(<span class="string">&#x27;\tadding row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; to unique list\n&#x27;</span>)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                sp.write(<span class="string">&#x27;\tcomparing to &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">                <span class="keyword">if</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">0</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">1</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; and &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27; are the same\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">1</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">0</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qend and qstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">3</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">4</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as sstart and send of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">4</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">3</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as send and sstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">0</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">1</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qstart and qend of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">1</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">0</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qend and qstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">3</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">4</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as sstart and send of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">4</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">3</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as send and sstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">else</span>:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is different\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">sp.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Write uniques into output file  </span></span><br><span class="line"><span class="comment"># Start list for copy number table  </span></span><br><span class="line">rous_count = <span class="number">0</span>  </span><br><span class="line">g = <span class="built_in">open</span>(outfa, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">repcopies = []  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(uniques)):  </span><br><span class="line">    qstart = uniques[i][<span class="number">0</span>]  </span><br><span class="line">    qend = uniques[i][<span class="number">1</span>]  </span><br><span class="line">    length = uniques[i][<span class="number">2</span>]  </span><br><span class="line">    seq = uniques[i][<span class="number">7</span>]  </span><br><span class="line">      </span><br><span class="line">    rous_count += <span class="number">1</span>  </span><br><span class="line">    g.write(<span class="string">&#x27;&gt;Repeat_&#x27;</span>+<span class="built_in">str</span>(rous_count)+<span class="string">&#x27;\n&#x27;</span>+seq+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">    repcopies.append([<span class="string">&#x27;Repeat_&#x27;</span>+<span class="built_in">str</span>(rous_count),length])  </span><br><span class="line">          </span><br><span class="line"><span class="keyword">if</span> rous_count == <span class="number">0</span>:  </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;\tRepeats of unusual size? I don&#x27;t think they exist&quot;</span>  </span><br><span class="line">g.close()  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Repeat fasta file is done, as you wish.&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Now find each copy of each repeat. Again, this is because the blastn output file does not have every possible alignment.  </span></span><br><span class="line"><span class="comment"># It is also because the information on locations and strand is not organized well in the blastn output.  </span></span><br><span class="line"><span class="comment"># In addition, this subroutine eliminates duplicates of nested repeats.  </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Finding all copies of repeats...&quot;</span>  </span><br><span class="line">g = <span class="built_in">open</span>(outfa, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+outfa+<span class="string">&#x27; -strand both -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward 1 -penalty -20 -ungapped -dust no -soft_masking false -evalue 1000 -outfmt &quot;10 qseqid length sstart send sstrand qcovhsp&quot; &gt; &#x27;</span>+temprepeats)  </span><br><span class="line">g.close()  </span><br><span class="line">  </span><br><span class="line">tempr = <span class="built_in">open</span>(temprepeats, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">reader = csv.reader(tempr)  </span><br><span class="line">replist = <span class="built_in">list</span>(reader)  </span><br><span class="line">tempr.close()  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Making a table of the repeats...&quot;</span>  </span><br><span class="line">sum_rep_len = <span class="number">0</span>  </span><br><span class="line">bin_dict = &#123;&#125;  </span><br><span class="line">binned = [seqname,seqlen,<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># defining the bins  </span></span><br><span class="line">i = <span class="number">0</span>  </span><br><span class="line">j = <span class="number">50</span>  </span><br><span class="line"><span class="keyword">while</span> j &lt; <span class="number">1000</span>:  </span><br><span class="line">    bin_dict[i] = j  </span><br><span class="line">    binned.append(<span class="number">0</span>)  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    j += <span class="number">50</span>  </span><br><span class="line"><span class="keyword">while</span> j &lt;= <span class="number">10000</span>:  </span><br><span class="line">    bin_dict[i] = j  </span><br><span class="line">    binned.append(<span class="number">0</span>)  </span><br><span class="line">    i +=<span class="number">1</span>  </span><br><span class="line">    j += <span class="number">250</span>  </span><br><span class="line">      </span><br><span class="line"><span class="comment"># make list for entire sequence, set each position as 0  </span></span><br><span class="line">posit = []  </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(seqlen):  </span><br><span class="line">    posit.append(<span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Thanks to Emily Wynn for suggesting qcovhsp for this loop.  </span></span><br><span class="line"><span class="comment"># if qcovhsp is &gt;98%, write to the file  </span></span><br><span class="line"><span class="comment"># write tab separated values of repeat name, length, start, end, strand to outtab  </span></span><br><span class="line"><span class="comment"># make list for genbank file  </span></span><br><span class="line"><span class="comment"># Keep stats on lengths  </span></span><br><span class="line">rt = <span class="built_in">open</span>(outtab, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">rt.write(seqname+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(seqlen)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">templist = []  </span><br><span class="line">gblist =[]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># look at each repeat in turn  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(replist)):  </span><br><span class="line">    <span class="comment"># if repeat is good (&gt;98% identical to another one), write it to the file, and put the name in a list  </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(replist[i][<span class="number">5</span>])&gt;<span class="number">98</span>:  </span><br><span class="line">        rt.write(<span class="built_in">str</span>(replist[i][<span class="number">0</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">1</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">2</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">3</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">4</span>])+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">        <span class="keyword">if</span> replist[i][<span class="number">4</span>] == <span class="string">&#x27;minus&#x27;</span>:  </span><br><span class="line">            location = <span class="string">&#x27;complement(&#x27;</span>+replist[i][<span class="number">3</span>]+<span class="string">&#x27;..&#x27;</span>+replist[i][<span class="number">2</span>]+<span class="string">&#x27;)&#x27;</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            location = replist[i][<span class="number">2</span>]+<span class="string">&#x27;..&#x27;</span>+replist[i][<span class="number">3</span>]  </span><br><span class="line">        gblist.append(<span class="string">&#x27;     repeat_region   &#x27;</span>+location+<span class="string">&#x27;\n                     /rpt_type=dispersed\n                     /label=&#x27;</span>+replist[i][<span class="number">0</span>]+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">        templist.append(replist[i][<span class="number">0</span>])  </span><br><span class="line">        <span class="comment"># then write 1&#x27;s at every position in the sequence covered by that repeat  </span></span><br><span class="line">        <span class="comment"># these can then be summed to get total bases of repeats  </span></span><br><span class="line">        <span class="comment"># bases in overlapping repeats are only counted once  </span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(replist[i][<span class="number">2</span>]), <span class="built_in">int</span>(replist[i][<span class="number">3</span>])):  </span><br><span class="line">            posit[n] = <span class="number">1</span>  </span><br><span class="line">        <span class="comment"># then scan through bin sizes and if a repeat is greater than the  </span></span><br><span class="line">        <span class="comment"># bin_dict size cutoff, add one to the bin  </span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binned)-<span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>):  </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(replist[i][<span class="number">1</span>]) &gt;= bin_dict[j]:  </span><br><span class="line">                binned[j+<span class="number">3</span>] +=<span class="number">1</span>  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">sum_rep_len = posit.count(<span class="number">1</span>)  </span><br><span class="line">binned[<span class="number">2</span>] = sum_rep_len  </span><br><span class="line">rt.close()  </span><br><span class="line"><span class="keyword">if</span> genbank == <span class="literal">True</span>:  </span><br><span class="line">    gb = <span class="built_in">open</span>(outgb, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gblist)):  </span><br><span class="line">        gb.write(gblist[i])  </span><br><span class="line">    gb.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># write tab separated values of repeat name, length, copy number to outcount  </span></span><br><span class="line"><span class="comment"># first two lines are also a table of stats on repeats  </span></span><br><span class="line">rc = <span class="built_in">open</span>(outcount,<span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">rc.write(<span class="string">&#x27;Sequence\tGenome_size\tNumRepeats\tAvgSize\tAvgCopyNum\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">numrous = <span class="number">0</span>  </span><br><span class="line">sizerous = <span class="number">0</span>  </span><br><span class="line">copyrous = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(repcopies)):  </span><br><span class="line">    repname = repcopies[i][<span class="number">0</span>]  </span><br><span class="line">    replen = <span class="built_in">float</span>(repcopies[i][<span class="number">1</span>])  </span><br><span class="line">    repcop = <span class="built_in">float</span>(templist.count(repname))  </span><br><span class="line">  </span><br><span class="line">    numrous += <span class="number">1</span>  </span><br><span class="line">    sizerous += replen  </span><br><span class="line">    copyrous += repcop  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> numrous == <span class="number">0</span>:  </span><br><span class="line">    avsizerous = <span class="string">&#x27;NA&#x27;</span>  </span><br><span class="line">    avcopyrous = <span class="string">&#x27;NA&#x27;</span>  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    avsizerous = sizerous/numrous  </span><br><span class="line">    avcopyrous = copyrous/numrous  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">rc.write(seqname+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(seqlen)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(numrous)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(avsizerous)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(avcopyrous)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(repcopies)):  </span><br><span class="line">    rc.write(repcopies[i][<span class="number">0</span>]+<span class="string">&#x27;\t&#x27;</span>+repcopies[i][<span class="number">1</span>]+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(templist.count(repcopies[i][<span class="number">0</span>]))+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">rc.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Write binned table headers, then stats for this sequence.  </span></span><br><span class="line">binfile = <span class="built_in">open</span>(outbin, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;Sequence\tSeq_len\tRep_len\t&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bin_dict)):  </span><br><span class="line">    binfile.write(<span class="built_in">str</span>(bin_dict[i])+<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binned)):  </span><br><span class="line">    binfile.write(<span class="built_in">str</span>(binned[i])+<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">binfile.close()  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Repeat tables are done, as you wish.&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Removing temp files if necessary  </span></span><br><span class="line"><span class="keyword">if</span> keep == <span class="literal">False</span>:  </span><br><span class="line">    os.system(<span class="string">&#x27;rm &#x27;</span>+tempblast+<span class="string">&#x27; &#x27;</span>+temprepeats+<span class="string">&#x27; &#x27;</span>+tempparse)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Rachael Schulte, William Goldman and Rob Reiner inspired this section of code  </span></span><br><span class="line">quote_dict = &#123;<span class="number">0</span>:<span class="string">&quot;48656c6c6f2e204d79206e616d6520697320496e69676f204d6f6e746f79612e20596f75206b696c6c6564206d79206661746865722e205072657061726520746f206469652e&quot;</span>, <span class="number">1</span>:<span class="string">&quot;5768656e20492077617320796f7572206167652c2074656c65766973696f6e207761732063616c6c656420626f6f6b732e&quot;</span>, <span class="number">2</span>:<span class="string">&quot;486176652066756e2073746f726d696e2720646120636173746c6521&quot;</span>, <span class="number">3</span>:<span class="string">&quot;4d79207761792773206e6f7420766572792073706f7274736d616e6c696b652e&quot;</span>, <span class="number">4</span>:<span class="string">&quot;596f75206b656570207573696e67207468617420776f72642e204920646f206e6f74207468696e6b206974206d65616e73207768617420796f75207468696e6b206974206d65616e732e&quot;</span>, <span class="number">5</span>:<span class="string">&quot;4d75726465726564206279207069726174657320697320676f6f642e&quot;</span>,<span class="number">6</span>:<span class="string">&quot;496e636f6e6365697661626c6521&quot;</span>, <span class="number">7</span>:<span class="string">&quot;5468657265277320612062696720646966666572656e6365206265747765656e206d6f73746c79206465616420616e6420616c6c20646561642e&quot;</span>, <span class="number">8</span>:<span class="string">&quot;596f7520727573682061206d697261636c65206d616e2c20796f752067657420726f7474656e206d697261636c65732e&quot;</span>, <span class="number">9</span>:<span class="string">&quot;476f6f64206e696768742c20576573746c65792e20476f6f6420776f726b2e20536c6565702077656c6c2e2049276c6c206d6f7374206c696b656c79206b696c6c20796f7520696e20746865206d6f726e696e672e&quot;</span>,<span class="number">10</span>:<span class="string">&quot;4e6f206d6f7265207268796d65732c2049206d65616e2069742120416e79626f64792077616e742061207065616e75743f&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">import</span> random, binascii  </span><br><span class="line">z = random.randint(<span class="number">0</span>,<span class="number">10</span>)  </span><br><span class="line"><span class="built_in">print</span> binascii.unhexlify(quote_dict[z])+<span class="string">&#x27;\n&#x27;</span>  </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>MultipleRepeats.py</li>
</ol>
<ul>
<li>MultipleRepeats.py批量运行一个文件夹下的每个序列文件。</li>
<li>脚本贴在下面：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> sys, math, os, argparse  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Usage: -din directory of files to find repeats in  </span></span><br><span class="line"><span class="comment">#        -word word_size  </span></span><br><span class="line">  </span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;Find repeats in a directory of fasta sequence files&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-din&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;din&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Input .fasta directory&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-word&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;word&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Word size for blast&#x27;</span>)  </span><br><span class="line">results = parser.parse_args()  </span><br><span class="line">din = results.din  </span><br><span class="line">word = results.word  </span><br><span class="line">  </span><br><span class="line">li = os.listdir(din)  </span><br><span class="line">inputs = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: <span class="string">&#x27;.fasta&#x27;</span> <span class="keyword">in</span> x, li)  </span><br><span class="line">inputs.sort()  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inputs)):  </span><br><span class="line">    infile = <span class="built_in">str</span>(inputs[i])  </span><br><span class="line">    os.system(<span class="string">&quot;/home/alan/applications/ROUSFinder.py -m &quot;</span>+word+<span class="string">&quot; &quot;</span>+din+infile) </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>ROUSFinder2.py</li>
</ol>
<ul>
<li>ROUSFinder2.py可以在命令行设置match赏分和mismatch罚分。</li>
<li>脚本贴在下面：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python  </span></span><br><span class="line"><span class="keyword">import</span> sys, math, os, argparse, csv  </span><br><span class="line">csv.field_size_limit(sys.maxsize)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Version 2.0, November 21, 2018  </span></span><br><span class="line"><span class="comment"># Changes: uses variable parameters  </span></span><br><span class="line"><span class="comment"># Find dispersed repeated sequences in genomes.   </span></span><br><span class="line"><span class="comment"># Designed for plant mitochondrial genomes of up to a few Mbp.  </span></span><br><span class="line"><span class="comment"># May be very slow with larger genomes.   </span></span><br><span class="line"><span class="comment"># Blast can also sometimes give odd results with large or highly repetetive genomes.  </span></span><br><span class="line"><span class="comment"># Gaps, or runs of &#x27;N&#x27;s in the sequence will definitely give weird results.   </span></span><br><span class="line"><span class="comment"># The program assumes there aren&#x27;t any, and that the longest repeat will be the full sequence to itself.  </span></span><br><span class="line"><span class="comment"># If there are long repeats in the output that are listed as being only at one location, this is probably what happened.  </span></span><br><span class="line"><span class="comment"># If there are a lot of repeats within repeats the results can also be odd.  </span></span><br><span class="line"><span class="comment"># Copyright Alan C. Christensen, University of Nebraska, 2018  </span></span><br><span class="line"><span class="comment"># No guarantees, warranties, support, or anything else is implicit or explicit.  </span></span><br><span class="line"><span class="comment"># Input is a fasta format file of a sequence. Genbank format works but generates lots of error messages in stdout.  </span></span><br><span class="line"><span class="comment"># Output is a list of unique, ungapped repeated sequences, fasta formatted.  </span></span><br><span class="line"><span class="comment"># The names are in the format &#x27;&gt;Repeat/ROUS_name_start_end_length&#x27;.  </span></span><br><span class="line"><span class="comment"># A table of repeats with the coordinates of each one is generated.  </span></span><br><span class="line"><span class="comment"># A list of repeat name, length and copy number is generated.  </span></span><br><span class="line"><span class="comment"># A binned table of the total number of repeats in size ranges is generated.  </span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># PARAMETERS  </span></span><br><span class="line"><span class="comment">#   REQUIRED:  </span></span><br><span class="line"><span class="comment">#      input file in fasta format  </span></span><br><span class="line"><span class="comment">#   Optional  </span></span><br><span class="line"><span class="comment">#      -o output file name  </span></span><br><span class="line"><span class="comment">#      -m minimum length of exact matches to keep  </span></span><br><span class="line"><span class="comment">#      -b path to blastn (default is /usr/bin/)  </span></span><br><span class="line"><span class="comment">#      -k keep temp files  </span></span><br><span class="line"><span class="comment">#      -gb to write the repeats to a genbank format file  </span></span><br><span class="line"><span class="comment">#      -rew reward for match (default is 1)  </span></span><br><span class="line"><span class="comment">#      -pen penalty for mismatch (default is 20)  </span></span><br><span class="line">  </span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;Find repeats in a fasta sequence file&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;infile&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Input .fasta file&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-o&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;outfile&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Output file name seed, default is input_repeats&#x27;</span>, default=<span class="string">&#x27;default&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-m&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;minlen&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Minimum length of matches to keep, default=50&#x27;</span>, default=<span class="string">&#x27;50&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-b&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;blast_path&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Path to blastn program, default is /usr/bin/&#x27;</span>, default=<span class="string">&#x27;/usr/bin/&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-k&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, dest=<span class="string">&#x27;keep&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;True to keep temp files&#x27;</span>, default=<span class="literal">False</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-gb&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, dest=<span class="string">&#x27;genbank&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;True to write GenBank format file&#x27;</span>, default=<span class="literal">False</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-rew&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;reward&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Reward for match&#x27;</span>, default=<span class="string">&#x27;1&#x27;</span>)  </span><br><span class="line">parser.add_argument(<span class="string">&#x27;-pen&#x27;</span>, action=<span class="string">&#x27;store&#x27;</span>, dest=<span class="string">&#x27;penalty&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Penalty for mismatch&#x27;</span>, default=<span class="string">&#x27;20&#x27;</span>)  </span><br><span class="line">results = parser.parse_args()  </span><br><span class="line">infile = results.infile  </span><br><span class="line">outfile = results.outfile  </span><br><span class="line">minlen = <span class="built_in">int</span>(results.minlen)  </span><br><span class="line">blast_path = results.blast_path  </span><br><span class="line">keep = results.keep  </span><br><span class="line">genbank = results.genbank  </span><br><span class="line">reward = results.reward  </span><br><span class="line">penalty = results.penalty  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># It might be useful to define the wordsize as something less than minlen, so both variables are used.  </span></span><br><span class="line"><span class="comment"># Wordsize smaller than minlen would give smaller core identical sequences in the middle of repeats.  </span></span><br><span class="line"><span class="comment"># An example might be to change this to wordsize = str(int(minlen/2)).  </span></span><br><span class="line">wordsize = <span class="built_in">str</span>(minlen)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># If no output file seed is specified, make one by stripping leading directory information  </span></span><br><span class="line"><span class="comment"># and stripping trailing .fa or .fasta from the input file name and using that.  </span></span><br><span class="line"><span class="keyword">if</span> outfile == <span class="string">&#x27;default&#x27;</span>:  </span><br><span class="line">    outfile = infile  </span><br><span class="line">    <span class="keyword">if</span> outfile.count(<span class="string">&#x27;/&#x27;</span>) &gt; <span class="number">0</span>:  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(outfile.count(<span class="string">&#x27;/&#x27;</span>)):  </span><br><span class="line">            index = outfile.index(<span class="string">&#x27;/&#x27;</span>)  </span><br><span class="line">            outfile = outfile[index+<span class="number">1</span>:]  </span><br><span class="line">    <span class="keyword">if</span> outfile.endswith(<span class="string">&#x27;.fa&#x27;</span>) <span class="keyword">or</span> outfile.endswith(<span class="string">&#x27;.fasta&#x27;</span>):  </span><br><span class="line">        outfile = outfile.rstrip(<span class="string">&#x27;fasta&#x27;</span>)  </span><br><span class="line">    outfile = outfile.rstrip(<span class="string">&#x27;.&#x27;</span>)  </span><br><span class="line">outfa = outfile+<span class="string">&#x27;_rep.fasta&#x27;</span>  </span><br><span class="line">outtab = outfile+<span class="string">&#x27;_rep_table.txt&#x27;</span>  </span><br><span class="line">outbin = outfile+<span class="string">&#x27;_binned.txt&#x27;</span>  </span><br><span class="line">outcount = outfile+<span class="string">&#x27;_rep_counts.txt&#x27;</span>  </span><br><span class="line">outgb = outfile+<span class="string">&#x27;_repeats.gb.txt&#x27;</span>  </span><br><span class="line">tempblast = outfile+<span class="string">&#x27;_tempblast.txt&#x27;</span>  </span><br><span class="line">temprepeats = outfile+<span class="string">&#x27;_temprepeats.txt&#x27;</span>  </span><br><span class="line">tempparse = outfile+<span class="string">&#x27;_sequence_parsing.txt&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Get sequence name and length from fasta file.  </span></span><br><span class="line">seq = <span class="built_in">open</span>(infile, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">seqname = seq.readline()  </span><br><span class="line">seqname = seqname.lstrip(<span class="string">&#x27;&gt; &#x27;</span>)  </span><br><span class="line">seqname = seqname.rstrip()  </span><br><span class="line">seqlen = <span class="number">0</span>   </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> seq:  </span><br><span class="line">    <span class="keyword">if</span>(line[<span class="number">0</span>] == <span class="string">&quot;&gt;&quot;</span>):  </span><br><span class="line">        <span class="keyword">continue</span>  </span><br><span class="line">    seqlen += <span class="built_in">len</span>(line.strip())  </span><br><span class="line">seq.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># run blastn with query file plus strand (removing first line which is full length sequence), minus strand, and concatenate  </span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Performing self-blastn comparison with &#x27;</span>+seqname      </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+infile+<span class="string">&#x27; -strand plus -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward &#x27;</span>+reward+<span class="string">&#x27; -penalty -&#x27;</span>+penalty+<span class="string">&#x27; -ungapped -dust no -soft_masking false -evalue 10  -outfmt &quot;10 qstart qend length sstart send mismatch sstrand qseq&quot; | tail -n+2 &gt; tempblast1.txt&#x27;</span>)  </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+infile+<span class="string">&#x27; -strand minus -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward &#x27;</span>+reward+<span class="string">&#x27; -penalty -&#x27;</span>+penalty+<span class="string">&#x27; -ungapped -dust no -soft_masking false -evalue 10 -outfmt &quot;10 qstart qend length sstart send mismatch sstrand qseq&quot; &gt; tempblast2.txt&#x27;</span>)  </span><br><span class="line">os.system(<span class="string">&#x27;cat tempblast1.txt tempblast2.txt &gt; &#x27;</span>+tempblast)  </span><br><span class="line">os.system(<span class="string">&#x27;rm tempblast1.txt tempblast2.txt&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># open tempblast.txt, convert to list of lists, and sort by length and position descending  </span></span><br><span class="line"><span class="comment"># This is necessary because blastn does not output every possible pair of hits when there are more than 2 copies of a repeat  </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Sorting alignments...&#x27;</span>  </span><br><span class="line">f = <span class="built_in">open</span>(tempblast, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">reader = csv.reader(f)  </span><br><span class="line">alignments = <span class="built_in">list</span>(reader)  </span><br><span class="line">f.close()  </span><br><span class="line">alignments = <span class="built_in">sorted</span>(alignments, key=<span class="keyword">lambda</span> x: (-<span class="number">1</span>*<span class="built_in">int</span>(x[<span class="number">2</span>]), -<span class="number">1</span>*<span class="built_in">int</span>(x[<span class="number">0</span>])))  </span><br><span class="line">alignments.append([<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;X&#x27;</span>])  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># New list of uniques  </span></span><br><span class="line"><span class="comment"># Text file &#x27;_sequence_parsing.txt&#x27; includes the information on how duplicates were found.  </span></span><br><span class="line"><span class="comment"># Start at row 0. Compare to subsequent rows.   </span></span><br><span class="line"><span class="comment"># If repeat length is different from the next row, it has passed all the tests, write it to the file.  </span></span><br><span class="line"><span class="comment"># If query or subject coordinates are the same as the query or subject or reversed coordinates  </span></span><br><span class="line"><span class="comment"># of a subsequent row, it is not unique, so go to the next row and do the comparisons again.  </span></span><br><span class="line"><span class="comment"># Thanks to Alex Kozik for repeatedly testing and finding bugs in the algorithm.  </span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Finding unique repeats...&#x27;</span>  </span><br><span class="line">uniques = []  </span><br><span class="line">sp = <span class="built_in">open</span>(tempparse, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(alignments)):  </span><br><span class="line">    sp.write(<span class="string">&#x27;row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(alignments[row][<span class="number">2</span>]) &lt; minlen:  </span><br><span class="line">        <span class="comment"># This won&#x27;t happen unless the word_size is defined as something other than minlen.  </span></span><br><span class="line">        <span class="comment"># That could be useful under some circumstances.  </span></span><br><span class="line">        sp.write(<span class="string">&#x27;row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is less than minlength&#x27;</span>)  </span><br><span class="line">        <span class="keyword">break</span>  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> compare <span class="keyword">in</span> <span class="built_in">range</span>(row+<span class="number">1</span>,<span class="built_in">len</span>(alignments)):  </span><br><span class="line">            <span class="keyword">if</span> alignments[row][<span class="number">2</span>] != alignments[compare][<span class="number">2</span>]:   </span><br><span class="line">                uniques.append(alignments[row])  </span><br><span class="line">                sp.write(<span class="string">&#x27;\tadding row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; to unique list\n&#x27;</span>)  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                sp.write(<span class="string">&#x27;\tcomparing to &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">      </span><br><span class="line">                <span class="keyword">if</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">0</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">1</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; and &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27; are the same\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">1</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">0</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qend and qstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">3</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">4</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as sstart and send of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">0</span>] == alignments[compare][<span class="number">4</span>] <span class="keyword">and</span> alignments[row][<span class="number">1</span>] == alignments[compare][<span class="number">3</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tqstart and qend of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as send and sstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">0</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">1</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qstart and qend of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">1</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">0</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as qend and qstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">3</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">4</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as sstart and send of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">elif</span> alignments[row][<span class="number">3</span>] == alignments[compare][<span class="number">4</span>] <span class="keyword">and</span> alignments[row][<span class="number">4</span>] == alignments[compare][<span class="number">3</span>]:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\tsstart and send of row &#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is the same as send and sstart of &#x27;</span>+<span class="built_in">str</span>(compare)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">                    <span class="keyword">break</span>  </span><br><span class="line">                <span class="keyword">else</span>:  </span><br><span class="line">                    sp.write(<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(row)+<span class="string">&#x27; is different\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">sp.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Write uniques into output file  </span></span><br><span class="line"><span class="comment"># Start list for copy number table  </span></span><br><span class="line">rous_count = <span class="number">0</span>  </span><br><span class="line">g = <span class="built_in">open</span>(outfa, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">repcopies = []  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(uniques)):  </span><br><span class="line">    qstart = uniques[i][<span class="number">0</span>]  </span><br><span class="line">    qend = uniques[i][<span class="number">1</span>]  </span><br><span class="line">    length = uniques[i][<span class="number">2</span>]  </span><br><span class="line">    seq = uniques[i][<span class="number">7</span>]  </span><br><span class="line">      </span><br><span class="line">    rous_count += <span class="number">1</span>  </span><br><span class="line">    g.write(<span class="string">&#x27;&gt;Repeat_&#x27;</span>+<span class="built_in">str</span>(rous_count)+<span class="string">&#x27;\n&#x27;</span>+seq+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">    repcopies.append([<span class="string">&#x27;Repeat_&#x27;</span>+<span class="built_in">str</span>(rous_count),length])  </span><br><span class="line">          </span><br><span class="line"><span class="keyword">if</span> rous_count == <span class="number">0</span>:  </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;\tRepeats of unusual size? I don&#x27;t think they exist&quot;</span>  </span><br><span class="line">g.close()  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;Repeat fasta file is done, as you wish.&#x27;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Now find each copy of each repeat. Again, this is because the blastn output file does not have every possible alignment.  </span></span><br><span class="line"><span class="comment"># It is also because the information on locations and strand is not organized well in the blastn output.  </span></span><br><span class="line"><span class="comment"># In addition, this subroutine eliminates duplicates of nested repeats.  </span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Finding all copies of repeats...&quot;</span>  </span><br><span class="line">g = <span class="built_in">open</span>(outfa, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">os.system(blast_path+<span class="string">&#x27;blastn -query &#x27;</span>+outfa+<span class="string">&#x27; -strand both -subject &#x27;</span>+infile+<span class="string">&#x27; -word_size &#x27;</span>+wordsize+<span class="string">&#x27; -reward 1 -penalty -20 -ungapped -dust no -soft_masking false -evalue 1000 -outfmt &quot;10 qseqid length sstart send sstrand qcovhsp&quot; &gt; &#x27;</span>+temprepeats)  </span><br><span class="line">g.close()  </span><br><span class="line">  </span><br><span class="line">tempr = <span class="built_in">open</span>(temprepeats, <span class="string">&#x27;r&#x27;</span>)  </span><br><span class="line">reader = csv.reader(tempr)  </span><br><span class="line">replist = <span class="built_in">list</span>(reader)  </span><br><span class="line">tempr.close()  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Making a table of the repeats...&quot;</span>  </span><br><span class="line">sum_rep_len = <span class="number">0</span>  </span><br><span class="line">bin_dict = &#123;&#125;  </span><br><span class="line">binned = [seqname,seqlen,<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># defining the bins  </span></span><br><span class="line">i = <span class="number">0</span>  </span><br><span class="line">j = <span class="number">50</span>  </span><br><span class="line"><span class="keyword">while</span> j &lt; <span class="number">1000</span>:  </span><br><span class="line">    bin_dict[i] = j  </span><br><span class="line">    binned.append(<span class="number">0</span>)  </span><br><span class="line">    i += <span class="number">1</span>  </span><br><span class="line">    j += <span class="number">50</span>  </span><br><span class="line"><span class="keyword">while</span> j &lt;= <span class="number">10000</span>:  </span><br><span class="line">    bin_dict[i] = j  </span><br><span class="line">    binned.append(<span class="number">0</span>)  </span><br><span class="line">    i +=<span class="number">1</span>  </span><br><span class="line">    j += <span class="number">250</span>  </span><br><span class="line">      </span><br><span class="line"><span class="comment"># make list for entire sequence, set each position as 0  </span></span><br><span class="line">posit = []  </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(seqlen):  </span><br><span class="line">    posit.append(<span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Thanks to Emily Wynn for suggesting qcovhsp for this loop.  </span></span><br><span class="line"><span class="comment"># if qcovhsp is &gt;98%, write to the file  </span></span><br><span class="line"><span class="comment"># write tab separated values of repeat name, length, start, end, strand to outtab  </span></span><br><span class="line"><span class="comment"># make list for genbank file  </span></span><br><span class="line"><span class="comment"># Keep stats on lengths  </span></span><br><span class="line">rt = <span class="built_in">open</span>(outtab, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">rt.write(seqname+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(seqlen)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">templist = []  </span><br><span class="line">gblist =[]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># look at each repeat in turn  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(replist)):  </span><br><span class="line">    <span class="comment"># if repeat is good (&gt;98% identical to another one), write it to the file, and put the name in a list  </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(replist[i][<span class="number">5</span>])&gt;<span class="number">98</span>:  </span><br><span class="line">        rt.write(<span class="built_in">str</span>(replist[i][<span class="number">0</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">1</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">2</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">3</span>])+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(replist[i][<span class="number">4</span>])+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">        <span class="keyword">if</span> replist[i][<span class="number">4</span>] == <span class="string">&#x27;minus&#x27;</span>:  </span><br><span class="line">            location = <span class="string">&#x27;complement(&#x27;</span>+replist[i][<span class="number">3</span>]+<span class="string">&#x27;..&#x27;</span>+replist[i][<span class="number">2</span>]+<span class="string">&#x27;)&#x27;</span>  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            location = replist[i][<span class="number">2</span>]+<span class="string">&#x27;..&#x27;</span>+replist[i][<span class="number">3</span>]  </span><br><span class="line">        gblist.append(<span class="string">&#x27;     repeat_region   &#x27;</span>+location+<span class="string">&#x27;\n                     /rpt_type=dispersed\n                     /label=&#x27;</span>+replist[i][<span class="number">0</span>]+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">        templist.append(replist[i][<span class="number">0</span>])  </span><br><span class="line">        <span class="comment"># then write 1&#x27;s at every position in the sequence covered by that repeat  </span></span><br><span class="line">        <span class="comment"># these can then be summed to get total bases of repeats  </span></span><br><span class="line">        <span class="comment"># bases in overlapping repeats are only counted once  </span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(replist[i][<span class="number">2</span>]), <span class="built_in">int</span>(replist[i][<span class="number">3</span>])):  </span><br><span class="line">            posit[n] = <span class="number">1</span>  </span><br><span class="line">        <span class="comment"># then scan through bin sizes and if a repeat is greater than the  </span></span><br><span class="line">        <span class="comment"># bin_dict size cutoff, add one to the bin  </span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binned)-<span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>):  </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(replist[i][<span class="number">1</span>]) &gt;= bin_dict[j]:  </span><br><span class="line">                binned[j+<span class="number">3</span>] +=<span class="number">1</span>  </span><br><span class="line">                <span class="keyword">break</span>  </span><br><span class="line">sum_rep_len = posit.count(<span class="number">1</span>)  </span><br><span class="line">binned[<span class="number">2</span>] = sum_rep_len  </span><br><span class="line">rt.close()  </span><br><span class="line"><span class="keyword">if</span> genbank == <span class="literal">True</span>:  </span><br><span class="line">    gb = <span class="built_in">open</span>(outgb, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gblist)):  </span><br><span class="line">        gb.write(gblist[i])  </span><br><span class="line">    gb.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># write tab separated values of repeat name, length, copy number to outcount  </span></span><br><span class="line"><span class="comment"># first two lines are also a table of stats on repeats  </span></span><br><span class="line">rc = <span class="built_in">open</span>(outcount,<span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">rc.write(<span class="string">&#x27;Sequence\tGenome_size\tNumROUS\tAvgSize\tAvgCopyNum\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">numrous = <span class="number">0</span>  </span><br><span class="line">sizerous = <span class="number">0</span>  </span><br><span class="line">copyrous = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(repcopies)):  </span><br><span class="line">    repname = repcopies[i][<span class="number">0</span>]  </span><br><span class="line">    replen = <span class="built_in">float</span>(repcopies[i][<span class="number">1</span>])  </span><br><span class="line">    repcop = <span class="built_in">float</span>(templist.count(repname))  </span><br><span class="line">  </span><br><span class="line">    numrous += <span class="number">1</span>  </span><br><span class="line">    sizerous += replen  </span><br><span class="line">    copyrous += repcop  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> numrous == <span class="number">0</span>:  </span><br><span class="line">    avsizerous = <span class="string">&#x27;NA&#x27;</span>  </span><br><span class="line">    avcopyrous = <span class="string">&#x27;NA&#x27;</span>  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    avsizerous = sizerous/numrous  </span><br><span class="line">    avcopyrous = copyrous/numrous  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">rc.write(seqname+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(seqlen)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(numrous)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(avsizerous)+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(avcopyrous)+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(repcopies)):  </span><br><span class="line">    rc.write(repcopies[i][<span class="number">0</span>]+<span class="string">&#x27;\t&#x27;</span>+repcopies[i][<span class="number">1</span>]+<span class="string">&#x27;\t&#x27;</span>+<span class="built_in">str</span>(templist.count(repcopies[i][<span class="number">0</span>]))+<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">rc.close()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Write binned table headers, then stats for this sequence.  </span></span><br><span class="line">binfile = <span class="built_in">open</span>(outbin, <span class="string">&#x27;w&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;Sequence\tSeq_len\tRep_len\t&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(bin_dict)):  </span><br><span class="line">    binfile.write(<span class="built_in">str</span>(bin_dict[i])+<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(binned)):  </span><br><span class="line">    binfile.write(<span class="built_in">str</span>(binned[i])+<span class="string">&#x27;\t&#x27;</span>)  </span><br><span class="line">binfile.write(<span class="string">&#x27;\n&#x27;</span>)  </span><br><span class="line">binfile.close()  </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Repeat tables are done, as you wish.&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Removing temp files if necessary  </span></span><br><span class="line"><span class="keyword">if</span> keep == <span class="literal">False</span>:  </span><br><span class="line">    os.system(<span class="string">&#x27;rm &#x27;</span>+tempblast+<span class="string">&#x27; &#x27;</span>+temprepeats+<span class="string">&#x27; &#x27;</span>+tempparse)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># Rachael Schulte, William Goldman and Rob Reiner inspired this section of code  </span></span><br><span class="line">quote_dict = &#123;<span class="number">0</span>:<span class="string">&quot;48656c6c6f2e204d79206e616d6520697320496e69676f204d6f6e746f79612e20596f75206b696c6c6564206d79206661746865722e205072657061726520746f206469652e&quot;</span>, <span class="number">1</span>:<span class="string">&quot;5768656e20492077617320796f7572206167652c2074656c65766973696f6e207761732063616c6c656420626f6f6b732e&quot;</span>, <span class="number">2</span>:<span class="string">&quot;486176652066756e2073746f726d696e2720646120636173746c6521&quot;</span>, <span class="number">3</span>:<span class="string">&quot;4d79207761792773206e6f7420766572792073706f7274736d616e6c696b652e&quot;</span>, <span class="number">4</span>:<span class="string">&quot;596f75206b656570207573696e67207468617420776f72642e204920646f206e6f74207468696e6b206974206d65616e73207768617420796f75207468696e6b206974206d65616e732e&quot;</span>, <span class="number">5</span>:<span class="string">&quot;4d75726465726564206279207069726174657320697320676f6f642e&quot;</span>,<span class="number">6</span>:<span class="string">&quot;496e636f6e6365697661626c6521&quot;</span>, <span class="number">7</span>:<span class="string">&quot;5468657265277320612062696720646966666572656e6365206265747765656e206d6f73746c79206465616420616e6420616c6c20646561642e&quot;</span>, <span class="number">8</span>:<span class="string">&quot;596f7520727573682061206d697261636c65206d616e2c20796f752067657420726f7474656e206d697261636c65732e&quot;</span>, <span class="number">9</span>:<span class="string">&quot;476f6f64206e696768742c20576573746c65792e20476f6f6420776f726b2e20536c6565702077656c6c2e2049276c6c206d6f7374206c696b656c79206b696c6c20796f7520696e20746865206d6f726e696e672e&quot;</span>,<span class="number">10</span>:<span class="string">&quot;4e6f206d6f7265207268796d65732c2049206d65616e2069742120416e79626f64792077616e742061207065616e75743f&quot;</span>&#125;  </span><br><span class="line"><span class="keyword">import</span> random, binascii  </span><br><span class="line">z = random.randint(<span class="number">0</span>,<span class="number">10</span>)  </span><br><span class="line"><span class="built_in">print</span> binascii.unhexlify(quote_dict[z])+<span class="string">&#x27;\n&#x27;</span>  </span><br></pre></td></tr></table></figure>

<h2 id="2-2-鉴定重复的步骤"><a href="#2-2-鉴定重复的步骤" class="headerlink" title="2.2. 鉴定重复的步骤"></a>2.2. 鉴定重复的步骤</h2><p>选择ROUSFinder2.py脚本来鉴定线粒体的重复序列。</p>
<ol>
<li>脚本参数</li>
</ol>
<ul>
<li>必需参数：fasta格式的输入序列</li>
<li>-o out：输出文件名称</li>
<li>-m 50：鉴定的重复序列的最小长度，默认是50bp。</li>
<li>-b &#x2F;path&#x2F;to&#x2F;blastn&#x2F;：blastn命令的路径，默认是&#x2F;usr&#x2F;bin&#x2F;。</li>
<li>-k：保留临时文件，out_tempblast.txt和out_temprepeats.txt</li>
<li>-gb：生成重复序列的genbank格式文件，out_repeats.gb.txt</li>
<li>-rew 1：match赏分，默认是+1</li>
<li>-pen 20：mismatch罚分，默认是-20</li>
</ul>
<ol start="2">
<li>运行脚本</li>
</ol>
<ul>
<li><code>ROUSFinder2.py input.fa -m 30 -gb -o out</code></li>
</ul>
<ol start="3">
<li>输出</li>
</ol>
<ul>
<li>out_binned.txt：包含&gt;50bp,100bp,150bp,…,1000bp,1250bp,1500bp,…,10000bp的repeat的数量</li>
<li>out_rep.fasta：包含fasta格式的repeat序列</li>
<li>out_rep_counts.txt：包含repeat的总数（NumROUS），平均长度（AvgSize），平均数量（AvgCopyNum），和每个repeat的长度和数量。</li>
<li>out_rep_table.txt：包含每个repeat单元的长度，起始位置和终止位置，正负链（plus或minus）。</li>
<li>out_repeats.gb.txt：使用-gb参数则生成此文件，是genbank格式的repeat的注释文件。</li>
</ul>
<h2 id="2-3-重复的应用"><a href="#2-3-重复的应用" class="headerlink" title="2.3. 重复的应用"></a>2.3. 重复的应用</h2><ol>
<li>辅助线粒体组装</li>
</ol>
<ul>
<li>通过鉴定出来的重复，可以帮助线粒体组装得更完整。</li>
<li>调整线粒体的已有组装。比如通过计算重组率，把主导的优势构象作为最后的线粒体组装构象。</li>
</ul>
<ol start="2">
<li>鉴定重组</li>
</ol>
<ul>
<li>重复序列可能介导重组，所以鉴定重复是鉴定重组的基础。</li>
</ul>
<h1 id="3-鉴定重组和计算重组率"><a href="#3-鉴定重组和计算重组率" class="headerlink" title="3. 鉴定重组和计算重组率"></a>3. 鉴定重组和计算重组率</h1><p>鉴定出线粒体的重复序列后，还可以进一步鉴定这些重复序列是否介导了重组。</p>
<p>重组会导致构象的变化，构象变化的形式包括：</p>
<ol>
<li>位于不同染色体环上的一对重复序列可能介导重组，使得两个小环变成一个大环。</li>
<li>位于同一个染色体环上的同方向的一对重复序列可能介导重组，使得一个大环变成两个小环。</li>
<li>位于同一个染色体环上的反方向的一对重复序列，可能在其他重复对的重组变换下变成同方向或者两个小环的状态。</li>
</ol>
<h2 id="3-1-鉴定重组的步骤"><a href="#3-1-鉴定重组的步骤" class="headerlink" title="3.1. 鉴定重组的步骤"></a>3.1. 鉴定重组的步骤</h2><h3 id="3-1-1-构建参考构象和重组构象的序列"><a href="#3-1-1-构建参考构象和重组构象的序列" class="headerlink" title="3.1.1. 构建参考构象和重组构象的序列"></a>3.1.1. 构建参考构象和重组构象的序列</h3><ol>
<li>针对一对可能造成重组的重复序列，构建参考构象和重组构象</li>
<li>在参考构象和重组构象中，以重复序列加上两翼各300bp作为参考构象序列(ref_1和ref_2)和重组构象序列(rec_1和rec_2)</li>
<li>构建参考序列和mapping注意事项</li>
</ol>
<ul>
<li>可以把参考构象序列和重组构象序列（一共四条）一同作为参考序列（reference）用于mapping，避免同一条reads mapping到多个构象序列从而重复计数的情况。</li>
<li>如果担心叶绿体派生的reads影响重组率的计算，还可以加上叶绿体基因组作为参考序列（reference），这样叶绿体的reads会被mapping到叶绿体上，从而起到过滤的作用。</li>
<li>如果担心核基因派生的reads影响，可以用一个cutoff值(比如100bp)，小于100bp的mapping被筛除。</li>
</ul>
<h3 id="3-1-2-把reads往参考序列进行mapping"><a href="#3-1-2-把reads往参考序列进行mapping" class="headerlink" title="3.1.2. 把reads往参考序列进行mapping"></a>3.1.2. 把reads往参考序列进行mapping</h3><ol>
<li>把reads往参考序列进行mapping，之后再根据mapping的reads的位置进行筛选，筛选出横跨repeat区域的有效mapping。</li>
<li>比如repeat长度为220bp，两边各截取300bp，共820bp长度的参考序列。这里把跨越220bp的repeat，并且两边各至少映射上10bp的reads作为有效mapping。这意味着，mapping的起始位置需要小于290，终止位置需要大于530bp。</li>
<li>bwa进行mapping后得到的bam文件的第4列代表read比对到的参考序列最左侧的位置坐标（未必对上第4列为0）；第9列代表pair read完全匹配到同一条参考序列时，两个read之间的长度。可以理解为insert size。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a = 530 # 设置终止位置需要大于的值，这里是530bp</span><br><span class="line">bwa index reference.fa # 为参考序列建立索引</span><br><span class="line">bwa mem -t 4 reference.fa  sample_1.clean.fq sample_2.clean.fq | samtools sort -@ 4 -m 4G &gt; reference.bam # 映射reads到参考序列</span><br><span class="line">samtools view reference.bam |awk -F&quot;\t&quot; -v awka=&quot;$a&quot; &#x27;$4&lt;290 &amp;&amp; ($4+$9)&gt;awka &#123;print $0&#125;&#x27; &gt; reference.bam.filter # 筛选起始位置小于290，终止位置大于530bp的mapped reads。这里的`awk -F&quot;\t&quot;`参数设定列分隔符非常重要，已经坑过我两把了。</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-计算重组率-recombination-rate"><a href="#3-1-3-计算重组率-recombination-rate" class="headerlink" title="3.1.3. 计算重组率(recombination rate)"></a>3.1.3. 计算重组率(recombination rate)</h3><ol>
<li>把reads往参考序列进行mapping得到有效映射的比对文件reference.bam.filter后，计算不同参考序列的有效映射的reads数量（即数据行数）。</li>
<li>重组构象的两条序列(rec_1和rec_2)的比对reads数量之和作为分子，重组构象的两条序列(rec_1和rec_2)的比对reads数量与参考构象的两条序列(ref_1和ref_2)的比对reads数量之和作为分母，两者的比值可作为重组率。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">n_ref_1 = $(cat reference.bam.filter | awk &#x27;$3 == &quot;ref_1&quot; &#123;print $0&#125;&#x27; |wc -l) # 统计参考构象序列ref_1上有效映射reads的数量</span><br><span class="line">n_ref_2 = $(cat reference.bam.filter | awk &#x27;$3 == &quot;ref_2&quot; &#123;print $0&#125;&#x27; |wc -l) # 统计参考构象序列ref_2上有效映射reads的数量</span><br><span class="line">n_rec_1 = $(cat reference.bam.filter | awk &#x27;$3 == &quot;rec_1&quot; &#123;print $0&#125;&#x27; |wc -l) # 统计参考构象序列rec_1上有效映射reads的数量</span><br><span class="line">n_rec_2 = $(cat reference.bam.filter | awk &#x27;$3 == &quot;rec_2&quot; &#123;print $0&#125;&#x27; |wc -l) # 统计参考构象序列rec_2上有效映射reads的数量</span><br><span class="line">mapping_rate = $(($n_rec_1+$n_rec_2)/($n_ref_1+$n_ref_2+$n_rec_1+$n_rec_2)) # 计算重组率</span><br></pre></td></tr></table></figure>

<h1 id="4-references"><a href="#4-references" class="headerlink" title="4. references"></a>4. references</h1><ol>
<li>ROUSFinder.py脚本：<a href="https://academic.oup.com/g3journal/article/9/2/549/6026745">https://academic.oup.com/g3journal/article/9/2/549/6026745</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=30% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>organelle</category>
        <category>recombination</category>
      </categories>
      <tags>
        <tag>mitogenome</tag>
        <tag>repeat</tag>
        <tag>recombination</tag>
        <tag>rearrangement</tag>
        <tag>insert size</tag>
        <tag>recombination frequency</tag>
      </tags>
  </entry>
  <entry>
    <title>RNA-sequencing数据分析工具比较</title>
    <url>/2021/11/19/omics_transcriptome.RNA-seq/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=176028&auto=1&height=32"></iframe></div>

<h1 id="1-background"><a href="#1-background" class="headerlink" title="1. background"></a>1. background</h1><p>2017年nature communications上发表的Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis，对RNA-sequencing(RNA-seq)数据的39种分析工具做了比较和总结。</p>
<p>RNA-seq分析流程主要有四大模块：</p>
<ul>
<li>RNA-seq变异分析(Genomic variants)</li>
<li>短读长数据的亚型检测(Short-read isoform detection)</li>
<li>长读长数据的亚型jiance(Long-read isoform detection)</li>
<li>表达分析(Expression analysis)</li>
</ul>
<img src="https://media.springernature.com/full/springer-static/image/art%3A10.1038%2Fs41467-017-00050-4/MediaObjects/41467_2017_50_Fig1_HTML.jpg?as=webp" title="RNACocktail分析协议" width="90%" />

<p><strong><p align="center">Figure 1. RNACocktail分析协议</strong><br>from <a href="https://www.nature.com/articles/s41467-017-00050-4">paper: Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis</a></p></p>
<h1 id="2-比较结果总结"><a href="#2-比较结果总结" class="headerlink" title="2. 比较结果总结"></a>2. 比较结果总结</h1><ol>
<li>比对工具：<strong>HISAT2</strong>在准确性和运算速度上表现最好值得推荐，STAR和TopHat在剪切位点总数上表现更好。</li>
<li>有参组装工具：<strong>StringTie</strong>在组装的转录本数量，转录本水平的准确性和运行速度上都表现最好，Cufflinks表现一般，isoform detection and prediction(IDP)在基因水平准确性上表现最好。</li>
<li>从头组装工具：Trinity转录本长，灵敏度高；SOAPdenovo-Trans转录本多，准确性高；<strong>Oases</strong>鉴定长转录本有优势，能够较好地涵盖到低表达的基因。</li>
<li>三代测序错误纠正工具：<strong>LoRDEC</strong>在纠错质量和速度上更有优势，LSC在纠正后reads比对率的改善上表现更好。</li>
<li>全长转录本亚型检测工具：注重质量选GMAP，注重速度选<strong>STARlong</strong>。</li>
<li>转录本的定量：<strong>Salmon-SMEM</strong>(不经过比对)运行速度和表现都更好；StringTie(基于基因组)的定量结果更接近于不基于基因组比对的工具结果。</li>
<li>差异表达的工具：<strong>DESeq2</strong>在各项得分中均优于其他的工具。</li>
<li>检测基因组和转录组的突变：<strong>GATK</strong>在突变检测方面具有较高的准确性，在运行时间方面GATK与Samtools没有明显的差异。</li>
</ol>
<p>作者总结了每一步的高精度工具，作为RNA-seq分析工具选择的一般建议。</p>
<img src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41467-017-00050-4/MediaObjects/41467_2017_50_Fig8_HTML.jpg?as=webp" title="RNACocktail计算流程" width="90%" />

<p><strong><p align="center">Figure 2. RNACocktail计算流程</strong><br>from <a href="https://www.nature.com/articles/s41467-017-00050-4">paper: Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis</a></p></p>
<h1 id="3-比较结果"><a href="#3-比较结果" class="headerlink" title="3. 比较结果"></a>3. 比较结果</h1><h2 id="3-1-比对工具"><a href="#3-1-比对工具" class="headerlink" title="3.1. 比对工具"></a>3.1. 比对工具</h2><h3 id="3-1-1-比对工具用法"><a href="#3-1-1-比对工具用法" class="headerlink" title="3.1.1. 比对工具用法"></a>3.1.1. 比对工具用法</h3><p>RNA-seq分析的第一步通常是转录本的鉴定，需要把RNA-seq reads比对到合适的参考序列上。</p>
<p>如果用基因组作为参考序列可以检测到新的转录本，但可能需要耗费更多的计算资源；如果用转录组作为参考则无法找出新的转录本，但速度更快。如果研究物种没有可靠的参考序列，可以重头组装对转录本进行鉴定。</p>
<p>比对工具可以把RNA-seq short reads往参考基因组上进行mapping，做比对(alignment)，进行剪切点预测(junction prediction)和exon-intron边界的预测。</p>
<h3 id="3-1-2-比对结果"><a href="#3-1-2-比对结果" class="headerlink" title="3.1.2. 比对结果"></a>3.1.2. 比对结果</h3><p>比较了三款比对主流软件，<strong>HISAT2</strong>在准确性和运算速度上表现最好值得推荐，STAR和TopHat在剪切位点总数上表现更好。</p>
<ul>
<li><strong>HISAT2</strong>在所有样品中能检测到的剪接位点验证率最高，但找到的剪接位点总数则比TopHat和STAR都要少。在运行速度方面，HISAT2则有较大的优势，比STAR快大约2.5倍并且比TopHat快大约100倍。</li>
<li><strong>STAR</strong>对于成对reads的唯一比对表现则比较好，特别是对于有较长读长的MCF7-300细胞系的数据，不过STAR会有更多含有soft-clipped和碱基错配的较低质量比对情况。</li>
<li>如果单看有soft-clipped的reads，<strong>TopHat</strong>会把这部分reads全部舍弃。</li>
</ul>
<img src="https://media.springernature.com/full/springer-static/image/art%3A10.1038%2Fs41467-017-00050-4/MediaObjects/41467_2017_50_Fig2_HTML.jpg?as=webp" title="比对工具比较结果" width="90%" />

<p><strong><p align="center">Figure 3. 比对工具比较结果</strong><br>from <a href="https://www.nature.com/articles/s41467-017-00050-4">paper: Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis</a></p></p>
<h2 id="3-2-有参组装工具"><a href="#3-2-有参组装工具" class="headerlink" title="3.2. 有参组装工具"></a>3.2. 有参组装工具</h2><p>比对完成后，接着组装转录本。比较了三款组装工具，StringTie在组装的转录本数量，转录本水平的准确性和运行速度上都表现最好，Cufflinks表现一般，isoform detection and prediction(IDP)在基因水平准确性上表现最好。</p>
<ul>
<li>转录本数量：StringTie&gt;Cufflinks~IDP</li>
<li>基因水平准确性和灵敏度：IDP&gt;Cufflinks&gt;StringTie</li>
<li>转录本水平准确性：StringTie&gt;IDP&gt;Cufflink</li>
<li>运行速度：StringTie&gt;Cufflinks~IDP</li>
<li>IDP则会忽略单外显子转录本</li>
</ul>
<img src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41467-017-00050-4/MediaObjects/41467_2017_50_Fig3_HTML.jpg?as=webp" title="有参组装工具比较结果" width="90%" />

<p><strong><p align="center">Figure 4. 有参组装工具比较结果</strong><br>from <a href="https://www.nature.com/articles/s41467-017-00050-4">paper: Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis</a></p></p>
<h2 id="3-3-从头组装工具"><a href="#3-3-从头组装工具" class="headerlink" title="3.3. 从头组装工具"></a>3.3. 从头组装工具</h2><p>比较了三款从头组装转录本的工具：Trinity转录本长，灵敏度高；SOAPdenovo-Trans转录本多，准确性高；Oases鉴定长转录本有优势，能够较好地涵盖到低表达的基因。</p>
<ul>
<li>Trinity：组装的转录本较长，灵敏度高。</li>
<li>SOAPdenovo-Trans：组装到转录本数量多，准确性最高，对于高表达的转录本有明显的组装偏好性；花费的内存和CPU最低。</li>
<li>Oases：在所有样品中都有较好的N10-N50长度的表现，鉴定长转录本有优势；能够较好地涵盖到低表达的基因。</li>
</ul>
<img src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41467-017-00050-4/MediaObjects/41467_2017_50_Fig4_HTML.jpg?as=webp" title="从头组装工具比较结果" width="90%" />

<p><strong><p align="center">Figure 5. 从头组装工具比较结果</strong><br>from <a href="https://www.nature.com/articles/s41467-017-00050-4">paper: Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis</a></p></p>
<h2 id="3-4-三代测序错误纠正工具"><a href="#3-4-三代测序错误纠正工具" class="headerlink" title="3.4. 三代测序错误纠正工具"></a>3.4. 三代测序错误纠正工具</h2><p>LoRDEC在纠错质量和速度上更有优势，LSC在纠正后reads比对率的改善上表现更好。</p>
<ul>
<li>LoRDEC：纠正后的reads质量更高，运行速度比LSC快100倍。</li>
<li>LSC：纠正后的reads比对率提高更多。</li>
</ul>
<h2 id="3-5-全长转录本亚型检测工具"><a href="#3-5-全长转录本亚型检测工具" class="headerlink" title="3.5. 全长转录本亚型检测工具"></a>3.5. 全长转录本亚型检测工具</h2><p>注重质量选GMAP，注重速度选STARlong。</p>
<ul>
<li>GMAP：比对到参考序列的reads数量更多。</li>
<li>STARlong：运行速度快68倍。</li>
</ul>
<h2 id="3-6-转录本的定量"><a href="#3-6-转录本的定量" class="headerlink" title="3.6. 转录本的定量"></a>3.6. 转录本的定量</h2><h3 id="3-6-1-转录本定量软件"><a href="#3-6-1-转录本定量软件" class="headerlink" title="3.6.1. 转录本定量软件"></a>3.6.1. 转录本定量软件</h3><ol>
<li>基于比对的转录本定量</li>
</ol>
<ul>
<li>传统方法是将read比对(spliced -aligned)到参考基因组，然后利用Cufflinks和StringTie进行转录本组装，最后进行定量。</li>
<li>如果具有参考转录本序列，reads可以直接跟转录本序列比对(aligned)，然后使用Salmon-Aln和eXpress进行定量。</li>
</ul>
<ol start="2">
<li>不经过比对(alignment-free)的转录本定量</li>
</ol>
<ul>
<li>主要提供了四个工具：Sailfish、Salmon-SMEM、quasi-mapping和kallisto。</li>
</ul>
<ol start="3">
<li>基于长读长技术的IDP（使用不同的短读长和长读长比对工具）</li>
</ol>
<h3 id="3-6-2-比较结果"><a href="#3-6-2-比较结果" class="headerlink" title="3.6.2. 比较结果"></a>3.6.2. 比较结果</h3><ul>
<li>StringTie的定量结果更接近于不基于基因组比对的工具结果。</li>
<li>基于转录组比对的两款工具则和Salmon-SMEM的相关性更高，考虑到Salmon-SMEM更快的运行速度，eXpress和Salmon-Aln可能使用体验不如Salmon-SMEM。</li>
<li>kallisto和Salmon-SMEM表现最好。</li>
<li>基于比对基因组的工具则能够看到，使用HISAT2或者TopHat对具有较长读长的样品进行比对所得到的定量结果要比STAR要好。</li>
</ul>
<img src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41467-017-00050-4/MediaObjects/41467_2017_50_Fig5_HTML.jpg?as=webp" title="转录本表达定量比较结果" width="90%" />

<p><strong><p align="center">Figure 6. 转录本表达定量比较结果</strong><br>from <a href="https://www.nature.com/articles/s41467-017-00050-4">paper: Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis</a></p></p>
<h2 id="3-7-差异表达的工具"><a href="#3-7-差异表达的工具" class="headerlink" title="3.7. 差异表达的工具"></a>3.7. 差异表达的工具</h2><p>比较了基于计数的工具（DESeq2、limma和edgeR）和基于组装的工具（Cuffdiff和Ballgown）。</p>
<p><strong>DESeq2</strong>在各项得分中均优于其他的工具，而Cuffdiff和Ballgown的表现则相对比较差。<br>总的来说，基于计数的工具要比基于组装的工具效果要好；另外从运行时间上看的话，Cuffdiff也是最慢的工具。</p>
<img src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41467-017-00050-4/MediaObjects/41467_2017_50_Fig6_HTML.jpg?as=webp" title="差异表达比较结果" width="90%" />

<p><strong><p align="center">Figure 7. 差异表达比较结果</strong><br>from <a href="https://www.nature.com/articles/s41467-017-00050-4">paper: Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis</a></p></p>
<h2 id="3-8-检测基因组和转录组的突变"><a href="#3-8-检测基因组和转录组的突变" class="headerlink" title="3.8. 检测基因组和转录组的突变"></a>3.8. 检测基因组和转录组的突变</h2><p>两款突变检测的工具：GATK HaplotypeCaller和Samtools mpileup。</p>
<p><strong>GATK</strong>在突变检测方面具有较高的准确性，在运行时间方面GATK与Samtools没有明显的差异。</p>
<img src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41467-017-00050-4/MediaObjects/41467_2017_50_Fig7_HTML.jpg?as=webp" title="突变检测比较结果" width="90%" />

<p><strong><p align="center">Figure 8. 突变检测比较结果</strong><br>from <a href="https://www.nature.com/articles/s41467-017-00050-4">paper: Gaining comprehensive biological insight into the transcriptome by performing a broad-spectrum RNA-seq analysis</a></p></p>
<h1 id="4-39个RNA-seq分析工具版本号、重要参数及下载地址"><a href="#4-39个RNA-seq分析工具版本号、重要参数及下载地址" class="headerlink" title="4. 39个RNA-seq分析工具版本号、重要参数及下载地址"></a>4. 39个RNA-seq分析工具版本号、重要参数及下载地址</h1><h2 id="4-1-比对工具-——-Reference-based-transcript-identification"><a href="#4-1-比对工具-——-Reference-based-transcript-identification" class="headerlink" title="4.1. 比对工具 —— Reference-based transcript identification"></a>4.1. 比对工具 —— Reference-based transcript identification</h2><ol>
<li>TopHat2： –no-coverage-search<br><a href="http://ccb.jhu.edu/software/tophat/index.shtml">http://ccb.jhu.edu/software/tophat/index.shtml</a></li>
<li>STAR: -twopassMode Basic –outFilterType BySJout<br><a href="https://github.com/alexdobin/STAR/releases">https://github.com/alexdobin/STAR/releases</a></li>
<li>HISAT2 2.0.1-beta –dta (or –dta-cufflinks)<br><a href="http://www.ccb.jhu.edu/software/hisat/index.shtml">http://www.ccb.jhu.edu/software/hisat/index.shtml</a></li>
<li>RASER 0.52 -b 0.03<br><a href="https://www.ibp.ucla.edu/research/xiao/RASER.html">https://www.ibp.ucla.edu/research/xiao/RASER.html</a></li>
</ol>
<h2 id="4-2-有参考转录本组装工具"><a href="#4-2-有参考转录本组装工具" class="headerlink" title="4.2. 有参考转录本组装工具"></a>4.2. 有参考转录本组装工具</h2><ol>
<li>Cufflinks 2.2.1 –frag-bias-correct<br><a href="http://cole-trapnell-lab.github.io/cufflinks/">http://cole-trapnell-lab.github.io/cufflinks/</a></li>
<li>StringTie 1.2.1 -v -B<br><a href="http://www.ccb.jhu.edu/software/stringtie/">http://www.ccb.jhu.edu/software/stringtie/</a></li>
</ol>
<h2 id="4-3-无参考转录本组装工具"><a href="#4-3-无参考转录本组装工具" class="headerlink" title="4.3. 无参考转录本组装工具"></a>4.3. 无参考转录本组装工具</h2><ol>
<li>SOAPdenovoTrans 1.04 -K 25<br><a href="https://github.com/aquaskyline/SOAPdenovo-Trans/">https://github.com/aquaskyline/SOAPdenovo-Trans/</a></li>
<li>Oases 0.2.09 (Velvetv1.2.10) (velveth haslength: 25) (velvetg options: -read trkg yes)<br><a href="http://www.ebi.ac.uk/~zerbino/oases/">http://www.ebi.ac.uk/~zerbino/oases/</a></li>
<li>Trinity 2.1.1 –normalize reads<br><a href="http://trinityrnaseq.sourceforge.net/">http://trinityrnaseq.sourceforge.net/</a></li>
</ol>
<h2 id="4-4-三代长read分析工具"><a href="#4-4-三代长read分析工具" class="headerlink" title="4.4. 三代长read分析工具"></a>4.4. 三代长read分析工具</h2><ol>
<li>LoRDEC 0.6 -k 23 -s 3<br><a href="http://atgc.lirmm.fr/lordec/">http://atgc.lirmm.fr/lordec/</a></li>
<li>GMAP 12&#x2F;31&#x2F;15 -f 1<br><a href="http://research-pub.gene.com/gmap/">http://research-pub.gene.com/gmap/</a></li>
<li>STARlong 2.5.1b<br><a href="https://github.com/alexdobin/STAR/releases">https://github.com/alexdobin/STAR/releases</a></li>
</ol>
<p>Followed the recommended options : </p>
<ul>
<li>–outSAMattributes NH HI NM MD</li>
<li>–readNameSeparator space</li>
<li>–outFilterMultimapScoreRange 1</li>
<li>–outFilterMismatchNmax 2000</li>
<li>–scoreGapNoncan -20</li>
<li>–scoreGapGCAG -4</li>
<li>–scoreGapATAC -8</li>
<li>–scoreDelOpen -1</li>
<li>–scoreDelBase -1</li>
<li>–scoreInsOpen -1</li>
<li>–scoreInsBase -1</li>
<li>–alignEndsType Local</li>
<li>–seedSearchStartLmax 50</li>
<li>–seedPerReadNmax 100000</li>
<li>–seedPerWindowNmax 1000</li>
<li>–alignTranscriptsPerReadNmax 100000</li>
<li>–alignTranscriptsPerWindowNmax 10000</li>
<li>–outSAMstrandField intronMotif</li>
<li>–outSAMunmapped Within</li>
</ul>
<ol start="4">
<li>IDP 0.1.9<br><a href="https://www.healthcare.uiowa.edu/labs/au/IDP/">https://www.healthcare.uiowa.edu/labs/au/IDP/</a></li>
</ol>
<h2 id="4-5-定量工具"><a href="#4-5-定量工具" class="headerlink" title="4.5. 定量工具"></a>4.5. 定量工具</h2><ol>
<li>eXpress 1.5.1 (bowtie2 v2.2.7) (bowtie2 options: -a -X 600 –rdg 6,5 –rfg 6,5 –score-min L,-.6,-.4 –no-discordant –no-mixed)<br><a href="https://pachterlab.github.io/eXpress/index.html">https://pachterlab.github.io/eXpress/index.html</a></li>
<li>kallisto 0.42.4<br><a href="http://pachterlab.github.io/kallisto/about.html">http://pachterlab.github.io/kallisto/about.html</a></li>
<li>Sailfish 0.9.0<br><a href="http://www.cs.cmu.edu/~ckingsf/software/sailfish/">http://www.cs.cmu.edu/~ckingsf/software/sailfish/</a></li>
<li>Salmon-Aln 0.6.1<br><a href="https://github.com/COMBINE-lab/salmon">https://github.com/COMBINE-lab/salmon</a></li>
<li>Salmon-SMEM 0.6.1<br><a href="https://github.com/COMBINE-lab/salmon">https://github.com/COMBINE-lab/salmon</a><br>index: –type fmd<br>quant: -k,19 </li>
<li>Salmon-Quasi 0.6.1<br><a href="https://github.com/COMBINE-lab/salmon">https://github.com/COMBINE-lab/salmon</a><br>index: –type quasi -k 31 </li>
<li>featureCounts 1.5.0-p1 -p -B -C<br><a href="http://subread.sourceforge.net/">http://subread.sourceforge.net/</a></li>
</ol>
<h2 id="4-6-差异表达分析工具"><a href="#4-6-差异表达分析工具" class="headerlink" title="4.6. 差异表达分析工具"></a>4.6. 差异表达分析工具</h2><ol>
<li>DESeq2 1.14.1<br><a href="http://bioconductor.org/packages/release/bioc/html/DESeq2.html">http://bioconductor.org/packages/release/bioc/html/DESeq2.html</a></li>
<li>edgeR 3.16.5<br><a href="http://www.bioconductor.org/packages/release/bioc/html/edgeR.html">http://www.bioconductor.org/packages/release/bioc/html/edgeR.html</a></li>
<li>limma 3.30.7<br><a href="http://bioconductor.org/packages/release/bioc/html/limma.html">http://bioconductor.org/packages/release/bioc/html/limma.html</a></li>
<li>Cuffdiff 2.2.1<br>–frag-bias-correct –emit-count-tables<br><a href="http://cole-trapnell-lab.github.io/cufflinks/">http://cole-trapnell-lab.github.io/cufflinks/</a></li>
<li>Ballgown 2.6.0<br><a href="https://github.com/alyssafrazee/ballgown">https://github.com/alyssafrazee/ballgown</a></li>
<li>sleuth 0.28.1<br><a href="https://github.com/pachterlab/sleuth">https://github.com/pachterlab/sleuth</a></li>
</ol>
<h2 id="4-7-变异分析工具"><a href="#4-7-变异分析工具" class="headerlink" title="4.7. 变异分析工具"></a>4.7. 变异分析工具</h2><ol>
<li>SAMtools 1.2 (bcftools v1.2)<br>samtools mpileup -C50 -d 100000<br><a href="https://github.com/samtools/samtools">https://github.com/samtools/samtools</a></li>
<li>bcftools filter -s LowQual -e ‘%QUAL&lt;20 —— DP&gt;10000’<br><a href="https://github.com/samtools/bcftools">https://github.com/samtools/bcftools</a></li>
<li>GATK v3.5-0-g36282e4 (picard 1.129)<br><a href="https://software.broadinstitute.org/gatk/download/">https://software.broadinstitute.org/gatk/download/</a><br>Picard AddOrReplaceReadGroups: SO&#x3D;coordinate<br>Picard MarkDuplicates: CREATE INDEX&#x3D;true VALIDATION STRINGENCY&#x3D;SILENTGATK<br>SplitNCigarReads: -rf ReassignOneMappingQuality -RMQF 255 -RMQT 60</li>
</ol>
<p>-U ALLOW N CIGAR READSGATK<br>HaplotypeCaller: -stand call conf 20.0<br>-stand emit conf 20.0 -A StrandBiasBySample<br>-A StrandAlleleCountsBySampleGATK<br>VariantFiltration: -window 35 -cluster 3 -filterName FS -filter<br>“FS &gt;30.0” -filterName QD -filter “QD &lt;2.0”</p>
<h2 id="4-8-RNA编辑"><a href="#4-8-RNA编辑" class="headerlink" title="4.8. RNA编辑"></a>4.8. RNA编辑</h2><ol>
<li>GIREMI 0.2.1<br><a href="https://github.com/zhqingit/giremi">https://github.com/zhqingit/giremi</a></li>
<li>Varsim 0.5.1<br><a href="https://github.com/bioinform/varsim">https://github.com/bioinform/varsim</a></li>
</ol>
<h2 id="4-9-基因融合"><a href="#4-9-基因融合" class="headerlink" title="4.9. 基因融合"></a>4.9. 基因融合</h2><ol>
<li>FusionCatcher 0.99.5a beta<br><a href="https://github.com/ndaniel/fusioncatcher">https://github.com/ndaniel/fusioncatcher</a></li>
<li>JAFFA 1.0.6<br><a href="https://github.com/Oshlack/JAFFA">https://github.com/Oshlack/JAFFA</a></li>
<li>SOAPfuse 1.27<br><a href="http://soap.genomics.org.cn/soapfuse.html">http://soap.genomics.org.cn/soapfuse.html</a></li>
<li>STAR-Fusion 0.7.0<br><a href="https://github.com/STAR-Fusion/STAR-Fusion">https://github.com/STAR-Fusion/STAR-Fusion</a></li>
<li>TopHat-Fusion 2.0.14<br><a href="http://ccb.jhu.edu/software/tophat/fusion_index.shtml">http://ccb.jhu.edu/software/tophat/fusion_index.shtml</a><br>s</li>
</ol>
<h1 id="5-references"><a href="#5-references" class="headerlink" title="5. references"></a>5. references</h1><ol>
<li>paper：<a href="https://www.nature.com/articles/s41467-017-00050-4">https://www.nature.com/articles/s41467-017-00050-4</a></li>
<li><a href="https://mp.weixin.qq.com/s/hp_wxiLDI9EVB8Z3L1bxbw">https://mp.weixin.qq.com/s/hp_wxiLDI9EVB8Z3L1bxbw</a></li>
<li><a href="https://www.cnblogs.com/wangprince2017/p/9959008.html">https://www.cnblogs.com/wangprince2017/p/9959008.html</a></li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>omics</category>
        <category>transcriptome</category>
      </categories>
      <tags>
        <tag>RNA-sequencing</tag>
        <tag>RNA-seq</tag>
        <tag>HISAT2</tag>
        <tag>StringTie</tag>
        <tag>Oases</tag>
        <tag>LoRDEC</tag>
        <tag>STARlong</tag>
        <tag>Salmon-SMEM</tag>
        <tag>DESeq2</tag>
        <tag>GATK</tag>
      </tags>
  </entry>
  <entry>
    <title>scripts</title>
    <url>/2021/04/01/programming_scripts/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=476751845&auto=1&height=32"></iframe></div>

<h1 id="1-我写的脚本"><a href="#1-我写的脚本" class="headerlink" title="1. 我写的脚本"></a>1. 我写的脚本</h1><h2 id="1-1-多个RNA-seq数据，基于参考基因组的转录本组装和ORF预测"><a href="#1-1-多个RNA-seq数据，基于参考基因组的转录本组装和ORF预测" class="headerlink" title="1.1. 多个RNA-seq数据，基于参考基因组的转录本组装和ORF预测"></a>1.1. 多个RNA-seq数据，基于参考基因组的转录本组装和ORF预测</h2><p><a href="https://github.com/yanzhongsino/bioscripts/blob/main/my_scripts/multi-transcriptome_assembly_with_ref.sh">multi-transcriptome_assembly_with_ref.sh</a></p>
<h2 id="1-2-提取，合并，和比对单拷贝基因和蛋白"><a href="#1-2-提取，合并，和比对单拷贝基因和蛋白" class="headerlink" title="1.2. 提取，合并，和比对单拷贝基因和蛋白"></a>1.2. 提取，合并，和比对单拷贝基因和蛋白</h2><p><a href="https://github.com/yanzhongsino/bioscripts/blob/main/my_scripts/extract_single_copy_genes.sh">extract_single_copy_genes.sh</a></p>
<h1 id="2-我修改的脚本（其他人写的）"><a href="#2-我修改的脚本（其他人写的）" class="headerlink" title="2. 我修改的脚本（其他人写的）"></a>2. 我修改的脚本（其他人写的）</h1><h2 id="2-1-从包含mRNA和CDS的gff注释文件中提取intron的位置和长度信息"><a href="#2-1-从包含mRNA和CDS的gff注释文件中提取intron的位置和长度信息" class="headerlink" title="2.1. 从包含mRNA和CDS的gff注释文件中提取intron的位置和长度信息"></a>2.1. 从包含mRNA和CDS的gff注释文件中提取intron的位置和长度信息</h2><p><a href="https://github.com/yanzhongsino/bioscripts/blob/main/modifiedscripts/extract_intron_info.pl">extract_intron_info.pl</a></p>
<h1 id="3-保存的脚本"><a href="#3-保存的脚本" class="headerlink" title="3. 保存的脚本"></a>3. 保存的脚本</h1><h2 id="3-1-batch-run-sh-——-多线程并行运行批量化命令"><a href="#3-1-batch-run-sh-——-多线程并行运行批量化命令" class="headerlink" title="3.1. batch_run.sh —— 多线程并行运行批量化命令"></a>3.1. batch_run.sh —— 多线程并行运行批量化命令</h2><p><a href="https://github.com/yanzhongsino/bioscripts/blob/main/saved_scripts/batch_run.sh">batch_run.sh</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">batch_run.sh脚本用于多线程并行批量化循环命令，并控制并行数量始终为<span class="variable">$&#123;thread&#125;</span>。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">usage: 修改thread=后的值为想要设定的并行线程数，把需要并行的命令替换23行的run something。运行脚本batch_run.sh，实现并行运行循环任务。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ref：网上找的脚本，来源找不到了，侵删。</span></span><br><span class="line"></span><br><span class="line">thread=16</span><br><span class="line"></span><br><span class="line">start_time=`date +%s`              # 定义脚本运行的开始时间</span><br><span class="line">echo $&#123;start_time&#125;</span><br><span class="line">tmpFifo=/tmp/$$.fifo # 声明管道名称，$$表示脚本当前运行的进程PID</span><br><span class="line">mkfifo $&#123;tmpFifo&#125; # 创建有名管道</span><br><span class="line">exec 3&lt;&gt;$&#123;tmpFifo&#125;                   #创建文件描述符，以可读（&lt;）可写（&gt;）的方式关联管道文件，这时候文件描述符3就有了有名管道文件的所有特性</span><br><span class="line">rm -rf $&#123;tmpFifo&#125;                    #关联后的文件描述符拥有管道文件的所有特性,所以这时候管道文件可以删除，我们留下文件描述符来用就可以了</span><br><span class="line">for ((i=1;i&lt;=$&#123;thread&#125;;i++))</span><br><span class="line">do</span><br><span class="line">        echo &quot;&quot; &gt;&amp;3                   #&amp;3代表引用文件描述符3，这条命令代表往管道里面放入了一个&quot;令牌&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for sample in $(cat sample_list.txt) #并行运行的循环</span><br><span class="line">do</span><br><span class="line">        read -u3                           #代表从管道中读取一个令牌</span><br><span class="line">        &#123;</span><br><span class="line">                echo $&#123;sample&#125;</span><br><span class="line">                run something # 需要并行运行的真实命令</span><br><span class="line">                echo &#x27;success&#x27; $&#123;sample&#125;       </span><br><span class="line">                echo &quot;&quot; &gt;&amp;3                   #代表我这一次命令执行到最后，把令牌放回管道</span><br><span class="line">        &#125; &amp;</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># ps:可以使用while read line; do echo $line; done &lt; file.txt代替for i in $(cat file.txt);do echo $i; done循环。但是不能用cat file.txt | while read line; do echo $line; done代替。</span></span></span><br><span class="line"></span><br><span class="line">wait</span><br><span class="line"> </span><br><span class="line">stop_time=`date +%s`  #定义脚本运行的结束时间</span><br><span class="line"> </span><br><span class="line">echo &quot;TIME:`expr $stop_time - $start_time`&quot;</span><br><span class="line">exec 3&lt;&amp;-                       #关闭文件描述符的读</span><br><span class="line">exec 3&gt;&amp;-                       #关闭文件描述符的写</span><br></pre></td></tr></table></figure>

<h2 id="3-2-infernal-tblout2gff-pl-——-基因组ncRNA的infernal注释结果tblout格式转换成gff格式"><a href="#3-2-infernal-tblout2gff-pl-——-基因组ncRNA的infernal注释结果tblout格式转换成gff格式" class="headerlink" title="3.2. infernal-tblout2gff.pl —— 基因组ncRNA的infernal注释结果tblout格式转换成gff格式"></a>3.2. infernal-tblout2gff.pl —— 基因组ncRNA的infernal注释结果tblout格式转换成gff格式</h2><ol>
<li>背景<br>用Infernal注释基因组的ncRNA，得到的结果可以用脚本整理成gff3格式。</li>
</ol>
<p>脚本来源：<a href="https://www.cnblogs.com/jessepeng/p/15392809.html">https://www.cnblogs.com/jessepeng/p/15392809.html</a></p>
<ol start="2">
<li>脚本</li>
</ol>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env perl</span></span><br><span class="line"><span class="comment"># infernal-tblout2gff.pl: convert cmsearch or cmscan tblout files to GFF format</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># an important point of above ref:</span></span><br><span class="line"><span class="comment"># &quot;Start is always less than or equal to end&quot;</span></span><br><span class="line"><span class="comment"># EPN, Fri Jun  7 11:07:38 2019</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> warnings;</span><br><span class="line"><span class="keyword">use</span> Getopt::Long;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $in_tblout  = <span class="string">&quot;&quot;</span>;   <span class="comment"># name of input tblout file</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $usage;</span><br><span class="line">$usage  = <span class="string">&quot;infernal-tblout2gff.pl\n\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;Usage:\n\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;infernal-tblout2gff.pl [OPTIONS] &lt;cmsearch tblout file&gt;\n\tOR\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;infernal-tblout2gff.pl --cmscan [OPTIONS] &lt;cmscan tblout file&gt;\n\tOR\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;infernal-tblout2gff.pl --cmscan --fmt2 [OPTIONS] &lt;cmscan --fmt 2 tblout file&gt;\n\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;\tOPTIONS:\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;\t\t-T &lt;n&gt;       : minimum bit score to include is &lt;n&gt;\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;\t\t-E &lt;x&gt;       : maximum E-value to include is &lt;x&gt;\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;\t\t--cmscan     : tblout file was created by cmscan\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;\t\t--source &lt;s&gt; : specify &#x27;source&#x27; field should be &lt;s&gt; (e.g. tRNAscan-SE)\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;\t\t--fmt2       : tblout file was created with cmscan --fmt 2 option\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;\t\t--all        : output all info in &#x27;attributes&#x27; column   [default: E-value]\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;\t\t--none       : output no info in &#x27;attributes&#x27; column    [default: E-value]\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;\t\t--desc       : output desc field in &#x27;attributes&#x27; column [default: E-value]\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;\t\t--version &lt;s&gt;: append \&quot;-&lt;s&gt;\&quot; to &#x27;source&#x27; column\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;\t\t--extra &lt;s&gt;  : append \&quot;&lt;s&gt;;\&quot; to &#x27;attributes&#x27; column\n&quot;</span>;</span><br><span class="line">$usage .= <span class="string">&quot;\t\t--hidedesc   : do not includ \&quot;desc\:\&quot; prior to desc value in &#x27;attributes&#x27; column\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $do_minscore = <span class="number">0</span>;       <span class="comment"># set to &#x27;1&#x27; if -T used</span></span><br><span class="line"><span class="keyword">my</span> $do_maxevalue = <span class="number">0</span>;      <span class="comment"># set to &#x27;1&#x27; if -E used</span></span><br><span class="line"><span class="keyword">my</span> $minscore   = <span class="keyword">undef</span>;    <span class="comment"># defined if if -T used</span></span><br><span class="line"><span class="keyword">my</span> $maxevalue  = <span class="keyword">undef</span>;    <span class="comment"># defined if -E used</span></span><br><span class="line"><span class="keyword">my</span> $do_cmscan  = <span class="number">0</span>;        <span class="comment"># set to &#x27;1&#x27; if --cmscan used</span></span><br><span class="line"><span class="keyword">my</span> $do_fmt2    = <span class="number">0</span>;        <span class="comment"># set to &#x27;1&#x27; if --fmt</span></span><br><span class="line"><span class="keyword">my</span> $do_all_attributes = <span class="number">0</span>; <span class="comment"># set to &#x27;1&#x27; if --all</span></span><br><span class="line"><span class="keyword">my</span> $do_no_attributes  = <span class="number">0</span>; <span class="comment"># set to &#x27;1&#x27; if --none</span></span><br><span class="line"><span class="keyword">my</span> $do_de_attributes  = <span class="number">0</span>; <span class="comment"># set to &#x27;1&#x27; if --desc</span></span><br><span class="line"><span class="keyword">my</span> $version = <span class="keyword">undef</span>;       <span class="comment"># defined if --version used</span></span><br><span class="line"><span class="keyword">my</span> $extra = <span class="keyword">undef</span>;         <span class="comment"># defined if --extra used</span></span><br><span class="line"><span class="keyword">my</span> $do_hidedesc = <span class="number">0</span>;       <span class="comment"># set to 1 if --hidedesc used</span></span><br><span class="line"><span class="keyword">my</span> $opt_source = <span class="keyword">undef</span>;    <span class="comment"># set to &lt;s&gt; if --source &lt;s&gt; used</span></span><br><span class="line"></span><br><span class="line">&amp;GetOptions( <span class="string">&quot;T=s&quot;</span>       =&gt; \$minscore,</span><br><span class="line">             <span class="string">&quot;E=s&quot;</span>       =&gt; \$maxevalue,</span><br><span class="line">             <span class="string">&quot;cmscan&quot;</span>    =&gt; \$do_cmscan,</span><br><span class="line">             <span class="string">&quot;source=s&quot;</span>  =&gt; \$opt_source,</span><br><span class="line">             <span class="string">&quot;fmt2&quot;</span>      =&gt; \$do_fmt2,</span><br><span class="line">             <span class="string">&quot;all&quot;</span>       =&gt; \$do_all_attributes,</span><br><span class="line">             <span class="string">&quot;none&quot;</span>      =&gt; \$do_no_attributes,</span><br><span class="line">             <span class="string">&quot;desc&quot;</span>      =&gt; \$do_de_attributes,</span><br><span class="line">             <span class="string">&quot;version=s&quot;</span> =&gt; \$version, </span><br><span class="line">             <span class="string">&quot;extra=s&quot;</span>   =&gt; \$extra,</span><br><span class="line">             <span class="string">&quot;hidedesc&quot;</span>  =&gt; \$do_hidedesc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">scalar</span>(@ARGV) != <span class="number">1</span>) &#123; <span class="keyword">die</span> $usage; &#125;</span><br><span class="line"><span class="keyword">my</span> ($tblout_file) = @ARGV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">defined</span> $minscore)  &#123; $do_minscore  = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">defined</span> $maxevalue) &#123; $do_maxevalue = <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>($do_minscore &amp;&amp; $do_maxevalue) &#123; </span><br><span class="line">  <span class="keyword">die</span> <span class="string">&quot;ERROR, -T and -E cannot be used in combination. Pick one.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(($do_all_attributes) &amp;&amp; ($do_no_attributes)) &#123; </span><br><span class="line">  <span class="keyword">die</span> <span class="string">&quot;ERROR, --all and --none cannot be used in combination. Pick one.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(($do_all_attributes) &amp;&amp; ($do_de_attributes)) &#123; </span><br><span class="line">  <span class="keyword">die</span> <span class="string">&quot;ERROR, --all and --desc cannot be used in combination. Pick one.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(($do_no_attributes) &amp;&amp; ($do_de_attributes)) &#123; </span><br><span class="line">  <span class="keyword">die</span> <span class="string">&quot;ERROR, --none and --desc cannot be used in combination. Pick one.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(($do_fmt2) &amp;&amp; (! $do_cmscan)) &#123; </span><br><span class="line">  <span class="keyword">die</span> <span class="string">&quot;ERROR, --fmt2 only makes sense in combination with --cmscan&quot;</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">defined</span> $opt_source) &amp;&amp; (<span class="keyword">defined</span> $version)) &#123; </span><br><span class="line">  <span class="keyword">die</span> <span class="string">&quot;ERROR, --source and --version are incompatible&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(! -e $tblout_file) &#123; <span class="keyword">die</span> <span class="string">&quot;ERROR tblout file $tblout_file does not exist&quot;</span>; &#125;</span><br><span class="line"><span class="keyword">if</span>(! -s $tblout_file) &#123; <span class="keyword">die</span> <span class="string">&quot;ERROR tblout file $tblout_file is empty&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $source = ($do_cmscan) ? <span class="string">&quot;cmscan&quot;</span> : <span class="string">&quot;cmsearch&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">defined</span> $version)    &#123; $source .= <span class="string">&quot;-&quot;</span> . $version; &#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">defined</span> $opt_source) &#123; $source = $opt_source; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span>(IN, $tblout_file) || <span class="keyword">die</span> <span class="string">&quot;ERROR unable to open $tblout_file for reading&quot;</span>; </span><br><span class="line"><span class="keyword">my</span> $line;</span><br><span class="line"><span class="keyword">my</span> $i;</span><br><span class="line"><span class="keyword">while</span>($line = &lt;IN&gt;) &#123; </span><br><span class="line">  <span class="keyword">if</span>($line !~ <span class="regexp">m/^\#/</span>) &#123; </span><br><span class="line">    <span class="keyword">chomp</span> $line;</span><br><span class="line">    <span class="keyword">my</span> @el_A = <span class="keyword">split</span>(<span class="regexp">/\s+/</span>, $line);</span><br><span class="line">    <span class="keyword">my</span> $nfields = <span class="keyword">scalar</span>(@el_A);</span><br><span class="line">    <span class="keyword">if</span>((! $do_fmt2) &amp;&amp; ($nfields &lt; <span class="number">18</span>)) &#123; </span><br><span class="line">      <span class="keyword">die</span> <span class="string">&quot;ERROR expected at least 18 space delimited fields in tblout line (fmt 1, default) but got $nfields on line:\n$line\n&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(($do_fmt2) &amp;&amp; ($nfields &lt; <span class="number">27</span>)) &#123; </span><br><span class="line">      <span class="keyword">die</span> <span class="string">&quot;ERROR expected at least 27 space delimited fields in tblout line (fmt 2, --fmt2) but got $nfields on line:\n$line\n&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># ref Infernal 1.1.2 user guide, pages 59-61</span></span><br><span class="line">    <span class="keyword">my</span> $idx     = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $seqname = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $seqaccn = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $mdlname = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $mdlaccn = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $clan    = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $mdl     = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $mdlfrom = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $mdlto   = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $seqfrom = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $seqto   = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $strand  = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $trunc   = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $pass    = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $gc      = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $bias    = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $score   = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $evalue  = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $inc     = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $olp     = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $anyidx  = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $anyfrct1= <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $anyfrct2= <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $winidx  = <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $winfrct1= <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $winfrct2= <span class="keyword">undef</span>;</span><br><span class="line">    <span class="keyword">my</span> $desc    = <span class="keyword">undef</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>($do_fmt2) &#123; <span class="comment"># 27 fields</span></span><br><span class="line">      $idx     = $el_A[<span class="number">0</span>];</span><br><span class="line">      $seqname = ($do_cmscan) ? $el_A[<span class="number">3</span>] : $el_A[<span class="number">1</span>];</span><br><span class="line">      $seqaccn = ($do_cmscan) ? $el_A[<span class="number">4</span>] : $el_A[<span class="number">2</span>];</span><br><span class="line">      $mdlname = ($do_cmscan) ? $el_A[<span class="number">1</span>] : $el_A[<span class="number">3</span>];</span><br><span class="line">      $mdlaccn = ($do_cmscan) ? $el_A[<span class="number">2</span>] : $el_A[<span class="number">4</span>];</span><br><span class="line">      $clan    = $el_A[<span class="number">5</span>];</span><br><span class="line">      $mdl     = $el_A[<span class="number">6</span>];</span><br><span class="line">      $mdlfrom = $el_A[<span class="number">7</span>];</span><br><span class="line">      $mdlto   = $el_A[<span class="number">8</span>];</span><br><span class="line">      $seqfrom = $el_A[<span class="number">9</span>];</span><br><span class="line">      $seqto   = $el_A[<span class="number">10</span>];</span><br><span class="line">      $strand  = $el_A[<span class="number">11</span>];</span><br><span class="line">      $trunc   = $el_A[<span class="number">12</span>];</span><br><span class="line">      $pass    = $el_A[<span class="number">13</span>];</span><br><span class="line">      $gc      = $el_A[<span class="number">14</span>];</span><br><span class="line">      $bias    = $el_A[<span class="number">15</span>];</span><br><span class="line">      $score   = $el_A[<span class="number">16</span>];</span><br><span class="line">      $evalue  = $el_A[<span class="number">17</span>];</span><br><span class="line">      $inc     = $el_A[<span class="number">18</span>];</span><br><span class="line">      $olp     = $el_A[<span class="number">19</span>];</span><br><span class="line">      $anyidx  = $el_A[<span class="number">20</span>];</span><br><span class="line">      $anyfrct1= $el_A[<span class="number">21</span>];</span><br><span class="line">      $anyfrct2= $el_A[<span class="number">22</span>];</span><br><span class="line">      $winidx  = $el_A[<span class="number">23</span>];</span><br><span class="line">      $winfrct1= $el_A[<span class="number">24</span>];</span><br><span class="line">      $winfrct2= $el_A[<span class="number">25</span>];</span><br><span class="line">      $desc    = $el_A[<span class="number">26</span>]; </span><br><span class="line">      <span class="keyword">for</span>($i = <span class="number">27</span>; $i &lt; $nfields; $i++) &#123; $desc .= <span class="string">&quot;_&quot;</span> . $el_A[$i]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment"># fmt 1, default</span></span><br><span class="line">      $seqname = ($do_cmscan) ? $el_A[<span class="number">2</span>] : $el_A[<span class="number">0</span>];</span><br><span class="line">      $seqaccn = ($do_cmscan) ? $el_A[<span class="number">3</span>] : $el_A[<span class="number">1</span>];</span><br><span class="line">      $mdlname = ($do_cmscan) ? $el_A[<span class="number">0</span>] : $el_A[<span class="number">2</span>];</span><br><span class="line">      $mdlaccn = ($do_cmscan) ? $el_A[<span class="number">1</span>] : $el_A[<span class="number">3</span>];</span><br><span class="line">      $mdl     = $el_A[<span class="number">4</span>];</span><br><span class="line">      $mdlfrom = $el_A[<span class="number">5</span>];</span><br><span class="line">      $mdlto   = $el_A[<span class="number">6</span>];</span><br><span class="line">      $seqfrom = $el_A[<span class="number">7</span>];</span><br><span class="line">      $seqto   = $el_A[<span class="number">8</span>];</span><br><span class="line">      $strand  = $el_A[<span class="number">9</span>];</span><br><span class="line">      $trunc   = $el_A[<span class="number">10</span>];</span><br><span class="line">      $pass    = $el_A[<span class="number">11</span>];</span><br><span class="line">      $gc      = $el_A[<span class="number">12</span>];</span><br><span class="line">      $bias    = $el_A[<span class="number">13</span>];</span><br><span class="line">      $score   = $el_A[<span class="number">14</span>];</span><br><span class="line">      $evalue  = $el_A[<span class="number">15</span>];</span><br><span class="line">      $inc     = $el_A[<span class="number">16</span>];</span><br><span class="line">      $desc    = $el_A[<span class="number">17</span>]; </span><br><span class="line">      <span class="keyword">for</span>($i = <span class="number">18</span>; $i &lt; $nfields; $i++) &#123; $desc .= <span class="string">&quot;_&quot;</span> . $el_A[$i]; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># one sanity check, strand should make sense</span></span><br><span class="line">    <span class="keyword">if</span>(($strand <span class="keyword">ne</span> <span class="string">&quot;+&quot;</span>) &amp;&amp; ($strand <span class="keyword">ne</span> <span class="string">&quot;-&quot;</span>)) &#123; </span><br><span class="line">      <span class="keyword">if</span>(($do_fmt2) &amp;&amp; (($seqfrom eq <span class="string">&quot;+&quot;</span>) || ($seqfrom eq <span class="string">&quot;-&quot;</span>))) &#123; </span><br><span class="line">        <span class="keyword">die</span> <span class="string">&quot;ERROR problem parsing, you specified --fmt2 but tblout file appears to have NOT been created with --fmt 2, retry without --fmt2\nproblematic line:\n$line\n&quot;</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>((! $do_fmt2) &amp;&amp; (($pass eq <span class="string">&quot;+&quot;</span>) || ($pass eq <span class="string">&quot;-&quot;</span>))) &#123; </span><br><span class="line">        <span class="keyword">die</span> <span class="string">&quot;ERROR problem parsing, you did not specify --fmt2 but tblout file appears to have been created with --fmt 2, retry with --fmt2\nproblematic line:\n$line\n&quot;</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">die</span> <span class="string">&quot;ERROR unable to parse, problematic line:\n$line\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(($do_minscore) &amp;&amp; ($score &lt; $minscore)) &#123; </span><br><span class="line">      ; <span class="comment"># skip</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">elsif</span>(($do_maxevalue) &amp;&amp; ($evalue &gt; $maxevalue)) &#123; </span><br><span class="line">      ; <span class="comment"># skip</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="keyword">my</span> $attributes = <span class="string">&quot;evalue=&quot;</span> . $evalue; <span class="comment"># default to just evalue</span></span><br><span class="line">      <span class="keyword">if</span>($do_all_attributes) &#123; </span><br><span class="line">        <span class="keyword">if</span>($do_fmt2) &#123; </span><br><span class="line">          $attributes .= <span class="keyword">sprintf</span>(<span class="string">&quot;;idx=$idx;seqaccn=$seqaccn;mdlaccn=$mdlaccn;clan=$clan;mdl=$mdl;mdlfrom=$mdlfrom;mdlto=$mdlto;trunc=$trunc;pass=$pass;gc=$gc;bias=$bias;inc=$inc;olp=$olp;anyidx=$anyidx;anyfrct1=$anyfrct1;anyfrct2=$anyfrct2;winidx=$winidx;winfrct1=$winfrct1;winfrct2=$winfrct2;%s$desc&quot;</span>, ($do_hidedesc ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;desc=&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">          $attributes .= <span class="keyword">sprintf</span>(<span class="string">&quot;;seqaccn=$seqaccn;mdlaccn=$mdlaccn;mdl=$mdl;mdlfrom=$mdlfrom;mdlto=$mdlto;trunc=$trunc;pass=$pass;gc=$gc;bias=$bias;inc=$inc;%s$desc&quot;</span>, ($do_hidedesc ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;desc=&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">elsif</span>($do_no_attributes) &#123; </span><br><span class="line">        $attributes = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">elsif</span>($do_de_attributes) &#123; </span><br><span class="line">        $attributes = $desc;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">defined</span> $extra) &#123; </span><br><span class="line">        <span class="keyword">if</span>($attributes eq <span class="string">&quot;-&quot;</span>)       &#123; $attributes = <span class="string">&quot;&quot;</span>; &#125;</span><br><span class="line">        <span class="keyword">elsif</span>($attributes !~ <span class="regexp">m/\;$/</span>) &#123; $attributes .= <span class="string">&quot;;&quot;</span>; &#125;</span><br><span class="line">        $attributes .= $extra . <span class="string">&quot;;&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">printf</span>(<span class="string">&quot;%s\t%s\t%s\t%d\t%d\t%.1f\t%s\t%s\t%s\n&quot;</span>, </span><br><span class="line">             $seqname,                             <span class="comment"># token 1: &#x27;sequence&#x27; (sequence name)</span></span><br><span class="line">             $source,                              <span class="comment"># token 2: &#x27;source&#x27;</span></span><br><span class="line">             $mdlname,                             <span class="comment"># token 3: &#x27;feature&#x27; (model name) you may want to change this to &#x27;ncRNA&#x27;</span></span><br><span class="line">             ($strand eq <span class="string">&quot;+&quot;</span>) ? $seqfrom : $seqto, <span class="comment"># token 4: &#x27;start&#x27; in coordinate space [1..seqlen], must be &lt;= &#x27;end&#x27;</span></span><br><span class="line">             ($strand eq <span class="string">&quot;+&quot;</span>) ? $seqto : $seqfrom, <span class="comment"># token 5: &#x27;end&#x27; in coordinate space [1..seqlen], must be &gt;= &#x27;start&#x27;</span></span><br><span class="line">             $score,                               <span class="comment"># token 6: &#x27;score&#x27; bit score</span></span><br><span class="line">             $strand,                              <span class="comment"># token 7: &#x27;strand&#x27; (&#x27;+&#x27; or &#x27;-&#x27;)</span></span><br><span class="line">             <span class="string">&quot;.&quot;</span>,                                  <span class="comment"># token 8: &#x27;phase&#x27; irrelevant for noncoding RNAs</span></span><br><span class="line">             $attributes);                         <span class="comment"># token 9: attributes, currently only E-value, unless --all, --none or --desc</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>运行<br><code>perl infernal-tblout2gff.pl --cmscan --fmt2 genome.tblout &gt;genome.infernal.ncRNA.gff3</code></li>
</ol>
<p>输入是Infernal的table格式输出文件，输出是gff3格式的ncRNA注释文件。</p>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>programming</category>
        <category>scripts</category>
      </categories>
      <tags>
        <tag>biosoft</tag>
        <tag>scripts</tag>
        <tag>batch_run.sh</tag>
        <tag>ROUSFinder2.0.py</tag>
        <tag>extract_intron_info.pl</tag>
        <tag>multi-transcriptome_assembly_with_ref.sh</tag>
        <tag>extract_single_copy_genes.sh</tag>
      </tags>
  </entry>
  <entry>
    <title>香港市花是什么，紫荆花？洋紫荆？羊蹄甲？</title>
    <url>/2021/03/27/taxon_Bauhinia/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=1959134563&auto=1&height=32"></iframe></div>

<p>（全文约2000字）</p>
<h1 id="1-香港市花"><a href="#1-香港市花" class="headerlink" title="1. 香港市花"></a>1. 香港市花</h1><h2 id="1-1-香港市花的前世今生"><a href="#1-1-香港市花的前世今生" class="headerlink" title="1.1. 香港市花的前世今生"></a>1.1. 香港市花的前世今生</h2><h3 id="1-1-1-前世"><a href="#1-1-1-前世" class="headerlink" title="1.1.1. 前世"></a>1.1.1. 前世</h3><p><strong>香港市花</strong> —— 红花羊蹄甲的故事要从1880年说起，一位来自法国巴黎的传教士在香港偶然发现了这种植物，并以插枝栽种在薄扶林道一带的伯大尼修道院。由于红花羊蹄甲无法产生有繁殖力的后代，所以今天见到的所有红花羊蹄甲都来自这个传教士栽种的0号个体。</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e7/Bauhinia_2.jpg/240px-Bauhinia_2.jpg" width=100% title="红花羊蹄甲" alt="红花羊蹄甲" align=center/>

<p><strong><p align="center">Figure 1. 红花羊蹄甲 图片来源：wiki</p></strong></p>
<p>18年后，香港的植物及林务部主管Stephen Troyte Dunn第一次对红花羊蹄甲进行科学的描述，将其定为羊蹄甲属的新物种，并发表在科学期刊《Journal of Botany》上。</p>
<p>Dunn用前任香港英国总督的名字给这个新种命名为“<strong>Sir Henry and Lady Blake</strong>”，用这种方式感谢夫妇俩对香港植物园的支持。历史上类似的故事很多，伽利略发现的木卫也是通过命名致敬了他的赞助人科西莫二世Medici。科学家们这么做可以获得持续的资助，促进科学的长足发展。</p>
<h3 id="1-1-2-今生"><a href="#1-1-2-今生" class="headerlink" title="1.1.2. 今生"></a>1.1.2. 今生</h3><p>由于红花羊蹄甲花色鲜艳，花期几乎持续全年，扦插成活率高，很快就成了遍布香港的行道树。在1997年，正式把红花羊蹄甲定为香港市花，出现在区旗、区徽和硬币上，成为香港的标志。也就是我们耳熟能详的<strong>洋紫荆</strong>，或者避免使用<strong>洋</strong>而叫<strong>紫荆花</strong>。</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5b/Flag_of_Hong_Kong.svg/240px-Flag_of_Hong_Kong.svg.png" width=90% title="香港区旗" alt="香港区旗" align=center/>

<p><strong><p align="center">Figure 2. 香港区旗 图片来源：wiki</p></strong></p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/90/Regional_Emblem_of_Hong_Kong.svg/240px-Regional_Emblem_of_Hong_Kong.svg.png" width=80% title="香港区徽" alt="香港区徽" align=center/>

<p><strong><p align="center">Figure 3. 香港区徽 图片来源：wiki</p></strong></p>
<h2 id="1-2-科学性"><a href="#1-2-科学性" class="headerlink" title="1.2. 科学性"></a>1.2. 科学性</h2><p>但是，从植物科学的角度，紫荆指的是豆科的另一个属紫荆属的植物<em>Cercis chinensis</em>；香港市花却是羊蹄甲属的植物。</p>
<p>真正的紫荆长这样</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/CercisChinensisShrub2.jpg/440px-CercisChinensisShrub2.jpg" width=80% title="紫荆" alt="紫荆" align=center/>

<p><strong><p align="center">Figure 4. 紫荆 图片来源：wiki</p></strong></p>
<p>红花羊蹄甲的学名是<em>Bauhinia purpurea</em> x <em>variegata</em> ‘<em>Blakeana</em>‘, cv. nov.，从学名中的x我们就可以看出这个种是羊蹄甲（<em>B. purpurea</em>）和洋紫荆（<em>B. variegata</em>）杂交形成的。</p>
<p>下面我们就来介绍一下红花羊蹄甲及两个亲本，以及怎么区分这三个种。</p>
<h1 id="2-羊蹄甲属"><a href="#2-羊蹄甲属" class="headerlink" title="2. 羊蹄甲属"></a>2. 羊蹄甲属</h1><p>羊蹄甲属（<em>Bauhinia</em>）的羊蹄甲（<em>B. purpurea</em>）、洋紫荆（<em>B. variegata</em>）和红花羊蹄甲（<em>B.</em> x <em>blakeana</em>）是华南地区三种园林植物，常植为行道树，在广州尤为普遍，常常能够同时看见这三种植物。</p>
<p>但由于这三个种是关系很近的一家人，所以常常被人混作一种。接下来我们就来看看到底怎么区分这三个种。</p>
<p>接下来，干得不能再干的知识点来啦！！！</p>
<h2 id="2-1-羊蹄甲属常见三种类群的分类特征"><a href="#2-1-羊蹄甲属常见三种类群的分类特征" class="headerlink" title="2.1. 羊蹄甲属常见三种类群的分类特征"></a>2.1. 羊蹄甲属常见三种类群的分类特征</h2><table>
<thead>
<tr>
<th>羊蹄甲属（<em>Bauhinia</em>）学名</th>
<th><em>B. purpurea</em></th>
<th><em>B. variegata</em></th>
<th><em>B. variegata</em> var. <em>candida</em></th>
<th><em>Bauhinia purpurea</em> x <em>variegata</em> ‘<em>Blakeana</em>‘, cv. nov.</th>
</tr>
</thead>
<tbody><tr>
<td>中文正名&#x2F;中国大陆常用俗名</td>
<td>羊蹄甲</td>
<td>洋紫荆</td>
<td>白花洋紫荆</td>
<td>红花羊蹄甲</td>
</tr>
<tr>
<td>香港常用俗名</td>
<td>红花羊蹄甲</td>
<td>宫粉羊蹄甲</td>
<td>白花羊蹄甲</td>
<td>洋紫荆</td>
</tr>
<tr>
<td>台湾常用俗名</td>
<td>洋紫荆</td>
<td>羊蹄甲</td>
<td>–</td>
<td>艶&#x2F;豔&#x2F;艳（yan4）紫荆</td>
</tr>
<tr>
<td>主要区别</td>
<td>能育雄蕊3，退化雄蕊5-6，花瓣较狭窄，具长柄</td>
<td>能育雄蕊5，无退化雄蕊，落叶后盛花，花色粉红，总状花序极短缩，正常结果</td>
<td>洋紫荆的白花变种，花白色</td>
<td>雄蕊5，花叶同期，花色紫红，总状花序开展，不结果</td>
</tr>
<tr>
<td>雄蕊</td>
<td>能育雄蕊3，退化雄蕊5-6</td>
<td>能育雄蕊5(7)，无退化雄蕊</td>
<td>同洋紫荆</td>
<td>雄蕊5(7)，退化雄蕊2-5</td>
</tr>
<tr>
<td>花期</td>
<td>花期9-11月</td>
<td>花期1-4月（3月盛花期）</td>
<td>同洋紫荆</td>
<td>花期全年（3-4月盛花期）</td>
</tr>
<tr>
<td>花色</td>
<td>花色桃红，中国发现一棵白花</td>
<td>花色粉红到淡紫，有白花、黄花变种</td>
<td>花白色</td>
<td>花色紫红</td>
</tr>
<tr>
<td>花着生</td>
<td>集中顶生</td>
<td>分散腋生</td>
<td>同洋紫荆</td>
<td>集中顶生</td>
</tr>
<tr>
<td>花瓣形态</td>
<td>窄而相互分离</td>
<td>宽而相互重叠</td>
<td>同洋紫荆</td>
<td>稍宽而分离</td>
</tr>
<tr>
<td>物候</td>
<td></td>
<td>落叶后盛花</td>
<td>同洋紫荆</td>
<td>花叶同期</td>
</tr>
<tr>
<td>其他</td>
<td>树皮、花和根可药用外用，根皮剧毒</td>
<td>花芽、嫩叶和幼果可食</td>
<td>同洋紫荆，云南有白花变种的花瓣食用史</td>
<td>香港市花，红花羊蹄甲是羊蹄甲和洋紫荆杂交起源的杂交种，不结果。</td>
</tr>
</tbody></table>
<p>由于这三个物种在两岸三地都有栽培，如果同时和台湾人香港人讨论，一定很有趣。</p>
<ul>
<li>羊蹄甲&#x3D;台湾的洋紫荆</li>
<li>洋紫荆&#x3D;台湾的羊蹄甲</li>
<li>红花羊蹄甲&#x3D;香港的洋紫荆</li>
<li>台湾的洋紫荆&#x3D;香港的红花羊蹄甲</li>
</ul>
<p>你<del>记住</del>记晕了吗？</p>
<h2 id="2-2-简单来说，三个物种可以这样来分"><a href="#2-2-简单来说，三个物种可以这样来分" class="headerlink" title="2.2. 简单来说，三个物种可以这样来分"></a>2.2. 简单来说，三个物种可以这样来分</h2><ol>
<li>如果看到全树的粉花，几乎没有叶子，花瓣有点宽，那就是洋紫荆（<em>B. variegata</em>），开白花的大概率也是这个物种的白花变种——白花洋紫荆。</li>
</ol>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/23/Bauhinia_variegata_flower.jpg/440px-Bauhinia_variegata_flower.jpg" width=100% title="洋紫荆" alt="洋紫荆" align=center/>

<p><strong><p align="center">Figure 5. 洋紫荆 图片来源：wiki</p></strong></p>
<ol start="2">
<li>如果看到花色紫红，花瓣窄窄的，花和叶同时在树上，不结果，全年持续开花的，大概率是红花羊蹄甲（<em>B.</em> x <em>blakeana</em>）。</li>
</ol>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Bauhinia_blakeana_%28Key_West%29.jpg/440px-Bauhinia_blakeana_%28Key_West%29.jpg" width=100% title="红花羊蹄甲" alt="红花羊蹄甲" align=center/>

<p><strong><p align="center">Figure 6. 红花羊蹄甲 图片来源：wiki</p></strong></p>
<ol start="3">
<li>如果在别的羊蹄甲都在开花的时候结了一树果，像挂了一树豆角一样，就是羊蹄甲（<em>B. purpurea</em>）。</li>
</ol>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/Phanera_purpurea_tree_with_fruits_%28Philippines%29.jpg/440px-Phanera_purpurea_tree_with_fruits_%28Philippines%29.jpg" width=100% title="羊蹄甲" alt="羊蹄甲" align=center/>

<p><strong><p align="center">Figure 7. 羊蹄甲 图片来源：wiki</p></strong></p>
<h2 id="2-3-课后习题"><a href="#2-3-课后习题" class="headerlink" title="2.3. 课后习题"></a>2.3. 课后习题</h2><p>紫荆，洋紫荆，羊蹄甲，红花羊蹄甲这四个里面到底哪个是香港市花？</p>
<h1 id="3-reference"><a href="#3-reference" class="headerlink" title="3. reference"></a>3. reference</h1><ol>
<li>wiki: Bauhinia：<a href="https://zh.wikipedia.org/wiki/%E7%BE%8A%E8%B9%84%E7%94%B2%E5%B1%9E#%E5%90%8D%E7%A8%B1%E6%B7%B7%E6%B7%86">https://zh.wikipedia.org/wiki/%E7%BE%8A%E8%B9%84%E7%94%B2%E5%B1%9E#%E5%90%8D%E7%A8%B1%E6%B7%B7%E6%B7%86</a></li>
<li>paper: Hybrid origin of Bauhinia blakeana：<a href="https://bsapubs.onlinelibrary.wiley.com/doi/full/10.3732/ajb.92.3.525">https://bsapubs.onlinelibrary.wiley.com/doi/full/10.3732/ajb.92.3.525</a></li>
<li>Bauhinia purpuprea: 羊蹄甲：<a href="http://www.iplant.cn/info/Bauhinia%20purpurea?t=z">http://www.iplant.cn/info/Bauhinia%20purpurea?t=z</a></li>
<li>Bauhinia variegata： 洋紫荆：<a href="http://www.iplant.cn/info/Bauhinia%20variegata?t=z">http://www.iplant.cn/info/Bauhinia%20variegata?t=z</a></li>
<li>Bauhinia × blakeana: 红花羊蹄甲：<a href="http://www.iplant.cn/info/Bauhinia%20%C3%97%20blakeana">http://www.iplant.cn/info/Bauhinia%20%C3%97%20blakeana</a></li>
<li>《羊蹄甲属植物资源培育与利用》魏丹著 2021年12月</li>
</ol>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>bio</category>
        <category>taxon</category>
      </categories>
      <tags>
        <tag>Bauhinia</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2018/06/04/web_CSS/</url>
    <content><![CDATA[<h1 id="1-CSS基础知识"><a href="#1-CSS基础知识" class="headerlink" title="1. CSS基础知识"></a>1. CSS基础知识</h1><h2 id="1-1-动画的CSS实现"><a href="#1-1-动画的CSS实现" class="headerlink" title="1.1. 动画的CSS实现"></a>1.1. 动画的CSS实现</h2><ol>
<li><p>transform</p>
<p>用于元素的2D或3D变化，默认值为none，有六种种变化方式。</p>
<ul>
<li>translate(x,y)、translate3d(x,y,z)位移变化，分别为2d和3d变化方式，衍生出translateX(x)、translateY(y)、translateZ(Z)</li>
<li>scale(x,y)、scale3d(x,y,z)缩放变化，同样衍生三轴的单独变化方式。</li>
<li>rotate(angle)、rotate3d(x,y,z,angle)旋转变化，同样衍生三轴的单独变化方式。rotate旋转中心点默认是元素中心，可以通过设置<code>tranform-origin：x-axis y-axis z-axis</code>来改变旋转中心点的位置。</li>
<li>skew(x-angle,y-angle)沿着x和y轴的2d倾斜变化，衍生两轴单独变化方式。</li>
<li>matrix(n,n,n,n,n,n)、matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)分别定义2d和3d转换，使用6个值或16个值（4*4）的矩阵。</li>
<li>perspective(n)为3d元素定义透视视图。</li>
</ul>
<p><code>transform-style:flat(default)/preserve-3d</code>指定嵌套元素怎样在三维空间呈现，flat表示所有子元素在2d平面呈现，preserve-3d表示所有子元素在3d空间呈现。</p>
</li>
<li><p>transition</p>
<p><code>transition</code>是<code>transition-property</code>、<code>transition-duration</code>、<code>transition-timing-function</code>和<code>transition-delay</code>四个属性的简写，默认值<code>all 0 ease 0</code>，是指定元素属性发生渐变的一种效果，一定要事件触发。</p>
<ul>
<li><code>transition-property:width</code>指定需要渐变变化的css属性，比如宽度的渐变。</li>
<li><code>transition-duration:xs</code>指定渐变效果的时长为x秒，必须指定，否则为0，等同于没有渐变效果。</li>
<li><code>transition-timing-function</code>指定transition效果的转速曲线，可取以下值：<br>* linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。<br>* ease 规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。<br>* ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。<br>* ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。<br>* ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。<br>* cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</li>
<li><code>transition-delay:xs</code>指定transition效果需要等待x秒才开始。</li>
</ul>
</li>
<li><p>animation</p>
<p>通过@keyframes定义动画的每一帧，然后使用animation属性调用动画，animation默认值是<code>none 0 ease 0 1 normal</code>，是多个属性的简写，属性依次如下：</p>
<ul>
<li><code>animation-name</code>在@keyframes中定义的动画名。</li>
<li><code>animation-duration</code>指定动画的时长。</li>
<li><code>animation-timing-function</code>指定动画的转速曲线，同<code>transition</code>。</li>
<li><code>animation-delay</code>指定动画在启动前的延迟间隔，可为负值，负值时直接跳过动画的制定时间开始播放。</li>
<li><code>animation-iteration-count</code>指定动画播放次数，值为<code>infinite</code>时无限多次播放。</li>
<li><code>animation-direction</code>指定是否轮流反向播放动画。</li>
<li><code>animation-fill-mode</code>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。</li>
<li><code>animation-play-state</code>指定动画是否正在运行或已暂停。</li>
</ul>
</li>
</ol>
<p><strong>@keyframes语法</strong></p>
<p>@keyframes myanimation{}</p>
<ol>
<li>tips</li>
</ol>
<p>配合hover等事件来实现动画效果。</p>
<h3 id="1-1-1-几个要点"><a href="#1-1-1-几个要点" class="headerlink" title="1.1.1. 几个要点"></a>1.1.1. 几个要点</h3><ol>
<li>class属性</li>
</ol>
<ul>
<li>元素在设置样式时，首先考虑是否有多个相同元素具有同一样式和是否复用的问题，如果单个元素使用的样式或者不会复用，则优先使用内联样式，在html中就实现。</li>
<li>如果需要在css文件中实现的样式，则尽量使用class属性，使得具有同样样式的元素使用同一class属性，减少css的冗余。</li>
<li>对class属性的命明尽量语意化。</li>
</ul>
<ol start="2">
<li>初始化</li>
</ol>
<ul>
<li>使用<strong>reset.css</strong>或者<strong>normalize.css</strong>来初始化，使得css设置更轻松。或者在css文档开头，简单地用<code>*&#123;margin:0;padding:0&#125;</code>来初始化所有元素的边距，因为某些元素（例如h）自带一些边距。</li>
<li>使用<strong>felxible.js</strong>来在css中可以使用<strong>rem</strong>（为显示设备宽度的十分之一）来作为长度单位，更多地应用在移动端。</li>
</ul>
<ol start="3">
<li>border-width</li>
</ol>
<p>参考<a href="https://www.jianshu.com/p/63fdbd7fdc9b">简书</a>的这个总结和<a href="https://www.imooc.com/video/6858">慕课网</a>的这个使用border-width制作折角效果的视频。border-width实现三角形等图形很方便。</p>
<p>当content区为空（width和height都为0）时，四个方向的border分别为三角形，当四个方向的border-width都不为0时，组成一个矩形。</p>
<p>没有定义基本border时，未被定义的边那个方向的矩形的一半不会显示，并影响相邻边的显示。所以，若只定义了对边的边框，则相当于四个边框都未被定义。<br>当定义了基本border，即使是白色或透明，在此基础上再定义边框时，则会安装定义的边框的三角形的组合来显示。</p>
<h2 id="1-2-问题笔记"><a href="#1-2-问题笔记" class="headerlink" title="1.2. 问题笔记"></a>1.2. 问题笔记</h2><ol>
<li>任意数量图片从左到右按顺序排列，每行预期排五个，图片间有相同间距的样式的实现。<br>Q:解决分散排列，并适用于不同数量图片的问题。<br>如果直接定义父容器的<code>display:flex</code>和<code>justify-content:space-between</code>可以实现图片分散排列，但是当图片数量不是5时（比如为3时），也会展示分散排列的效果，而非占据左边2&#x2F;5的位置。<br>A：定义父容器的<code>display:flex</code>和子元素图片<code>width:20%</code>即可实现。<br>Q:解决图片排列紧凑的问题。<br>A:定义子元素图片<code>box-sizing:border-box;padding:1%;</code>来实现图片间隙。</li>
<li>实现任意元素单行排列，不换行，超出省略并显示省略号。<br>Q：强制不换行<br>A：<code>white-space:nowrap;</code><br>Q:超出省略<br>A：<code>overflow: hidden;</code><br>Q：超出显示省略号<br>A：<code>text-overflow: ellipsis;</code></li>
</ol>
<h2 id="1-3-tips"><a href="#1-3-tips" class="headerlink" title="1.3. tips"></a>1.3. tips</h2><ul>
<li>公司项目少有使用<strong>响应式</strong>CSS，而是移动端和web端各一套CSS，以使得网页在不同设备的展示更和谐，主要是长度设置、移动端键盘弹出遮盖内容区、移动端触摸屏更多操作等问题。</li>
<li>尽量不要设定元素的<code>height</code>，使其保持auto。</li>
<li>一些icon、line和矩形可以使用<code>div</code>或者<code>:before :after</code>来实现。</li>
<li>使用<code>border-randius</code>属性来控制矩形或者圆形。</li>
<li><code>white-space</code>属性指定元素内的空白怎么处理，文本元素取值<code>nowrap</code>时，文本强制不换行，直到遇到<br>元素。</li>
<li>使用图片作为背景时，一般设置<code>background-position:center</code>来使图片居中展示，当图片与背景尺寸不匹配时，图片仍然居中。</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>参考文献管理软件EndNote的中英文混排技巧</title>
    <url>/2023/05/11/tools_academia_EndNote/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=399341112&auto=1&height=32"></iframe></div>

<h1 id="1-EndNote的中英文混排"><a href="#1-EndNote的中英文混排" class="headerlink" title="1. EndNote的中英文混排"></a>1. EndNote的中英文混排</h1><h2 id="1-1-添加EndNote的【中文文献】类型"><a href="#1-1-添加EndNote的【中文文献】类型" class="headerlink" title="1.1. 添加EndNote的【中文文献】类型"></a>1.1. 添加EndNote的【中文文献】类型</h2><ul>
<li>在EndNote中选择【Edit】-【References】，找到【Reference Types】选项；</li>
<li>【Default Reference Type】选择【unused】1&#x2F;2&#x2F;3中的任意一个之前未被修改过的，然后选择【Modify Reference Types】；</li>
<li>在弹出的【Modify Reference Types】对话框中按照下面的图片输入每项内容。包括【Generic】命名为【中文文献】，【Author】填入【Author】，【Year】填入【Year】，【Title】填入【Title】，【Secondary Author】填入【Secondary Author】，【Secondary Title】要填入【Journal】，【Volume】填入【Volume】，【Number of Volumes】填入【Issue】，【Pages】填入【Pages】，其他都一致，点击【OK】后就添加了【中文文献】的参考文献类型。</li>
</ul>
<img src="https://pic3.zhimg.com/v2-b2557ffb99bf0743123d02ca539185ca_r.jpg" title="Modify Reference Types" width="60%"/>

<p><strong><p align="center">图 1. Modify Reference Types 对话框 图源：<a href="https://zhuanlan.zhihu.com/p/312093759">https://zhuanlan.zhihu.com/p/312093759</a></p></strong></p>
<h2 id="1-2-EndNote的文献目录-Bibliography-的中英文混排"><a href="#1-2-EndNote的文献目录-Bibliography-的中英文混排" class="headerlink" title="1.2. EndNote的文献目录(Bibliography)的中英文混排"></a>1.2. EndNote的文献目录(Bibliography)的中英文混排</h2><h3 id="1-2-1-文献目录-Bibliography-的中英文顺序"><a href="#1-2-1-文献目录-Bibliography-的中英文顺序" class="headerlink" title="1.2.1. 文献目录(Bibliography)的中英文顺序"></a>1.2.1. 文献目录(Bibliography)的中英文顺序</h3><ul>
<li>在EndNote中选择【Edit】-【Output Styles】-【Edit **】，选择需要编辑的参考文献Styles；</li>
<li>在【Bibliography】- 【Sort Order】中选择文献目录(Bibliography)的显示排序规则；</li>
<li>需要英文在前，中文在后的，则选择【Other…】，然后依次选择排序标准，推荐选择【Language】+【Author】+【Title】，然后保存设置。</li>
<li>注意每一条参考文献的【Language】字段，中文可以设置成【Chinese】，英文设置成【English】或不设置。</li>
</ul>
<h3 id="1-2-2-文献目录-Bibliography-的作者的et-al-和-等-混排"><a href="#1-2-2-文献目录-Bibliography-的作者的et-al-和-等-混排" class="headerlink" title="1.2.2. 文献目录(Bibliography)的作者的et al. 和**等.**混排"></a>1.2.2. 文献目录(Bibliography)的作者的<strong>et al.</strong> 和**等.**混排</h3><ul>
<li>基于已添加【中文文献】类型下操作；</li>
<li>在EndNote中选择【Edit】-【Output Styles】-【Edit **】，选择需要编辑的参考文献Styles；</li>
<li>在【Bibliography】-【Templates】的【Reference Type】中添加【中文文献】的类型；</li>
</ul>
<img src="https://pic1.zhimg.com/v2-0ac5695cfe8180233993929c00c15bec_r.jpg" title="在Templates中添加中文文献类型" width="90%"/>

<p><strong><p align="center">图 2. 在Templates中添加中文文献类型 图源：<a href="https://zhuanlan.zhihu.com/p/312093759">https://zhuanlan.zhihu.com/p/312093759</a></p></strong></p>
<ul>
<li>将【Journal Article】里的参考格式复制到【中文文献】里，再在Author前面加上Secondary，注意Secondary和Author之间打一个空格，显示为一个点.。</li>
</ul>
<img src="https://pic4.zhimg.com/v2-2415ffab7677257fc3e16474c89a6c27_r.jpg" title="在Templates中添加中文文献类型2" width="90%"/>

<p><strong><p align="center">图 3. 在Templates中添加中文文献类型2 图源：<a href="https://zhuanlan.zhihu.com/p/312093759">https://zhuanlan.zhihu.com/p/312093759</a></p></strong> </p>
<ul>
<li>在【Bibliography】-【Author List】中，对于显示作者人数进行设置，多作者的缩写默认为【，et al.】，这里代表英文文献多作者在文献目录(Bibliography)中的显示规则；</li>
<li>在【Bibliography】-【Editor List】中，对于显示作者人数进行设置，多作者的缩写改为【，等.】，这里代表中文文献多作者在文献目录(Bibliography)中的显示规则；</li>
</ul>
<img src="https://pic2.zhimg.com/v2-cb026088966e21676868136d33f7e051_r.jpg" title="修改中文文献的多作者显示" width="90%"/>

<p><strong><p align="center">图 4. 修改中文文献的多作者显示 图源：<a href="https://zhuanlan.zhihu.com/p/312093759">https://zhuanlan.zhihu.com/p/312093759</a></p></strong> </p>
<ul>
<li>EndNote导入的中文文献可选择【中文文献】这种类型，然后把【Author】这项内容复制到【Secondary Author】，这样就会遵循【中文文献】的引用的显示规则。</li>
</ul>
<p>ref：<a href="https://zhuanlan.zhihu.com/p/312093759">https://zhuanlan.zhihu.com/p/312093759</a></p>
<h2 id="1-3-EndNote的正文引用的中英文混排"><a href="#1-3-EndNote的正文引用的中英文混排" class="headerlink" title="1.3. EndNote的正文引用的中英文混排"></a>1.3. EndNote的正文引用的中英文混排</h2><h3 id="1-3-1-作者的et-al-和-等-混排"><a href="#1-3-1-作者的et-al-和-等-混排" class="headerlink" title="1.3.1. 作者的et al. 和**等.**混排"></a>1.3.1. 作者的<strong>et al.</strong> 和**等.**混排</h3><ol>
<li>手动修改中文文献的<strong>et al.<strong>成</strong>等.</strong></li>
</ol>
<ul>
<li>在Word正文的EndNote引用文献(张三 et al. 2023)中右键，选择【edit citations】-【more】；</li>
<li>然后在【Edit &amp; Manage Citations】对话框中把这一条参考文献的【Formatting】从【Default】改成【Exclude Author】，这样正文会不显示作者；</li>
<li>继续在【Prefix】中手动添加前缀，这里填写【张三等，】，则正文会显示(张三等，2023);</li>
<li>依次修改正文中每一条参考文献。</li>
</ul>
<p>ref：<a href="https://www.baishujun.com/archives/7634.html">https://www.baishujun.com/archives/7634.html</a></p>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>
]]></content>
      <categories>
        <category>tools</category>
        <category>academia</category>
        <category>EndNote</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>EndNote</tag>
        <tag>中英文混排</tag>
      </tags>
  </entry>
  <entry>
    <title>录屏软件</title>
    <url>/2022/09/22/tools_screen.recorder/</url>
    <content><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=298 height=52 src="//music.163.com/outchain/player?type=2&id=105136&auto=1&height=32"></iframe></div>

<h1 id="1-录屏软件"><a href="#1-录屏软件" class="headerlink" title="1. 录屏软件"></a>1. 录屏软件</h1><p>尝试了多种录屏方式，也遇到一些问题。记录下来，供参考。</p>
<p>如果在window上简单录制，则优先window+G使用xbox即可。如果是需要录课程等非游戏视频，推荐开源免费的OBS Studio，类似的还有Captura。</p>
<h1 id="2-Xbox"><a href="#2-Xbox" class="headerlink" title="2. Xbox"></a>2. Xbox</h1><p>Xbox是window10自带的录制游戏的软件，不需下载。</p>
<p>Xbox只能录制应用程序，不能录制桌面。</p>
<h2 id="2-1-Xbox使用"><a href="#2-1-Xbox使用" class="headerlink" title="2.1. Xbox使用"></a>2.1. Xbox使用</h2><ol>
<li>window+G调出Xbox录屏界面</li>
<li>点击屏幕上方的“捕获”调出捕获小组件</li>
<li>建议点击调出来的捕获小组件右上角的小图钉，在桌面固定捕获小组件</li>
<li>简单地点击“录制”和“停止录制”开关按钮即可开始或停止录制</li>
</ol>
<h2 id="2-2-Xbox设置"><a href="#2-2-Xbox设置" class="headerlink" title="2.2. Xbox设置"></a>2.2. Xbox设置</h2><ol>
<li>把需要录制的软件选为游戏。这是为了避免录制时其他软件的干扰。</li>
</ol>
<ul>
<li>window+G调出Xbox界面</li>
<li>点击屏幕上方的“设置”调出设置窗口</li>
<li>在弹出的窗口选择“常规”</li>
<li>有一个选项：“记住这是一款游戏”，下面会实时显示在最上层的软件，把需要录制的软件放在最上层，选中“记住这是一款游戏”。</li>
</ul>
<ol start="2">
<li>后台录制。这是为了避免录制时其他软件的干扰。</li>
</ol>
<ul>
<li>“设置”界面选择“正在捕获”</li>
<li>在“正在录制”的下面选择“当我玩游戏时进行后台录制”</li>
</ul>
<ol start="3">
<li>音频选择</li>
</ol>
<ul>
<li>在“正在捕获”界面的“要录制的音频”下选择录制那些音频：游戏、所有、无。</li>
<li>我选择的是“所有”，包括游戏和已启用麦克风，系统和其他应用程序。</li>
</ul>
<ol start="4">
<li>麦克风</li>
</ol>
<ul>
<li>在右上角的“查看我的捕获”界面，有个麦克风开关。可以根据需要选择，如果录课则关闭，需要录自己声音则打开。</li>
</ul>
<h1 id="3-OBS-Studio"><a href="#3-OBS-Studio" class="headerlink" title="3. OBS Studio"></a>3. OBS Studio</h1><h2 id="3-1-OBS-Studio简介"><a href="#3-1-OBS-Studio简介" class="headerlink" title="3.1. OBS Studio简介"></a>3.1. OBS Studio简介</h2><p>OBS Studio是开源软件，完全免费，适用windows，macOS和Liunx系统，可用于视频录制和推流。</p>
<p>OBS Studio主页：<a href="https://obsproject.com/">https://obsproject.com/</a></p>
<h2 id="3-2-OBS-Studio使用"><a href="#3-2-OBS-Studio使用" class="headerlink" title="3.2. OBS Studio使用"></a>3.2. OBS Studio使用</h2><p>以录制腾讯会议为例</p>
<ol>
<li>打开软件</li>
<li>在“来源”中添加需要录制的源</li>
</ol>
<ul>
<li>点击“+”号，有非常多种来源可选择：包括“窗口采集”，“显示器采集”，“浏览器”，“游戏源”，“媒体源”等等。</li>
<li>这里录制腾讯会议，选择“窗口采集”</li>
<li>弹出创建源窗口：命名来源，点击确定</li>
<li>弹出属性窗口：在“窗口”中选择“腾讯会议”，“显示鼠标指针”可以根据需要选择，点击确定。</li>
</ul>
<ol start="3">
<li>使源窗口全屏</li>
</ol>
<ul>
<li>添加的源未必刚好覆盖录制的全屏，如果这样开始录制，视频会包含大量的黑框部分。</li>
<li>可以直接拉伸添加的源外面的红框，使其覆盖全屏录制区域。</li>
<li>也可以简单地在“编辑”-“变换”中选择“比例适配屏幕”来最大化源窗口使其适配录制屏幕【推荐】，或者选择“拉伸到全屏”来调整源窗口比例，从而实现完全全屏。</li>
</ul>
<ol start="4">
<li>录制</li>
</ol>
<ul>
<li>在“来源”中出现新建的源，选中这个源，右边的“控件”中使用“开始录制”即可开始，“停止录制”即停止。</li>
</ul>
<h2 id="3-3-OBS-Studio设置"><a href="#3-3-OBS-Studio设置" class="headerlink" title="3.3. OBS Studio设置"></a>3.3. OBS Studio设置</h2><h3 id="3-3-1-打开“暂停录制”功能"><a href="#3-3-1-打开“暂停录制”功能" class="headerlink" title="3.3.1. 打开“暂停录制”功能"></a>3.3.1. 打开“暂停录制”功能</h3><p>软件默认设置是不支持“暂停录制”，可通过修改设置来打开“暂停录制”的按钮。</p>
<ol>
<li>“文件”-“设置”，弹出设置窗口</li>
<li>“输出”，下面有显示“当录像质量设为与串流画质相同时，无法暂停录制”。所以需要把“录像”-“录像质量”中选择其他的，我这里选择“高质量”。</li>
<li>“输出”-“输出模式”中选择“高级”，然后选择“录像”，下面有显示“当录像编码器设为使用推流编码器时，无法暂停录制。”所以在“录制设置”-“编码器”中选择其他的，我这里选择“x264”。</li>
<li>应用和保存设置。</li>
<li>这时，如果点击“开始录制”，右边会出现一个暂停按钮，暂停功能就打开了。</li>
</ol>
<h3 id="3-3-2-输出设置"><a href="#3-3-2-输出设置" class="headerlink" title="3.3.2. 输出设置"></a>3.3.2. 输出设置</h3><ol>
<li>“文件”-“设置”，弹出设置窗口</li>
<li>“输出”-“录像”这里可以设置录像的质量，格式，编码器等。</li>
</ol>
<h1 id="4-Captura"><a href="#4-Captura" class="headerlink" title="4. Captura"></a>4. Captura</h1><p>Captura也是开源的录屏软件，网上看到很多推荐，界面简单。</p>
<p>Captura下载：<a href="https://mathewsachin.github.io/Captura/">https://mathewsachin.github.io/Captura/</a></p>
<p>但是我自己用下来遇到几个问题。</p>
<ol>
<li>首先FFmpeg解码器我用不了也无法自动下载，自己下载导入后也用不了，就没继续折腾了。</li>
<li>选择窗口录屏，这个窗口一定要一直保持在最上方，如果有其他软件覆盖，就会录到其他软件。</li>
<li>音频录制的选择，要不就没声音，要不就把麦克风录进去，反正没调对。</li>
</ol>
<p>应该是挺不错的软件，可能是和我电脑哪里不兼容，还是我没设置对，反正最后弃了。</p>
<hr>
<ul>
<li>欢迎关注微信公众号：<strong>生信技工</strong></li>
<li>公众号主要分享生信分析、生信软件、基因组学、转录组学、植物进化、生物学概念等相关内容，包括生物信息学工具的基本原理、操作步骤和学习心得。</li>
</ul>
<img src="https://github.com/yanzhongsino/yanzhongsino.github.io/blob/hexo/source/wechat/Wechat_public_qrcode.jpg?raw=true" width=50% title="wechat_public_QRcode.png" align=center/>]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>screen recorder</tag>
        <tag>video</tag>
        <tag>Xbox</tag>
        <tag>OBS Studio</tag>
        <tag>Captura</tag>
      </tags>
  </entry>
  <entry>
    <title>bootstrap</title>
    <url>/2018/06/11/web_bootstrap/</url>
    <content><![CDATA[<h1 id="1-bootstrap简介"><a href="#1-bootstrap简介" class="headerlink" title="1. bootstrap简介"></a>1. bootstrap简介</h1><p>bootstrap是一个用于快速开发web应用和网站的前端框架。<br>它能用于开发响应式布局、移动设备优先的web项目。</p>
<h1 id="2-bootstrap的安装"><a href="#2-bootstrap的安装" class="headerlink" title="2. bootstrap的安装"></a>2. bootstrap的安装</h1><p>需要在html的link标签引入bootstrap的css插件bootstrap.css，并在script标签中引用bootstrap的js插件bootstrap.js(bootstrap的js插件使用需要先引入jQuery)，有两种方式：</p>
<h4 id="2-0-0-1-通过CDN（内容分发网络）引用bootstrap，多个CDN可以使用。比如bootCDN。"><a href="#2-0-0-1-通过CDN（内容分发网络）引用bootstrap，多个CDN可以使用。比如bootCDN。" class="headerlink" title="2.0.0.1. 通过CDN（内容分发网络）引用bootstrap，多个CDN可以使用。比如bootCDN。"></a>2.0.0.1. 通过CDN（内容分发网络）引用bootstrap，多个CDN可以使用。比如<a href="http://www.bootcdn.cn/bootstrap/">bootCDN</a>。</h4><h4 id="2-0-0-2-在bootstrap中文网下载bootstrap，是一个文件夹，下有css、js、fonts三个目录。"><a href="#2-0-0-2-在bootstrap中文网下载bootstrap，是一个文件夹，下有css、js、fonts三个目录。" class="headerlink" title="2.0.0.2. 在bootstrap中文网下载bootstrap，是一个文件夹，下有css、js、fonts三个目录。"></a>2.0.0.2. 在<a href="http://v3.bootcss.com/">bootstrap中文网</a>下载bootstrap，是一个文件夹，下有css、js、fonts三个目录。</h4><p>在link标签中引入文件夹的css目录下的bootstrap.min.css文件</p>
<p><code>&lt;link href=&quot;css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;</code></p>
<p>在script标签中引用文件夹的js目录下的bootstrap.min.js文件(bootstrap的js插件使用需要先引入jQuery)</p>
<h1 id="3-bootstrap的css"><a href="#3-bootstrap的css" class="headerlink" title="3. bootstrap的css"></a>3. bootstrap的css</h1><ol>
<li><p>使用<code>&lt;img src=&quot;&quot; class=&quot;img-responsive&quot;&gt;</code>使图像对响应式布局更友好地支持。</p>
</li>
<li><p>Bootstrap 排版、链接样式设置了基本的全局样式。分别是：</p>
<ul>
<li>为 body 元素设置 <code>background-color: #fff</code>;</li>
<li>使用 <code>@font-family-base</code>、<code>@font-size-base</code> 和 <code>@line-height-base a</code>变量作为排版的基本参数</li>
<li>为所有链接设置了基本颜色 <code>@link-color</code> ，并且当链接处于 :hover 状态时才添加下划线</li>
<li>这些样式都能在 scaffolding.less 文件中找到对应的源码。</li>
</ul>
</li>
<li><p>使用<strong>normalize.css</strong>来建立跨浏览器的一致性。</p>
</li>
<li><p>.container 类用于固定宽度并支持响应式布局的容器。.container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title>flex</title>
    <url>/2018/06/12/web_flex/</url>
    <content><![CDATA[<h1 id="1-flex基础知识"><a href="#1-flex基础知识" class="headerlink" title="1. flex基础知识"></a>1. flex基础知识</h1><p>以下是学习<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">阮一峰老师教程</a>后的笔记。<br>传统布局解决方案基于<strong>盒模型</strong>，常使用<code>display</code>、<code>position</code>和<code>float</code>属性来实现，但对某些特殊布局非常不方便，比如垂直居中。<br>使用**<code>display:flex</code>**可以方便地实现多个元素的优雅排版，居中对齐也很方便。</p>
<h2 id="1-1-flex基本概念"><a href="#1-1-flex基本概念" class="headerlink" title="1.1. flex基本概念"></a>1.1. flex基本概念</h2><ol>
<li><p>任何元素都可以指定为flex布局。</p>
<ul>
<li>块级元素 <code>display:flex;</code></li>
<li>行内元素 <code>display:inline-flex;</code></li>
</ul>
<p><em>注意：设置flex布局后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性就会失效。</em></p>
</li>
<li><p>对元素采用flex布局后，此元素被称为<strong>flex容器</strong>，它的所有子元素成为容器成员，被称为<strong>flex项目</strong>。<br>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。<br>项目默认沿主轴排列。单个项目占据的主轴空间叫<code>main size</code>，占据的交叉轴空间叫<code>cross size</code>。</p>
</li>
</ol>
<h3 id="1-1-1-容器的属性"><a href="#1-1-1-容器的属性" class="headerlink" title="1.1.1. 容器的属性"></a>1.1.1. 容器的属性</h3><ol>
<li>flex-flow</li>
</ol>
<p><code>flex-flow</code>属性是<code>flex-direction</code>和<code>flex-wrap</code>两个属性的简写，默认值为<code>row nowrap</code>。</p>
<ul>
<li><p>flex-direction</p>
<p> <code>flex-direction</code>属性决定主轴的方向，它有四个可选的值。</p>
<ul>
<li>row（default）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
</li>
<li><p>flex-wrap</p>
<p> <code>flex-wrap</code>属性决定，如果一条轴线排不下所有项目的情况下如何换行，有三个可选的值。</p>
<ul>
<li>nowrap(default)：不换行。</li>
<li>wrap：换行，从<code>main start</code>方向往<code>main end</code>方向排列，第一行在<code>main start</code>方向（上方）。</li>
<li>wrap-reverse：换行，从<code>main end</code>方向往<code>main start</code>方向排列，第一行在<code>main end</code>方向（下方）。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>对齐方式</li>
</ol>
<ul>
<li><p>justify-content<br> <code>justify-centent</code>属性定义了项目在主轴上的对齐方式，与定义的主轴方向<code>flex-direction</code>有关，下面假设主轴从左到右，有四个可选的值。</p>
<ul>
<li>flex-start（default）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
</li>
<li><p>align-items<br> <code>align-items</code>属性定义了项目在交叉轴上的对齐方式，与定义的主轴方向<code>flex-direction</code>有关，下面假设交叉轴从上到下，有五个可选的值。</p>
<ul>
<li>stretch（default）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
</ul>
</li>
<li><p>align-content<br> <code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。有六个可选的值。</p>
<ul>
<li>stretch（default）：轴线占满整个交叉轴。</li>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
</ul>
</li>
</ul>
<h3 id="1-1-2-项目属性"><a href="#1-1-2-项目属性" class="headerlink" title="1.1.2. 项目属性"></a>1.1.2. 项目属性</h3><ol>
<li>order</li>
</ol>
<p><code>order</code>属性定义项目的排列顺序，数值越小，排列越靠前，默认为0。</p>
<ol start="2">
<li>align-self</li>
</ol>
<p><code>align-selff</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性，默认为auto，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。有六个可选的值，除了auto，其他都与align-items属性完全一致。</p>
<ul>
<li>auto(default)</li>
<li>flex-start</li>
<li>flex-end</li>
<li>center</li>
<li>baseline</li>
<li>stretch</li>
</ul>
<ol start="3">
<li>flex</li>
</ol>
<p><code>flex</code>属性是<code>flex-grow</code>、<code>flex-shrink</code>、<code>flex-basis</code>三个属性的简写，默认值为<code>0 1 auto</code>，后两个属性可选。<br>flex属性有两个快捷键：<code>auto(1 1 auto)</code>和<code>none(0 0 auto)</code>。</p>
<ul>
<li>flex-grow<br> <code>flex-grow</code>属性定义如果存在剩余空间，项目的放大比例，默认为0，即不放大。<br> 如果容器存在多余空间，多余空间分配给各个项目的比例按各个项目的flex-grow的值占容器内所有项目的flex-grow值的和的比例来确定。</li>
<li>flex-shrink<br> <code>flex-shrink</code>属性定义了如果容器空间不足，项目的缩小比例，默认为1，负值无效。<br> 如果容器的空间不足，需要缩小的空间会分配给各个项目，并按各个项目的flex-shrink值占容器内所有项目的flex-shrink值和的比例来确定。</li>
<li>flex-basis<br> <code>flex-basis</code>属性定义了在放大和缩小之前，项目占据的主轴空间（main size），值为长度值，默认值为<code>auto</code>，即项目本来大小。s</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6</title>
    <url>/2018/06/12/web_ES6/</url>
    <content><![CDATA[<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>const pi &#x3D; 3.1415926<br>常量是只读的，不可修改。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>ES6中有块级作用域<br>const、let，在每次循环内都有自己的闭包和作用域。<br>{}内就是块级作用域。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ol>
<li>语法：(参数)&#x3D;&gt;{函数体}<br>当只有一个参数时，可省略()；当函数体只有return something时，可以省略{}。eg：i&#x3D;&gt;i+1</li>
<li>箭头函数的this是定义该名称时this的指向</li>
</ol>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>function func(x&#x3D;1,y&#x3D;5,z&#x3D;20){<br>return x+y+z<br>}</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>不知数量参数的求和<br>function func(…a){<br>a.forEach(item&#x3D;&gt;{<br>sum+&#x3D;item*1<br>});<br>return sum<br>}</p>
<h3 id="利用扩展运算符合并数组"><a href="#利用扩展运算符合并数组" class="headerlink" title="利用扩展运算符合并数组"></a>利用扩展运算符合并数组</h3><p>var params &#x3D; [‘hello’,true,1,23]<br>var concatlist &#x3D; [1,2,’world’,…params]<br>相当于concatlist为[1,2,’world’,’hello’,true,1,23]</p>
<h2 id="对象代理"><a href="#对象代理" class="headerlink" title="对象代理"></a>对象代理</h2><p>私有属性<br>let Person &#x3D; {<br>name: ‘karen’,<br>sex: ‘female’,<br>age: 18<br>}</p>
<p>let person &#x3D; new Proxy(Person,{<br>get(target,key){<br>return target[key]<br>},<br>set(target,key,value){<br>if(key!&#x3D;&#x3D;’sex’){<br>target[key]&#x3D;value;<br>}<br>}<br>})<br>通过Proxy对象代理实现保护Person的sex属性，使其不能修改。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>html</title>
    <url>/2018/06/04/web_html/</url>
    <content><![CDATA[<h1 id="HTML基础知识"><a href="#HTML基础知识" class="headerlink" title="HTML基础知识"></a>HTML基础知识</h1><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>html lang&#x3D;”en”<br>!–设置语言–!<br>!–head部分开始–!<br>head eta charset&#x3D;”UTF-8”<br>!–设置编码方式–!<br>meta name&#x3D;”viewport” content&#x3D;”width&#x3D;device-width, initial-scale&#x3D;1.0”<br>!–设置网页内容宽度为显示设备的宽度，初始比例为1.0–!<br>meta http-equiv&#x3D;”X-UA-Compatible” content&#x3D;”ie&#x3D;edge”<br>!–兼容IE浏览器–<br>link rel&#x3D;”stylesheet” type&#x3D;”text&#x2F;css” href&#x3D;”reset.css”<br>!–链接重置样式的reset.css–!<br>link rel&#x3D;”stylesheet” type&#x3D;”text&#x2F;css” href&#x3D;”index.css”<br>!–链接应用于网页的样式–!<br>script src&#x3D;”index.js” &#x2F;script<br>!–链接应用于网页的js文件–!<br>titleDocument&#x2F;title<br>!–title会显示在浏览器的顶部标签页–!<br>&#x2F;head<br>!–head部分结束–!<br>body<br>!–网页的主体内容–!<br>&#x2F;body<br>&#x2F;html</p>
<h2 id="表单form"><a href="#表单form" class="headerlink" title="表单form"></a>表单form</h2><p>使用label来联系，</p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul>
<li>设置多个<code>&lt;input type=radio&gt;</code>时，需要把多个input的name设置成一样，才会实现在多个radio中单选的效果。</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>glup</title>
    <url>/2018/06/12/web_gulp/</url>
    <content><![CDATA[<h1 id="glup"><a href="#glup" class="headerlink" title="glup"></a>glup</h1><p>用来压缩打包html、css、img等。</p>
<p>gulp的工作方式是<strong>流（stream）</strong>，使用pipe作为传输管道。</p>
<p><strong>gulp的使用流程一般是</strong>：首先通过gulp.src()方法获取到想要处理的文件流，然后把文件流通过pipe方法导入到gulp的插件中，最后把经过插件处理后的流再通过pipe方法导入到gulp.dest()中，gulp.dest()方法则把流中的内容写入到文件中。</p>
<p>获取流<br>gulp.src(global[,options])</p>
<p>写文件<br>gulp.dest(path[,options])</p>
<p>监视文件<br>gulp.watch(global[,options],tasks)<br>或 gulp.watch(global[,options,cb])</p>
<p>定义任务<br>gulp.task(name[, deps], fn)<br>name为default的task会在执行gulp没有指定task的name时执行。</p>
<p>执行任务<br>gulp.run()</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>jquery</title>
    <url>/2018/06/05/web_jquery/</url>
    <content><![CDATA[<h1 id="1-jQuery基础知识"><a href="#1-jQuery基础知识" class="headerlink" title="1. jQuery基础知识"></a>1. jQuery基础知识</h1><h2 id="1-1-jquery的安装"><a href="#1-1-jquery的安装" class="headerlink" title="1.1. jquery的安装"></a>1.1. jquery的安装</h2><p>只需要在html的script标签中引用jquery，两种方式：</p>
<ul>
<li><p>通过CDN（内容分发网络）引用jquery，多个CDN可以使用。比如百度CDN，在html中按如下语法引用。</p>
<p><code>&lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;</code></p>
</li>
<li><p>在<a href="http://jquery.com/download/">jquery.com</a>中下载jquery文本，它是一个js文件，在script标签中引用这个文件即可。<code>&lt;script type=&quot;text/javascript&quot; src=&quot;flexible.js&quot;&gt;&lt;/script&gt;</code></p>
</li>
</ul>
<h2 id="1-2-jquery语法"><a href="#1-2-jquery语法" class="headerlink" title="1.2. jquery语法"></a>1.2. jquery语法</h2><h3 id="1-2-1-基础语法"><a href="#1-2-1-基础语法" class="headerlink" title="1.2.1. 基础语法"></a>1.2.1. 基础语法</h3><p><code>$(selector).action()</code></p>
<ul>
<li>美元符号<code>$</code>定义 jQuery</li>
<li>选择符<code>(selector）</code>“查询”和”查找” HTML 元素，选择器类似css选择器。</li>
<li>jQuery 的 <code>.action()</code>执行对元素的操作，主要通过方法的实现来达到jquery的目的。</li>
<li>jQuery允许我们在相同元素上运行多条jQuery命令，一条接一条，这称为链接技术（chaining）。</li>
</ul>
<h2 id="1-3-jquery基础知识"><a href="#1-3-jquery基础知识" class="headerlink" title="1.3. jquery基础知识"></a>1.3. jquery基础知识</h2><p><code>$.each(array/object,callback)</code>可以遍历数组或者对象</p>
<p><code>$.trim(string)</code>用于去除字符串两端的空白字符</p>
<p><code>$(selector).get([index])</code>get方法通过索引在获取的dom对象中查找元素，从0开始索引对象。</p>
<p><code>$(selector).index(selector/element)</code>index方法通过已知的元素搜索对应的索引值。</p>
<h2 id="1-4-jquery动画"><a href="#1-4-jquery动画" class="headerlink" title="1.4. jquery动画"></a>1.4. jquery动画</h2><h3 id="1-4-1-三种隐藏元素的方式"><a href="#1-4-1-三种隐藏元素的方式" class="headerlink" title="1.4.1. 三种隐藏元素的方式"></a>1.4.1. 三种隐藏元素的方式</h3><h4 id="1-4-1-1-基础隐藏显示动画-display-none）"><a href="#1-4-1-1-基础隐藏显示动画-display-none）" class="headerlink" title="1.4.1.1. 基础隐藏显示动画 (display:none）"></a>1.4.1.1. 基础隐藏显示动画 (display:none）</h4><ol>
<li><p><code>$(selector).hide([ duration ], [ easing ], [ complete ])</code><br>隐藏，只有元素的<code>display</code>不为<code>none</code>时才有效，options可以为隐藏的时长，就产生了动画效果。</p>
</li>
<li><p><code>$(selector).show([ duration ], [ easing ], [ complete ])</code><br>显示，只有元素的<code>display：none</code>时才有效，options可以为显示的时长。</p>
</li>
<li><p><code>$(selector).toggle([ duration ], [ easing ], [ complete ])</code><br>hide和show的切换，动画效果是从右至左，横向动作。</p>
<p>以上三种方法修改的是元素的<code>display</code>属性，会影响元素的<code>width</code>、<code>height</code>和<code>opacity</code>三个属性。</p>
</li>
</ol>
<h4 id="1-4-1-2-上卷下拉效果-height-0"><a href="#1-4-1-2-上卷下拉效果-height-0" class="headerlink" title="1.4.1.2. 上卷下拉效果 (height:0)"></a>1.4.1.2. 上卷下拉效果 (height:0)</h4><ol>
<li><p><code>$(selector).slideDown([ duration ], [ easing ], [ complete ])</code><br>下拉效果</p>
</li>
<li><p><code>$(selector).slideUp([ duration ], [ easing ], [ complete ])</code><br>上卷效果</p>
</li>
<li><p><code>$(selector).slideToggle([ duration ], [ easing ], [ complete ])</code><br>slideDown和slideUp的切换，动画效果是从下至上，竖向动作。</p>
<p>以上三种方法修改的是元素的<code>height</code>属性。</p>
</li>
</ol>
<h4 id="1-4-1-3-淡入淡出效果-opacity-0"><a href="#1-4-1-3-淡入淡出效果-opacity-0" class="headerlink" title="1.4.1.3. 淡入淡出效果 (opacity:0)"></a>1.4.1.3. 淡入淡出效果 (opacity:0)</h4><ol>
<li><p><code>$(selector).fadeOut([ duration ], [ easing ], [ complete ])</code><br>淡出效果</p>
</li>
<li><p><code>$(selector).fadeIn([ duration ], [ easing ], [ complete ])</code><br>淡入效果</p>
</li>
<li><p><code>$(selector).fadeToggle([ duration ], [ easing ], [ complete ])</code><br>fadeOut和fadeIn的切换。</p>
</li>
<li><p><code>$(selector).fadeTo(duration,opacity,callback)</code></p>
<p>以上四种方法修改的是元素的<code>opacity</code>属性，不会影响元素的高度和宽度。</p>
</li>
</ol>
<h3 id="1-4-2-自定义动画"><a href="#1-4-2-自定义动画" class="headerlink" title="1.4.2. 自定义动画"></a>1.4.2. 自定义动画</h3><p><code>$(selector).animate( properties ,[ duration ], [ easing ], [ complete ] )</code></p>
<p>其中，<code>properties</code>是不小于一个css属性的键值对构成的object对象，所有用于动画的属性必须是<strong>数字</strong>的。<code>duration</code>设置动画执行的时间。<code>easing</code>规定每个动画的每一步完成后要执行的函数。<code>progress</code>规定每一次动画调用时会执行这个回调，是一个进度的概念。<code>complete</code>动画完成的回调函数。</p>
<p><code>$(selector).stop( [clearQueue ], [ jumpToEnd ] ) .stop( [queue ], [ clearQueue ] ,[ jumpToEnd ] )</code></p>
<ul>
<li>.stop(); 停止当前动画，点击在暂停处继续开始</li>
<li>.stop(true); 如果同一元素调用多个动画方法，尚未被执行的动画被放置在元素的效果队列中。这些动画不会开始，直到第一个完成。当调用.stop()的时候，队列中的下一个动画立即开始。如果clearQueue参数提供true值,那么在队列中的动画其余被删除并永远不会运行</li>
<li>.stop(true,true); 当前动画将停止，但该元素上的 CSS 属性会被立刻修改成动画的目标值。</li>
</ul>
<h2 id="1-5-jquery-操作html的DOM"><a href="#1-5-jquery-操作html的DOM" class="headerlink" title="1.5. jquery 操作html的DOM"></a>1.5. jquery 操作html的DOM</h2><h3 id="1-5-1-捕获"><a href="#1-5-1-捕获" class="headerlink" title="1.5.1. 捕获"></a>1.5.1. 捕获</h3><ol>
<li>.text() - 设置或返回所选元素的文本内容</li>
<li>.html() - 设置或返回所选元素的内容（包括 HTML 标记）</li>
<li>.val() - 设置或返回表单字段的值</li>
<li>.attr() -设置或返回属性值<br>以上四种方法，如果没有参数，就返回相应值；如果有参数，参数为设置的值。</li>
</ol>
<h3 id="1-5-2-添加内容"><a href="#1-5-2-添加内容" class="headerlink" title="1.5.2. 添加内容"></a>1.5.2. 添加内容</h3><ol>
<li>.append(“追加内容”) 在被选元素的结尾插入内容（仍然在该元素内部）</li>
<li>.prepend(“追加内容”) 在被选元素开头插入内容（仍然在该元素内部）</li>
<li>.after(“追加内容”) 在被选元素的后面插入内容（不在该元素内部）</li>
<li>.before(“追加内容”) 在被选元素的前面插入内容（不在该元素内部）<br>以上四种方法都可以有多个参数，实现批量追加内容。</li>
</ol>
<h3 id="1-5-3-删除内容"><a href="#1-5-3-删除内容" class="headerlink" title="1.5.3. 删除内容"></a>1.5.3. 删除内容</h3><ol>
<li>.remove() 删除被选元素及其子元素；接受一个jquery选择器语法的参数，用于过滤被删元素。</li>
<li>.empty() 从被选元素中删除子元素</li>
</ol>
<h3 id="1-5-4-操作CSS"><a href="#1-5-4-操作CSS" class="headerlink" title="1.5.4. 操作CSS"></a>1.5.4. 操作CSS</h3><ol>
<li>addClass(“classname”) - 向被选元素添加一个或多个类</li>
<li>removeClass(“classname”) - 从被选元素删除一个或多个类</li>
<li>toggleClass(“classname”) - 对被选元素进行添加&#x2F;删除类的切换操作</li>
<li>css(“propertyname”，“value”) &#x2F;css({“propertyname”:”value”,”propertyname”:”value”,…})- 若无设置value值，则返回指定样式属性；若设置value值，就设置样式属性。</li>
</ol>
<h3 id="1-5-5-控制尺寸"><a href="#1-5-5-控制尺寸" class="headerlink" title="1.5.5. 控制尺寸"></a>1.5.5. 控制尺寸</h3><ol>
<li>width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。</li>
<li>height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。</li>
<li>innerWidth() 方法返回元素的宽度（包括内边距）。</li>
<li>innerHeight() 方法返回元素的高度（包括内边距）。</li>
<li>outerWidth() 方法返回元素的宽度（包括内边距和边框）。</li>
<li>outerHeight() 方法返回元素的高度（包括内边距和边框）。</li>
</ol>
<h2 id="1-6-DOM遍历"><a href="#1-6-DOM遍历" class="headerlink" title="1.6. DOM遍历"></a>1.6. DOM遍历</h2><ol>
<li>祖先<ul>
<li>parent() 方法返回被选元素的直接父元素。</li>
<li>parents() 方法返回被选元素的所有祖先元素，它一路向上直到文档的根元素 ()。</li>
<li>parentsUntil() 方法返回介于两个给定元素之间的所有祖先元素。</li>
</ul>
</li>
<li>后代<ul>
<li>children() 方法返回被选元素的所有直接子元素。</li>
<li>find() 方法返回被选元素的后代元素，一路向下直到最后一个后代。</li>
</ul>
</li>
<li>同胞<ul>
<li>siblings() 方法返回被选元素的所有同胞元素。</li>
<li>next() 方法返回被选元素的下一个同胞元素。</li>
<li>nextAll() 方法返回被选元素的所有跟随的同胞元素。</li>
<li>nextUntil() 方法返回介于两个给定参数之间的所有跟随的同胞元素。</li>
<li>prev(), prevAll() 以及 prevUntil() 方法的工作方式与上面的方法类似，只不过方向相反而已：它们返回的是前面的同胞元素（在 DOM 树中沿着同胞之前元素遍历，而不是之后元素遍历）。</li>
</ul>
</li>
<li>过滤<ul>
<li>first() 方法返回被选元素的首个元素。</li>
<li>last() 方法返回被选元素的最后一个元素。</li>
<li>eq() 方法返回被选元素中带有指定索引号的元素。</li>
<li>filter() 方法允许您规定一个标准。不匹配这个标准的元素会被从集合中删除，匹配的元素会被返回。</li>
<li>not() 方法返回不匹配标准的所有元素，与filter()方法相反。</li>
</ul>
</li>
</ol>
<h2 id="1-7-tips"><a href="#1-7-tips" class="headerlink" title="1.7. tips"></a>1.7. tips</h2><p>使用jquery实现相同样式容器的批量导入。<br>从json文件中取数据并遍历数据，然后通过每条数据与重复项字符串的手动拼接，获得字符串格式的html结构，在把这个结果字符串通过<code>$(&quot;selector&quot;).append(结果字符串)</code>到指定位置，即可实现导入相同样式容器到html中。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>react</title>
    <url>/2018/06/14/web_react/</url>
    <content><![CDATA[<h1 id="1-react"><a href="#1-react" class="headerlink" title="1. react"></a>1. react</h1><h2 id="1-1-JSX"><a href="#1-1-JSX" class="headerlink" title="1.1. JSX"></a>1.1. JSX</h2><p>react使用JSX代替javascript，JSX是有点像XML的javascript语法扩展。</p>
<h3 id="1-1-1-基本语法"><a href="#1-1-1-基本语法" class="headerlink" title="1.1.1. 基本语法"></a>1.1.1. 基本语法</h3><p>ReactDOM.render(<br>  div<br>    h1 react教程 &#x2F;h1<br>    h2 欢迎学习 React &#x2F;h2<br>    p 这是一个很不错的 JavaScript 库! &#x2F;p<br>  &#x2F;div<br>document.getElementById(‘example’))</p>
<p>多个html标签需要全包含在一个div中，以上代码表示在id&#x3D;example的html标签位置渲染一个div，里面有两个标题和一个段落。</p>
<h3 id="1-1-2-嵌入javascript表达式"><a href="#1-1-2-嵌入javascript表达式" class="headerlink" title="1.1.2. 嵌入javascript表达式"></a>1.1.2. 嵌入javascript表达式</h3><ul>
<li>JSX中可以嵌入javascript表达式，但需要写在花括号{}内。</li>
<li>注释也需要写在花括号中。</li>
<li>花括号中的数组会自动展开所有成员。</li>
<li>表达式不能使用<code>if else</code>语句，但可以用<code>conditional</code>三元运算表达式。<br><code>&lt;h1&gt;&#123;i == 1 ? &#39;True!&#39; : &#39;False&#39;&#125;&lt;/h1&gt;</code></li>
</ul>
<h3 id="1-1-3-内联样式"><a href="#1-1-3-内联样式" class="headerlink" title="1.1.3. 内联样式"></a>1.1.3. 内联样式</h3><p>使用驼峰法设置内联样式</p>
<p>ReactDOM.render(<br>  h1 style &#x3D; {myStyle} 菜鸟教程 &#x2F;h1<br>  document.getElementById(‘example’))</p>
<h3 id="1-1-4-渲染HTML标签（strings）和React组件（classes）"><a href="#1-1-4-渲染HTML标签（strings）和React组件（classes）" class="headerlink" title="1.1.4. 渲染HTML标签（strings）和React组件（classes）"></a>1.1.4. 渲染HTML标签（strings）和React组件（classes）</h3><p>React 可以渲染 HTML 标签 (strings) 或 React 组件 (classes)。</p>
<p>要渲染 HTML 标签，只需在 JSX 里使用小写字母的标签名。</p>
<p>要渲染 React 组件，只需创建一个大写字母开头的本地变量。</p>
<h3 id="1-1-5-tips"><a href="#1-1-5-tips" class="headerlink" title="1.1.5. tips"></a>1.1.5. tips</h3><p>由于 JSX 就是 JavaScript，一些标识符像 class 和 for 不建议作为 XML 属性名。作为替代，React DOM 使用 className 和 htmlFor 来做对应的属性。</p>
<h2 id="1-2-组件"><a href="#1-2-组件" class="headerlink" title="1.2. 组件"></a>1.2. 组件</h2><p>组件API的7个方法：</p>
<ul>
<li>设置状态：setState</li>
<li>替换状态：replaceState</li>
<li>设置属性：setProps</li>
<li>替换属性：replaceProps</li>
<li>强制更新：forceUpdate</li>
<li>获取DOM节点：findDOMNode</li>
<li>判断组件挂载状态：isMounted</li>
</ul>
<p>react元素是DOM标签或者用户自定义组件，当是自定义组件时，会将JSX属性作为单个对象传递给该组件，这个对象是“props”。<br>组件名称必须以大写字母开头。<br>组件的返回值只能有一个根元素。<br>所有的React组件必须像纯函数（即不能改变输入值的函数）那样使用它们的props。<br>React应用中，按钮、表单、对话框、整个屏幕的内容等，这些通常都被表示为组件。</p>
<h2 id="1-3-生命周期"><a href="#1-3-生命周期" class="headerlink" title="1.3. 生命周期"></a>1.3. 生命周期</h2><ol>
<li>组件的生命周期可分成三个状态：</li>
</ol>
<ul>
<li>Mounting：已插入真实 DOM</li>
<li>Updating：正在被重新渲染</li>
<li>Unmounting：已移出真实 DOM</li>
</ul>
<ol start="2">
<li>生命周期的方法有：</li>
</ol>
<ul>
<li>componentWillMount 在渲染前调用,在客户端也在服务端。</li>
<li>componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。</li>
<li>componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。</li>
<li>shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。</li>
<li>可以在你确认不需要更新组件时使用。</li>
<li>componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。</li>
<li>componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。</li>
<li>componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
</search>
